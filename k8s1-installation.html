<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="erIKW497yS"><meta name="google-site-verification" content="UgdHTfiMSYvSc5WkTMWIBaRheQv9f_np2Dm0RUlPFco"><title> Kubernetes笔记（一）：十分钟部署一套K8s环境 · 空山新雨的技术空间</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Kubernetes笔记（一）：十分钟部署一套K8s环境 - 空山新雨"><meta name="keywords" content="Spring,DevOps,技术管理"><meta name="author" content="空山新雨"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.jboost.cn/atom.xml" title="空山新雨的技术空间"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Kubernetes笔记（一）：十分钟部署一套K8s环境</h1><div class="post-info">2020-04-28<p class="visit"><i data-identity="k8s1-installation.html" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><p>Kubernetes是Goole开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理 —— 百度百科。</p>
<a id="more"></a>
<p>接触K8s也有半年多了，也基于阿里云平台搭建了包含多级服务、目前运行较为稳定的K8s集群（感兴趣的可参考 <a href="https://mp.weixin.qq.com/s/8s-OUUsZI0UyyyTgruEO1A" target="_blank" rel="noopener">k8s云集群混搭模式，可能帮你节省50%以上的服务成本</a>， <a href="https://mp.weixin.qq.com/s/VuSWn7cWacW6i_MtpvQ5Sw" target="_blank" rel="noopener">k8s云集群混搭模式落地分享</a>），但一直没来得及对其进行系统的学习，本系列文章还像以前Docker系列一样，以笔记的形式进行记录与分享，会包括理论与实践，感兴趣的同学可以关注，一起探索下目前较为流行的容器化及服务编排解决方案。</p>
<p>工欲善其事，必先利其器，本文先介绍如何在本地自行搭建一套k8s集群，并且采用我们前面介绍过的Ansible来提高效率（参考 <a href="https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw" target="_blank" rel="noopener">Ansible简明教程</a>）</p>
<p>本文所涉及的所有配置文件可在这里找到 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation" target="_blank" rel="noopener">github</a></p>
<h2 id="一-准备服务器节点"><a href="#一-准备服务器节点" class="headerlink" title="一. 准备服务器节点"></a>一. 准备服务器节点</h2><p>如果还没有服务器，可以参考 <a href="https://mp.weixin.qq.com/s/FVyzPVwwQ85AC4jlVZvF4g" target="_blank" rel="noopener">ubuntu18.04上搭建KVM虚拟机环境超完整过程</a> 创建虚拟服务器。</p>
<p>服务器节点IP（hostname）：</p>
<ul>
<li>192.168.40.111 (kmaster)</li>
<li>192.168.40.112 (knode1)</li>
<li>192.168.40.113 (knode2)</li>
<li>192.168.40.114 (knode3)</li>
</ul>
<p>操作系统版本：</p>
<ul>
<li><code>cat /etc/redhat-release</code> : CentOS Linux release 7.6.1810 (Core)</li>
<li><code>uname -a</code> : 3.10.0-957.el7.x86_64</li>
</ul>
<h2 id="二-配置Ansible"><a href="#二-配置Ansible" class="headerlink" title="二. 配置Ansible"></a>二. 配置Ansible</h2><p>如果还没有Ansible环境，可以参考 [Ansible简明教程]<a href="https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw</a>) 搭建。</p>
<ol>
<li>在Ansible服务器上的/etc/hosts文件中添加k8s服务器节点信息(参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/hosts" target="_blank" rel="noopener">hosts</a>)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.40.111 kmaster</span><br><span class="line">192.168.40.112 knode1</span><br><span class="line">192.168.40.113 knode2</span><br><span class="line">192.168.40.114 knode3</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在Ansible服务器上的/etc/ansible/hosts文件中添加k8s服务器节点（参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/ansible_hosts" target="_blank" rel="noopener">ansible_hosts</a>）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[k8s-all]</span><br><span class="line">kmaster</span><br><span class="line">knode1</span><br><span class="line">knode2</span><br><span class="line">knode3</span><br><span class="line"></span><br><span class="line">[k8s-master]</span><br><span class="line">kmaster</span><br><span class="line"></span><br><span class="line">[k8s-nodes]</span><br><span class="line">knode1</span><br><span class="line">knode2</span><br><span class="line">knode3</span><br></pre></td></tr></table></figure>
<h2 id="三-修改k8s集群各节点-etc-hosts（非必须）"><a href="#三-修改k8s集群各节点-etc-hosts（非必须）" class="headerlink" title="三. 修改k8s集群各节点/etc/hosts（非必须）"></a>三. 修改k8s集群各节点/etc/hosts（非必须）</h2><p>修改所有主机/etc/hosts文件，添加IP/主机名映射，方便通过主机名ssh访问</p>
<ol>
<li>创建playbook文件（参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/set_hosts_playbook.yml" target="_blank" rel="noopener">set_hosts_playbook.yml</a>）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim set_hosts_playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: k8s-all</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: backup /etc/hosts</span><br><span class="line">      shell: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">    - name: copy local hosts file to remote</span><br><span class="line">      copy: src=/etc/hosts dest=/etc/ owner=root group=root mode=0644</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>执行ansible-playbook</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook set_hosts_playbook.yml</span><br></pre></td></tr></table></figure>
<h2 id="四-安装Docker"><a href="#四-安装Docker" class="headerlink" title="四. 安装Docker"></a>四. 安装Docker</h2><p>在所有主机上安装Docker</p>
<ol>
<li>创建playbook文件（参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/install_docker_playbook.yml" target="_blank" rel="noopener">install_docker_playbook.yml</a>）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vim install_docker_playbook.yml</span><br><span class="line">- hosts: k8s-all</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars: </span><br><span class="line">     docker_version: 18.09.2</span><br><span class="line"></span><br><span class="line">  tasks: </span><br><span class="line">     - name: install dependencies</span><br><span class="line">       #shell: yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br><span class="line">       yum: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">       with_items:</span><br><span class="line">          - yum-utils</span><br><span class="line">          - device-mapper-persistent-data</span><br><span class="line">          - lvm2</span><br><span class="line"></span><br><span class="line">     - name: config yum repo</span><br><span class="line">       shell: yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">     - name: install docker</span><br><span class="line">       yum: name=docker-ce-&#123;&#123;docker_version&#125;&#125; state=present</span><br><span class="line"></span><br><span class="line">     - name: start docker</span><br><span class="line">       shell: systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>执行ansible-playbook</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook install_docker_playbook.yml</span><br></pre></td></tr></table></figure>
<h2 id="五-部署k8s-master"><a href="#五-部署k8s-master" class="headerlink" title="五. 部署k8s master"></a>五. 部署k8s master</h2><ol>
<li><p>开始部署之前，需要做一些初始化处理：关闭防火墙、关闭selinux、禁用swap、配置k8s阿里云yum源等，所有操作放在脚本 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/pre-setup.sh" target="_blank" rel="noopener">pre-setup.sh</a> 中，并在2中playbook中通过script模块执行</p>
</li>
<li><p>创建playbook文件 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/deploy_master_playbook.yml" target="_blank" rel="noopener">deploy_master_playbook.yml</a>，只针对master节点，安装kubectl，kubeadm，kubelet，以及flannel（将kube-flannel.yml文件里镜像地址的quay.io改为quay-mirror.qiniu.com避免超时，参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/kube-flannel.yml" target="_blank" rel="noopener">kube-flannel.yml</a>）</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vim deploy_master_playbook.yml</span><br><span class="line">- hosts: k8s-master</span><br><span class="line">  remote_user: root：q</span><br><span class="line">  vars:</span><br><span class="line">    kube_version: 1.16.0-0</span><br><span class="line">    k8s_version: v1.16.0</span><br><span class="line">    k8s_master: 192.168.40.111 </span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: prepare env</span><br><span class="line">      script: ./pre-setup.sh      </span><br><span class="line"></span><br><span class="line">    - name: install kubectl,kubeadm,kubelet</span><br><span class="line">      yum: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - kubectl-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">        - kubeadm-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">        - kubelet-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    - name: init k8s</span><br><span class="line">      shell: kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version &#123;&#123;k8s_version&#125;&#125; --apiserver-advertise-address &#123;&#123;k8s_master&#125;&#125;  --pod-network-cidr=10.244.0.0/16 --token-ttl 0</span><br><span class="line">    </span><br><span class="line">    - name: config kube</span><br><span class="line">      shell: mkdir -p $HOME/.kube &amp;&amp; cp -i /etc/kubernetes/admin.conf $HOME/.kube/config &amp;&amp; chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">    </span><br><span class="line">    - name: copy flannel yaml file</span><br><span class="line">      copy: src=./kube-flannel.yml dest=/tmp/ owner=root group=root mode=0644 </span><br><span class="line">    </span><br><span class="line">    - name: install flannel</span><br><span class="line">      shell: kubectl apply -f /tmp/kube-flannel.yml</span><br><span class="line"></span><br><span class="line">    - name: get join command</span><br><span class="line">      shell: kubeadm token create --print-join-command </span><br><span class="line">      register: join_command</span><br><span class="line">    - name: show join command</span><br><span class="line">      debug: var=join_command verbosity=0</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>执行ansible-playbook</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook deploy_master_playbook.yml</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>上述命令执行完成会输出节点加入k8s集群的命令，如下图。记下该命令，后面部署node时会用到</li>
</ol>
<p><img src="/assets/join-command.png" alt="图片"></p>
<h2 id="六-部署k8s-node"><a href="#六-部署k8s-node" class="headerlink" title="六. 部署k8s node"></a>六. 部署k8s node</h2><ol>
<li><p>同master一样，开始部署之前，需要做一些初始化处理：关闭防火墙、关闭selinux、禁用swap、配置k8s阿里云yum源等，所有操作放在脚本  <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/pre-setup.sh" target="_blank" rel="noopener">pre-setup.sh</a> 中，并在2中playbook中通过script模块执行</p>
</li>
<li><p>创建playbook文件 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/deploy_nodes_playbook.yml" target="_blank" rel="noopener">deploy_nodes_playbook.yml</a>，针对除master外的其它集群节点，安装kubeadm，kubelet，并将节点加入到k8s集群中，使用的是前面部署master时输出的加入集群命令</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vim deploy_nodes_playbook.yml</span><br><span class="line">- hosts: k8s-nodes</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">     kube_version: 1.16.0-0</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: prepare env</span><br><span class="line">      script: ./pre-setup.sh</span><br><span class="line"></span><br><span class="line">    - name: install kubeadm,kubelet</span><br><span class="line">      yum: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - kubeadm-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">        - kubelet-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    - name: start kubelt</span><br><span class="line">      shell: systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line">   </span><br><span class="line">    - name: join cluster</span><br><span class="line">      shell: kubeadm join 192.168.40.111:6443 --token zgx3ov.zlq3jh12atw1zh8r --discovery-token-ca-cert-hash sha256:60b7c62687974ec5803e0b69cfc7ccc2c4a8236e59c8e8b8a67f726358863fa7</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>执行ansible-playbook</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook deploy_nodes_playbook.yml</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>稍等片刻，即可在master节点上通过<code>kubectl get nodes</code>看到加入到集群中的节点，并且status为Ready状态，如下<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES    AGE     VERSION</span><br><span class="line">kmaster   Ready    master   37m     v1.16.0</span><br><span class="line">knode1    Ready    &lt;none&gt;   7m1s    v1.16.0</span><br><span class="line">knode2    Ready    &lt;none&gt;   7m1s    v1.16.0</span><br><span class="line">knode3    Ready    &lt;none&gt;   4m12s   v1.16.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>至此，k8s集群基本部署完成。接下来可安装Ingress与Dashboard。</p>
<h2 id="七-安装Ingress"><a href="#七-安装Ingress" class="headerlink" title="七. 安装Ingress"></a>七. 安装Ingress</h2><p>Ingress为集群内服务提供外网访问，包括基于Nginx与Traefik两个版本，这里使用比较熟悉的Nginx版本。安装Ingress的操作在master节点进行（因为前面在master节点安装并配置了kubectl，也可在其它安装并配置好了kubectl的节点进行）</p>
<ol>
<li>下载yaml文件（此目录已包含 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/ingress/nginx-ingress.yaml" target="_blank" rel="noopener">nginx-ingress.yaml</a>，并修改了镜像地址，可直接进入第3步） </li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O nginx-ingress.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/deploy.yaml</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将里面的quay.io修改为quay-mirror.qiniu.com，避免镜像拉取超时。同时在nginx-ingress-controller的Deployment上添加hostNetwork为true及nginx-ingress的标签，以使用宿主机网络与控制Ingress部署的节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim nginx-ingress.yaml</span><br><span class="line">:s/quay.io/quay-mirror.qiniu.com/g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim nginx-ingress.yaml</span><br><span class="line"></span><br><span class="line">    spec:</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      nodeSelector:</span><br><span class="line">        nginx-ingress: "true"</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>部署Ingress</li>
</ol>
<p>首先在knode1节点上打标签nginx-ingress=true，控制Ingress部署到knode1上，保持IP固定。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl label node knode1 nginx-ingress=true</span><br><span class="line">node/knode1 labeled</span><br></pre></td></tr></table></figure>
<p>然后完成nginx-ingress的部署</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-ingress.yaml</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>部署完成，稍等片刻等Pod创建完成，可通过如下命令查看ingress相关Pod情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl get pods -n ingress-nginx -o wide</span><br><span class="line">NAME                                        READY   STATUS      RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">ingress-nginx-admission-create-drpg5        0/1     Completed   0          79m   10.244.2.2       knode1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-admission-patch-db2rt         0/1     Completed   1          79m   10.244.3.2       knode3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-controller-575cffb49c-4xm55   1/1     Running     0          79m   192.168.40.112   knode1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<h2 id="八-安装Kubernetes-Dashboard"><a href="#八-安装Kubernetes-Dashboard" class="headerlink" title="八. 安装Kubernetes Dashboard"></a>八. 安装Kubernetes Dashboard</h2><ol>
<li>下载yaml文件（此目录已包含 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/dashboard/kubernetes-dashboard.yaml" target="_blank" rel="noopener">kubernetes-dashboard.yaml</a> 文件，可直接进入第3步）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O kubernetes-dashboard.yaml  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta5/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改kubernetes-dashboard.yaml</li>
</ol>
<p>将Service type改为NodePort，使得可通过IP访问Dashboard。注释掉默认的Secret（默认的secret权限很有限，看不到多少数据）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30443</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>部署Dashboard，并创建绑定cluster-admin角色的ServiceAccount —— admin-user (参考 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/dashboard/kubernetes-dashboard-auth.yaml" target="_blank" rel="noopener">auth.yaml</a>)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f kubernetes-dashboard.yaml</span><br><span class="line">kubectl apply -f kubernetes-dashboard-auth.yaml</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>访问Dashboard</li>
</ol>
<p>访问 https://集群任意节点IP:30443，打开Dashboard登录页面，执行如下命令获取登录token</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '&#123;print $1&#125;')</span><br></pre></td></tr></table></figure>
<p>使用token完成登录，如图</p>
<p><img src="/assets/dashboard-login.png" alt="图片"></p>
<h2 id="九-解决证书无效问题"><a href="#九-解决证书无效问题" class="headerlink" title="九. 解决证书无效问题"></a>九. 解决证书无效问题</h2><p>安装完后，默认的证书可能无效，在Chrome浏览中无法打开Dashboard，可通过重新生成证书解决。</p>
<ol>
<li>创建自定义证书 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# cd /etc/kubernetes/pki/</span><br><span class="line"><span class="meta">#</span><span class="bash">生成私钥</span></span><br><span class="line">[root@kmaster pki]# openssl genrsa -out dashboard.key 2048</span><br><span class="line"><span class="meta">#</span><span class="bash">生成证书</span></span><br><span class="line">[root@kmaster pki]# openssl req -new -key dashboard.key -out dashboard.csr -subj "/O=JBST/CN=kubernetes-dashboard"</span><br><span class="line"><span class="meta">#</span><span class="bash">使用集群的CA来签署证书</span></span><br><span class="line">[root@kmaster pki]# openssl x509 -req -in dashboard.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out dashboard.crt -days 3650</span><br><span class="line"><span class="meta">#</span><span class="bash">查看自创证书</span></span><br><span class="line">[root@kmaster pki]# openssl x509 -in dashboard.crt -noout -text</span><br></pre></td></tr></table></figure>
<p>注释 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/dashboard/kubernetes-dashboard.yaml" target="_blank" rel="noopener">kubernetes-dashboard.yaml</a> 中默认的Secret，</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#apiVersion: v1</span></span><br><span class="line"><span class="comment">#kind: Secret</span></span><br><span class="line"><span class="comment">#metadata:</span></span><br><span class="line"><span class="comment">#  labels:</span></span><br><span class="line"><span class="comment">#    k8s-app: kubernetes-dashboard</span></span><br><span class="line"><span class="comment">#  name: kubernetes-dashboard-certs</span></span><br><span class="line"><span class="comment">#  namespace: kubernetes-dashboard</span></span><br><span class="line"><span class="comment">#type: Opaque</span></span><br></pre></td></tr></table></figure>
<p>重新部署Dashboard，并通过自定义证书创建新的Secret</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl delete -f kubernetes-dashboard.yaml</span><br><span class="line">[root@kmaster k8s-deploy]# kubectl apply -f kubernetes-dashboard.yaml </span><br><span class="line">[root@kmaster k8s-deploy]# kubectl create secret generic kubernetes-dashboard-certs --from-file=dashboard.crt=/etc/kubernetes/pki/dashboard.crt --from-file=dashboard.key=/etc/kubernetes/pki/dashboard.key  -n kubernetes-dashboard</span><br></pre></td></tr></table></figure>
<h2 id="十-在本地（win10）管理k8s集群"><a href="#十-在本地（win10）管理k8s集群" class="headerlink" title="十. 在本地（win10）管理k8s集群"></a>十. 在本地（win10）管理k8s集群</h2><ol>
<li><p>下载kubectl windows版本： <a href="https://storage.googleapis.com/kubernetes-release/release/v1.16.0/bin/windows/amd64/kubectl.exe" target="_blank" rel="noopener">https://storage.googleapis.com/kubernetes-release/release/v1.16.0/bin/windows/amd64/kubectl.exe</a></p>
</li>
<li><p>将kubectl.exe文件所在目录加入系统环境变量的Path中</p>
</li>
<li><p>将master节点上 /etc/kubernetes/admin.conf 的内容拷贝到本地用户目录的 .kube/config 文件中，如 <code>C:\Users\Administrator\.kube\config</code></p>
</li>
<li><p>验证</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES    AGE     VERSION</span><br><span class="line">kmaster   Ready    master   4d19h   v1.16.0</span><br><span class="line">knode1    Ready    &lt;none&gt;   4d19h   v1.16.0</span><br><span class="line">knode2    Ready    &lt;none&gt;   4d19h   v1.16.0</span><br><span class="line">knode3    Ready    &lt;none&gt;   4d19h   v1.16.0</span><br></pre></td></tr></table></figure>
<hr>
<p>作者：空山新雨<br>欢迎关注作者微信公众号：空山新雨的技术空间，一起学习成长  </p>
<p><img src="/assets/qrcode-05.jpg" alt="微信公众号"></p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/ansible.html" title="Ansible简明教程" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz",
    appKey: "PhFNiYoBJ1Fge6n8stpsfggG",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2019 - 2020 <a target="_blank">空山新雨</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;"> </span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz", "PhFNiYoBJ1Fge6n8stpsfggG");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>