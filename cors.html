<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="erIKW497yS"><meta name="google-site-verification" content="UgdHTfiMSYvSc5WkTMWIBaRheQv9f_np2Dm0RUlPFco"><title> 老被跨域问题烦？看看都有哪些处理方法 · 空山新雨的技术空间</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="老被跨域问题烦？看看都有哪些处理方法 - 空山新雨"><meta name="keywords" content="Spring,DevOps,技术管理"><meta name="author" content="空山新雨"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.jboost.cn/atom.xml" title="空山新雨的技术空间"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">老被跨域问题烦？看看都有哪些处理方法</h1><div class="post-info">2019-07-30<p class="visit"><i data-identity="cors.html" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><p>前面写的《IT技术人员的自我修养》，没想到几天内收到了不少良好的反馈，在此也感谢大家的关注。往后会不定时分享一些技术、管理领域的工作经验总结与感悟，欢迎大家持续关注、交流。最近被问及一个跨域的问题，包括之前面试时发现很多面试者对跨域及其处理也是一知半解，故本文对该问题进行了梳理总结，以供参考。<br><a id="more"></a></p>
<h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1. 什么是跨域"></a>1. 什么是跨域</h2><p>理解什么是跨域，就要先了解一个叫“同源策略”的东西，什么是“同源策略”？这是浏览器为了网站访问安全，对来自不同源的请求做一些必要的访问限制的一种策略。那什么叫“同源”呢？我们知道，一个http请求地址一般包含四部分：<code>协议://域名:端口/路径</code>，所谓同源，就是前面三者，即协议、域名、端口都一样。举例说明，假如我们有一个地址 <code>http://blog.jboost.cn/docker-1.html</code>， 来看以下地址是否与它同源</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">是否同源</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://blog.jboost.cn/docker-1.html">https://blog.jboost.cn/docker-1.html</a></td>
<td style="text-align:center">不同源</td>
<td style="text-align:center">协议不同，一个http，一个https</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://www.jboost.cn/docker-1.html" target="_blank" rel="noopener">http://www.jboost.cn/docker-1.html</a></td>
<td style="text-align:center">不同源</td>
<td style="text-align:center">域名不同</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://blog.jboost.cn:8080/docker-1.html">http://blog.jboost.cn:8080/docker-1.html</a></td>
<td style="text-align:center">不同源</td>
<td style="text-align:center">端口不同，一个是默认端口80，一个是8080</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://blog.jboost.cn/docker-2.html">http://blog.jboost.cn/docker-2.html</a></td>
<td style="text-align:center">同源</td>
<td style="text-align:center">虽然路径不同，但协议、域名、端口（默认80）都相同</td>
</tr>
</tbody>
</table>
<p>那么浏览器对不同源的请求做了哪些访问限制呢？共有三种限制</p>
<ol>
<li>对Cookie、LocalStorage，以及IndexDB（浏览器提供的类NoSQL的一个本地数据库）的访问</li>
<li>对DOM的访问</li>
<li>AJAX请求</li>
</ol>
<p>而跨域就是要打破这种访问限制，对不同源的资源请求也能顺利进行，最常见的就是AJAX请求，比如前后端分离架构中，两者服务域名不同，前端通过AJAX直接访问服务端接口，就会存在跨域问题。</p>
<h2 id="2-为什么会存在跨域"><a href="#2-为什么会存在跨域" class="headerlink" title="2. 为什么会存在跨域"></a>2. 为什么会存在跨域</h2><p>前面说“同源策略”时已经提到，浏览器是为了网站的访问安全，才设置了跨域这道屏障。那么前面所说的三种限制，分别都是如何来保障网站安全的。</p>
<ol>
<li>对本地存储Cookie、LocalStorage、IndexDB的访问限制<br>我们系统的登录凭证一般是通过在Cookie中设置 SESSIONID（如针对浏览器表单请求）或直接返回 token（如针对REST请求）的形式返回给客户端的，比如Tomcat是通过在Cookie中设置名为 JSESSIONID 的属性来保存的，而一般REST请求的token前端会存储于 LocalStorage 中，如果不存在访问限制，则你访问的其它网站可能就会获取到这些凭证，然后伪造你的身份来发起非法请求，这就太不安全了。</li>
<li>对DOM的访问限制<br>如果不对DOM进行访问限制，那么其它网站，尤其一些钓鱼网站，就可以通过 <code>&lt;iframe&gt;</code> 的形式拿到你访问网站的DOM，进而获取到你输入的一些敏感信息，比如用户名、密码…</li>
<li>对AJAX请求的限制<br>同源策略规定，AJAX请求只能发给同源的网址，否则就会报错。至于为什么要限制，一方面是避免1中所提到伪造非法请求，另一方面我理解是AJAX过于灵活，如果不做限制，可能网站的接口资源就会被其它网站随意使用，就像你的私有物品被别人招呼都不打任意拿去用一样。</li>
</ol>
<p>总之，同源策略是浏览器提供的最基本的一种安全保障机制或约定。</p>
<h2 id="3-怎么实现跨域访问"><a href="#3-怎么实现跨域访问" class="headerlink" title="3. 怎么实现跨域访问"></a>3. 怎么实现跨域访问</h2><p>我们平常遇到的跨域问题基本都出现在AJAX请求的场景，一般而言，可以通过代理、CORS、JSONP等方式来解决跨域问题。</p>
<h3 id="3-1-代理"><a href="#3-1-代理" class="headerlink" title="3.1 代理"></a>3.1 代理</h3><p>既然“同源策略”是浏览器端的机制，那我们就可以绕开浏览器，最常见的做法就是使用代理，如 Nginx，比如我们前端项目的域名是 <a href="http://blog.jboost.cn，服务端接口域名是" target="_blank" rel="noopener">http://blog.jboost.cn，服务端接口域名是</a> <a href="http://api.jboost.cn，我们在" target="_blank" rel="noopener">http://api.jboost.cn，我们在</a> Nginx 中提供如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    # 端口</span><br><span class="line">    listen 80;</span><br><span class="line">    # 域名</span><br><span class="line">    server_name blog.jboost.cn;</span><br><span class="line">    # 所有 http://blog.jboost.cn/api/xxx 请求都会被转发到 http://api.jboost.cn/api/xxx</span><br><span class="line">    location ^~ /api &#123;</span><br><span class="line">        proxy_pass http://api.jboost.cn;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则前端通过AJAX请求服务端接口 <a href="http://api.jboost.cn/api/xxx" target="_blank" rel="noopener">http://api.jboost.cn/api/xxx</a> 都可以改为通过 <a href="http://blog.jboost.cn/api/xxx">http://blog.jboost.cn/api/xxx</a> 来访问，从而避免不同源的跨域问题。</p>
<h3 id="3-2-CORS"><a href="#3-2-CORS" class="headerlink" title="3.2 CORS"></a>3.2 CORS</h3><p>CORS是Cross-Origin Resource Sharing的简写，即跨域资源共享，CORS需要服务端与浏览器同时支持，目前所有浏览器（除IE10以下）都支持CORS，因此，实现CORS，主要就是服务端的工作了。例如在Spring Boot中，我们可通过如下配置注册一个CorsFilter的过滤器来实现跨域支持。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;Servlet.class, CorsFilter.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CORSAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"corsFilterRegistrationBean"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line"></span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.applyPermitDefaultValues();</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(CorsConfiguration.ALL));</span><br><span class="line">        corsConfiguration.addExposedHeader(HttpHeaders.DATE);</span><br><span class="line"></span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line"></span><br><span class="line">        CorsFilter corsFilter = <span class="keyword">new</span> CorsFilter(corsConfigurationSource);</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(corsFilter);</span><br><span class="line">        filterRegistrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实质就是在响应消息的Header中添加几个属性，主要有</p>
<ul>
<li>Access-Control-Allow-Origin  必需，表示允许跨域的请求源，可以是具体的域名，也可以是 * ，表示任意域名</li>
<li>Access-Control-Allow-Methods 必需，表示允许跨域访问的HTTP方法，如GET、POST、PUT、DELETE等，可以是 * ，表示所有</li>
<li>Access-Control-Allow-Headers 如果请求包括 Access-Control-Request-Headers 头信息，则必需，表示服务器支持的所有头信息字段</li>
</ul>
<h3 id="3-3-JSONP"><a href="#3-3-JSONP" class="headerlink" title="3.3 JSONP"></a>3.3 JSONP</h3><p>JSONP是利用浏览器对JS一些标签（如 <code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>等）的 src 属性不具有同源策略限制的特性实现的，如前端添加<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://api.jboost.cn/hello?name=jboost&amp;callback=jsonpCallback"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>并且定义JS方法 <code>jsonpCallback</code>。服务端接口返回内容需要是JS方法<code>jsonpCallback</code>的调用格式，如<code>jsonpCallback({&quot;name&quot;:&quot;jboost&quot;})</code>，这样在<code>jsonpCallback</code>方法中就可以获取服务端实际返回的结果数据<code>{&quot;name&quot;:&quot;jboost&quot;}</code>了。<br>JSONP方式的局限性也很明显，一是只支持GET请求——你没见过哪些<code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>标签是POST请求吧，二是需要对服务端返回数据格式做处理。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>三种跨域支持的实现，代理方式最简单，对客户端、服务端都不具有侵入性，但如果需要支持的请求源比较多，或者是与第三方对接的话，代理方式就不太适用了。CORS相对来说是一种标准的处理方式，并且通过过滤器的方式对业务代码也没有任何侵入性。而JSONP方式局限性较大，只支持GET，并且需要服务端做返回数据格式的支持。可针对具体情况选择适用的方式。</p>
<p><br><br><img src="/assets/card-2.png" alt="微信公众号">  </p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/springboot-simpleauth.html" title="Spring Boot（十一）：注解结合JWT实现简单的接口鉴权" class="prev">上一篇</a><a href="/springboot-async.html" title="Spring Boot从入门到实战（十）：异步处理" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz",
    appKey: "PhFNiYoBJ1Fge6n8stpsfggG",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2019 - 2020 <a target="_blank">空山新雨</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;"> </span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz", "PhFNiYoBJ1Fge6n8stpsfggG");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>