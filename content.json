{"meta":{"title":"空山新雨","subtitle":null,"description":"分享技术与管理的点滴","author":"ronwxy","url":"http://blog.jboost.cn","root":"/"},"pages":[{"title":"关于我","date":"2019-06-05T08:11:27.000Z","updated":"2019-06-10T07:36:24.249Z","comments":true,"path":"about/index.html","permalink":"http://blog.jboost.cn/about/index.html","excerpt":"","text":"上海交通大学计算机应用技术硕士毕业，十多年软件技术研发经验 多年软件及互联网行业从业经验。从世界500强到国企，到民企，再到创业公司，经历过几百人参与的跨国大项目，也从0到1主管研发过多款互联网产品 以技术负责人身份主导过多个项目的微服务架构实践，负责过日均TB级大数据平台的研发与运维 多年技术团队管理经验，担任过技术主管，技术经理，技术总监等职务，目前在一公司担任技术总监、研发副总职位 曾利用空闲时间整理过一些技术分享，但终究由于阶段性太忙或其它原因未能坚持。 虽然现在较少写代码，但一直有意愿将多年企业产品与项目技术实践及团队管理的经验分享出来，一方面给有需求的软件与互联网行业技术人员（尤其是计算机相关专业，并有志于从事软件技术工作的高校学生）以参考，另一方面也是对自己技术与经验的梳理、总结。于是花了点时间整了这个博客，希望能坚持下来。 我的github地址，里面有文章涉及源码或其它项目，欢迎follow、打星 为了能及时收到更新的分享文章，欢迎关注我的微信公众号"}],"posts":[{"title":"Spring Boot从入门到实战：整合通用Mapper简化单表操作","slug":"springboot-tkmapper","date":"2019-06-24T11:32:15.000Z","updated":"2019-06-24T11:42:59.602Z","comments":true,"path":"2019/06/24/springboot-tkmapper.html","link":"","permalink":"http://blog.jboost.cn/2019/06/24/springboot-tkmapper.html","excerpt":"数据库访问是web应用必不可少的部分。现今最常用的数据库ORM框架有Hibernate与Mybatis，Hibernate貌似在传统IT企业用的较多，而Mybatis则在互联网企业应用较多。通用Mapper（https://github.com/abel533/Mapper） 是一个基于Mybatis，将单表的增删改查通过通用方法实现，来减少SQL编写的开源框架，且也有对应开源的mapper-spring-boot-starter提供。我们在此基础上加了一些定制化的内容，以便达到更大程度的复用。","text":"数据库访问是web应用必不可少的部分。现今最常用的数据库ORM框架有Hibernate与Mybatis，Hibernate貌似在传统IT企业用的较多，而Mybatis则在互联网企业应用较多。通用Mapper（https://github.com/abel533/Mapper） 是一个基于Mybatis，将单表的增删改查通过通用方法实现，来减少SQL编写的开源框架，且也有对应开源的mapper-spring-boot-starter提供。我们在此基础上加了一些定制化的内容，以便达到更大程度的复用。 框架源码地址：https://github.com/ronwxy/base-spring-boot （持续更新完善中，欢迎follow，star）Demo源码地址：https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper 在开源mapper-spring-boot-starter的基础上，增加了如下内容： 针对MySQL数据库与PostgreSQL数据库添加了一些Java类型与数据库类型的转换处理类，如将List、Map类型与MySQL数据库的json类型进行转换处理 对Domain、Mapper、Service、Controller各层进行了封装，将基本的增删改查功能在各层通用化 提供了基于druid连接池的自动配置 其它一些调整，如默认映射复杂类型属性（主要是List、Map类型，其它自定义类型需要自定义转换处理类），将枚举作为简单类型处理 提供了一个parent项目，将一些常用的框架进行集成，实际项目可继承parent简化依赖配置（持续更新完善） 该框架可用于实际基于springboot的项目，只需简单配置数据源，即可引入druid连接池及通用mapper的功能，以及各层基本的增删改查方法。 如何使用？下文给出使用步骤，可参考示例：https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper 1. 框架Maven部署安装下载框架源码后，在项目根路径下执行mvn clean install可安装到本地maven库。如果需要共享，且搭了Nexus私服，则在根路径pom.xml文件中添加distributionManagement配置，指定Nexus仓库分发地址，使用mvn clean deploy安装到远程maven仓库，如1234567891011121314&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;url&gt; http://ip:port/repository/maven-releases/ &lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;url&gt; http://ip:port/repository/maven-snapshots/ &lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 上述指定的repository需要在maven的全部配置文件settings.xml中有对应账号配置(id需要一一对应)，如 123456789101112 &lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;xxx&lt;/password&gt; &lt;/server&gt;&lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;xxx&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 2. pom.xml配置项目中引入该数据库框架有三种方式： 直接引入 cn.jboost.springboot:tkmapper-spring-boot-starter（没有连接池） 直接引入 cn.jboost.springboot:druid-spring-boot-starter（druid连接池支持） 项目继承 cn.jboost.springboot:spring-boot-parent（使用的是druid连接池） 三种方式的pom.xml配置如下 123456789101112131415161718192021#第一种方式&lt;dependency&gt; &lt;groupId&gt;cn.jboost.springboot&lt;/groupId&gt; &lt;artifactId&gt;tkmapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;#第二种方式&lt;dependency&gt; &lt;groupId&gt;cn.jboost.springboot&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;#第三种方式&lt;parent&gt; &lt;groupId&gt;cn.jboost.springboot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;1.2-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 根据情况引入mysql或postgresql的驱动依赖（其它数据库暂未做类型转换支持，未作测试） 3. 配置数据源如果使用druid连接池，则在application.yml配置文件中，加入如下数据源配置（推荐）12345678910111213141516171819202122232425262728293031spring: datasource: druid: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8 username: root password: # 自定义配置 initialSize: 2 # 初始化大小 minIdle: 1 # 最小连接 maxActive: 5 # 最大连接 druidServletSettings: allow: 127.0.0.1 deny: loginUsername: admin loginPassword: Passw0rd resetEnable: true druidFilterSettings: exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*' maxWait: 60000 # 配置获取连接等待超时的时间 timeBetweenEvictionRunsMillis: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 minEvictableIdleTimeMillis: 300000 # 配置一个连接在池中最小生存的时间，单位是毫秒 validationQuery: SELECT 'x' testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 打开PSCache，并且指定每个连接上PSCache的大小 maxPoolPreparedStatementPerConnectionSize: 20 filters: stat #,wall（添加wall代码里不能直接拼接sql，druid有sql注入校验） # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 useGlobalDataSourceStat: true # 合并多个DruidDataSource的监控数据 如果不使用连接池，则配置相对简单，如下123456spring: datasource: url: jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8 username: root password: driver-class-name: com.mysql.jdbc.Driver 4. 定义相应domain，mapper，service，controller各层对象以demo为例（demo数据库脚本见resources/schema.sql），domain定义一个User类,12345678910111213141516@Table(name = \"user\")@Getter@Setter@ToStringpublic class User extends AutoIncrementKeyBaseDomain&lt;Integer&gt; &#123; private String name; @ColumnType(jdbcType = JdbcType.CHAR) private Gender gender; private List&lt;String&gt; favor; private Map&lt;String, String&gt; address; public enum Gender&#123; M, F &#125;&#125; 需要添加@Table注解指定数据库表名，可通过继承AutoIncrementKeyBaseDomain来实现自增主键，或UUIDKeyBaseDomain来实现UUID主键，如果自定义其它类型主键，则继承BaseDomain。 该框架Service层通用方法实现BaseService只支持单列主键，不支持组合主键（也不建议使用组合主键） 框架默认对List、Map等复杂类型属性会映射到mysql的json类型或postgresql的jsonb类型，如果某个属性不需要映射，可添加@Transient注解；枚举类型需添加@ColumnType指定jdbcType。 dao层定义UserMapper，123@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; BaseMapper默认实现了单表的增删改查及批量插入等功能，如需定义复杂查询，可在该接口中定义，然后通过mapper xml文件编写实现。 service层定义 UserService，继承了BaseService的通用功能（具体可查看源码），同样可在该类中自定义方法12345678910@Servicepublic class UserService extends BaseService&lt;Integer, User&gt; &#123; @Transactional public void createWithTransaction(User user)&#123; create(user); //用于测试事务 throw new RuntimeException(\"抛出异常，让前面的数据库操作回滚\"); &#125;&#125; controller层定义 UserController，继承了BaseController的通用接口（具体可查看源码）1234@RestController@RequestMapping(\"/user\")public class UserController extends BaseController&lt;Integer, User&gt; &#123;&#125; 如上，只需要定义各层对应的接口或类，继承基础接口或类，便完成了用户基本的增删改查功能，不需要写一行具体的实现代码。 5. 测试、运行 示例中提供了两个新建用户的单元测试，参考SpringbootTkmapperApplicationTests类 运行，在主类上直接运行，然后浏览器里打开 http://localhost:8080/user 则可列出单元测试中创建的用户（其它接口参考BaseController实现） 6. 总结本文介绍框架基于tk.mybatis:mapper-spring-boot-starter做了一些自定义扩展，以更大程度地实现复用。可用于实际项目开发，使用过程中如果遇到问题，可关注公众号留言反馈。我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy ———————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.jboost.cn/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.jboost.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.jboost.cn/tags/springboot/"}]},{"title":"案例解析：使用IDEA异常断点来定位java.lang.ArrayStoreException的问题","slug":"issue-errortrack","date":"2019-06-21T10:31:03.000Z","updated":"2019-06-21T11:27:06.343Z","comments":true,"path":"2019/06/21/issue-errortrack.html","link":"","permalink":"http://blog.jboost.cn/2019/06/21/issue-errortrack.html","excerpt":"最近对 base-spring-boot （https://github.com/ronwxy/base-spring-boot） 项目进行了升级。在将其用于应用开发中时遇到java.lang.ArrayStoreException的异常导致程序无法启动。平常开发过程中面对这种描述不够清楚，无法定位具体原因的问题该如何处理？本文分享通过使用IDEA异常断点来定位此类问题的方法。","text":"最近对 base-spring-boot （https://github.com/ronwxy/base-spring-boot） 项目进行了升级。在将其用于应用开发中时遇到java.lang.ArrayStoreException的异常导致程序无法启动。平常开发过程中面对这种描述不够清楚，无法定位具体原因的问题该如何处理？本文分享通过使用IDEA异常断点来定位此类问题的方法。 启动程序时抛出如下异常，导致启动失败 12345678910111213141516171819202122232425org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;devGlobalExceptionHandler&apos; defined in class path resource [cn/jboost/springboot/autoconfig/error/exception/ExceptionHandlerAutoConfiguration.class]: Post-processing of merged bean definition failed; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:570) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:843) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at com.cnbot.kindergarten.CnbotKindergartenApplication.main(CnbotKindergartenApplication.java:10) [classes/:na]Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724) ~[na:1.8.0_201] at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531) ~[na:1.8.0_201] at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355) ~[na:1.8.0_201] at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286) ~[na:1.8.0_201] at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120) ~[na:1.8.0_201] at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72) ~[na:1.8.0_201] ... 单纯看异常栈，无法定位问题原因，只能看到是在调用devGlobalExceptionHandler创建bean时出错，错误信息java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy。这属于框架内部抛出的异常，通常的设置断点Debug的方法很难定位到具体原因，可通过IDEA的异常断点来进行定位，它会在程序运行过程中出现指定异常时进行阻断。 1. 添加异常断点在IDEA的Debug面板中，点击“View Breakpoints”（两个重叠的红色圈按钮），如下 打开“Breakpoints”窗口，在该窗口中点击“+”按钮，选择“Java Exception Breakpoints”， 如下图 然后在弹出的“Enter Exception Class”窗口中输入ArrayStoreException选中对应异常，依次点击OK，Done按钮即完成异常断点添加。 2. 程序debug开始以Debug模式启动程序。 程序运行后，在前面配置的异常出现时，将会进行阻断，如图 可以看到程序阻断在上图高亮的那行代码处，异常便是从这里抛出的。查看parseClassValue方法，可看到这里有catchTypeNotPresentException异常，并且包装成我们在异常栈看到的TypeNotPresentExceptionProxy返回。离真相很近了。 我们可以在上述catch块中添加一个断点，查看异常包装前的状态，如图 重新Debug运行，将定位到上图代码处，查看异常，看到如下图所示信息 该信息表示org.springframework.security.access.AccessDeniedException这个类不存在，导致BaseWebApplicationExceptionHandler类型的bean实例化时出错。这时候问题基本已经定位到了。 查看源码，在BaseWebApplicationExceptionHandler中有对AccessDeniedException的统一处理，但是spring-boot-autoconfigure所有的依赖都是optional的（不会传递依赖），而在新开发的项目中，并没有引入spring-security，因此导致AccessDeniedException这个类找不到而报错。目前通过去掉该部分处理解决。 总结IDEA的Debug支持好几种断点类型，如前文介绍的异常断点，以及比较常用的条件断点等。当无法从异常栈信息找到问题所在时，借用这些类型的断点进行Debug，往往事情就变得简单了。 我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy ———————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"案例解析","slug":"案例解析","permalink":"http://blog.jboost.cn/categories/案例解析/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.jboost.cn/tags/java/"}]},{"title":"Spring Boot从入门到实战：整合Web项目常用功能","slug":"springboot-base","date":"2019-06-20T14:17:22.000Z","updated":"2019-06-21T10:28:06.768Z","comments":true,"path":"2019/06/20/springboot-base.html","link":"","permalink":"http://blog.jboost.cn/2019/06/20/springboot-base.html","excerpt":"在Web应用开发过程中，一般都涵盖一些常用功能的实现，如数据库访问、异常处理、消息队列、缓存服务、OSS服务，以及接口日志配置，接口文档生成等。如果每个项目都来一套，则既费力又难以维护。可以通过Spring Boot的Starter来将这些常用功能进行整合与集中维护，以达到开箱即用的目的。","text":"在Web应用开发过程中，一般都涵盖一些常用功能的实现，如数据库访问、异常处理、消息队列、缓存服务、OSS服务，以及接口日志配置，接口文档生成等。如果每个项目都来一套，则既费力又难以维护。可以通过Spring Boot的Starter来将这些常用功能进行整合与集中维护，以达到开箱即用的目的。 项目基于Spring Boot 2.1.5.RELEASE 版。项目地址： https://github.com/ronwxy/base-spring-boot 整个项目分为如下几部分： spring-boot-autoconfigure： 具体的各功能实现，每个功能通过package的形式组织 spring-boot-commons： 一些公共的工具类或共享类 spring-boot-dependencies： 依赖的集中维护管理，集中管理各个依赖的版本号 spring-boot-parent： 提供一个基本的父项目，web服务项目可通过继承该项目创建 spring-boot-starters： 各功能的starter项目，引入相应starter即引入相应功能 spring-boot-dependencies 项目该项目主要是对所有依赖进行集中定义。通过 dependencyManagement 对依赖进行声明， 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.jboost.springboot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;base-spring-boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; ... &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 这样，所有依赖的版本可以集中统一管理，在其它地方引用的时候可以省去版本的声明，如 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; spring-boot-autoconfigure 项目该项目是各功能自动配置的具体实现，以package的形式进行组织，如 tkmapper 包下实现了通用Mapper的自动配置，error 包下实现了错误处理的自动配置， 等等。 该项目继承了spring-boot-dependencies， 在项目的 pom.xml 中，依赖部分声明类似于 1234567891011121314&lt;dependencies&gt; &lt;!-- spring denpendencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; ...&lt;/dependencies&gt; 不需要再指定版本号，通过将optional设置为true，表示该依赖不会进行传递，即另外一个项目引用该项目时，optional的依赖不会被传递依赖过去。 在 resources/META-INF/spring.factories 文件中，声明了所有自动配置类， 如下 1234567891011org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\cn.jboost.springboot.autoconfig.tkmapper.MapperAutoConfiguration,\\cn.jboost.springboot.autoconfig.aoplog.AopLoggerAutoConfiguration,\\cn.jboost.springboot.autoconfig.alimq.config.AliMQAutoConfiguration,\\cn.jboost.springboot.autoconfig.qiniu.QiniuAutoConfiguration,\\cn.jboost.springboot.autoconfig.swagger.Swagger2AutoConfiguration,\\cn.jboost.springboot.autoconfig.druid.DruidAutoConfiguration,\\cn.jboost.springboot.autoconfig.error.exception.ExceptionHandlerAutoConfiguration,\\cn.jboost.springboot.autoconfig.alimns.MnsAutoConfiguration,\\cn.jboost.springboot.autoconfig.redis.RedisClientAutoConfiguration,\\cn.jboost.springboot.autoconfig.web.CORSAutoConfiguration spring-boot-starters 项目该项目包含按功能划分的多个子项目，主要用来引入依赖以达到自动配置的依赖条件，使引入对应starter时，能让自动配置生效。如通用Mapper集成的 tkmapper-spring-boot-starter 依赖如下 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 同时在 resources/META-INF/spring.provides 里声明了该starter的用途，这里可随意编写。 spring-boot-commons 项目可将一些常用的工具类， 或共享类放到这个项目中。比如一些常量定义，加解密工具类等。 spring-boot-parent 项目该项目将Web应用需要的一些常见功能整合进来，应用项目可继承该项目进行构建，从而直接引入相应的功能。 在接下来的spring boot系列博文中，将一一详细介绍各功能的整合集成与应用。同时会不断更新与完善，以达到能直接用于生产项目的水平。 我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy ——————————————————————————————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.jboost.cn/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.jboost.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.jboost.cn/tags/springboot/"}]},{"title":"研发团队如何借助Gitlab来做代码review","slug":"code-review","date":"2019-06-18T12:03:21.000Z","updated":"2019-06-19T02:21:39.715Z","comments":true,"path":"2019/06/18/code-review.html","link":"","permalink":"http://blog.jboost.cn/2019/06/18/code-review.html","excerpt":"代码review是代码质量保障的手段之一，同时开发成员之间代码review也是一种技术交流的方式，虽然会占用一些时间，但对团队而言，总体是个利大于弊的事情。如何借助现有工具在团队内部形成代码review的流程与规范，是team leader或技术管理者需要考虑的问题。本文分享一种基于Gitlab代码merge流程的code review方法，以供参考与探讨。如有更好的方法，欢迎交流。","text":"代码review是代码质量保障的手段之一，同时开发成员之间代码review也是一种技术交流的方式，虽然会占用一些时间，但对团队而言，总体是个利大于弊的事情。如何借助现有工具在团队内部形成代码review的流程与规范，是team leader或技术管理者需要考虑的问题。本文分享一种基于Gitlab代码merge流程的code review方法，以供参考与探讨。如有更好的方法，欢迎交流。 1. 设置成员角色首先需要对你团队的成员分配角色，在Gitlab groups里选择一个group，然后左边菜单栏点击 Members，可在 Members 页面添加或编辑成员角色，如下图所示。 其中角色包含如下几类： Guest：权限最小，基本查看功能 Reporter：只能查看，不能push Developer：能push，也能merge不受限制的分支 Master：除了项目的迁移、删除等管理权限没有，其它权限基本都有 Owner：权限最大，包括项目的迁移、删除等管理权限 详细权限参考： https://docs.gitlab.com/ee/user/permissions.html 确定团队中技术水平、经验较好的成员为Master，负责代码的review与分支的合并；其他成员为Developer，提交合并请求，接受review意见；Master之间可以互相review。 2. 配置分支保护在项目页面左侧菜单栏 Settings -&gt; Repository， 进入“Protected Branches”部分配置分支保护，如下图所示。 在这里可以针对每个分支，设置允许什么角色可以merge，允许什么角色可以push，选项包括三个：“Masters”， “Developers + Masters”， “No one”。这里设置成只允许master可以直接push与merge这几个常设分支的代码。（如果更严格一点，可以将“Allowed to push”设置成“No one”） 3. 代码review流程3.1. 开发（开发者负责） 本地切到develop分支， 拉取最新代码（相关命令如下，GUI工具操作自行查相关文档） 123git branch #查看当前位于哪个分支，前面打星号即为当前分支git checkout develop #切换到develop分支git pull #拉取最新代码 从develop分支切出子分支 1git checkout -b feature-1101 #从当前分支切出子分支，命名为\"feature-1101\" 编码、本地自测完之后，提交子分支到远程仓库 123git add * #加入暂存区git commit -m \"commit msg\" #提交到本地仓库git push origin feature-1101 #提交到远程仓库 3.2 发起Merge请求（开发者负责） 在项目主页面，依次点击左侧“Merge Requests”（下图1），“New merge request”（下图2），打开新建Merge请求页面 在新建Merge请求页面，选择merge的源分支，及目标分支，如下图源分支为“feature-1101”，目标分支为“develop”，点击“Compare branches and continue”按钮进入对比与提交页面 在对比与提交页面，可以点击“Changes” tab查看本次修改（这里我为了演示，只是加了两个换行），确认无误，点击“Submit merge request”按钮，提交merge请求 提交之后，将结果页面的浏览器地址发到团队即时通讯群（如钉钉），并@相应的同事申请review 3.3 代码Review（code reviewer负责） 负责代码Review的同事收到申请后，点击merge请求地址，打开页面，查看“Changes” 这里可通过“Inline”单边查看，也可以通过“Side-by-side”两个版本对比查看 review完成后，若无问题，则可点击”Merge”按钮完成merge，同时可删除对应的子分支“feature-1101”，若有问题，则可点击“Close merge request”按钮关闭该merge请求（也可以不关闭复用该merge请求），同时通知开发者进行相应调整，重新提交代码发起merge请求（如果之前没关闭merge请求，则刷新即可看到调整）。 3.4 冲突解决（开发者负责） merge的时候，可能存在代码冲突，这时，开发者可从develop分支重新拉取最新代码进行本地merge， 解决冲突后重新提交代码进行review 12345678git pull origin develop #在当前子分支拉取develop分支的最新代码进行本地merge# 解决冲突代码# 提交git add *git commit -m \"fix merge conflict\"git push origin feature-1101 自行解决不了时，寻求协助 4. 借助阿里钉钉机器人来改善体验前面流程中提醒code reviewer是需要开发者自己来发消息通知的，可不可以把这个流程自动化。我们可以借助Gitlab的webhook与钉钉机器人来实现。 在钉钉群右上角点击“…”，打开群设置，群机器人中点击添加机器人，会显示可以添加的机器人类型，如下图所示 选择Gitlab，点击添加，输入机器人名称，如“Gitlab”，点击完成即创建了一个Gitlab的钉钉机器人。回到“群机器人”窗口，将能看到刚刚创建的Gitlab机器人，如图 点击齿轮按钮，进入设置页，可看到webhook地址，点击复制，复制该机器人的webhook地址。如图 在Gitlab项目主页进入 Settings -&gt; Integrations， 将前面复制的webhook地址填入URL中，Trigger 部分选择“Merge request events”（不要勾太多，不然提醒太多就有点骚扰了），然后点击“Add webhook”就完成了。如图 当有开发人员提交merge请求时，钉钉机器人将在钉钉群里发出通知，code reviewer点击消息里的链接即可进入页面进行code review， review完成，将分支merge之后，钉钉机器人也会发出消息（所有merge相关的事件都会发出消息）。如图 5. 总结团队协作，流程、规范很重要，不同的团队可能有不同的适用流程与规范。此文分享了基于Gitlab与阿里钉钉群机器人的代码review流程，希望对团队研发协作有一定参考价值，也欢迎一起探讨、交流。 我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy ———————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"teamwork","slug":"teamwork","permalink":"http://blog.jboost.cn/categories/teamwork/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.jboost.cn/tags/git/"}]},{"title":"团队项目的Git分支如何管理","slug":"git-branch","date":"2019-06-17T05:28:19.000Z","updated":"2019-06-18T12:03:59.043Z","comments":true,"path":"2019/06/17/git-branch.html","link":"","permalink":"http://blog.jboost.cn/2019/06/17/git-branch.html","excerpt":"许多公司的开发团队都采用Git来做代码版本控制。如何有效地协同开发人员之间，以及开发、测试、上线各环节的工作，可能都有各自的流程与规范。本文分享的是作者一直沿用的团队项目Git分支管理规范，希望给有缘阅读的人以参考，如果有更好的实践，也欢迎指教、讨论。","text":"许多公司的开发团队都采用Git来做代码版本控制。如何有效地协同开发人员之间，以及开发、测试、上线各环节的工作，可能都有各自的流程与规范。本文分享的是作者一直沿用的团队项目Git分支管理规范，希望给有缘阅读的人以参考，如果有更好的实践，也欢迎指教、讨论。 分支管理创建项目时（一般是服务型项目，工具型或辅助型项目可以简单一些），会针对不同环境创建三个常设分支： develop：开发环境的稳定分支，公共开发环境基于该分支构建。 pre-release：测试环境的稳定分支，测试环境基于该分支构建。 master：生产环境的稳定分支，生产环境基于该分支构建。仅用来发布新版本，除了从pre-release或生产环境Bug修复分支进行merge，不接受任何其它修改 平时开发工作中，会根据需要由开发人员创建两类临时分支： 功能（feature）分支：为了开发某个特定功能，从develop分支上面分出来的。开发完成后，要merge到develop分支。功能分支的命名，可以采用feature-*的形式命名(*为任务单号) Bug修复（fixbug）分支：为了修复某个bug，从常设分支上面分出来的。修复完成后，再merge到对应的分支。Bug修复分支的命名，可以采用fixbug-*的形式命名（*为bug单号） 流程规范正常开发流程 从develop分支切出一个新分支，根据是功能还是bug，命名为feature-* 或 fixbug-*。 开发者完成开发，提交分支到远程仓库。 开发者发起merge请求（可在gitlab页面“New merge request”），将新分支请求merge到develop分支，并提醒code reviewer进行review code reviewer对代码review之后，若无问题，则接受merge请求，新分支merge到develop分支，同时可删除新建分支；若有问题，则不能进行merge，可close该请求，同时通知开发者在新分支上进行相应调整。调整完后提交代码重复review流程。 转测时，直接从当前develop分支merge到pre-release分支，重新构建测试环境完成转测。 测试完成后，从pre-release分支merge到master分支，基于master分支构建生产环境完成上线。并对master分支打tag，tag名可为v1.0.0_2019032115（即版本号_上线时间） 流程示意图如下所示 并行开发测试环境Bug修复流程并行开发（即前一个版本已经转测但未上线，后一个版本又已在开发中并部分合并到了develop分支）过程中，转测后测试环境发现的bug需要修复，但是develop分支此时又有新内容且该部分内容目前不计划转测，可以pre-release切出一个bug修复分支。完成之后需要同时merge到pre-release分支与develop分支。merge时参考“正常开发流程”。流程示意图如下 生产环境Bug修复流程生产环境的Bug分两种情况： 紧急Bug：严重影响用户使用的为紧急Bug，需立即进行修复。如关键业务流程存在问题，影响用户正常的业务行为。 非紧急Bug或优化：非关键业务流程问题，仅影响用户使用体验，或出现频率较小等，为非紧急Bug，可规划到后续版本进行修复。 非紧急Bug修复参考“正常开发流程”。 紧急Bug修复，需要从master分支切出一个bug修复分支，完成之后需要同时merge到master分支与develop分支（如果需要测试介入验证，则可先merge到pre-release分支，验证通过后再merge到master分支上线）。merge时参考“正常开发流程”。流程示意图如下 我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy ———————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"teamwork","slug":"teamwork","permalink":"http://blog.jboost.cn/categories/teamwork/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.jboost.cn/tags/git/"}]},{"title":"命令行高效操作Git，看这篇就够了","slug":"use-git","date":"2019-06-16T06:30:07.000Z","updated":"2019-06-16T09:33:04.787Z","comments":true,"path":"2019/06/16/use-git.html","link":"","permalink":"http://blog.jboost.cn/2019/06/16/use-git.html","excerpt":"对于软件开发人员来说，git几乎是每天都需要接触的工具。但对于相处如此亲密的工作伙伴，你对它的了解又有多少，是不是还在傻瓜式地打开一个GUI工具，点击提交按钮，然后“卧槽，又冲突了”，一脸懵逼到不知所措，责怪谁又在你前面提交了，谁又改了你的代码。","text":"对于软件开发人员来说，git几乎是每天都需要接触的工具。但对于相处如此亲密的工作伙伴，你对它的了解又有多少，是不是还在傻瓜式地打开一个GUI工具，点击提交按钮，然后“卧槽，又冲突了”，一脸懵逼到不知所措，责怪谁又在你前面提交了，谁又改了你的代码。 博主从一开始接触git，就没用过任何GUI工具，都是通过命令行进行操作，发现这种方式不仅对git的理解更深，效率也更高，遇到问题时一般都知道如何来处理，故做此分享。本文所有知识与操作只涉及日常使用场景，更多详细内容可自行查阅其它资料。本文Git版本为 windows-2.20.1版。 基础理论git的理论知识，对使用者来说只需要知道它是分布式版本控制系统，了解如下三个概念即可， 工作区：就是你直接操作的文件目录与内容 暂存区：暂时为你保存还没将内容提交到版本库的一个区域，对应.git目录下的stage或index文件 版本库：分本地版本库与远程版本库，本地版本库就理解为对应.git目录即可，远程版本库就是远程仓库，如gitlab或github的repository。 如下图，我们平时提交代码的过程基本都是从工作区add到暂存区，然后再commit到本地仓库，最后push到远程仓库。 基本命令对于日常工作，掌握如下几个基本命令一般就够了 git status 查看修改状态 git pull origin master 拉取远程仓库master分支合并到本地，master根据场景换成其它分支名 git add file 添加文件到暂存区，可用 * 添加所有 git commit -m &quot;commit message&quot; 提交到本地版本库，并添加注释，注释表明此次修改内容，要清晰准确 git push origin master 将本地版本提交到远程仓库的master分支，master根据场景换成其它分支名 对大部分日常工作来说， 上面几个命令基本就够用了。 新建项目1. 从本地到远程 项目开发的时候，有时候是先在本地建一个项目，再提交到远程仓库的。 创建项目目录（或通过IDE创建），命令行cd到项目目录 执行git init ， 将在项目目录创建.git目录 执行git add * ，将所有文件添加到暂存区，这里要先创建一个.gitignore文件，将不需要版本维护的文件添加进去忽略，不然各种IDE编译文件夹，环境相关文件都加到版本库去了。删除文件用git rm file_name 执行git commit -m &quot;upload project&quot; ，提交到本地仓库 在gitlab或github上创建一个仓库，并将仓库地址复制下来 执行git remote add origin git@server-name:path/repo-name.git ，关联远程仓库，仓库地址如果是http开头则要用户名密码，如果是git开头，则是走的ssh协议，需要将你本机的ssh公钥添加到远程仓库服务上。 执行git push -u origin master ，推送本地仓库内容到远程仓库 这样在远程仓库目录，就能看到你提交上去的文件内容了。 2. 从远程到本地更多的时候，是远程仓库已有项目了，需要下载到本地开发。 git clone git@server-name:path/repo-name.git ， 将远程仓库的内容下载到本地，这里仓库地址的处理同上 修改内容 git add * ，将修改的内容添加到暂存区 git commit -m &quot;fix xxx issue&quot; ，提交到本地仓库 git push -u origin master ， 推送本地仓库内容至远程仓库 版本回退有时候改了文件，想反悔怎么办，git给你“后悔药”。 单个文件的还原： git checkout file_name ，丢弃工作区的修改，还原到上次提交（commit）的版本， git reset HEAD file_name ，把暂存区的修改撤销掉（unstage），重新放回工作区。即还原到上次添加到暂存区（add）的版本 这里涉及几个场景 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout file_name。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时（执行了add，但没执行commit），想丢弃修改，分两步，第一步用命令git reset HEAD file_name，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次的全部提交，参考下面的整个版本的还原，不过前提是没有推送到远程库。 整个版本的还原： git reset --hard HEAD^^， 回退到上上个版本 git reset --hard 3628164， 回退到具体某个版本 3628164 是具体某个commit_id缩写 找不到commit_id？ git reflog 可查看每一个命令的历史记录，获取对应操作的commit_id。git log [--pretty=oneline]， 可查看commit记录 上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100。3628164 是具体某个commit_id，不需要写全，只需要唯一确定就行，可往前进也可往后退。（git windows2.20.1版貌似不支持对HEAD^的操作） 多人协作 首先，可以试图用 git push origin branch_name 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用 git pull 试图合并； 如果合并有冲突，则手动解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用 git push origin branch-name 推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致 分支管理平时开发时需要创建子分支来实现你的功能模块，然后再合并到主分支中。 git checkout -b your_branch_name ， 创建并切换分支 git branch ， 查看分支，标有*号表示当前所在分支 git merge dev ， 合并指定dev分支到当前分支 git merge --no-ff -m &quot;merge with no-ff&quot; dev ， 合并分支并生成commit记录 git branch -d dev ， 删除分支 git checkout -b dev = git branch dev + git checkout dev Fast-forward合并，“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。存在冲突的不能fast forward。git merge --no-ff -m &quot;merge with no-ff&quot; dev Fast forward模式下，删除分支后，会丢掉分支信息。如果强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 标签管理当发布版本时，一般需要对当前版本进行标签记录，以便后续进行版本查看或回退。 git tag tag_name ， 对当前分支打标签 git tag ， 查看所有标签 git tag v0.9 6224937 ，针对某个具体commit id打标签 git show tag_name ， 查看标签信息 git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 ， 带有说明的标签 git tag -d v0.1 ， 删除标签 git push origin tag_name ， 推送标签到远程 git push origin --tags ， 一次性推送所有标签 删除已经推送到远程的标签： git tag -d v0.9 ， 先本地删除 git push origin :refs/tags/v0.9 ， 然后从远程删除 提高效率的Tips 配置命令别名 123git config --global alias.st status # 后面可以用git st 来代替git status了git config --global alias.ck checkout # 后面可以用 git ck 来代替 git checkout了git config --global alias.cm 'commit -m' # 后面可以用git cm 来代替 git commit -m 了 git pull origin master 或 git push origin master， 可直接 git pull 或 git push， 如果出现“no tracking information”的提示，则说明本地分支和远程分支的链接关系没有创建，用命令 git branch --set-upstream-to=origin/master master 建立关联即可。 总结以上命令虽然看起来多，但平常用的最频繁的应该是“基本命令”与“分支管理”部分，只要多用几次，自然便能记住，应付日常工作完全没有问题，彻底脱离GUI操作，让工作更有效率。 我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy ———————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"高效工作","slug":"高效工作","permalink":"http://blog.jboost.cn/categories/高效工作/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.jboost.cn/tags/git/"}]},{"title":"案例解析：线程池使用不当导致系统崩溃","slug":"issue-threadpool","date":"2019-06-15T03:01:58.000Z","updated":"2019-06-16T06:31:49.313Z","comments":true,"path":"2019/06/15/issue-threadpool.html","link":"","permalink":"http://blog.jboost.cn/2019/06/15/issue-threadpool.html","excerpt":"前几天，发现一台阿里云服务器上的Web服务不可用。远程SSH登录不上，尝试几次登录上去之后，执行命令都显示1-bash: fork: Cannot allocate memory 一看以为是内存泄漏导致溢出。因为执行不了任何命令， 只能通过控制台重启服务器恢复服务。","text":"前几天，发现一台阿里云服务器上的Web服务不可用。远程SSH登录不上，尝试几次登录上去之后，执行命令都显示1-bash: fork: Cannot allocate memory 一看以为是内存泄漏导致溢出。因为执行不了任何命令， 只能通过控制台重启服务器恢复服务。 初步排查服务恢复后，查看系统日志，linux系统日志路径/var/log/messages，可通过journalctl命令查看，如12journalctl --since=\"2019-06-12 06:00:00\" --until=\"2019-06-12 10:00:00\"` 可查看since之后，until之前时间段的日志。除了发现crond[14954]: (CRON) CAN&#39;T FORK (do_command): Cannot allocate memory 这个错误日志，未见其它异常（下面的sshd[10764]: error: fork: Cannot allocate memory应是ssh登录执行命名失败的日志） 通过阿里云-云监控-主机监控查看内存使用率指标，这段时间内，内存使用率一直在40%以下，基本可排除内存溢出的可能。 通过搜索查阅到进程数超过操作系统限制可能导致bash: fork: Cannot allocate memory的报错(参考： https://blog.csdn.net/wangshuminjava/article/details/80603847 ）。通过ps -eLf|wc -l查看当前进程线程数(ps -ef只打印进程，ps -eLf会打印所有的线程), 只有1000多个，故障时刻系统到底运行了多少线程已无从得知，只能持续跟进监测。 问题定位几天后，再次通过ps -eLf|wc -l查看，发现线程数已达16000多个。直接执行ps -eLf可看到大量tomcat进程所产生的线程，猜测是不是线程死锁导致大量线程未完成一直hung在那里。 执行 jstack 进程号 &gt; ~/jstack.txt 命令将进程所运行线程情况打印出来分析，发现大量的WAITING状态的线程，如下1234567891011\"pool-19-thread-1\" #254 prio=5 os_prio=0 tid=0x00007f0b700a6000 nid=0x29a9 waiting on condition [0x00007f0b274df000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x00000006ce3d8790&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 根据上述内容可看出线程在等一个条件，并且是在执行LinkedBlockingQueue.take方法的时候，查看该方法的java doc，当队列为空时，该方法将会一直等待直到有元素可用。12345678/** * Retrieves and removes the head of this queue, waiting if necessary * until an element becomes available. * * @return the head of this queue * @throws InterruptedException if interrupted while waiting */E take() throws InterruptedException; 询问同事在哪里用到了LinkedBlockingQueue，同事回忆起不久前用线程池实现往阿里云OSS服务通过追加的方式上传文件功能，查看代码后发现问题——线程池没有关闭。为了使文件片段保存不存在错乱，每次保存文件时，都new了一个线程池对象，1ThreadPoolExecutor saveImgThreadPool = new ThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;()); 但处理完后， 没有关闭这个线程池对象，这样线程池仍会通过take方法去取等待队列中是否还有未完成的线程任务，等待队列为空时将会一直等待，这样就导致大量的线程hung在这里了（基本是只要方法被调一次，就会产生一个hung住的线程）。 延伸 线程状态为“waiting for monitor entry”：意味着它 在等待进入一个临界区 ，所以它在”Entry Set“队列中等待。此时线程状态一般都是 Blocked：java.lang.Thread.State: BLOCKED (on object monitor) 线程状态为“waiting on condition”：说明它在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了 sleep(N)。此时线程状态大致为以下几种：java.lang.Thread.State: WAITING (parking)：一直等那个条件发生（本文案例即为此种场景）；java.lang.Thread.State: TIMED_WAITING (parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。 如果大量线程在“waiting for monitor entry”：可能是一个全局锁阻塞住了大量线程。如果短时间内打印的thread dump 文件反映，随着时间流逝，waiting for monitor entry 的线程越来越多，没有减少的趋势，可能意味着某些线程在临界区里呆的时间太长了，以至于越来越多新线程迟迟无法进入临界区。 如果大量线程在“waiting on condition”：可能是它们又跑去获取第三方资源，尤其是第三方网络资源，迟迟获取不到Response，导致大量线程进入等待状态。所以如果你发现有大量的线程都处在 Wait on condition，从线程堆栈看，正等待网络读写，这可能是一个网络瓶颈的征兆，因为网络阻塞导致线程无法执行。也可能是如本文所提到的，由于程序编写不当所致。 参考： https://www.cnblogs.com/rainy-shurun/p/5732341.html 我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy —————————————————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"案例解析","slug":"案例解析","permalink":"http://blog.jboost.cn/categories/案例解析/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.jboost.cn/tags/java/"}]},{"title":"Spring Boot从入门到实战：写一个自己的starter","slug":"springboot-starter","date":"2019-06-14T07:19:43.000Z","updated":"2019-06-14T04:27:58.543Z","comments":true,"path":"2019/06/14/springboot-starter.html","link":"","permalink":"http://blog.jboost.cn/2019/06/14/springboot-starter.html","excerpt":"曾遇到几位面试者，简历上写着精通Spring Boot，当聊到自动配置及对starter的理解时，却说不出个所以然来。找工作时，简历一定要注重实际，精通这种字眼还是少用，不然面试官对你期望越高，失望也就越大。其实结合前一篇介绍的Spring Boot自动配置，对Spring Boot的Starter实现将很容易理解，不论是使用其官方提供的Starter，还是自定义自己的Starter，都变得很容易。","text":"曾遇到几位面试者，简历上写着精通Spring Boot，当聊到自动配置及对starter的理解时，却说不出个所以然来。找工作时，简历一定要注重实际，精通这种字眼还是少用，不然面试官对你期望越高，失望也就越大。其实结合前一篇介绍的Spring Boot自动配置，对Spring Boot的Starter实现将很容易理解，不论是使用其官方提供的Starter，还是自定义自己的Starter，都变得很容易。 根据前面介绍，Spring Boot自动配置的实现，主要由如下几部分完成： @EnableAutoConfiguration注解 SpringApplication类 spring-boot-autoconfigure jar包 spring.factories文件 项目结构官方提供的starter，大多包含两个jar包： 一个starter——没有任何实现，只用来管理依赖（即实现这个starter的功能需要依赖哪些jar），一个autoconfigure——包含所有具体实现，包括自动配置类，及META-INF/spring.factories文件。本文示例的自定义starter，为了方便，将两者合并写到了一个。 但是在实际项目中，还是建议像官方一样，定义一个spring-boot-dependencies声明所有依赖及其版本，做统一依赖版本管理，一个spring-boot-autoconfigure，实现所有自动配置类及相应的Bean，一个spring-boot-starters，针对每个模块引入必须的jar依赖，方便项目中引入。 官方提供的starter，命名遵循spring-boot-starter-xxx， 自定义starter，命名遵循xxx-spring-boot-starter。 示例的项目结构如下图 springboot-starter这里为了简单，将starter与autoconfigure整到一个项目，命名也为了与前面demo项目保持一致，没按规范来。 配置类 MyAutoConfig12345678910111213@Configuration@EnableConfigurationProperties(MyProperties.class)public class MyAutoConfig &#123; @Autowired private MyProperties myProperties; @Bean @ConditionalOnProperty(prefix = \"my\", name = \"disable\", havingValue = \"false\") public MyService myService()&#123; return new MyService(\"Hi \" + myProperties.getName() + \", welcome to visit \" + myProperties.getWebsite()); &#125;&#125; 该类中通过@EnableConfigurationProperties及@Autowired 引入了配置属性Bean MyProperties 以访问用户配置的属性，@Bean注解即向容器中注入方法返回值类型的Bean，这样在容器其它bean中通过@Autowired即可引用访问， @ConditionalOnProperty是条件注解，这里表明当配置属性my.disable=false时才实例化这个MyService bean。 配置属性类 MyProperties1234567@ConfigurationProperties(prefix = \"my\")public class MyProperties &#123; private String name; private String website; getter/setter;&#125; 配置属性类封装了用户在配置文件中定义的属性，该示例中将前缀为my的属性封装起来，访问name，website对应配置属性key就是my.name，my.website。 服务Bean MyService1234567891011public class MyService &#123; private String hiStr; public MyService(String hiStr)&#123; this.hiStr = hiStr; &#125; public String sayHi()&#123; return this.hiStr; &#125;&#125; 提供服务功能的bean，也即需要实例化注入到Spring上下文的bean。 spring.factories12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ cn.jboost.springboot.starter.MyAutoConfig 指定了自动配置类（带包名的全路径类名） springboot-usingstarter该项目引用springboot-starter，调用MyService服务的项目，主类没什么特别的1234567@SpringBootApplicationpublic class SpringbootUsingstarterApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootUsingstarterApplication.class, args); &#125;&#125; 配置文件application.properties123my.disable=falsemy.name=jboostmy.website=blog.jboost.cn 在测试类SpringbootUsingstarterApplicationTests中编写测试1234567@Autowiredprivate MyService myService;@Testpublic void testStarter()&#123; System.out.printf(myService.sayHi());&#125; pom.xml中引入springboot-starter依赖12345678910111213 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.jboost.springboot&lt;/groupId&gt; &lt;artifactId&gt;springboot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 运行，控制台会打印出 Hi jboost, welcome to visit blog.jboost.cn将配置属性my.disable的值改为true或其它非false的值再运行测试代码试试，会报MyService bean找不到的错误，说明@ConditionalOnProperty注解生效了 本示例仅作实现自定义starter演示用，项目结构、命名都不够规范，仅供参考，项目实战starter在后面继续分享。 本文示例项目源码地址：https://github.com/ronwxy/springboot-demos/tree/master/springboot-starterhttps://github.com/ronwxy/springboot-demos/tree/master/springboot-usingstarter我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy —————————————————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.jboost.cn/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.jboost.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.jboost.cn/tags/springboot/"}]},{"title":"Spring Boot从入门到实战：Spring Boot配置","slug":"springboot-config","date":"2019-06-11T07:46:02.000Z","updated":"2019-06-14T00:15:51.526Z","comments":true,"path":"2019/06/11/springboot-config.html","link":"","permalink":"http://blog.jboost.cn/2019/06/11/springboot-config.html","excerpt":"Spring Boot之所以受开发者欢迎， 其中最重要的一个因素就是其配置简单。传统的Spring应用需要手动配置各种.xml文件，为数据库访问，事务支持，缓存功能等提供各项繁杂且重复的配置。Spring Boot将这种繁杂且重复的工作通过预定义的启动器（starter）来实现，只要引入即可拥有相应的功能支持，从而将开发者从复杂的配置工作中解放出来，能够更专注于业务逻辑的开发。","text":"Spring Boot之所以受开发者欢迎， 其中最重要的一个因素就是其配置简单。传统的Spring应用需要手动配置各种.xml文件，为数据库访问，事务支持，缓存功能等提供各项繁杂且重复的配置。Spring Boot将这种繁杂且重复的工作通过预定义的启动器（starter）来实现，只要引入即可拥有相应的功能支持，从而将开发者从复杂的配置工作中解放出来，能够更专注于业务逻辑的开发。 配置方式在Spring Boot中，虽然仍然可以通过之前的.xml文件方式来进行配置，但最好还是通过基于java的配置来进行配置管理。在Spring Boot中，基于java的配置是通过注解@Configuration来实现的12345678@Configurationpublic class MyConfig &#123; @Bean public MyService myService()&#123; return new MyService(); &#125;&#125; 上述代码将一个MyService的Bean注入了容器，这样在其它地方就可以直接通过@Autowired来引用访问。与.xml文件中通过&lt;bean&gt;&lt;/bean&gt;实例化的效果是一样的。1234567@Autowiredprivate MyService myService;@RequestMapping(\"/hi\")public String sayHello(@RequestParam String name)&#123; return myService.sayHello(name);&#125; 实际项目开发中，有可能存在一些基于xml配置的旧服务，比如以jar包的形式发布，如果要复用该怎么引入呢？很简单，在@Configuration注解标注的类上，加入@ImportResource注解引用相应的xml文件即可，123456789@Configuration@ImportResource(\"spring.xml\")public class MyConfig &#123; @Bean public MyService myService()&#123; return new MyService(); &#125;&#125; 这样类路径下spring.xml配置文件中声明的内容都将生效。在一个应用中，可以定义多个@Configuration配置类，这些配置类可以被@ComponentScan自动扫描并注入容器。 如果应用中没有通过@ComponentScan进行自动扫描，则可在主配置类（一般为入口类）上通过@Import({MyConfig.class})的方式类引入其它配置类 自动配置个人认为，自动配置是Spring Boot非常基础但又核心的部分。曾经遇到几个面试者，简历写着精通Spring Boot，当问及自动配置时却支支吾吾不知所云。其实理解Spring Boot的自动配置也不难，基本了解如下几部分差不多就够了： @EnableAutoConfiguration注解 SpringApplication类 spring-boot-autoconfigure jar包 spring.factories文件 @EnableAutoConfiguration注解这个注解的作用是告诉Spring Boot基于添加的jar依赖来自动配置Spring，比如添加了spring-boot-starter-web依赖，则Spring Boot认为你在开发一个web应用，就会自动做好web相应配置。这个注解一般放在主类上。在前面的示例项目中， 我们在主类上都是使用@SpringBootApplication， 查看源码可以知道： @SpringBootApplication 这个注解实际上等效于 @SpringBootConfiguration（等效于@Configuration）， @EnableAutoConfiguration，启用自动配置 @ComponentScan 自动扫描@Component, @Service, @Controller等注解标注的各类组件 三者的组合。如果去掉@EnableAutoConfiguration注解，则Spring Boot将不会自动配置Spring（如实例化必要的Bean），将可能导致应用启动失败。 SpringApplication类在应用主类中，我们是通过SpringApplication的run方法来启动应用的，如：1234567@SpringBootApplicationpublic class SpringbootConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootConfigApplication.class, args); &#125;&#125; 查看源码，SpringApplication的静态run方法，实际也是通过创建SpringApplication实例，调用实例方法执行，在SpringApplication构造器方法中，调用了getSpringFactoriesInstances 方法，12345678910public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources&#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, \"PrimarySources must not be null\"); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath(); setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass();&#125; 追溯下去，最终会调用到SpringFactoriesLoader的loadSpringFactories方法，123456789101112131415161718192021222324252627private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; ... try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; String factoryClassName = ((String) entry.getKey()).trim(); for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(\"Unable to load factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); &#125;&#125; 在该方法中，会从所有的META-INF目录下加载spring.factories文件里配置的各类型的类名称（包括初始化器，监听器，自动配置类等）。然后上层方法中通过反射机制实例化这些初始化器、监听器，自动配置等，从而完成相应Bean的自动化配置与注入。 spring-boot-autoconfigure 官方提供的starter，如spring-boot-starter-web， 都依赖了spring-boot-starter， 而spring-boot-starter又依赖了spring-boot-autoconfigure。 在spring-boot-autoconfigure中提供了大量官方提供的自动配置类，并且包含META-INF/spring.factories文件，如下图 spring.factories 由上图可看出，spring.factories包含了 org.springframework.context.ApplicationContextInitializer 应用初始化器 org.springframework.context.ApplicationListener 应用监听器 org.springframework.boot.autoconfigure.AutoConfigurationImportListener 自动配置引入监听器 org.springframework.boot.autoconfigure.AutoConfigurationImportFilter 自动配置引入过滤器 org.springframework.boot.autoconfigure.EnableAutoConfiguration 自动配置类 org.springframework.boot.diagnostics.FailureAnalyzer 失败分析器 org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider 模板提供者 其中org.springframework.boot.autoconfigure.EnableAutoConfiguration即实现自动配置的@Configuration配置类列表。 Spring Boot就是通过这种自动配置机制，以starter依赖包的方式，使开发者非常方便地使用项目开发中的许多常用功能，如数据库访问、缓存、队列等。同时，用户也可以根据自身需求，自定义自己的starter（后面介绍）。 通过注解控制自动配置Spring Boot自动配置包含了许多条件类注解及顺序类注解，这些注解可方便地让自动配置按照某种条件或者顺序进行配置。 其中条件类注解包括： 类级别条件注解 @ConditionalOnClass： 类路径中存在指定的类才进行该配置；@ConditionalOnMissingClass： 类路径中不存在指定的类才进行该配置 实例级别条件注解 @ConditionalOnBean：只有在当前上下文中存在指定Bean时，才进行该配置@ConditionalOnMissingBean： 只有在当前上下文不存在指定Bean时，才进行该配置 属性级别条件注解 @ConditionalOnProperty：当存在某个指定属性，且值为指定值时，才进行该配置 资源级别条件注解 @ConditionalOnResource：在类路径下存在指定的Resource时，才进行配置 Web应用条件注解 @ConditionalOnWebApplication：该应用为Web应用时进行该配置@ConditionalOnNotWebApplication： 该应用不为Web应用时进行该配置 SpEL（ Spring Expression Language）表达式注解 @ConditionalOnExpression： 计算SpEL表达式值，值为true时才进行该配置 顺序类注解包括： @AutoConfigureAfter： 在指定的配置类初始化后再加载 @AutoConfigureBefore： 在指定的配置类初始化前加载 @AutoConfigureOrder： 数值越小越先初始化 注意：自动配置类不应该位于组件扫描路径（@ComponentScan注解指定的扫描路径）下，否则上述条件注解与顺序注解可能不会生效。建议只在自动配置的类上注解@ConditionalOnBean， @ConditionalOnMissingBean，因为这可以保证在用户定义bean已经添加到ApplicationContext之后才会加载。这两个注解放在class上，则相当于class里面每一个@Bean标注的方法都加上了。 自动配置是非侵入式的，你可以在任何地方自定义配置来覆盖自动配置中的某些内容，比如你在应用中通过@Configuration类注入一个自定义的DataSource，默认的基于内存的DataSource将被覆盖 禁用某个自动配置类有时候引入的自动配置可能包含我们不想让其生效的配置类，这时候可以通过@EnableAutoConfiguration注解的属性进行排除，使其不生效。1@EnableAutoConfiguration(exclude = &#123;XXAutoConfiguration.class&#125;) 其中XXAutoConfiguration为某个自动配置类，如果该类不在应用的类路径中，则可以通过属性excludeName指定完整类路径来排除。@SpringBootApplicationz注解同样支持1@SpringBootApplication(exclude = &#123;XXAutoConfiguration.class&#125;) 本文示例项目源码地址：https://github.com/ronwxy/springboot-demos/tree/master/springboot-config我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy —————————————————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.jboost.cn/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.jboost.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.jboost.cn/tags/springboot/"}]},{"title":"Spring Boot从入门到实战：Spring Boot自定义属性","slug":"springboot-properties","date":"2019-06-10T10:47:51.000Z","updated":"2019-06-14T00:15:25.108Z","comments":true,"path":"2019/06/10/springboot-properties.html","link":"","permalink":"http://blog.jboost.cn/2019/06/10/springboot-properties.html","excerpt":"Web项目开发中，经常需要自定义一些属性，如数据库连接，第三方服务接口地址，第三方服务的appKey、appSecret等，以及针对不同环境，这些属性的值还需要有相应的调整，如开发环境、测试环境、生产环境所用数据库不同，则针对不同环境的同一属性需要配置不同的值。","text":"Web项目开发中，经常需要自定义一些属性，如数据库连接，第三方服务接口地址，第三方服务的appKey、appSecret等，以及针对不同环境，这些属性的值还需要有相应的调整，如开发环境、测试环境、生产环境所用数据库不同，则针对不同环境的同一属性需要配置不同的值。 传统自定义属性配置及访问（参考Github示例测试类）在传统的Spring Web应用中，自定义属性一般是通过在类路径中（如resources目录）添加一个类似my.properties配置文件（文件名自定义），然后在xml配置中通过 1&lt;util:properties id=\"myProps\" location=\"classpath:my.properties\"/&gt; 引入属性文件。再定义一个Bean来读取这些属性，Bean配置： 12345678&lt;bean class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\"&gt; &lt;property name=\"staticMethod\" value=\"cn.jboost.springboot.properties.MyPropertiesUtil.init\"/&gt; &lt;property name=\"arguments\"&gt; &lt;list&gt; &lt;ref bean=\"myProps\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; Bean定义：123456789101112public class MyPropertiesUtil &#123; private static Properties properties; public static void init(Properties props) &#123; properties = props; &#125; public static String getValue(String key) &#123; return properties.getProperty(key); &#125;&#125; 在其它需要访问的地方通过 MyPropertiesUtil.getValue() 方法来访问具体某个属性的值。 Spring Boot自定义属性配置及优先级在Spring Boot中，可以在多个地方配置属性，包括.properties文件，.yaml文件，环境变量， 系统属性，命令行参数等， 这些属性都会被Spring Boot加载到Environment中，可通过@Value注解，Environment实例，或 @ConfigurationProperties注解的类来访问。 属性加载优先级顺序： 如果有使用devtools，devtools 全局设置的属性（用户目录 ~/.spring-bootdevtools.properties） 测试类的注解@TestPropertySource 测试类注解 @SpringBootTest#properties 配置的属性 命令行参数 SPRING_APPLICATION_JSON里的属性（环境变量或系统属性） ServletConfig初始化参数 ServletContext初始化参数 JNDI参数 java:comp/env Java系统属性 System.getProperties() 操作系统环境变量 RandomValuePropertySource 配置的属性 random.* jar包外部的applictaion-{profile}.properties，applictaion-{profile}.yml配置文件 jar包内部的applictaion-{profile}.properties，applictaion-{profile}.yml配置文件 jar包外部的applictaion.properties，applictaion.yml配置文件 jar包内部的applictaion.properties，applictaion.yml配置文件 @Configuration类上的 @PropertySource注解指定的配置文件 默认属性： SpringApplication.setDefaultProperties 上述属性配置，除了粗体标注的外，其它一般应用较少。序号低的配置优先级高于序号高的配置，即如果存在相同属性配置 ，则序号低的配置会覆盖序号高的配置。applictaion-{profile}.properties 一般用于具体某个环境特有的属性配置，如application-dev.properties用于开发环境，可通过 spring.profiles.active=dev指定加载dev环境配置 常用属性配置方式 命令行参数启动Spring Boot应用时，可以指定命令行参数，如：1java -jar springboot-properties.jar --my.name=jboost@command_line 该参数值将会覆盖应用在其它地方配置的同名属性值。命令行参数放在xx.jar 的后面。 可以通过SpringApplication.setAddCommandLineProperties(false) 禁用命令行参数配置 Java系统属性同样在启动Spring Boot应用时，可以指定Java系统属性，一般见于自定义jvm参数，如：1java -Dmy.name=jboost@system_properties -jar springboot-properties.jar Java系统属性放在java命令之后。 操作系统环境变量（实际应用其实较少）配置过JAVA_HOME的应该理解何为环境变量。某些操作系统可能不支持.分隔的属性名，可以改为以下划线连接。Spring Boot将myName, my.name, MY_NAME视为等效。 应用属性配置文件（.properties文件或 .yml文件）.properties文件属性配置格式： 123my.name=jboostmy.list[0]=aaa //配置列表my.list[1]=bbb .yml文件属性配置格式： 12345my: name: devlink list: //配置列表 - aaa - bbb yml中，属性名与值之间冒号后面必须有空格。 应用属性配置文件位置： jar包所在当前目录下的子目录/config（外置属性文件） jar包所在当前目录（外置属性文件） classpath根目录下的子目录/config（内置属性文件） classpath根目录（内置属性文件） 序号低的优先级高于序号高的优先级，即jar包外的配置优先级高于jar包内的配置。同一目录下，.properties文件的优先级高于.yml文件。application-{profile}.properties的优先级高于application.properties。 Spring Boot自定义属性访问方式（参考Github示例测试类） 类中属性上添加 @Value(“${xx}”) 注解方式。如：12@Value(\"$&#123;my.name&#125;\")private String name; 可以指定默认值，如 @Value(“${my.name:jboost}”)， 当my.name未配置时，默认使用值”jboost” 通过@ConfigurationProperties注解的类来访问。如定义：12345678@Component@ConfigurationProperties(prefix = \"my\")public class MyConfigProperties &#123; private String name; private String website; //省略了getter、setter函数&#125; 然后在需要访问的Bean中，通过@Autowired 注入MyConfigProperties实例，通过getName()方法即可访问my.name属性值。123456789@Autowiredprivate MyConfigProperties myConfigProperties;@Testpublic void testConfigurationProperties()&#123; System.out.println(\"test @ConfigurationProperties ==========\"); System.out.println(myConfigProperties.getName()); System.out.println(myConfigProperties.getWebsite());&#125; 通过Environment 实例访问。如：123456789@Autowiredprivate Environment env;@Testpublic void testEnvironment()&#123; System.out.println(\"test Environment ==========\"); System.out.println(env.getProperty(\"my.name\")); System.out.println(env.getProperty(\"my.website\", \"default value\"));&#125; 另外也可以通过 spring-boot-starter-actuator 的接口来查看项目加载的属性配置，在pom.xml中加入 spring-boot-starter-actuator 依赖，因为 spring-boot-starter-actuator 在2.x版本中，出于安全性考虑，将actuator 控件中的端口，只默认开放/health 和/info 两个端口，其他端口默认关闭，因此需要添加配置management.endpoints.web.exposure.include= *，management.endpoints.web.exposure.exclude=beans,trace，management.endpoint.health.show-details=ALWAYS，启动项目后，访问 http://localhost:8080/actuator/env ，返回的 propertySources 即为加载的所有属性源，优先级从上往下依次降低，与上文所述优先级相符 本文示例项目源码地址：https://github.com/ronwxy/springboot-demos/tree/master/springboot-properties 我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy ——————————————————————————————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.jboost.cn/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.jboost.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.jboost.cn/tags/springboot/"}]},{"title":"Spring Boot从入门到实战：第一个Spring Boot应用","slug":"springboot-firstapp","date":"2019-06-06T12:46:50.000Z","updated":"2019-06-14T00:15:46.644Z","comments":true,"path":"2019/06/06/springboot-firstapp.html","link":"","permalink":"http://blog.jboost.cn/2019/06/06/springboot-firstapp.html","excerpt":"Spring Boot应用可以通过如下三种方法创建： 通过 https://start.spring.io/ 网站创建 通过 Spring Initializr 创建 自主创建","text":"Spring Boot应用可以通过如下三种方法创建： 通过 https://start.spring.io/ 网站创建 通过 Spring Initializr 创建 自主创建 推荐开发工具 JDK 1.8+ IntelliJ IDEA maven 3.3+ 在开始之前，先确认是否安装上述工具，在命令行输入 java -version 查看JDK是否正确安装， 输入 mvn -version 查看maven是否正确安装，如果未正确安装，请先查阅相关文档完成安装。12345678910111213PS D:\\&gt; java -versionjava version \"1.8.0_201\"Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)PS D:\\&gt;PS D:\\&gt;PS D:\\&gt; mvn -versionApache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)Maven home: D:\\tool\\apache-maven-3.6.0\\bin\\..Java version: 1.8.0_201, vendor: Oracle Corporation, runtime: C:\\Program Files\\Java\\jdk1.8.0_201\\jreDefault locale: zh_CN, platform encoding: GBKOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"windows\"PS D:\\&gt; 1. 通过 https://start.spring.io/ 网站创建进入 https://start.spring.io/，填写对应的信息，如下图所示其中project选 Maven Project， Spring Boot版本选 2.1.5 版， Project Metadata部分， Group一般用你域名的倒序字符串，Artifact即项目名称，选择Packaging类型为Jar，Java版本为8，在Dependencies部分输入Web，选中第一个Spring Web Starter，然后点击“Generate the project”按钮，下载生成的项目。解压项目，在IntelliJ IDEA中 File -&gt; Open 选中项目解压目录打开，即可看到生成的项目结构如下图具体各文件含义后面详述。 2. 通过Spring Initializr创建（推荐）IntelliJ IDEA中File -&gt; New -&gt; Project...打开新建项目窗口（这里也可以选择New Module, IDEA的Project类似于Eclipse的Workspace，Module则类似于Eclipse的Project，有时候为了将一些项目统一管理，可以建一个Project，然后在Project内部建立Module），如下图所示 选择Spring Initializr，点击Next，填写相应信息， 如下图所示 点击Next，选择Spring Boot版本以及相应依赖，如下图（这里选择2.1.5版本及Spring Web Starter依赖） 然后依次点击Next, Finish完成项目创建。可以看到创建的项目结构与第一种方法一致。 有的旧IDEA版本下项目可能不能编译，IDE未将其识别为maven项目，只需在pom.xml文件上右键，点击Add as Maven project即可。 3. 自主创建自主创建即像普通Java Maven项目一样，先创建maven项目，然后参考1、2方法中创建的项目结构与目录，手动进行添加。 上述三种创建方法，第1种需要网站生成再下载解压导入，第2种直接基于IDE创建，第3种完全自主手动创建。实际开发中推荐采用第2种创建初始项目原型，再根据具体需求删除或添加相应目录与文件。 4. 项目结构通过上述方法创建的项目，结构如下图所示 其中 SpringbootFirstappApplication 为项目入口类，通过SpringApplication.run()方法来启动项目 入口类上的注解 @SpringBootApplication 表明，这是一个Spring Boot项目，它会为你自动做一些Spring Boot项目的处理 resources 下的static目录为静态资源目录，可以放置js，css，img之类的资源，templates目录可放置模板文件，一般做前后端分离开发，这两个目录可删除 application.properties 文件为项目的配置文件，可在该文件中配置项目所需要的各项配置属性 SpringbootFirstappApplicationTests 生成的测试类，可基于此进行单元测试编写 pom.xml即为maven配置文档，可看到项目已继承spring-boot-starter-parent，并且引入了spring-boot-starter-web，spring-boot-starter-test两项依赖，以及spring-boot-maven-plugin 5. 运行 上述创建的项目可直接运行，大致有如下几种运行方式： 直接在项目入口类SpringbootFirstappApplication中右键，点击Run &#39;SpringbootFirstappAp...&#39;运行 在项目根目录下打开终端，或IDEA的Terminal中执行mvn spring-boot:run（前提是项目pom.xml文件中引入了spring-boot-maven-plugin） 使用mvn package打包，然后通过java -jar target\\springboot-firstapp-1.0.0-SNAPSHOT.jar 启动（一般用于远程环境的部署启动） 如果打包成war，将war包部署到tomcat等Servlet容器运行 项目启动后，从启动日志可看出默认端口为8080，但打开 http://localhost:8080 会显示一个404报错页面，这是因为我们还没有编写任何服务。下面我们添加一个非常简单的Rest服务接口，在项目的根包下（我这里是cn.jboost.springboot.firstapp，实际项目中一般会创建一个controller的子包）添加HelloController类，代码如下 1234567@RestController(\"/hello\")public class HelloController &#123; @GetMapping public String hello(@RequestParam(name = \"name\")String name)&#123; return \"您好，\" + name; &#125;&#125; 其中@RestController注解会将返回结果以字符串的方式解析，@GetMapping等效于@RequestMapping(method = {RequestMethod.GET})重启应用，然后浏览器地址栏中输入 http://localhost:8080/hello?name=jboost， 页面输出如下图： 至此，一个可运行的Web项目即已搭建完成，是不是非常简单。 本文示例项目源码地址：https://github.com/ronwxy/springboot-demos/tree/master/springboot-firstapp我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy ——————————————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.jboost.cn/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.jboost.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.jboost.cn/tags/springboot/"}]},{"title":"Spring Boot从入门到实战：Spring Boot简介","slug":"springboot-overview","date":"2019-06-06T06:29:02.000Z","updated":"2019-06-14T00:15:38.150Z","comments":true,"path":"2019/06/06/springboot-overview.html","link":"","permalink":"http://blog.jboost.cn/2019/06/06/springboot-overview.html","excerpt":"Spring Boot这几年非常流行，差不多是基于Spring框架应用开发的首选，同时在微服务架构领域，如Spring Cloud 框架中，Spring Boot也是基础，因此掌握Spring Boot，应成为Java开发人员必不可少的技能。","text":"Spring Boot这几年非常流行，差不多是基于Spring框架应用开发的首选，同时在微服务架构领域，如Spring Cloud 框架中，Spring Boot也是基础，因此掌握Spring Boot，应成为Java开发人员必不可少的技能。 简述传统的基于Spring的Java Web应用，需要配置 web.xml, applicationContext.xml 等大量xml配置信息，然后将应用打成war包放入web应用服务器(如Tomcat, Jetty等)中运行。有过实践经验的开发者应能体会到这个过程繁杂且重复。Spring Boot将这种繁杂且重复的工作通过自动化配置等手段实现，从而将开发者从复杂的配置工作中解放出来，能够更专注于业务逻辑的开发。因此，Spring Boot并不是Spring的替代解决方案，它本身并不提供Spring框架的核心特性以及扩展功能，而是和Spring框架紧密结合用于提升Spring开发者体验，提高开发效率的的工具框架。截至本文，Spring Boot最新GA版本为2.1.5。 特性Spring Boot框架大致包括如下特性： 自动化配置。Spring Boot 通过autoconfiguration的方式（后面会详细讨论何为autoconfiguration）来简化配置管理。比如如果需要访问数据库，则只需要引入相应的starter依赖包，Spring Boot便会自动为你配置访问数据库所需要的Bean，如 DataSource， JdbcTemplate等。使用Spring Boot，项目中几乎不需要任何 xml 配置文件。 内嵌的Web服务容器。Spring Boot内嵌了Tomcat、Jetty、Undertow。因此，Spring Boot应用可以像普通java应用一样打成jar包直接通过 java -jar 执行，而不需传统web应用一样需要打成war包部署到独立的web服务容器中。 简化依赖管理。Spring Boot官方提供了大量的starter依赖包，帮你管理了使用某个功能所需要的依赖，开发者只需要引入starter依赖，即可使用对应的功能。如spring-boot-starter-web，spring-boot-starter-jdbc等。同时自己也可以自定义starter，为某些通用功能提供模块化共享支持。 提供生产环境级的应用配置、度量指标、操作控制接口。Spring Boot的spring-boot-starter-actuator提供了查看应用配置信息，获取应用运行指标，以及控制应用（如关闭应用）三种类型的接口。通过这些接口，可以排查问题，监控服务运行情况等。 Spring Boot的这些特性，使得应用Spring Boot开发Web应用非常便捷、高效，因此在快速应用开发（Rapid Application Development）领域以及微服务架构方面，Spring Boot都是比较好的选择。 工具该序列涉及的开发工具包括但不限于： JDK 1.8+ , 一般用的是1.8 Maven 3.3+ , 我们用的是Maven3.6.0 IntelliJ IDEA Ultimate Edition， 需要激活，参考这里 MySQL，可选，数据库访问示例需要 Redis， 可选，缓存示例需要 我的个人博客地址：http://blog.jboost.cn我的头条空间： https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112我的github地址：https://github.com/ronwxy我的微信公众号：jboost-ksxy ——————————————————————————————————————————————————————————————— 欢迎关注我的微信公众号，及时获取最新分享","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.jboost.cn/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.jboost.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.jboost.cn/tags/springboot/"}]},{"title":"写在前面","slug":"ahead","date":"2019-06-05T08:48:37.000Z","updated":"2019-06-10T07:36:24.244Z","comments":true,"path":"2019/06/05/ahead.html","link":"","permalink":"http://blog.jboost.cn/2019/06/05/ahead.html","excerpt":"","text":"一点感悟在软件与互联网技术领域从业多年，从一个一知半解的职场菜鸟成长为行业“老司机”，也从一个邯郸学步的技术新手晋升成为能带领团队披荆斩棘，在技术范畴能掌握话语权的技术管理者。其间也与大多数同行一样，踩过不少坑，加过不少班，背过不少锅……，但同时，也为自己不断成长、进步——包括技术、能力层面，也包括薪酬、职位层面，而感到欣慰。但技术领域日新月异，接触的越多，越发现自己的无知，因此 Stay hungry，Stay foolish，保持持续学习的热情，永远不要满足于现状，才能保持自身竞争力，不至于在年龄增长时，出现所谓的“中年危机”。 一点初衷大学期间也曾玩过新浪博客，写过一些心路历程与人生感悟（^_^），随着年龄的增长，逐渐失去了用文字来抒发情感的激情。工作后，开始接触技术博客，也断断续续写过一些分享，但终因阶段性忙或懒惰，没能坚持下来。与之前抒发情感与感悟不同，技术博客更多的是一种经验的自我梳理总结与分享。一方面为那些踏入职场不久实践经验较缺乏的同行提供参考，另一方面也是对自我日常技术工作的整理，以达到“好记性不如烂笔头”的效果。因此，虽然现今从事一线编码工作相对较少，心中一直还是有一个将以往及现在所接触的实践经验记录与分享出来的想法。于是，花了点时间整了这个博客，希望能坚持下去。 一点期望凡事做了，总希望有所回报。整理文章其实需要花费不少时间与精力，因此也希望发出来的分享能为大家带来切实的收获，获得大家的肯定与良性反馈。有更好建议，也欢迎大家通过留言或其它方式与我交流。希望这是一个好的开始，加油！","categories":[],"tags":[]}]}