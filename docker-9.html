<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="erIKW497yS"><meta name="google-site-verification" content="UgdHTfiMSYvSc5WkTMWIBaRheQv9f_np2Dm0RUlPFco"><title> Docker笔记（九）：网络管理 · 空山新雨的技术空间</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Docker笔记（九）：网络管理 - 空山新雨"><meta name="keywords" content="Spring,DevOps,技术管理"><meta name="author" content="空山新雨"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.jboost.cn/atom.xml" title="空山新雨的技术空间"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Docker笔记（九）：网络管理</h1><div class="post-info">2019-08-30<p class="visit"><i data-identity="docker-9.html" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><p>Docker的应用运行在容器中，其相互之间或与外部之间是如何通信的，涉及到哪些知识点，本文对相关内容进行整理。因网络这块牵涉的面较多，因此只从日常使用或理解的角度出发，过于专业的就不深入探讨了。<br><a id="more"></a></p>
<h2 id="1-Docker默认的网络拓扑"><a href="#1-Docker默认的网络拓扑" class="headerlink" title="1. Docker默认的网络拓扑"></a>1. Docker默认的网络拓扑</h2><p>在<a href="/docker-2.html">Docker笔记（二）：Docker管理的对象</a>中，介绍了Docker通过一些驱动程序来实现容器之间或容器与外部的互联，包括bridge（默认的虚拟网桥形式），host（与主机共享网络栈），overlay（跨Docker Daemon容器间的互联），macvlan（为容器分配mac地址），none（禁用所有网络）等。</p>
<p>默认情况下，Docker启动时会创建一个虚拟网桥 docker0，可以理解为一个软件交换机。当创建一个 Docker 容器的时候，会创建一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0 ；另一端在宿主机本地并被挂载到 docker0 网桥，名称以veth 开头，如 veth340c305，docker0会在挂载到它上面的网口之间进行转发，从而实现主机与容器之间及容器与容器之间的相互通信。Docker默认的网络拓扑图如下：<br><img src="/assets/docker0.png" alt="docker0"></p>
<p>我们可以在宿主机上通过<code>ifconfig</code>查看相关的网络接口，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">~$ ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:46ff:fe26:ce0b  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:46:26:ce:0b  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 16868344  bytes 127838098551 (127.8 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 17929275  bytes 137867853738 (137.8 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">veth340c305: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::50f7:7ff:fe8f:6e72  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 52:f7:07:8f:6e:72  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 8093606  bytes 126893792744 (126.8 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8795102  bytes 10834735399 (10.8 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">veth6c803b7: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::1045:4cff:fe66:7f5a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 12:45:4c:66:7f:5a  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 140  bytes 9832 (9.8 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></p>
<p>通过<code>brctl show</code>可查看网络接口的挂载情况，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ brctl show</span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">docker0		8000.02424626ce0b	no		veth340c305</span><br><span class="line">							veth6c803b7</span><br></pre></td></tr></table></figure></p>
<p>由上可看出网络接口veth340c305，veth6c803b7都挂在虚拟网桥docker0上。</p>
<h2 id="2-容器与外部的互联"><a href="#2-容器与外部的互联" class="headerlink" title="2. 容器与外部的互联"></a>2. 容器与外部的互联</h2><p>我们前面的许多容器启动命令都有添加类似 -p 8080:8080 的参数，以指定将宿主机端口映射到容器端口，从而通过访问 <code>宿主机IP：宿主机端口</code> 的地址来访问对应端口的容器服务。<br>端口映射的完整格式为 <code>宿主机IP：宿主机端口：容器端口</code>，其中前两个是可以两者都取，或只取其一</p>
<ul>
<li><code>宿主机IP：宿主机端口：容器端口</code>：将指定宿主机IP的一个指定端口映射到容器端口，如<code>192.168.40.205:8090:8080</code></li>
<li><code>宿主机IP::容器端口</code>：将指定宿主机IP的一个随机端口映射到容器端口上，如果宿主机有多个IP，则可以通过这种格式指定绑定其中一个宿主机IP，随机端口范围为49000~49900</li>
<li><code>宿主机端口：容器端口</code>：将宿主机所有网络接口IP的指定端口映射到容器端口上，<code>8090:8080</code>等效于<code>0.0.0.0:8090:8080</code>（<code>0.0.0.0</code>即表示所有网络接口地址）</li>
</ul>
<p>可以使用 <code>docker port 容器ID或名称 容器端口</code>或<code>docker ps</code>命令来查看端口映射情况，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ docker port test-dev 8080</span><br><span class="line">0.0.0.0:32768</span><br><span class="line"></span><br><span class="line">~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">696a76944e72        cnbots:dev                                      "/bin/sh -c '/usr/lo…"   23 minutes ago      Up 23 minutes       0.0.0.0:32768-&gt;8080/tcp             test-dev</span><br></pre></td></tr></table></figure></p>
<p>在容器启动时，可以多次使用 -p 来指定映射多个端口。</p>
<p>如果不指定具体的宿主机端口，则可以使用 -P（大写）来分配一个宿主机的随机端口（范围为49000~49900）， 如<code>docker run -d -P --name test-dev test:dev</code>，然后通过<code>docker port 容器ID或名称 容器端口</code>或<code>docker ps</code>命令来查看具体映射到了哪个端口。</p>
<h2 id="3-容器之间的互联"><a href="#3-容器之间的互联" class="headerlink" title="3. 容器之间的互联"></a>3. 容器之间的互联</h2><p>同一个Docker Daemon下的容器，彼此之间是可以通过容器IP互相访问的（如何查看容器IP？用<code>docker inspect 容器ID或名称</code>命令），如果要实现两个容器之间可以通过容器名直接访问，则可以通过自建一个docker网络。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个自定义网络，-d 表示网络类型，可以为bridge（网桥，软件交换机），或overlay（跨Docker Daemon容器间的互联）</span></span><br><span class="line">~$ docker network create -d bridge my-net</span><br><span class="line">0c97fc265ed1cab67d84b9376d6914c9558419c73bb5abc040e75c945cd99f0a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个centos容器centos1，通过 --network 指定自定义网络</span></span><br><span class="line">~$ docker run -it --name centos1 --network my-net centos:7.3.1611 bash</span><br><span class="line">[root@3dcf507bd12a /]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再启动一个centos容器centos2（打开另一个窗口），指定同一个自定义网络</span></span><br><span class="line">~$ docker run -it --name centos2 --network my-net centos:7.3.1611 bash</span><br><span class="line">[root@16dcce660a89 /]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在centos1容器中直接ping centos2</span></span><br><span class="line">[root@3dcf507bd12a /]# ping centos2</span><br><span class="line">PING centos2 (172.19.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos2.my-net (172.19.0.2): icmp_seq=1 ttl=64 time=0.111 ms</span><br><span class="line">64 bytes from centos2.my-net (172.19.0.2): icmp_seq=2 ttl=64 time=0.058 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在centos2容器中直接ping centos1</span></span><br><span class="line">[root@16dcce660a89 /]# ping centos1</span><br><span class="line">PING centos1 (172.19.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos1.my-net (172.19.0.3): icmp_seq=1 ttl=64 time=0.061 ms</span><br><span class="line">64 bytes from centos1.my-net (172.19.0.3): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure></p>
<p>由上可见通过自定义网桥连接的容器可以通过容器名称互相访问。如果需要多个容器之间互联，则可以使用Docker Compose。</p>
<h2 id="4-配置容器的DNS"><a href="#4-配置容器的DNS" class="headerlink" title="4. 配置容器的DNS"></a>4. 配置容器的DNS</h2><p>如果要自定义所有容器的DNS，则可以在 /etc/docker/daemon.json 中增加<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"dns"</span> : [</span><br><span class="line">        <span class="string">"114.114.114.114"</span>,</span><br><span class="line">        <span class="string">"8.8.8.8"</span></span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以在启动容器时通过参数指定单个容器的DNS配置，<code>--dns=IP_ADDRESS</code>，这会将指定DNS的地址添加到容器的 /etc/resolv.conf 文件中，让容器用这个DNS服务器来解析所有不在 /etc/hosts 中的主机名。 </p>
<h2 id="5-Docker网络的底层实现"><a href="#5-Docker网络的底层实现" class="headerlink" title="5. Docker网络的底层实现"></a>5. Docker网络的底层实现</h2><p>容器的网络访问控制，主要是通过Linux上的<strong>iptables防火墙</strong>来实现与管理的。</p>
<ol>
<li><strong>容器访问外部网络</strong><br>容器访问外部网络，需要通过本地系统的转发，可以通过如下命令查看转发是否打开<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sysctl net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为1为打开，为0则未打开，可通过如下命令打开，也可以在Docker服务启动时通过参数--ip-forward=<span class="literal">true</span>打开</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sysctl -w net.ipv4.ip_forward=1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>容器所有到外部网络的访问，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 iptables 的源地址伪装操作实现的，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~# iptables -t nat -nL</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0</span><br></pre></td></tr></table></figure>
<p>上述规则将所有源地址在 172.17.0.0/16 的网段（容器IP所在网段），目标地址为任意网段（包括外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。 </p>
<ol start="2">
<li><strong>外部访问容器</strong></li>
</ol>
<p>通过 -p 或 -P 指定端口映射，允许外部访问容器端口，实质也是在本地的 iptable 的 nat 表中添加相应的规则，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~# iptables -t nat -nL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination                 </span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:3306 to:172.17.0.2:3306</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:11090 to:172.17.0.3:11090</span><br></pre></td></tr></table></figure></p>
<p>这里的规则映射了 0.0.0.0 ，意味着将接受主机来自所有网络接口的流量。</p>
<ol start="3">
<li><strong>容器之间的访问</strong><br>容器之间能互相访问，需要满足两个条件：1）容器的网络拓扑是否已经互联，默认情况下容器都连接到docker0网桥上，默认是互联的。2）本地系统的防火墙iptables是否允许通过。当容器启动时通过–link互联时，也是在iptables中创建对应规则来实现。</li>
</ol>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文整理了Docker网络相关知识，对容器之间及容器与外部之间的通信机制应该有了一定的了解。除了默认的网络实现，Docker还提供了网络的配置及自定义网络，出于篇幅，本文介绍到这，后续再补充。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/docker-elk.html" title="Docker笔记（十）：使用Docker来搭建一套ELK日志分析系统" class="prev">上一篇</a><a href="/linux-cmd.html" title="开发人员需要掌握的日常Linux命令集" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz",
    appKey: "PhFNiYoBJ1Fge6n8stpsfggG",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2019 <a target="_blank">空山新雨</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;"> </span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz", "PhFNiYoBJ1Fge6n8stpsfggG");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>