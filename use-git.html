<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="erIKW497yS"><meta name="google-site-verification" content="UgdHTfiMSYvSc5WkTMWIBaRheQv9f_np2Dm0RUlPFco"><title> 命令行高效操作Git，看这篇就够了 · 空山新雨的技术空间</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="命令行高效操作Git，看这篇就够了 - 空山新雨"><meta name="keywords" content="Spring,DevOps,技术管理"><meta name="author" content="空山新雨"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.jboost.cn/atom.xml" title="空山新雨的技术空间"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">命令行高效操作Git，看这篇就够了</h1><div class="post-info">2019-06-16<p class="visit"><i data-identity="use-git.html" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><p>对于软件开发人员来说，git几乎是每天都需要接触的工具。但对于相处如此亲密的工作伙伴，你对它的了解又有多少，是不是还在傻瓜式地打开一个GUI工具，点击提交按钮，然后“卧槽，又冲突了”，一脸懵逼到不知所措，责怪谁又在你前面提交了，谁又改了你的代码。</p>
<a id="more"></a>
<p>博主从一开始接触git，就没用过任何GUI工具，都是通过命令行进行操作，发现这种方式不仅对git的理解更深，效率也更高，遇到问题时一般都知道如何来处理，故做此分享。本文所有知识与操作只涉及日常使用场景，更多详细内容可自行查阅其它资料。本文Git版本为 windows-2.20.1版。</p>
<h3 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h3><p>git的理论知识，对使用者来说只需要知道它是分布式版本控制系统，了解如下三个概念即可，</p>
<ul>
<li>工作区：就是你直接操作的文件目录与内容</li>
<li>暂存区：暂时为你保存还没将内容提交到版本库的一个区域，对应.git目录下的stage或index文件</li>
<li>版本库：分本地版本库与远程版本库，本地版本库就理解为对应.git目录即可，远程版本库就是远程仓库，如gitlab或github的repository。</li>
</ul>
<p>如下图，我们平时提交代码的过程基本都是从工作区<code>add</code>到暂存区，然后再<code>commit</code>到本地仓库，最后<code>push</code>到远程仓库。</p>
<p><img src="/assets/git1.png" alt="git"></p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>对于日常工作，掌握如下几个基本命令一般就够了</p>
<ul>
<li><code>git status</code> 查看修改状态</li>
<li><code>git pull origin master</code> 拉取远程仓库master分支合并到本地，master根据场景换成其它分支名</li>
<li><code>git add file</code> 添加文件到暂存区，可用 * 添加所有</li>
<li><code>git commit -m &quot;commit message&quot;</code> 提交到本地版本库，并添加注释，注释表明此次修改内容，要清晰准确</li>
<li><code>git push origin master</code> 将本地版本提交到远程仓库的master分支，master根据场景换成其它分支名</li>
</ul>
<p>对大部分日常工作来说， 上面几个命令基本就够用了。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p><strong>1. 从本地到远程</strong></p>
<p>项目开发的时候，有时候是先在本地建一个项目，再提交到远程仓库的。</p>
<ol>
<li>创建项目目录（或通过IDE创建），命令行cd到项目目录</li>
<li>执行<code>git init</code> ， 将在项目目录创建.git目录</li>
<li>执行<code>git add *</code> ，将所有文件添加到暂存区，这里要先创建一个.gitignore文件，将不需要版本维护的文件添加进去忽略，不然各种IDE编译文件夹，环境相关文件都加到版本库去了。删除文件用<code>git rm file_name</code></li>
<li>执行<code>git commit -m &quot;upload project&quot;</code> ，提交到本地仓库</li>
<li>在gitlab或github上创建一个仓库，并将仓库地址复制下来</li>
<li>执行<code>git remote add origin git@server-name:path/repo-name.git</code> ，关联远程仓库，仓库地址如果是http开头则要用户名密码，如果是git开头，则是走的ssh协议，需要将你本机的ssh公钥添加到远程仓库服务上。</li>
<li>执行<code>git push -u origin master</code> ，推送本地仓库内容到远程仓库</li>
</ol>
<p>这样在远程仓库目录，就能看到你提交上去的文件内容了。</p>
<p><strong>2. 从远程到本地</strong><br>更多的时候，是远程仓库已有项目了，需要下载到本地开发。</p>
<ol>
<li><code>git clone git@server-name:path/repo-name.git</code> ， 将远程仓库的内容下载到本地，这里仓库地址的处理同上</li>
<li>修改内容</li>
<li><code>git add *</code> ，将修改的内容添加到暂存区</li>
<li><code>git commit -m &quot;fix xxx issue&quot;</code> ，提交到本地仓库</li>
<li><code>git push -u origin master</code> ， 推送本地仓库内容至远程仓库</li>
</ol>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>有时候改了文件，想反悔怎么办，git给你“后悔药”。</p>
<p>单个文件的还原：</p>
<ul>
<li><code>git checkout file_name</code> ，丢弃工作区的修改，还原到上次提交（commit）的版本，</li>
<li><code>git reset HEAD file_name</code> ，把暂存区的修改撤销掉（unstage），重新放回工作区。即还原到上次添加到暂存区（add）的版本</li>
</ul>
<p>这里涉及几个场景</p>
<ul>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout file_name</code>。</li>
<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时（执行了add，但没执行commit），想丢弃修改，分两步，第一步用命令<code>git reset HEAD file_name</code>，就回到了场景1，第二步按场景1操作。</li>
<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次的全部提交，参考下面的整个版本的还原，不过前提是没有推送到远程库。</li>
</ul>
<p>整个版本的还原：</p>
<ul>
<li><code>git reset --hard HEAD^^</code>， 回退到上上个版本</li>
<li><code>git reset --hard 3628164</code>， 回退到具体某个版本 3628164 是具体某个commit_id缩写</li>
</ul>
<blockquote>
<p>找不到commit_id？ <code>git reflog</code> 可查看每一个命令的历史记录，获取对应操作的commit_id。<code>git log [--pretty=oneline]</code>， 可查看commit记录</p>
</blockquote>
<blockquote>
<p>上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100。3628164 是具体某个commit_id，不需要写全，只需要唯一确定就行，可往前进也可往后退。（git windows2.20.1版貌似不支持对HEAD^的操作）</p>
</blockquote>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ol>
<li>首先，可以试图用 <code>git push origin branch_name</code> 推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用 <code>git pull</code> 试图合并；</li>
<li>如果合并有冲突，则手动解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用 <code>git push origin branch-name</code> 推送就能成功！</li>
</ol>
<p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name</p>
<p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>平时开发时需要创建子分支来实现你的功能模块，然后再合并到主分支中。</p>
<ul>
<li><code>git checkout -b your_branch_name</code> ， 创建并切换分支</li>
<li><code>git branch</code>  ， 查看分支，标有*号表示当前所在分支</li>
<li><code>git merge dev</code> ， 合并指定dev分支到当前分支</li>
<li><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code> ， 合并分支并生成commit记录</li>
<li><code>git branch -d dev</code> ， 删除分支</li>
</ul>
<blockquote>
<p><code>git checkout -b dev =  git branch dev + git checkout dev</code></p>
</blockquote>
<blockquote>
<p>Fast-forward合并，“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。存在冲突的不能fast forward。<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>  Fast forward模式下，删除分支后，会丢掉分支信息。如果强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p>
</blockquote>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>当发布版本时，一般需要对当前版本进行标签记录，以便后续进行版本查看或回退。</p>
<ul>
<li><code>git tag tag_name</code>  ， 对当前分支打标签</li>
<li><code>git tag</code> ， 查看所有标签</li>
<li><code>git tag v0.9 6224937</code>  ，针对某个具体commit id打标签</li>
<li><code>git show tag_name</code> ， 查看标签信息</li>
<li><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164</code>  ， 带有说明的标签</li>
<li><code>git tag -d v0.1</code> ， 删除标签</li>
<li><code>git push origin tag_name</code> ， 推送标签到远程    </li>
<li><code>git push origin --tags</code> ， 一次性推送所有标签</li>
</ul>
<p>删除已经推送到远程的标签：</p>
<ul>
<li><code>git tag -d v0.9</code> ， 先本地删除</li>
<li><code>git push origin :refs/tags/v0.9</code> ， 然后从远程删除</li>
</ul>
<h3 id="提高效率的Tips"><a href="#提高效率的Tips" class="headerlink" title="提高效率的Tips"></a>提高效率的Tips</h3><ol>
<li><p>配置命令别名   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status # 后面可以用git st 来代替git status了</span><br><span class="line">git config --global alias.ck checkout  # 后面可以用 git ck 来代替 git checkout了</span><br><span class="line">git config --global alias.cm 'commit -m' # 后面可以用git cm 来代替 git commit -m 了</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git pull origin master</code> 或 <code>git push origin master</code>， 可直接 <code>git pull</code> 或 <code>git push</code>， 如果出现“no tracking information”的提示，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream-to=origin/master master</code> 建立关联即可。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上命令虽然看起来多，但平常用的最频繁的应该是“基本命令”与“分支管理”部分，只要多用几次，自然便能记住，应付日常工作完全没有问题，彻底脱离GUI操作，让工作更有效率。</p>
<p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p>
<p>————————————————————————————————————————</p>
<p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/git-branch.html" title="团队项目的Git分支如何管理" class="prev">上一篇</a><a href="/issue-threadpool.html" title="案例解析：线程池使用不当导致系统崩溃" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz",
    appKey: "PhFNiYoBJ1Fge6n8stpsfggG",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2019 - 2020 <a target="_blank">空山新雨</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;"> </span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz", "PhFNiYoBJ1Fge6n8stpsfggG");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>