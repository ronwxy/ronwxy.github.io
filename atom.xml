<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空山新雨</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jboost.cn/"/>
  <updated>2019-06-29T02:16:06.420Z</updated>
  <id>http://blog.jboost.cn/</id>
  
  <author>
    <name>ronwxy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redission-tomcat 快速实现从单机部署到多机部署</title>
    <link href="http://blog.jboost.cn/2019/06/29/session-redis.html"/>
    <id>http://blog.jboost.cn/2019/06/29/session-redis.html</id>
    <published>2019-06-29T01:01:24.000Z</published>
    <updated>2019-06-29T02:16:06.420Z</updated>
    
    <content type="html"><![CDATA[<p>一些项目初期出于简单快速，都是做单机开发与部署，但是随着业务的扩展或对可用性要求的提高，单机环境已不满足需求。单机部署往多机部署切换，其中可能存在的一个重要环节就是session的共享（如果一开始就是基于token的认证则可忽略）。本文介绍一个基于redis的tomcat session管理开源项目：redission-tomcat，可无代码侵入式地快速实现session共享。<br><a id="more"></a></p><h3 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h3><p>redisson是与jedis类似的一个redis客户端，其功能比jedis要更丰富一些。redission-tomcat是一个基于redis的tomcat session管理器项目，项目地址：<a href="https://github.com/redisson/redisson/tree/master/redisson-tomcat。相比于其它实现，该项目的存储更为高效，写操作也更为优化。每一个session参数是在调用`HttpSession.setAttribute`时写入redis的，其它方案却一般是每次都将整个session进行序列化后写入。" target="_blank" rel="noopener">https://github.com/redisson/redisson/tree/master/redisson-tomcat。相比于其它实现，该项目的存储更为高效，写操作也更为优化。每一个session参数是在调用`HttpSession.setAttribute`时写入redis的，其它方案却一般是每次都将整个session进行序列化后写入。</a></p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ol><li><p>将<code>redisson-all-3.11.0.jar</code>，<code>redisson-tomcat-8-3.11.0.jar</code>（针对tomcat8，可在上述项目地址页面找到下载链接）两个jar包下载放到tomcat的lib目录下。</p></li><li><p>在tomcat conf目录下的context.xml文件中添加如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"org.redisson.tomcat.RedissonSessionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">configPath</span>=<span class="string">"$&#123;catalina.base&#125;/conf/redisson.conf"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">readMode</span>=<span class="string">"MEMORY"</span> <span class="attr">updateMode</span>=<span class="string">"AFTER_REQUEST"</span> <span class="attr">broadcastSessionEvents</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>其中</p><ul><li>configPath：指向Redisson的json或yaml格式的配置文件，第3步中给出。</li><li>readMode：session属性的读取模式。可取值 1. MEMORY, 该模式会将session属性同时保存到本地tomcat session与redis中，后续的session更新通过redis事件传播到本地tomcat session；2. REDIS，只将session属性保存到redis中。默认为REDIS。</li><li>updateMode：session属性的更新模式。可取值 1. DEFAULT，session属性只通过<code>setAttribute</code>方法保存到redis中；2. AFTER_REQUEST，在每次请求之后，将所有session属性保存至redis。默认为DEFAULT。</li><li>broadcastSessionEvents：如果设置为true，则sessionCreated与sessionDestroyed事件将会被广播到所有tomcat实例，并使所有注册的HttpSessionListeners监听器被触发。默认为false。</li></ul><ol start="3"><li>在tomcat conf目录下新增配置文件redisson.conf，内容如下<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"singleServerConfig"</span>:&#123;</span><br><span class="line">    <span class="attr">"idleConnectionTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"connectTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"retryAttempts"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">"retryInterval"</span>:<span class="number">1500</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"123456"</span>,</span><br><span class="line">    <span class="attr">"subscriptionsPerConnection"</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="attr">"clientName"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"address"</span>: <span class="string">"redis://127.0.0.1:6379"</span>,</span><br><span class="line">    <span class="attr">"subscriptionConnectionMinimumIdleSize"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"subscriptionConnectionPoolSize"</span>:<span class="number">50</span>,</span><br><span class="line">    <span class="attr">"connectionMinimumIdleSize"</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="attr">"connectionPoolSize"</span>:<span class="number">64</span>,</span><br><span class="line">    <span class="attr">"database"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"dnsMonitoringInterval"</span>:<span class="number">5000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"threads"</span>:<span class="number">16</span>,</span><br><span class="line">  <span class="attr">"nettyThreads"</span>:<span class="number">32</span>,</span><br><span class="line">  <span class="attr">"codec"</span>:&#123;</span><br><span class="line">    <span class="attr">"class"</span>:<span class="string">"org.redisson.codec.FstCodec"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"transportMode"</span>:<span class="string">"NIO"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上为单机模式redis环境配置，其中password，address修改为自己的值。如果是集群模式，则配置文件为<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sentinelServersConfig"</span>:&#123;</span><br><span class="line">    <span class="attr">"idleConnectionTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"connectTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"retryAttempts"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">"retryInterval"</span>:<span class="number">1500</span>,</span><br><span class="line">    <span class="attr">"failedSlaveReconnectionInterval"</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"failedSlaveCheckInterval"</span>:<span class="number">60000</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"subscriptionsPerConnection"</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="attr">"clientName"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"loadBalancer"</span>:&#123;</span><br><span class="line">      <span class="attr">"class"</span>:<span class="string">"org.redisson.connection.balancer.RoundRobinLoadBalancer"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"subscriptionConnectionMinimumIdleSize"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"subscriptionConnectionPoolSize"</span>:<span class="number">50</span>,</span><br><span class="line">    <span class="attr">"slaveConnectionMinimumIdleSize"</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="attr">"slaveConnectionPoolSize"</span>:<span class="number">64</span>,</span><br><span class="line">    <span class="attr">"masterConnectionMinimumIdleSize"</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="attr">"masterConnectionPoolSize"</span>:<span class="number">64</span>,</span><br><span class="line">    <span class="attr">"readMode"</span>:<span class="string">"SLAVE"</span>,</span><br><span class="line">    <span class="attr">"subscriptionMode"</span>:<span class="string">"SLAVE"</span>,</span><br><span class="line">    <span class="attr">"sentinelAddresses"</span>:[</span><br><span class="line">      <span class="string">"redis://127.0.0.1:26379"</span>,</span><br><span class="line">      <span class="string">"redis://127.0.0.1:26389"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"masterName"</span>:<span class="string">"mymaster"</span>,</span><br><span class="line">    <span class="attr">"database"</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"threads"</span>:<span class="number">16</span>,</span><br><span class="line">  <span class="attr">"nettyThreads"</span>:<span class="number">32</span>,</span><br><span class="line">  <span class="attr">"codec"</span>:&#123;</span><br><span class="line">    <span class="attr">"class"</span>:<span class="string">"org.redisson.codec.FstCodec"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"transportMode"</span>:<span class="string">"NIO"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>我们可以使用nginx来实现负载均衡，参考配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream cnserver&#123;</span><br><span class="line">  server 127.0.0.1:8080 weight=2 fail_timeout=10s max_fails=1;</span><br><span class="line">  server 127.0.0.1:8081 weight=2 fail_timeout=10s max_fails=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  index index.html index.htm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  location /rest/ &#123;</span><br><span class="line">    index index.html;</span><br><span class="line">    proxy_pass http://cnserver/rest/;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上即为使用redisson-tomcat来实现单机部署到多机部署的所有配置。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>技术架构都是随着业务的发展而不断演进。在业务发展初期，用户量、业务复杂度都相对较低，为了实现快速上线验证，往往采用简单单一的架构。许多项目可能还没来得及进行架构演进升级就GG了，而有幸继续成长的项目必然会随着业务的扩张不断优化与升级。本文介绍的redisson-tomcat可帮助单机项目快速切换到多机支持，当然只是在session管理环节。如果涉及到其它如文件上传，定时任务等分布式支持，则要另做相应调整了。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号， 欢迎关注）<br>———————————————————————————————————————————————————————————————<br><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些项目初期出于简单快速，都是做单机开发与部署，但是随着业务的扩展或对可用性要求的提高，单机环境已不满足需求。单机部署往多机部署切换，其中可能存在的一个重要环节就是session的共享（如果一开始就是基于token的认证则可忽略）。本文介绍一个基于redis的tomcat session管理开源项目：redission-tomcat，可无代码侵入式地快速实现session共享。&lt;br&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="session" scheme="http://blog.jboost.cn/tags/session/"/>
    
      <category term="tomcat" scheme="http://blog.jboost.cn/tags/tomcat/"/>
    
      <category term="redission" scheme="http://blog.jboost.cn/tags/redission/"/>
    
  </entry>
  
  <entry>
    <title>swagger api文档集中化注册管理</title>
    <link href="http://blog.jboost.cn/2019/06/28/swagger-register.html"/>
    <id>http://blog.jboost.cn/2019/06/28/swagger-register.html</id>
    <published>2019-06-28T08:59:05.000Z</published>
    <updated>2019-06-28T11:09:53.498Z</updated>
    
    <content type="html"><![CDATA[<p>接口文档是前后端开发对接时很重要的一个组件。手动编写接口文档既费时，又存在文档不能随代码及时更新的问题，因此产生了像swagger这样的自动生成接口文档的框架。swagger文档一般是随项目代码生成与更新，访问地址也是基于项目地址，因此对项目数不多的团队还好。如果团队的项目很多，比如采用微服务架构的团队，动则几十甚至上百个服务项目，那就意味着前端开发人员需要记住几十甚至上百个swagger文档地址，那就很不友好了。目前貌似还没有较流行的API文档集中化管理项目（也或者是我没找到），因此花了点时间自己集成了一个，介绍如下。</p><a id="more"></a><h3 id="1-swagger-bootstrap-ui项目"><a href="#1-swagger-bootstrap-ui项目" class="headerlink" title="1. swagger-bootstrap-ui项目"></a>1. swagger-bootstrap-ui项目</h3><p>该项目是github上的一个开源项目（<a href="https://github.com/xiaoymin/swagger-bootstrap-ui" target="_blank" rel="noopener">https://github.com/xiaoymin/swagger-bootstrap-ui</a> ），对swagger ui做了增强，功能整体看起来要丰富一些。来看看效果，</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/swaggerui.png" alt="swagger-bootstrap-ui"></p><p>该项目的调试url地址原本是基于自身服务的，我将它改为了注册服务的url地址，以支持注册服务的接口调试。调整后的源码地址： <a href="https://github.com/ronwxy/swagger-bootstrap-ui" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-bootstrap-ui</a></p><h3 id="2-swagger-api注册服务"><a href="#2-swagger-api注册服务" class="headerlink" title="2. swagger api注册服务"></a>2. swagger api注册服务</h3><p>该项目集成了swagger-bootstrap-ui，并提供了swagger api注册接口，接受所有提供了有效配置的服务项目注册，让注册的服务在一个页面上可统一查看，再也不用记太多文档地址了。</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/swaggerui2.png" alt="swagger-bootstrap-ui2"></p><p>启动注册服务后，访问 <a href="http://localhost:11090/doc.html" target="_blank" rel="noopener">http://localhost:11090/doc.html</a> 打开文档页面。如上图，可通过下拉列表来选择不同项目，加载项目的接口文档查看或调试。<br>项目地址： <a href="https://github.com/ronwxy/swagger-register" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-register</a> （如果觉得有用，不要吝啬你的star，反正又不要钱，O(∩_∩)O）</p><h3 id="3-服务端配置"><a href="#3-服务端配置" class="headerlink" title="3. 服务端配置"></a>3. 服务端配置</h3><p>在业务服务端，需要提供一些配置。<br>首先，需要配置一些Bean，如下提供了一个配置类（这里只列出了主要部分，完整代码参考： <a href="https://github.com/ronwxy/base-spring-boot）" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot）</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2AutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">restApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ParameterBuilder builder = <span class="keyword">new</span> ParameterBuilder();</span><br><span class="line">        builder.name(<span class="string">"x-auth-token"</span>).description(<span class="string">"授权token"</span>)</span><br><span class="line">                .modelRef(<span class="keyword">new</span> ModelRef(<span class="string">"string"</span>))</span><br><span class="line">                .parameterType(<span class="string">"header"</span>)</span><br><span class="line">                .required(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(groupName)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(apisBasePackage))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .globalOperationParameters(Collections.singletonList(builder.build()))</span><br><span class="line">                .apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"dev"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">swaggerRegistar</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SwaggerInfoRegistar(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * use to register swagger api info url to swagger api registry;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> liubo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerInfoRegistar</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String url = buildLocalSwaggerDocsUrl();</span><br><span class="line">            registerLocalSwaggerUrl(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * register the v2/api-docs url</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerLocalSwaggerUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">            RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">            restTemplate.getMessageConverters().add(<span class="keyword">new</span> FormHttpMessageConverter());</span><br><span class="line">            MultiValueMap&lt;String, Object&gt; body = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            body.add(<span class="string">"project"</span>, getApiTitle());</span><br><span class="line">            body.add(<span class="string">"url"</span>, url);</span><br><span class="line">            ResponseEntity&lt;Map&gt; re = restTemplate.postForEntity(getSwaggerRegisterUrl(), body, Map.class);</span><br><span class="line">            <span class="keyword">if</span> (HttpStatus.OK.equals(re.getStatusCode())) &#123;</span><br><span class="line">                logger.info(<span class="string">"swagger api registered success to &#123;&#125;"</span>, getSwaggerRegisterUrl());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"swagger api registered failed [&#123;&#125;]"</span>, re.getBody().get(<span class="string">"msg"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该类完成了swagger的基本配置，同时将swagger的/v2/api-docs地址注册到了步骤2中介绍的注册服务。</p><p>然后，因为要从注册服务端调用该业务服务的接口进行调试，存在跨域，因此服务需要做跨域支持，配置文件中添加如下定义，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"corsFilterRegistrationBean"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line"></span><br><span class="line">    CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    corsConfiguration.applyPermitDefaultValues();</span><br><span class="line">    corsConfiguration.setAllowedMethods(Arrays.asList(CorsConfiguration.ALL));</span><br><span class="line">    corsConfiguration.addExposedHeader(HttpHeaders.DATE);</span><br><span class="line"></span><br><span class="line">    corsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line"></span><br><span class="line">    CorsFilter corsFilter = <span class="keyword">new</span> CorsFilter(corsConfigurationSource);</span><br><span class="line">    FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    filterRegistrationBean.setFilter(corsFilter);</span><br><span class="line">    filterRegistrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    filterRegistrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在属性配置文件application.yml中配置一些必要的属性，<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">swagger:</span></span><br><span class="line"><span class="attr">  api-title:</span> <span class="string">Demo标题</span>  <span class="comment">#会展示在下拉列表框中，一般写项目名称</span></span><br><span class="line"><span class="attr">  api-description:</span>  <span class="string">Demo描述，集中注册</span></span><br><span class="line"><span class="attr">  group-name:</span> <span class="string">Demo项目</span></span><br><span class="line"><span class="attr">  apis-base-package:</span> <span class="string">cn.jboost.springboot.swagger</span> <span class="comment"># API类所在包名</span></span><br><span class="line"><span class="attr">  swagger-registry-path:</span> <span class="attr">http://localhost:11090/swagger/register</span>  <span class="comment">#就是2中注册服务的注册接口地址</span></span><br></pre></td></tr></table></figure></p><p>配置完后， 就可以像一般项目一样编写接口类，加swagger注解。项目启动时， 会自动向注册服务完成注册，刷新注册服务的文档页面即可在下拉列表看到。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>本文介绍了一个基于swagger ui增强版项目swagger-bootstrap-ui的接口文档集中化管理实现。采用该实现，将所有swagger在线接口文档集中管理，有效提高前后端对接效率。</p><p>如果觉得本文有用，欢迎转发、推荐。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （欢迎关注，及时获取技术干货分享）<br>———————————————————————————————————————————————————————————————<br><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口文档是前后端开发对接时很重要的一个组件。手动编写接口文档既费时，又存在文档不能随代码及时更新的问题，因此产生了像swagger这样的自动生成接口文档的框架。swagger文档一般是随项目代码生成与更新，访问地址也是基于项目地址，因此对项目数不多的团队还好。如果团队的项目很多，比如采用微服务架构的团队，动则几十甚至上百个服务项目，那就意味着前端开发人员需要记住几十甚至上百个swagger文档地址，那就很不友好了。目前貌似还没有较流行的API文档集中化管理项目（也或者是我没找到），因此花了点时间自己集成了一个，介绍如下。&lt;/p&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="swagger" scheme="http://blog.jboost.cn/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战：集成AOPLog来记录接口访问日志</title>
    <link href="http://blog.jboost.cn/2019/06/27/springboot-aoplog.html"/>
    <id>http://blog.jboost.cn/2019/06/27/springboot-aoplog.html</id>
    <published>2019-06-27T03:03:57.000Z</published>
    <updated>2019-06-27T07:06:00.409Z</updated>
    
    <content type="html"><![CDATA[<p>日志是一个Web项目中必不可少的部分，借助它我们可以做许多事情，比如问题排查、访问统计、监控告警等。一般通过引入slf4j的一些实现框架来做日志功能，如log4j,logback,log4j2，其性能也是依次增强。在springboot中，默认使用的框架是logback。我们经常需要在方法开头或结尾加日志记录传入参数或返回结果，以此来复现当时的请求情况。但是手动添加日志，不仅繁琐重复，也影响代码的美观简洁。本文引入一个基于AOP实现的日志框架，并通过spring-boot-starter的方式完成集成。</p><p>原文地址：<a href="http://blog.jboost.cn/2019/06/27/springboot-aoplog.html">http://blog.jboost.cn/2019/06/27/springboot-aoplog.html</a><br><a id="more"></a></p><h3 id="1-aop-logging项目"><a href="#1-aop-logging项目" class="headerlink" title="1. aop-logging项目"></a>1. aop-logging项目</h3><p>项目地址： <a href="https://github.com/ronwxy/aop-logging" target="_blank" rel="noopener">https://github.com/ronwxy/aop-logging</a><br>该项目基于 <a href="https://github.com/nickvl/aop-logging.git" target="_blank" rel="noopener">https://github.com/nickvl/aop-logging.git</a> ， 在其基础上添加了ReqId来串联某次客户端请求（参考<code>com.github.nickvl.xspring.core.log.aop.ReqIdFilter</code>）, 添加了方法执行时长（参考<code>com.github.nickvl.xspring.core.log.aop.AOPLogger.logTheMethod</code>方法中elapsedTime）。</p><p>该项目提供了基于注解的AOP日志功能。根据不同的日志级别，提供的注解有LogTrace,LogDebug,LogInfo,LogWarn,LogError,LogFatal,LogException，可修饰于类（等同于该类内所有方法上添加）与方法上，前面六个分别表示在不同日志级别下记录方法被调用的日志，LogException表示在方法抛出异常时，记录相应日志。这些注解都提供了一个LogPoint枚举类型的属性value，取值{IN,OUT,BOTH}，分别表示在方法调用入口、方法调用返回前，以及包含两者的位置打印对应日志，默认为BOTH。</p><h3 id="2-集成"><a href="#2-集成" class="headerlink" title="2. 集成"></a>2. 集成</h3><p>可以通过基于xml或基于java配置的方式来集成AOP日志功能，我这里基于java配置（基于xml的方式参考源码README文件）并且通过spring-boot-starter的形式进行封装（源码地址： <a href="https://github.com/ronwxy/base-spring-boot" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot</a> ），避免每个项目都需要配置。自动配置类如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(AOPLogger.class)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(AOPLogger.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopLoggerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SKIP_NULL_FIELDS = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; EXCLUDE_SECURE_FIELD_NAMES = Collections.emptySet();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AOPLogger <span class="title">aopLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">AOPLogger aopLogger = <span class="keyword">new</span> AOPLogger();</span><br><span class="line">aopLogger.setLogAdapter(<span class="keyword">new</span> UniversalLogAdapter(SKIP_NULL_FIELDS, EXCLUDE_SECURE_FIELD_NAMES));</span><br><span class="line"><span class="keyword">return</span> aopLogger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 注册一个过滤器，用来生成一个reqId，标记一次请求，从而将本次请求所产生的日志串联起来</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">reqIdFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ReqIdFilter reqIdFilter = <span class="keyword">new</span> ReqIdFilter();</span><br><span class="line">FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">registrationBean.setFilter(reqIdFilter);</span><br><span class="line">List&lt;String&gt; urlPatterns = Collections.singletonList(<span class="string">"/*"</span>);</span><br><span class="line">registrationBean.setUrlPatterns(urlPatterns);</span><br><span class="line">registrationBean.setOrder(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将基础框架base-spring-boot通过<code>mvn clean install</code>进行本地安装后，即可在项目中通过依赖进行引入（基础框架中已在spring-boot-parent中引入，直接继承亦可），如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aoplog-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><p>引入依赖之后，我们再定义一个日志配置文件logback-spring.xml，为了后面方便地将日志导入ELK做集中的日志分析管理，该配置文件中将日志以json格式输出，并根据日志级别分别写入debug.log,info.log,warn.log,error.log以及interface.log（专用于接口访问日志），配置示例如下（完整配置参考： <a href="https://github.com/ronwxy/springboot-demos/blob/master/springboot-aoplog/src/main/resources/logback-spring.xml）" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/blob/master/springboot-aoplog/src/main/resources/logback-spring.xml）</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;logPath&#125;/elk/interface.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                        &#123;</span><br><span class="line">                        "project": "$&#123;projectName&#125;",</span><br><span class="line">                        "timestamp": "%date&#123;\"yyyy-MM-dd'T'HH:mm:ss,SSSZ\"&#125;",</span><br><span class="line">                        "log_level": "%level",</span><br><span class="line">                        "thread": "%thread",</span><br><span class="line">                        "class_name": "%X&#123;callingClass&#125;",</span><br><span class="line">                        "class_method":"%X&#123;callingMethod&#125;",</span><br><span class="line">                        "line_number": null,</span><br><span class="line">                        "message": "%message",</span><br><span class="line">                        "stack_trace": "%exception&#123;5&#125;",</span><br><span class="line">                        "req_id": "%X&#123;reqId&#125;",</span><br><span class="line">                        "elapsed_time": "#asLong&#123;%X&#123;elapsedTime&#125;&#125;"</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;logPath&#125;/bak/interface.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>1GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>为了将该日志配置文件可以不经修改地达到复用，将一些参数配置外置了，故需在配置文件applicaiton.yml中配置如下参数<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logger:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="attr">D:\logs</span> <span class="comment">#默认当前项目路径下的logs目录</span></span><br><span class="line"><span class="attr">  level:</span> <span class="string">info</span> <span class="comment"># 默认info</span></span><br><span class="line"><span class="attr">  apiPackage:</span> <span class="string">cn.jboost.springboot.aoplog.controller</span> <span class="comment">#必须配置, api接口类所在包</span></span><br><span class="line"><span class="attr">  rootPackage:</span> <span class="string">cn.jboost.springboot</span> <span class="comment">#必须配置，项目根包，记录该包内各类通过slf4j输出的日志</span></span><br></pre></td></tr></table></figure></p><p>最后，直接在需要记录访问日志的接口类上加注解@LogInfo就行了，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@LogInfo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AoplogTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestParam String user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi "</span> + user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：在pom.xml中默认添加的spring-boot-maven-plugin下需要添加repackage的goal才能自动生成日志目录与日志文件，如下所示</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动程序，调用@LogInfo标注的接口类下的API时，可以看到控制台有打印接口访问日志，如执行demo程序（源码： <a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-aoplog" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-aoplog</a> ），调用  <a href="http://localhost:8080/test?user=jboost" target="_blank" rel="noopener">http://localhost:8080/test?user=jboost</a> 时，控制台打印日志如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2019-06-27 14:29:59] [INFO ] [http-nio-8080-exec-1] [cn.jboost.springboot.aoplog.controller.AoplogTestController:184] --calling: test(user=jboost)</span><br><span class="line">[2019-06-27 14:29:59] [INFO ] [http-nio-8080-exec-1] [cn.jboost.springboot.aoplog.controller.AoplogTestController:189] --returning: test(1 arguments):Hi jboost</span><br></pre></td></tr></table></figure></p><p>日志文件interface.log中打印日志如下，（其中req_id在本次请求的所有日志都相同，这样就可以将一次请求的所有日志串联起来，便于分析与定位问题；elapsed_time标明了方法执行时长，可用于接口性能监测）<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"project"</span>:<span class="string">"aoplog-test"</span>,<span class="attr">"timestamp"</span>:<span class="string">"2019-06-27T14:29:59,030+0800"</span>,<span class="attr">"log_level"</span>:<span class="string">"INFO"</span>,<span class="attr">"thread"</span>:<span class="string">"http-nio-8080-exec-1"</span>,<span class="attr">"class_name"</span>:<span class="string">"cn.jboost.springboot.aoplog.controller.AoplogTestController"</span>,<span class="attr">"class_method"</span>:<span class="string">"test"</span>,<span class="attr">"line_number"</span>:<span class="literal">null</span>,<span class="attr">"message"</span>:<span class="string">"calling: test(user=jboost)"</span>,<span class="attr">"stack_trace"</span>:<span class="string">""</span>,<span class="attr">"req_id"</span>:<span class="string">"5d146267aa147904bc014e71"</span>,<span class="attr">"elapsed_time"</span>:<span class="literal">null</span>&#125;</span><br><span class="line">&#123;<span class="attr">"project"</span>:<span class="string">"aoplog-test"</span>,<span class="attr">"timestamp"</span>:<span class="string">"2019-06-27T14:29:59,036+0800"</span>,<span class="attr">"log_level"</span>:<span class="string">"INFO"</span>,<span class="attr">"thread"</span>:<span class="string">"http-nio-8080-exec-1"</span>,<span class="attr">"class_name"</span>:<span class="string">"cn.jboost.springboot.aoplog.controller.AoplogTestController"</span>,<span class="attr">"class_method"</span>:<span class="string">"test"</span>,<span class="attr">"line_number"</span>:<span class="literal">null</span>,<span class="attr">"message"</span>:<span class="string">"returning: test(1 arguments):Hi jboost"</span>,<span class="attr">"stack_trace"</span>:<span class="string">""</span>,<span class="attr">"req_id"</span>:<span class="string">"5d146267aa147904bc014e71"</span>,<span class="attr">"elapsed_time"</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>Web项目中经常需要通过查看接口请求及返回参数来定位问题，手动编写代码打印显得繁琐而重复。使用aop-logging通过简单的注解即可实现接口日志自动打印。本文介绍的方案与日志配置模板可直接用于实际项目开发。当然，注解不仅可用于Controller层，也可以用于Service等其它层，但一般Controller层加上即可，避免日志打印过多。</p><p>本文示例项目源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-aoplog" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-aoplog</a><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （欢迎关注，及时获取技术干货分享）<br>——————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志是一个Web项目中必不可少的部分，借助它我们可以做许多事情，比如问题排查、访问统计、监控告警等。一般通过引入slf4j的一些实现框架来做日志功能，如log4j,logback,log4j2，其性能也是依次增强。在springboot中，默认使用的框架是logback。我们经常需要在方法开头或结尾加日志记录传入参数或返回结果，以此来复现当时的请求情况。但是手动添加日志，不仅繁琐重复，也影响代码的美观简洁。本文引入一个基于AOP实现的日志框架，并通过spring-boot-starter的方式完成集成。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.jboost.cn/2019/06/27/springboot-aoplog.html&quot;&gt;http://blog.jboost.cn/2019/06/27/springboot-aoplog.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
      <category term="logback" scheme="http://blog.jboost.cn/tags/logback/"/>
    
  </entry>
  
  <entry>
    <title>案例解析：springboot自动配置未生效问题定位（条件断点）</title>
    <link href="http://blog.jboost.cn/2019/06/25/issue-conditiontrack.html"/>
    <id>http://blog.jboost.cn/2019/06/25/issue-conditiontrack.html</id>
    <published>2019-06-25T13:33:00.000Z</published>
    <updated>2019-06-27T02:28:38.932Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot在为开发人员提供更高层次的封装，进而提高开发效率的同时，也为出现问题时如何进行定位带来了一定复杂性与难度。但Spring Boot同时又提供了一些诊断工具来辅助开发与分析，如spring-boot-starter-actuator。本文分享一个基于actuator与IDEA条件断点来定位自动配置未生效的案例。望对类似问题分析与处理提供参考。<br><a id="more"></a></p><h3 id="问题确认"><a href="#问题确认" class="headerlink" title="问题确认"></a>问题确认</h3><p>在前文介绍的 <a href="http://blog.jboost.cn/2019/06/24/springboot-tkmapper.html">Spring Boot从入门到实战：整合通用Mapper简化单表操作</a> 中，我们对druid连接池做了自动配置，并且注入了druid的监控统计功能，如下</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/statviewservlet.png" alt="druidstat"></p><p>但本地运行后通过 <a href="http://localhost:8080/druid/index.html" target="_blank" rel="noopener">http://localhost:8080/druid/index.html</a> 访问时却出现错误，通过浏览器的开发者工具查看该请求返回404，推测上述代码中定义的<code>StatViewServlet</code>未注入成功。我们用actuator来确认下是否如此。在项目中加入spring-boot-starter-actuator，并且application.yml中添加如下配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">    endpoints:</span></span><br><span class="line"><span class="attr">        web:</span></span><br><span class="line"><span class="attr">            exposure:</span></span><br><span class="line"><span class="attr">                include:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">                exclude:</span> <span class="string">beans,trace</span></span><br><span class="line"><span class="attr">    endpoint:</span></span><br><span class="line"><span class="attr">        health:</span></span><br><span class="line"><span class="attr">            show-details:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></p><blockquote><p>在spring-boot 2.x 版本当中，作为安全性考虑，将actuator 控件中的端口，只默认开放/health 和/info 两个端口，其他端口默认关闭， 因此需要添加如上配置。注意include的值 <code>*</code> 必须加引号，否则无法启动。</p></blockquote><p>重启程序后访问 <a href="http://localhost:8080/actuator/conditions" target="_blank" rel="noopener">http://localhost:8080/actuator/conditions</a> 确认上述两个实例化方法未满足<code>@ConditionalOnProperty</code>的条件，从而未执行生效，如图</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/actuatorconditions.png" alt="actuator"></p><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>从上面分析确认是因为条件注解 <code>@ConditionalOnProperty(prefix = &quot;spring.datasource.druid&quot;, name = &quot;druidServletSettings&quot;)</code> 未满足使方法未执行导致。那这个条件为什么没有满足呢，查看application.yml中也做了 spring.datasource.druid.druidServletSettings属性的配置。</p><p>当你无法理清头绪，确定问题原因时，那就Debug吧。查看注解<code>@ConditionalOnProperty</code>源码，找到其实现支持类<code>OnPropertyCondition</code>，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;OnPropertyCondition.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnProperty &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">havingValue</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matchIfMissing</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看<code>OnPropertyCondition</code>源码，了解它是通过<code>getMatchOutcome</code>方法来判断是否满足注解参数所指定的条件的，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">List&lt;AnnotationAttributes&gt; allAnnotationAttributes = annotationAttributesFromMultiValueMap(</span><br><span class="line">metadata.getAllAnnotationAttributes(</span><br><span class="line">ConditionalOnProperty.class.getName()));</span><br><span class="line">List&lt;ConditionMessage&gt; noMatch = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;ConditionMessage&gt; match = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes annotationAttributes : allAnnotationAttributes) &#123;</span><br><span class="line">ConditionOutcome outcome = determineOutcome(annotationAttributes,</span><br><span class="line">context.getEnvironment());</span><br><span class="line">(outcome.isMatch() ? match : noMatch).add(outcome.getConditionMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!noMatch.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.of(noMatch));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ConditionOutcome.match(ConditionMessage.of(match));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在调用<code>determineOutcome</code>处打断点，调试什么原因导致条件未满足，但是这里是一个for循环，如果for元素过多的话，将可能需要断点阻断很多次才能找到你想要查看的那个元素。所幸IDEA提供了不同类型的断点来处理这类问题，前面 <a href="http://blog.jboost.cn/2019/06/21/issue-errortrack.html">案例解析：使用IDEA异常断点来定位java.lang.ArrayStoreException的问题</a> 我们介绍了异常断点的使用。这里介绍用条件断点来处理这类循环块中的debug问题。</p><p>在上述代码for循环中调用<code>determineOutcome</code>行打断点，并在断点上右键，弹出如下窗口</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/conditionbreak.png" alt="条件断点"></p><p>图中Condition框即可输入你要指定的条件，可以直接写java判断表达式代码，并引用该行代码处能访问的变量，如这里我们输入 <code>annotationAttributes.get(&quot;name&quot;).equals(&quot;druidServletSettings&quot;)</code>，然后点击Debug窗口的“Resume Program (F9)”按钮，则在不满足指定条件时，断点处将不会被阻断，直到条件满足，这样就能很容易定位到我们想要查看的元素。（当然这里<code>allAnnotationAttributes</code>变量其实只有一个元素，仅仅是为了演示条件变量的使用，当集合元素很多时，使用条件断点就能体会到它的方便之处）</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>通过Debug的方式深入条件注解的判断逻辑（其中循环处可使用条件断点），最终来到如下代码片段</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/conditonbreak3.png" alt="判断条件"></p><p>在这里是判断来自所有属性源配置的属性中，是否包含条件注解指定的属性，即<code>spring.datasource.druid.druidServletSettings</code>，由上图可见，<code>spring.datasource.druid.druidServletSettings</code>只是某些属性的前缀，并不存在完全匹配的属性，因此返回false，导致条件不满足。回看注解@ConditionOnProperty的javadoc，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* If the property is not contained in the &#123;@link Environment&#125; at all, the</span><br><span class="line"> * &#123;@link #matchIfMissing()&#125; attribute is consulted. By default missing attributes do not</span><br><span class="line"> * match.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * This condition cannot be reliably used for matching collection properties. For example,</span><br><span class="line"> * in the following configuration, the condition matches if &#123;@code spring.example.values&#125;</span><br><span class="line"> * is present in the &#123;@link Environment&#125; but does not match if</span><br><span class="line"> * &#123;@code spring.example.values[0]&#125; is present.</span><br><span class="line"> *</span><br></pre></td></tr></table></figure></p><p>当Environment中不包含该属性时，则看matchIfMissing的值，该值默认为false，如果包含该属性，则再对比属性值与havingValue的值，相等即满足，不等则不满足。并且该条件注解不能用于匹配集合类型属性。上述<code>spring.datasource.druid.druidServletSettings</code>实际上属于一个Map类型，因此不能想当然地认为该注解是只要属性集中某属性名称包含该值即满足。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当难以定位到问题原因时，可以进行Debug，跟踪程序运行的各个步骤，当要在循环中Debug定位到某个元素时，可以用条件断点来实现。@ConditionalOnProperty注解不是存在某属性就行，还需要值相等，并且不适用于集合类型属性。<br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot在为开发人员提供更高层次的封装，进而提高开发效率的同时，也为出现问题时如何进行定位带来了一定复杂性与难度。但Spring Boot同时又提供了一些诊断工具来辅助开发与分析，如spring-boot-starter-actuator。本文分享一个基于actuator与IDEA条件断点来定位自动配置未生效的案例。望对类似问题分析与处理提供参考。&lt;br&gt;
    
    </summary>
    
      <category term="案例解析" scheme="http://blog.jboost.cn/categories/%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战：整合通用Mapper简化单表操作</title>
    <link href="http://blog.jboost.cn/2019/06/24/springboot-tkmapper.html"/>
    <id>http://blog.jboost.cn/2019/06/24/springboot-tkmapper.html</id>
    <published>2019-06-24T11:32:15.000Z</published>
    <updated>2019-06-24T11:42:59.602Z</updated>
    
    <content type="html"><![CDATA[<p>数据库访问是web应用必不可少的部分。现今最常用的数据库ORM框架有Hibernate与Mybatis，Hibernate貌似在传统IT企业用的较多，而Mybatis则在互联网企业应用较多。通用Mapper（<a href="https://github.com/abel533/Mapper）" target="_blank" rel="noopener">https://github.com/abel533/Mapper）</a> 是一个基于Mybatis，将单表的增删改查通过通用方法实现，来减少SQL编写的开源框架，且也有对应开源的mapper-spring-boot-starter提供。我们在此基础上加了一些定制化的内容，以便达到更大程度的复用。</p><a id="more"></a><p>框架源码地址：<a href="https://github.com/ronwxy/base-spring-boot" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot</a>  （持续更新完善中，欢迎follow，star）<br>Demo源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper</a></p><p><strong>在开源mapper-spring-boot-starter的基础上，增加了如下内容：</strong></p><ol><li>针对MySQL数据库与PostgreSQL数据库添加了一些Java类型与数据库类型的转换处理类，如将List、Map类型与MySQL数据库的json类型进行转换处理</li><li>对Domain、Mapper、Service、Controller各层进行了封装，将基本的增删改查功能在各层通用化</li><li>提供了基于druid连接池的自动配置</li><li>其它一些调整，如默认映射复杂类型属性（主要是List、Map类型，其它自定义类型需要自定义转换处理类），将枚举作为简单类型处理</li><li>提供了一个parent项目，将一些常用的框架进行集成，实际项目可继承parent简化依赖配置（持续更新完善）</li></ol><p>该框架可用于实际基于springboot的项目，只需简单配置数据源，即可引入druid连接池及通用mapper的功能，以及各层基本的增删改查方法。</p><p><strong>如何使用？</strong><br>下文给出使用步骤，可参考示例：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper</a></p><h3 id="1-框架Maven部署安装"><a href="#1-框架Maven部署安装" class="headerlink" title="1. 框架Maven部署安装"></a>1. 框架Maven部署安装</h3><p>下载框架源码后，在项目根路径下执行<code>mvn clean install</code>可安装到本地maven库。如果需要共享，且搭了Nexus私服，则在根路径pom.xml文件中添加<code>distributionManagement</code>配置，指定Nexus仓库分发地址，使用<code>mvn clean deploy</code>安装到远程maven仓库，如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">             http://ip:port/repository/maven-releases/</span><br><span class="line">         <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">             http://ip:port/repository/maven-snapshots/</span><br><span class="line">         <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上述指定的repository需要在maven的全部配置文件settings.xml中有对应账号配置(id需要一一对应)，如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-pom-xml配置"><a href="#2-pom-xml配置" class="headerlink" title="2. pom.xml配置"></a>2. pom.xml配置</h3><p>项目中引入该数据库框架有三种方式：</p><ol><li>直接引入 cn.jboost.springboot:tkmapper-spring-boot-starter（没有连接池）</li><li>直接引入 cn.jboost.springboot:druid-spring-boot-starter（druid连接池支持）</li><li>项目继承 cn.jboost.springboot:spring-boot-parent（使用的是druid连接池）</li></ol><p>三种方式的pom.xml配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#第一种方式</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tkmapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#第二种方式</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#第三种方式</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据情况引入mysql或postgresql的驱动依赖（其它数据库暂未做类型转换支持，未作测试）</p><h3 id="3-配置数据源"><a href="#3-配置数据源" class="headerlink" title="3. 配置数据源"></a>3. 配置数据源</h3><p>如果使用druid连接池，则在application.yml配置文件中，加入如下数据源配置（推荐）<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    druid:</span></span><br><span class="line"><span class="attr">      driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      password:</span></span><br><span class="line">      <span class="comment"># 自定义配置</span></span><br><span class="line"><span class="attr">      initialSize:</span> <span class="number">2</span>  <span class="comment"># 初始化大小</span></span><br><span class="line"><span class="attr">      minIdle:</span> <span class="number">1</span>   <span class="comment"># 最小连接</span></span><br><span class="line"><span class="attr">      maxActive:</span> <span class="number">5</span> <span class="comment"># 最大连接</span></span><br><span class="line"><span class="attr">      druidServletSettings:</span></span><br><span class="line"><span class="attr">        allow:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">        deny:</span></span><br><span class="line"><span class="attr">        loginUsername:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">        loginPassword:</span> <span class="string">Passw0rd</span></span><br><span class="line"><span class="attr">        resetEnable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      druidFilterSettings:</span></span><br><span class="line"><span class="attr">        exclusions:</span> <span class="string">'*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*'</span></span><br><span class="line"><span class="attr">      maxWait:</span> <span class="number">60000</span>   <span class="comment"># 配置获取连接等待超时的时间</span></span><br><span class="line"><span class="attr">      timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span> <span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line"><span class="attr">      minEvictableIdleTimeMillis:</span> <span class="number">300000</span> <span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line"><span class="attr">      validationQuery:</span> <span class="string">SELECT</span> <span class="string">'x'</span></span><br><span class="line"><span class="attr">      testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      testOnReturn:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      poolPreparedStatements:</span> <span class="literal">true</span> <span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line"><span class="attr">      maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">      filters:</span> <span class="string">stat</span> <span class="comment">#,wall（添加wall代码里不能直接拼接sql，druid有sql注入校验） # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙</span></span><br><span class="line"><span class="attr">      connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span> <span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line"><span class="attr">      useGlobalDataSourceStat:</span> <span class="literal">true</span> <span class="comment"># 合并多个DruidDataSource的监控数据</span></span><br></pre></td></tr></table></figure></p><p>如果不使用连接池，则配置相对简单，如下<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure></p><h3 id="4-定义相应domain，mapper，service，controller各层对象"><a href="#4-定义相应domain，mapper，service，controller各层对象" class="headerlink" title="4. 定义相应domain，mapper，service，controller各层对象"></a>4. 定义相应domain，mapper，service，controller各层对象</h3><p>以demo为例（demo数据库脚本见resources/schema.sql），domain定义一个User类,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">AutoIncrementKeyBaseDomain</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ColumnType</span>(jdbcType = JdbcType.CHAR)</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; favor;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Gender&#123;</span><br><span class="line">        M,</span><br><span class="line">        F</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要添加<code>@Table</code>注解指定数据库表名，可通过继承<code>AutoIncrementKeyBaseDomain</code>来实现自增主键，或<code>UUIDKeyBaseDomain</code>来实现UUID主键，如果自定义其它类型主键，则继承<code>BaseDomain</code>。</p><blockquote><p>该框架Service层通用方法实现<code>BaseService</code>只支持单列主键，不支持组合主键（也不建议使用组合主键）</p></blockquote><blockquote><p>框架默认对List、Map等复杂类型属性会映射到mysql的json类型或postgresql的jsonb类型，如果某个属性不需要映射，可添加@Transient注解；枚举类型需添加@ColumnType指定jdbcType。</p></blockquote><p>dao层定义<code>UserMapper</code>，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>BaseMapper</code>默认实现了单表的增删改查及批量插入等功能，如需定义复杂查询，可在该接口中定义，然后通过mapper xml文件编写实现。</p><p>service层定义 <code>UserService</code>，继承了<code>BaseService</code>的通用功能（具体可查看源码），同样可在该类中自定义方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">Integer</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createWithTransaction</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        create(user);</span><br><span class="line">        <span class="comment">//用于测试事务</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"抛出异常，让前面的数据库操作回滚"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>controller层定义 <code>UserController</code>，继承了<code>BaseController</code>的通用接口（具体可查看源码）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span>&lt;<span class="title">Integer</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，只需要定义各层对应的接口或类，继承基础接口或类，便完成了用户基本的增删改查功能，不需要写一行具体的实现代码。</p><h3 id="5-测试、运行"><a href="#5-测试、运行" class="headerlink" title="5. 测试、运行"></a>5. 测试、运行</h3><ol><li><p>示例中提供了两个新建用户的单元测试，参考<code>SpringbootTkmapperApplicationTests</code>类</p></li><li><p>运行，在主类上直接运行，然后浏览器里打开 <a href="http://localhost:8080/user" target="_blank" rel="noopener">http://localhost:8080/user</a> 则可列出单元测试中创建的用户（其它接口参考<code>BaseController</code>实现）</p></li></ol><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>本文介绍框架基于<code>tk.mybatis:mapper-spring-boot-starter</code>做了一些自定义扩展，以更大程度地实现复用。可用于实际项目开发，使用过程中如果遇到问题，可关注公众号留言反馈。<br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库访问是web应用必不可少的部分。现今最常用的数据库ORM框架有Hibernate与Mybatis，Hibernate貌似在传统IT企业用的较多，而Mybatis则在互联网企业应用较多。通用Mapper（&lt;a href=&quot;https://github.com/abel533/Mapper）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/abel533/Mapper）&lt;/a&gt; 是一个基于Mybatis，将单表的增删改查通过通用方法实现，来减少SQL编写的开源框架，且也有对应开源的mapper-spring-boot-starter提供。我们在此基础上加了一些定制化的内容，以便达到更大程度的复用。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>案例解析：使用IDEA异常断点来定位java.lang.ArrayStoreException的问题</title>
    <link href="http://blog.jboost.cn/2019/06/21/issue-errortrack.html"/>
    <id>http://blog.jboost.cn/2019/06/21/issue-errortrack.html</id>
    <published>2019-06-21T10:31:03.000Z</published>
    <updated>2019-06-21T11:27:06.343Z</updated>
    
    <content type="html"><![CDATA[<p>最近对 base-spring-boot （<a href="https://github.com/ronwxy/base-spring-boot）" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot）</a> 项目进行了升级。在将其用于应用开发中时遇到<code>java.lang.ArrayStoreException</code>的异常导致程序无法启动。平常开发过程中面对这种描述不够清楚，无法定位具体原因的问题该如何处理？本文分享通过使用IDEA异常断点来定位此类问题的方法。</p><a id="more"></a><p>启动程序时抛出如下异常，导致启动失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;devGlobalExceptionHandler&apos; defined in class path resource [cn/jboost/springboot/autoconfig/error/exception/ExceptionHandlerAutoConfiguration.class]: Post-processing of merged bean definition failed; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:570) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:843) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at com.cnbot.kindergarten.CnbotKindergartenApplication.main(CnbotKindergartenApplication.java:10) [classes/:na]</span><br><span class="line">Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72) ~[na:1.8.0_201]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>单纯看异常栈，无法定位问题原因，只能看到是在调用<code>devGlobalExceptionHandler</code>创建bean时出错，错误信息<code>java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</code>。这属于框架内部抛出的异常，通常的设置断点Debug的方法很难定位到具体原因，可通过IDEA的异常断点来进行定位，它会在程序运行过程中出现指定异常时进行阻断。</p><h3 id="1-添加异常断点"><a href="#1-添加异常断点" class="headerlink" title="1. 添加异常断点"></a>1. 添加异常断点</h3><p>在IDEA的Debug面板中，点击“View Breakpoints”（两个重叠的红色圈按钮），如下</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/exceptionbreak0.png" alt="Debug面板"></p><p>打开“Breakpoints”窗口，在该窗口中点击“+”按钮，选择“Java Exception Breakpoints”， 如下图</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/exceptionbreak1.png" alt="Breakpoints"></p><p>然后在弹出的“Enter Exception Class”窗口中输入<code>ArrayStoreException</code>选中对应异常，依次点击OK，Done按钮即完成异常断点添加。</p><h3 id="2-程序debug"><a href="#2-程序debug" class="headerlink" title="2. 程序debug"></a>2. 程序debug</h3><p>开始以Debug模式启动程序。 程序运行后，在前面配置的异常出现时，将会进行阻断，如图</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/exceptionbreak3.png" alt="程序异常阻断"></p><p>可以看到程序阻断在上图高亮的那行代码处，异常便是从这里抛出的。查看<code>parseClassValue</code>方法，可看到这里有catch<code>TypeNotPresentException</code>异常，并且包装成我们在异常栈看到的<code>TypeNotPresentExceptionProxy</code>返回。离真相很近了。</p><p>我们可以在上述catch块中添加一个断点，查看异常包装前的状态，如图</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/exceptionbreak4.png" alt="断点定位"></p><p>重新Debug运行，将定位到上图代码处，查看异常，看到如下图所示信息</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/exceptionbreak5.png" alt="异常信息"></p><p>该信息表示<code>org.springframework.security.access.AccessDeniedException</code>这个类不存在，导致<code>BaseWebApplicationExceptionHandler</code>类型的bean实例化时出错。这时候问题基本已经定位到了。</p><p>查看源码，在BaseWebApplicationExceptionHandler中有对AccessDeniedException的统一处理，但是spring-boot-autoconfigure所有的依赖都是optional的（不会传递依赖），而在新开发的项目中，并没有引入spring-security，因此导致<code>AccessDeniedException</code>这个类找不到而报错。目前通过去掉该部分处理解决。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>IDEA的Debug支持好几种断点类型，如前文介绍的异常断点，以及比较常用的条件断点等。当无法从异常栈信息找到问题所在时，借用这些类型的断点进行Debug，往往事情就变得简单了。</p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对 base-spring-boot （&lt;a href=&quot;https://github.com/ronwxy/base-spring-boot）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ronwxy/base-spring-boot）&lt;/a&gt; 项目进行了升级。在将其用于应用开发中时遇到&lt;code&gt;java.lang.ArrayStoreException&lt;/code&gt;的异常导致程序无法启动。平常开发过程中面对这种描述不够清楚，无法定位具体原因的问题该如何处理？本文分享通过使用IDEA异常断点来定位此类问题的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="案例解析" scheme="http://blog.jboost.cn/categories/%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战：整合Web项目常用功能</title>
    <link href="http://blog.jboost.cn/2019/06/20/springboot-base.html"/>
    <id>http://blog.jboost.cn/2019/06/20/springboot-base.html</id>
    <published>2019-06-20T14:17:22.000Z</published>
    <updated>2019-06-21T10:28:06.768Z</updated>
    
    <content type="html"><![CDATA[<p>在Web应用开发过程中，一般都涵盖一些常用功能的实现，如数据库访问、异常处理、消息队列、缓存服务、OSS服务，以及接口日志配置，接口文档生成等。如果每个项目都来一套，则既费力又难以维护。可以通过Spring Boot的Starter来将这些常用功能进行整合与集中维护，以达到开箱即用的目的。</p><a id="more"></a><p>项目基于Spring Boot 2.1.5.RELEASE 版。<br>项目地址： <a href="https://github.com/ronwxy/base-spring-boot" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot</a></p><p>整个项目分为如下几部分：</p><ul><li>spring-boot-autoconfigure：  具体的各功能实现，每个功能通过package的形式组织</li><li>spring-boot-commons： 一些公共的工具类或共享类</li><li>spring-boot-dependencies： 依赖的集中维护管理，集中管理各个依赖的版本号</li><li>spring-boot-parent： 提供一个基本的父项目，web服务项目可通过继承该项目创建</li><li>spring-boot-starters： 各功能的starter项目，引入相应starter即引入相应功能</li></ul><h2 id="spring-boot-dependencies-项目"><a href="#spring-boot-dependencies-项目" class="headerlink" title="spring-boot-dependencies 项目"></a>spring-boot-dependencies 项目</h2><p>该项目主要是对所有依赖进行集中定义。通过 dependencyManagement 对依赖进行声明， </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;base-spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，所有依赖的版本可以集中统一管理，在其它地方引用的时候可以省去版本的声明，如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spring-boot-autoconfigure-项目"><a href="#spring-boot-autoconfigure-项目" class="headerlink" title="spring-boot-autoconfigure 项目"></a>spring-boot-autoconfigure 项目</h2><p>该项目是各功能自动配置的具体实现，以package的形式进行组织，如 tkmapper 包下实现了通用Mapper的自动配置，error 包下实现了错误处理的自动配置， 等等。</p><p>该项目继承了spring-boot-dependencies， 在项目的 pom.xml 中，依赖部分声明类似于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring denpendencies --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不需要再指定版本号，通过将optional设置为true，表示该依赖不会进行传递，即另外一个项目引用该项目时，optional的依赖不会被传递依赖过去。</p><p>在 resources/META-INF/spring.factories 文件中，声明了所有自动配置类， 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">cn.jboost.springboot.autoconfig.tkmapper.MapperAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.aoplog.AopLoggerAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.alimq.config.AliMQAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.qiniu.QiniuAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.swagger.Swagger2AutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.druid.DruidAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.error.exception.ExceptionHandlerAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.alimns.MnsAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.redis.RedisClientAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.web.CORSAutoConfiguration</span><br></pre></td></tr></table></figure><h2 id="spring-boot-starters-项目"><a href="#spring-boot-starters-项目" class="headerlink" title="spring-boot-starters 项目"></a>spring-boot-starters 项目</h2><p>该项目包含按功能划分的多个子项目，主要用来引入依赖以达到自动配置的依赖条件，使引入对应starter时，能让自动配置生效。如通用Mapper集成的 tkmapper-spring-boot-starter 依赖如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时在 resources/META-INF/spring.provides 里声明了该starter的用途，这里可随意编写。</p><h2 id="spring-boot-commons-项目"><a href="#spring-boot-commons-项目" class="headerlink" title="spring-boot-commons 项目"></a>spring-boot-commons 项目</h2><p>可将一些常用的工具类， 或共享类放到这个项目中。比如一些常量定义，加解密工具类等。</p><h2 id="spring-boot-parent-项目"><a href="#spring-boot-parent-项目" class="headerlink" title="spring-boot-parent 项目"></a>spring-boot-parent 项目</h2><p>该项目将Web应用需要的一些常见功能整合进来，应用项目可继承该项目进行构建，从而直接引入相应的功能。</p><p>在接下来的spring boot系列博文中，将一一详细介绍各功能的整合集成与应用。同时会不断更新与完善，以达到能直接用于生产项目的水平。</p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Web应用开发过程中，一般都涵盖一些常用功能的实现，如数据库访问、异常处理、消息队列、缓存服务、OSS服务，以及接口日志配置，接口文档生成等。如果每个项目都来一套，则既费力又难以维护。可以通过Spring Boot的Starter来将这些常用功能进行整合与集中维护，以达到开箱即用的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>研发团队如何借助Gitlab来做代码review</title>
    <link href="http://blog.jboost.cn/2019/06/18/code-review.html"/>
    <id>http://blog.jboost.cn/2019/06/18/code-review.html</id>
    <published>2019-06-18T12:03:21.000Z</published>
    <updated>2019-06-19T02:21:39.715Z</updated>
    
    <content type="html"><![CDATA[<p>代码review是代码质量保障的手段之一，同时开发成员之间代码review也是一种技术交流的方式，虽然会占用一些时间，但对团队而言，总体是个利大于弊的事情。如何借助现有工具在团队内部形成代码review的流程与规范，是team leader或技术管理者需要考虑的问题。本文分享一种基于Gitlab代码merge流程的code review方法，以供参考与探讨。如有更好的方法，欢迎交流。</p><a id="more"></a><h2 id="1-设置成员角色"><a href="#1-设置成员角色" class="headerlink" title="1. 设置成员角色"></a>1. 设置成员角色</h2><p>首先需要对你团队的成员分配角色，在Gitlab groups里选择一个group，然后左边菜单栏点击 Members，可在 Members 页面添加或编辑成员角色，如下图所示。</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/gitmember.png" alt="group成员"></p><p>其中角色包含如下几类：</p><ul><li>Guest：权限最小，基本查看功能</li><li>Reporter：只能查看，不能push</li><li>Developer：能push，也能merge不受限制的分支</li><li>Master：除了项目的迁移、删除等管理权限没有，其它权限基本都有</li><li>Owner：权限最大，包括项目的迁移、删除等管理权限</li></ul><p>详细权限参考： <a href="https://docs.gitlab.com/ee/user/permissions.html" target="_blank" rel="noopener">https://docs.gitlab.com/ee/user/permissions.html</a></p><p>确定团队中技术水平、经验较好的成员为Master，负责代码的review与分支的合并；其他成员为Developer，提交合并请求，接受review意见；Master之间可以互相review。</p><h2 id="2-配置分支保护"><a href="#2-配置分支保护" class="headerlink" title="2. 配置分支保护"></a>2. 配置分支保护</h2><p>在项目页面左侧菜单栏 Settings -&gt; Repository， 进入“Protected Branches”部分配置分支保护，如下图所示。</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/protectedbranch.png" alt="分支保护"></p><p>在这里可以针对每个分支，设置允许什么角色可以merge，允许什么角色可以push，选项包括三个：“Masters”， “Developers + Masters”， “No one”。<br>这里设置成只允许master可以直接push与merge这几个常设分支的代码。（如果更严格一点，可以将“Allowed to push”设置成“No one”）</p><h2 id="3-代码review流程"><a href="#3-代码review流程" class="headerlink" title="3. 代码review流程"></a>3. 代码review流程</h2><h3 id="3-1-开发（开发者负责）"><a href="#3-1-开发（开发者负责）" class="headerlink" title="3.1. 开发（开发者负责）"></a>3.1. 开发（开发者负责）</h3><ol><li>本地切到develop分支， 拉取最新代码（相关命令如下，GUI工具操作自行查相关文档） </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch #查看当前位于哪个分支，前面打星号即为当前分支</span><br><span class="line">git checkout develop   #切换到develop分支</span><br><span class="line">git pull  #拉取最新代码</span><br></pre></td></tr></table></figure><ol start="2"><li>从develop分支切出子分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature-1101  #从当前分支切出子分支，命名为"feature-1101"</span><br></pre></td></tr></table></figure><ol start="3"><li>编码、本地自测完之后，提交子分支到远程仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *  #加入暂存区</span><br><span class="line">git commit -m "commit msg" #提交到本地仓库</span><br><span class="line">git push origin feature-1101 #提交到远程仓库</span><br></pre></td></tr></table></figure><h3 id="3-2-发起Merge请求（开发者负责）"><a href="#3-2-发起Merge请求（开发者负责）" class="headerlink" title="3.2 发起Merge请求（开发者负责）"></a>3.2 发起Merge请求（开发者负责）</h3><ol><li>在项目主页面，依次点击左侧“Merge Requests”（下图1），“New merge request”（下图2），打开新建Merge请求页面</li></ol><p><img src="http://pso1tuwfq.bkt.clouddn.com/mergerequest1.png" alt="Merge请求"></p><ol start="2"><li>在新建Merge请求页面，选择merge的源分支，及目标分支，如下图源分支为“feature-1101”，目标分支为“develop”，点击“Compare branches and continue”按钮进入对比与提交页面</li></ol><p><img src="http://pso1tuwfq.bkt.clouddn.com/mergerequest2.png" alt="新建Merge请求"></p><ol start="3"><li>在对比与提交页面，可以点击“Changes” tab查看本次修改（这里我为了演示，只是加了两个换行），确认无误，点击“Submit merge request”按钮，提交merge请求</li></ol><p><img src="http://pso1tuwfq.bkt.clouddn.com/mergesubmit.png" alt="对比修改"></p><ol start="4"><li>提交之后，将结果页面的浏览器地址发到团队即时通讯群（如钉钉），并@相应的同事申请review</li></ol><h3 id="3-3-代码Review（code-reviewer负责）"><a href="#3-3-代码Review（code-reviewer负责）" class="headerlink" title="3.3 代码Review（code reviewer负责）"></a>3.3 代码Review（code reviewer负责）</h3><ol><li>负责代码Review的同事收到申请后，点击merge请求地址，打开页面，查看“Changes”</li></ol><p><img src="http://pso1tuwfq.bkt.clouddn.com/merge.png" alt="对比修改"></p><p>这里可通过“Inline”单边查看，也可以通过“Side-by-side”两个版本对比查看</p><ol start="2"><li>review完成后，若无问题，则可点击”Merge”按钮完成merge，同时可删除对应的子分支“feature-1101”，<br>若有问题，则可点击“Close merge request”按钮关闭该merge请求（也可以不关闭复用该merge请求），同时通知开发者进行相应调整，重新提交代码发起merge请求（如果之前没关闭merge请求，则刷新即可看到调整）。</li></ol><h3 id="3-4-冲突解决（开发者负责）"><a href="#3-4-冲突解决（开发者负责）" class="headerlink" title="3.4 冲突解决（开发者负责）"></a>3.4 冲突解决（开发者负责）</h3><ol><li>merge的时候，可能存在代码冲突，这时，开发者可从develop分支重新拉取最新代码进行本地merge， 解决冲突后重新提交代码进行review</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git pull origin develop #在当前子分支拉取develop分支的最新代码进行本地merge</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决冲突代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交</span></span><br><span class="line">git add *</span><br><span class="line">git commit -m "fix merge conflict"</span><br><span class="line">git push origin feature-1101</span><br></pre></td></tr></table></figure><ol start="2"><li>自行解决不了时，寻求协助</li></ol><h2 id="4-借助阿里钉钉机器人来改善体验"><a href="#4-借助阿里钉钉机器人来改善体验" class="headerlink" title="4. 借助阿里钉钉机器人来改善体验"></a>4. 借助阿里钉钉机器人来改善体验</h2><p>前面流程中提醒code reviewer是需要开发者自己来发消息通知的，可不可以把这个流程自动化。我们可以借助Gitlab的webhook与钉钉机器人来实现。</p><ol><li>在钉钉群右上角点击“…”，打开群设置，群机器人中点击添加机器人，会显示可以添加的机器人类型，如下图所示</li></ol><p><img src="http://pso1tuwfq.bkt.clouddn.com/dingdingmachine.png" alt="钉钉机器人"></p><ol start="2"><li>选择Gitlab，点击添加，输入机器人名称，如“Gitlab”，点击完成即创建了一个Gitlab的钉钉机器人。回到“群机器人”窗口，将能看到刚刚创建的Gitlab机器人，如图</li></ol><p><img src="http://pso1tuwfq.bkt.clouddn.com/dingdingmachinelist.png" alt="钉钉机器人列表"></p><p>点击齿轮按钮，进入设置页，可看到webhook地址，点击复制，复制该机器人的webhook地址。如图</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/dingdingwebhook.png" alt="钉钉机器人webhook"></p><ol start="3"><li>在Gitlab项目主页进入 Settings -&gt; Integrations， 将前面复制的webhook地址填入URL中，Trigger 部分选择“Merge request events”（不要勾太多，不然提醒太多就有点骚扰了），然后点击“Add webhook”就完成了。如图</li></ol><p><img src="http://pso1tuwfq.bkt.clouddn.com/gitlabwebhook.png" alt="GitlabWebhook"></p><ol start="4"><li>当有开发人员提交merge请求时，钉钉机器人将在钉钉群里发出通知，code reviewer点击消息里的链接即可进入页面进行code review， review完成，将分支merge之后，钉钉机器人也会发出消息（所有merge相关的事件都会发出消息）。如图</li></ol><p><img src="http://pso1tuwfq.bkt.clouddn.com/dingdingmachinechat.png" alt="钉钉机器人通知"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>团队协作，流程、规范很重要，不同的团队可能有不同的适用流程与规范。此文分享了基于Gitlab与阿里钉钉群机器人的代码review流程，希望对团队研发协作有一定参考价值，也欢迎一起探讨、交流。</p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码review是代码质量保障的手段之一，同时开发成员之间代码review也是一种技术交流的方式，虽然会占用一些时间，但对团队而言，总体是个利大于弊的事情。如何借助现有工具在团队内部形成代码review的流程与规范，是team leader或技术管理者需要考虑的问题。本文分享一种基于Gitlab代码merge流程的code review方法，以供参考与探讨。如有更好的方法，欢迎交流。&lt;/p&gt;
    
    </summary>
    
      <category term="teamwork" scheme="http://blog.jboost.cn/categories/teamwork/"/>
    
    
      <category term="git" scheme="http://blog.jboost.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>团队项目的Git分支如何管理</title>
    <link href="http://blog.jboost.cn/2019/06/17/git-branch.html"/>
    <id>http://blog.jboost.cn/2019/06/17/git-branch.html</id>
    <published>2019-06-17T05:28:19.000Z</published>
    <updated>2019-06-18T12:03:59.043Z</updated>
    
    <content type="html"><![CDATA[<p>许多公司的开发团队都采用Git来做代码版本控制。如何有效地协同开发人员之间，以及开发、测试、上线各环节的工作，可能都有各自的流程与规范。本文分享的是作者一直沿用的团队项目Git分支管理规范，希望给有缘阅读的人以参考，如果有更好的实践，也欢迎指教、讨论。<br><a id="more"></a></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>创建项目时（一般是服务型项目，工具型或辅助型项目可以简单一些），会针对不同环境创建三个常设分支：</p><ol><li>develop：开发环境的稳定分支，公共开发环境基于该分支构建。</li><li>pre-release：测试环境的稳定分支，测试环境基于该分支构建。</li><li>master：生产环境的稳定分支，生产环境基于该分支构建。仅用来发布新版本，除了从pre-release或生产环境Bug修复分支进行merge，不接受任何其它修改</li></ol><p>平时开发工作中，会根据需要由开发人员创建两类临时分支：</p><ol><li>功能（feature）分支：为了开发某个特定功能，从develop分支上面分出来的。开发完成后，要merge到develop分支。功能分支的命名，可以采用feature-*的形式命名(*为任务单号)</li><li>Bug修复（fixbug）分支：为了修复某个bug，从常设分支上面分出来的。修复完成后，再merge到对应的分支。Bug修复分支的命名，可以采用fixbug-*的形式命名（*为bug单号）</li></ol><h2 id="流程规范"><a href="#流程规范" class="headerlink" title="流程规范"></a>流程规范</h2><h3 id="正常开发流程"><a href="#正常开发流程" class="headerlink" title="正常开发流程"></a>正常开发流程</h3><ol><li>从develop分支切出一个新分支，根据是功能还是bug，命名为feature-* 或 fixbug-*。</li><li>开发者完成开发，提交分支到远程仓库。</li><li>开发者发起merge请求（可在gitlab页面“New merge request”），将新分支请求merge到develop分支，并提醒code reviewer进行review</li><li>code reviewer对代码review之后，若无问题，则接受merge请求，新分支merge到develop分支，同时可删除新建分支；若有问题，则不能进行merge，可close该请求，同时通知开发者在新分支上进行相应调整。调整完后提交代码重复review流程。</li><li>转测时，直接从当前develop分支merge到pre-release分支，重新构建测试环境完成转测。</li><li>测试完成后，从pre-release分支merge到master分支，基于master分支构建生产环境完成上线。并对master分支打tag，tag名可为v1.0.0_2019032115（即版本号_上线时间）</li></ol><p>流程示意图如下所示</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/gitbranch1.png" alt="正常开发流程"></p><h3 id="并行开发测试环境Bug修复流程"><a href="#并行开发测试环境Bug修复流程" class="headerlink" title="并行开发测试环境Bug修复流程"></a>并行开发测试环境Bug修复流程</h3><p>并行开发（即前一个版本已经转测但未上线，后一个版本又已在开发中并部分合并到了develop分支）过程中，转测后测试环境发现的bug需要修复，但是develop分支此时又有新内容且该部分内容目前不计划转测，可以pre-release切出一个bug修复分支。完成之后需要同时merge到pre-release分支与develop分支。merge时参考“正常开发流程”。流程示意图如下</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/gitbranch2.png" alt="并行开发测试环境Bug修复流程"></p><h3 id="生产环境Bug修复流程"><a href="#生产环境Bug修复流程" class="headerlink" title="生产环境Bug修复流程"></a>生产环境Bug修复流程</h3><p>生产环境的Bug分两种情况：</p><ol><li>紧急Bug：严重影响用户使用的为紧急Bug，需立即进行修复。如关键业务流程存在问题，影响用户正常的业务行为。</li><li>非紧急Bug或优化：非关键业务流程问题，仅影响用户使用体验，或出现频率较小等，为非紧急Bug，可规划到后续版本进行修复。</li></ol><p>非紧急Bug修复参考“正常开发流程”。</p><p>紧急Bug修复，需要从master分支切出一个bug修复分支，完成之后需要同时merge到master分支与develop分支（如果需要测试介入验证，则可先merge到pre-release分支，验证通过后再merge到master分支上线）。merge时参考“正常开发流程”。流程示意图如下</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/gitbranch3.png" alt="生产环境Bug修复流程"></p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多公司的开发团队都采用Git来做代码版本控制。如何有效地协同开发人员之间，以及开发、测试、上线各环节的工作，可能都有各自的流程与规范。本文分享的是作者一直沿用的团队项目Git分支管理规范，希望给有缘阅读的人以参考，如果有更好的实践，也欢迎指教、讨论。&lt;br&gt;
    
    </summary>
    
      <category term="teamwork" scheme="http://blog.jboost.cn/categories/teamwork/"/>
    
    
      <category term="git" scheme="http://blog.jboost.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>命令行高效操作Git，看这篇就够了</title>
    <link href="http://blog.jboost.cn/2019/06/16/use-git.html"/>
    <id>http://blog.jboost.cn/2019/06/16/use-git.html</id>
    <published>2019-06-16T06:30:07.000Z</published>
    <updated>2019-06-28T09:00:07.774Z</updated>
    
    <content type="html"><![CDATA[<p>对于软件开发人员来说，git几乎是每天都需要接触的工具。但对于相处如此亲密的工作伙伴，你对它的了解又有多少，是不是还在傻瓜式地打开一个GUI工具，点击提交按钮，然后“卧槽，又冲突了”，一脸懵逼到不知所措，责怪谁又在你前面提交了，谁又改了你的代码。</p><a id="more"></a><p>博主从一开始接触git，就没用过任何GUI工具，都是通过命令行进行操作，发现这种方式不仅对git的理解更深，效率也更高，遇到问题时一般都知道如何来处理，故做此分享。本文所有知识与操作只涉及日常使用场景，更多详细内容可自行查阅其它资料。本文Git版本为 windows-2.20.1版。</p><h3 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h3><p>git的理论知识，对使用者来说只需要知道它是分布式版本控制系统，了解如下三个概念即可，</p><ul><li>工作区：就是你直接操作的文件目录与内容</li><li>暂存区：暂时为你保存还没将内容提交到版本库的一个区域，对应.git目录下的stage或index文件</li><li>版本库：分本地版本库与远程版本库，本地版本库就理解为对应.git目录即可，远程版本库就是远程仓库，如gitlab或github的repository。</li></ul><p>如下图，我们平时提交代码的过程基本都是从工作区<code>add</code>到暂存区，然后再<code>commit</code>到本地仓库，最后<code>push</code>到远程仓库。</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/git1.png" alt="git"></p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>对于日常工作，掌握如下几个基本命令一般就够了</p><ul><li><code>git status</code> 查看修改状态</li><li><code>git pull origin master</code> 拉取远程仓库master分支合并到本地，master根据场景换成其它分支名</li><li><code>git add file</code> 添加文件到暂存区，可用 * 添加所有</li><li><code>git commit -m &quot;commit message&quot;</code> 提交到本地版本库，并添加注释，注释表明此次修改内容，要清晰准确</li><li><code>git push origin master</code> 将本地版本提交到远程仓库的master分支，master根据场景换成其它分支名</li></ul><p>对大部分日常工作来说， 上面几个命令基本就够用了。</p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p><strong>1. 从本地到远程</strong></p><p>项目开发的时候，有时候是先在本地建一个项目，再提交到远程仓库的。</p><ol><li>创建项目目录（或通过IDE创建），命令行cd到项目目录</li><li>执行<code>git init</code> ， 将在项目目录创建.git目录</li><li>执行<code>git add *</code> ，将所有文件添加到暂存区，这里要先创建一个.gitignore文件，将不需要版本维护的文件添加进去忽略，不然各种IDE编译文件夹，环境相关文件都加到版本库去了。删除文件用<code>git rm file_name</code></li><li>执行<code>git commit -m &quot;upload project&quot;</code> ，提交到本地仓库</li><li>在gitlab或github上创建一个仓库，并将仓库地址复制下来</li><li>执行<code>git remote add origin git@server-name:path/repo-name.git</code> ，关联远程仓库，仓库地址如果是http开头则要用户名密码，如果是git开头，则是走的ssh协议，需要将你本机的ssh公钥添加到远程仓库服务上。</li><li>执行<code>git push -u origin master</code> ，推送本地仓库内容到远程仓库</li></ol><p>这样在远程仓库目录，就能看到你提交上去的文件内容了。</p><p><strong>2. 从远程到本地</strong><br>更多的时候，是远程仓库已有项目了，需要下载到本地开发。</p><ol><li><code>git clone git@server-name:path/repo-name.git</code> ， 将远程仓库的内容下载到本地，这里仓库地址的处理同上</li><li>修改内容</li><li><code>git add *</code> ，将修改的内容添加到暂存区</li><li><code>git commit -m &quot;fix xxx issue&quot;</code> ，提交到本地仓库</li><li><code>git push -u origin master</code> ， 推送本地仓库内容至远程仓库</li></ol><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>有时候改了文件，想反悔怎么办，git给你“后悔药”。</p><p>单个文件的还原：</p><ul><li><code>git checkout file_name</code> ，丢弃工作区的修改，还原到上次提交（commit）的版本，</li><li><code>git reset HEAD file_name</code> ，把暂存区的修改撤销掉（unstage），重新放回工作区。即还原到上次添加到暂存区（add）的版本</li></ul><p>这里涉及几个场景</p><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout file_name</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时（执行了add，但没执行commit），想丢弃修改，分两步，第一步用命令<code>git reset HEAD file_name</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次的全部提交，参考下面的整个版本的还原，不过前提是没有推送到远程库。</li></ul><p>整个版本的还原：</p><ul><li><code>git reset --hard HEAD^^</code>， 回退到上上个版本</li><li><code>git reset --hard 3628164</code>， 回退到具体某个版本 3628164 是具体某个commit_id缩写</li></ul><blockquote><p>找不到commit_id？ <code>git reflog</code> 可查看每一个命令的历史记录，获取对应操作的commit_id。<code>git log [--pretty=oneline]</code>， 可查看commit记录</p></blockquote><blockquote><p>上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100。3628164 是具体某个commit_id，不需要写全，只需要唯一确定就行，可往前进也可往后退。（git windows2.20.1版貌似不支持对HEAD^的操作）</p></blockquote><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ol><li>首先，可以试图用 <code>git push origin branch_name</code> 推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用 <code>git pull</code> 试图合并；</li><li>如果合并有冲突，则手动解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用 <code>git push origin branch-name</code> 推送就能成功！</li></ol><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name</p><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>平时开发时需要创建子分支来实现你的功能模块，然后再合并到主分支中。</p><ul><li><code>git checkout -b your_branch_name</code> ， 创建并切换分支</li><li><code>git branch</code>  ， 查看分支，标有*号表示当前所在分支</li><li><code>git merge dev</code> ， 合并指定dev分支到当前分支</li><li><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code> ， 合并分支并生成commit记录</li><li><code>git branch -d dev</code> ， 删除分支</li></ul><blockquote><p><code>git checkout -b dev =  git branch dev + git checkout dev</code></p></blockquote><blockquote><p>Fast-forward合并，“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。存在冲突的不能fast forward。<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>  Fast forward模式下，删除分支后，会丢掉分支信息。如果强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p></blockquote><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>当发布版本时，一般需要对当前版本进行标签记录，以便后续进行版本查看或回退。</p><ul><li><code>git tag tag_name</code>  ， 对当前分支打标签</li><li><code>git tag</code> ， 查看所有标签</li><li><code>git tag v0.9 6224937</code>  ，针对某个具体commit id打标签</li><li><code>git show tag_name</code> ， 查看标签信息</li><li><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164</code>  ， 带有说明的标签</li><li><code>git tag -d v0.1</code> ， 删除标签</li><li><code>git push origin tag_name</code> ， 推送标签到远程    </li><li><code>git push origin --tags</code> ， 一次性推送所有标签</li></ul><p>删除已经推送到远程的标签：</p><ul><li><code>git tag -d v0.9</code> ， 先本地删除</li><li><code>git push origin :refs/tags/v0.9</code> ， 然后从远程删除</li></ul><h3 id="提高效率的Tips"><a href="#提高效率的Tips" class="headerlink" title="提高效率的Tips"></a>提高效率的Tips</h3><ol><li><p>配置命令别名   </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status # 后面可以用git st 来代替git status了</span><br><span class="line">git config --global alias.ck checkout  # 后面可以用 git ck 来代替 git checkout了</span><br><span class="line">git config --global alias.cm 'commit -m' # 后面可以用git cm 来代替 git commit -m 了</span><br></pre></td></tr></table></figure></li><li><p><code>git pull origin master</code> 或 <code>git push origin master</code>， 可直接 <code>git pull</code> 或 <code>git push</code>， 如果出现“no tracking information”的提示，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream-to=origin/master master</code> 建立关联即可。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上命令虽然看起来多，但平常用的最频繁的应该是“基本命令”与“分支管理”部分，只要多用几次，自然便能记住，应付日常工作完全没有问题，彻底脱离GUI操作，让工作更有效率。</p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于软件开发人员来说，git几乎是每天都需要接触的工具。但对于相处如此亲密的工作伙伴，你对它的了解又有多少，是不是还在傻瓜式地打开一个GUI工具，点击提交按钮，然后“卧槽，又冲突了”，一脸懵逼到不知所措，责怪谁又在你前面提交了，谁又改了你的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="git" scheme="http://blog.jboost.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>案例解析：线程池使用不当导致系统崩溃</title>
    <link href="http://blog.jboost.cn/2019/06/15/issue-threadpool.html"/>
    <id>http://blog.jboost.cn/2019/06/15/issue-threadpool.html</id>
    <published>2019-06-15T03:01:58.000Z</published>
    <updated>2019-06-16T06:31:49.313Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，发现一台阿里云服务器上的Web服务不可用。远程SSH登录不上，尝试几次登录上去之后，执行命令都显示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: fork: Cannot allocate memory</span><br></pre></td></tr></table></figure></p><p>一看以为是内存泄漏导致溢出。因为执行不了任何命令， 只能通过控制台重启服务器恢复服务。<br><a id="more"></a></p><h3 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h3><p>服务恢复后，查看系统日志，linux系统日志路径<code>/var/log/messages</code>，可通过<code>journalctl</code>命令查看，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since="2019-06-12 06:00:00" --until="2019-06-12 10:00:00"</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>可查看since之后，until之前时间段的日志。除了发现<code>crond[14954]: (CRON) CAN&#39;T FORK (do_command): Cannot allocate memory</code> 这个错误日志，未见其它异常（下面的<code>sshd[10764]: error: fork: Cannot allocate memory</code>应是ssh登录执行命名失败的日志）</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/linux-log.png" alt="linux-log"></p><p>通过阿里云-云监控-主机监控查看内存使用率指标，这段时间内，内存使用率一直在40%以下，基本可排除内存溢出的可能。</p><p>通过搜索查阅到进程数超过操作系统限制可能导致<code>bash: fork: Cannot allocate memory</code>的报错(参考： <a href="https://blog.csdn.net/wangshuminjava/article/details/80603847" target="_blank" rel="noopener">https://blog.csdn.net/wangshuminjava/article/details/80603847</a> ）。通过<code>ps -eLf|wc -l</code>查看当前进程线程数(<code>ps -ef</code>只打印进程，<code>ps -eLf</code>会打印所有的线程), 只有1000多个，故障时刻系统到底运行了多少线程已无从得知，只能持续跟进监测。</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>几天后，再次通过<code>ps -eLf|wc -l</code>查看，发现线程数已达16000多个。直接执行<code>ps -eLf</code>可看到大量tomcat进程所产生的线程，猜测是不是线程死锁导致大量线程未完成一直hung在那里。</p><p>执行 <code>jstack 进程号 &gt; ~/jstack.txt</code> 命令将进程所运行线程情况打印出来分析，发现大量的<code>WAITING</code>状态的线程，如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"pool-19-thread-1" #254 prio=5 os_prio=0 tid=0x00007f0b700a6000 nid=0x29a9 waiting on condition [0x00007f0b274df000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  <span class="tag">&lt;<span class="name">0x00000006ce3d8790</span>&gt;</span> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></p><p>根据上述内容可看出线程在等一个条件，并且是在执行<code>LinkedBlockingQueue.take</code>方法的时候，查看该方法的java doc，当队列为空时，该方法将会一直等待直到有元素可用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * until an element becomes available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure></p><p>询问同事在哪里用到了LinkedBlockingQueue，同事回忆起不久前用线程池实现往阿里云OSS服务通过追加的方式上传文件功能，查看代码后发现问题——线程池没有关闭。为了使文件片段保存不存在错乱，每次保存文件时，都new了一个线程池对象，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor saveImgThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br></pre></td></tr></table></figure></p><p>但处理完后， 没有关闭这个线程池对象，这样线程池仍会通过take方法去取等待队列中是否还有未完成的线程任务，等待队列为空时将会一直等待，这样就导致大量的线程hung在这里了（基本是只要方法被调一次，就会产生一个hung住的线程）。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><ol><li><p>线程状态为“waiting for monitor entry”：<br>意味着它 在等待进入一个临界区 ，所以它在”Entry Set“队列中等待。此时线程状态一般都是 Blocked：<br>java.lang.Thread.State: BLOCKED (on object monitor)</p></li><li><p>线程状态为“waiting on condition”：<br>说明它在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了 sleep(N)。此时线程状态大致为以下几种：<br>java.lang.Thread.State: WAITING (parking)：一直等那个条件发生（本文案例即为此种场景）；java.lang.Thread.State: TIMED_WAITING (parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。</p></li><li><p>如果大量线程在“waiting for monitor entry”：可能是一个全局锁阻塞住了大量线程。如果短时间内打印的thread dump 文件反映，随着时间流逝，waiting for monitor entry 的线程越来越多，没有减少的趋势，可能意味着某些线程在临界区里呆的时间太长了，以至于越来越多新线程迟迟无法进入临界区。</p></li><li><p>如果大量线程在“waiting on condition”：可能是它们又跑去获取第三方资源，尤其是第三方网络资源，迟迟获取不到Response，导致大量线程进入等待状态。所以如果你发现有大量的线程都处在 Wait on condition，从线程堆栈看，正等待网络读写，这可能是一个网络瓶颈的征兆，因为网络阻塞导致线程无法执行。也可能是如本文所提到的，由于程序编写不当所致。</p></li></ol><p>参考： <a href="https://www.cnblogs.com/rainy-shurun/p/5732341.html" target="_blank" rel="noopener">https://www.cnblogs.com/rainy-shurun/p/5732341.html</a></p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>——————————————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天，发现一台阿里云服务器上的Web服务不可用。远程SSH登录不上，尝试几次登录上去之后，执行命令都显示&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-bash: fork: Cannot allocate memory&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一看以为是内存泄漏导致溢出。因为执行不了任何命令， 只能通过控制台重启服务器恢复服务。&lt;br&gt;
    
    </summary>
    
      <category term="案例解析" scheme="http://blog.jboost.cn/categories/%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战：写一个自己的starter</title>
    <link href="http://blog.jboost.cn/2019/06/14/springboot-starter.html"/>
    <id>http://blog.jboost.cn/2019/06/14/springboot-starter.html</id>
    <published>2019-06-14T07:19:43.000Z</published>
    <updated>2019-06-14T04:27:58.543Z</updated>
    
    <content type="html"><![CDATA[<p>曾遇到几位面试者，简历上写着精通Spring Boot，当聊到自动配置及对starter的理解时，却说不出个所以然来。找工作时，简历一定要注重实际，精通这种字眼还是少用，不然面试官对你期望越高，失望也就越大。其实结合前一篇介绍的<a href="http://blog.jboost.cn/2019/06/11/springboot-config.html">Spring Boot自动配置</a>，对Spring Boot的Starter实现将很容易理解，不论是使用其官方提供的Starter，还是自定义自己的Starter，都变得很容易。<br><a id="more"></a></p><p>根据前面介绍，Spring Boot自动配置的实现，主要由如下几部分完成：</p><ol><li>@EnableAutoConfiguration注解</li><li>SpringApplication类</li><li>spring-boot-autoconfigure jar包</li><li>spring.factories文件</li></ol><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>官方提供的starter，大多包含两个jar包： 一个starter——没有任何实现，只用来管理依赖（即实现这个starter的功能需要依赖哪些jar），一个autoconfigure——包含所有具体实现，包括自动配置类，及META-INF/spring.factories文件。本文示例的自定义starter，为了方便，将两者合并写到了一个。</p><blockquote><p>但是在实际项目中，还是建议像官方一样，定义一个spring-boot-dependencies声明所有依赖及其版本，做统一依赖版本管理，一个spring-boot-autoconfigure，实现所有自动配置类及相应的Bean，一个spring-boot-starters，针对每个模块引入必须的jar依赖，方便项目中引入。</p></blockquote><p>官方提供的starter，命名遵循spring-boot-starter-xxx， 自定义starter，命名遵循xxx-spring-boot-starter。</p><p>示例的项目结构如下图<br><img src="http://pso1tuwfq.bkt.clouddn.com/starter-struct.png" alt="starter项目结构"></p><h2 id="springboot-starter"><a href="#springboot-starter" class="headerlink" title="springboot-starter"></a>springboot-starter</h2><p>这里为了简单，将starter与autoconfigure整到一个项目，命名也为了与前面demo项目保持一致，没按规范来。</p><p><strong>配置类 MyAutoConfig</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MyProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyProperties myProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"my"</span>, name = <span class="string">"disable"</span>, havingValue = <span class="string">"false"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyService(<span class="string">"Hi "</span> + myProperties.getName() + <span class="string">", welcome to visit "</span> + myProperties.getWebsite());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该类中通过<code>@EnableConfigurationProperties</code>及<code>@Autowired</code> 引入了配置属性Bean MyProperties 以访问用户配置的属性，<code>@Bean</code>注解即向容器中注入方法返回值类型的Bean，这样在容器其它bean中通过<code>@Autowired</code>即可引用访问， @ConditionalOnProperty是条件注解，这里表明当配置属性my.disable=false时才实例化这个MyService bean。</p><p><strong>配置属性类 MyProperties</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"my"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line"></span><br><span class="line">    getter/setter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置属性类封装了用户在配置文件中定义的属性，该示例中将前缀为my的属性封装起来，访问name，website对应配置属性key就是my.name，my.website。</p><p><strong>服务Bean MyService</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String hiStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(String hiStr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hiStr = hiStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hiStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提供服务功能的bean，也即需要实例化注入到Spring上下文的bean。</p><p><strong>spring.factories</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  cn.jboost.springboot.starter.MyAutoConfig</span><br></pre></td></tr></table></figure></p><p>指定了自动配置类（带包名的全路径类名）</p><h2 id="springboot-usingstarter"><a href="#springboot-usingstarter" class="headerlink" title="springboot-usingstarter"></a>springboot-usingstarter</h2><p>该项目引用springboot-starter，调用MyService服务的项目，主类没什么特别的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootUsingstarterApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootUsingstarterApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置文件application.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my.disable=false</span><br><span class="line">my.name=jboost</span><br><span class="line">my.website=blog.jboost.cn</span><br></pre></td></tr></table></figure></p><p>在测试类SpringbootUsingstarterApplicationTests中编写测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStarter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.printf(myService.sayHi());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>pom.xml中引入springboot-starter依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>运行，控制台会打印出 <code>Hi jboost,  welcome to visit blog.jboost.cn</code><br>将配置属性my.disable的值改为true或其它非false的值再运行测试代码试试，会报MyService bean找不到的错误，说明@ConditionalOnProperty注解生效了</p><p>本示例仅作实现自定义starter演示用，项目结构、命名都不够规范，仅供参考，项目实战starter在后面继续分享。</p><p>本文示例项目源码地址：<br><a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-starter" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-starter</a><br><a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-usingstarter" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-usingstarter</a><br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>——————————————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾遇到几位面试者，简历上写着精通Spring Boot，当聊到自动配置及对starter的理解时，却说不出个所以然来。找工作时，简历一定要注重实际，精通这种字眼还是少用，不然面试官对你期望越高，失望也就越大。其实结合前一篇介绍的&lt;a href=&quot;http://blog.jboost.cn/2019/06/11/springboot-config.html&quot;&gt;Spring Boot自动配置&lt;/a&gt;，对Spring Boot的Starter实现将很容易理解，不论是使用其官方提供的Starter，还是自定义自己的Starter，都变得很容易。&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战：Spring Boot配置</title>
    <link href="http://blog.jboost.cn/2019/06/11/springboot-config.html"/>
    <id>http://blog.jboost.cn/2019/06/11/springboot-config.html</id>
    <published>2019-06-11T07:46:02.000Z</published>
    <updated>2019-06-14T00:15:51.526Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot之所以受开发者欢迎， 其中最重要的一个因素就是其配置简单。传统的Spring应用需要手动配置各种.xml文件，为数据库访问，事务支持，缓存功能等提供各项繁杂且重复的配置。Spring Boot将这种繁杂且重复的工作通过预定义的启动器（starter）来实现，只要引入即可拥有相应的功能支持，从而将开发者从复杂的配置工作中解放出来，能够更专注于业务逻辑的开发。</p><a id="more"></a><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>在Spring Boot中，虽然仍然可以通过之前的.xml文件方式来进行配置，但最好还是通过基于java的配置来进行配置管理。在Spring Boot中，基于java的配置是通过注解@Configuration来实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码将一个MyService的Bean注入了容器，这样在其它地方就可以直接通过@Autowired来引用访问。与.xml文件中通过<code>&lt;bean&gt;&lt;/bean&gt;</code>实例化的效果是一样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  myService.sayHello(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际项目开发中，有可能存在一些基于xml配置的旧服务，比如以jar包的形式发布，如果要复用该怎么引入呢？很简单，在@Configuration注解标注的类上，加入@ImportResource注解引用相应的xml文件即可，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"spring.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样类路径下spring.xml配置文件中声明的内容都将生效。在一个应用中，可以定义多个@Configuration配置类，这些配置类可以被@ComponentScan自动扫描并注入容器。</p><blockquote><p>如果应用中没有通过@ComponentScan进行自动扫描，则可在主配置类（一般为入口类）上通过@Import({MyConfig.class})的方式类引入其它配置类</p></blockquote><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>个人认为，自动配置是Spring Boot非常基础但又核心的部分。曾经遇到几个面试者，简历写着精通Spring Boot，当问及自动配置时却支支吾吾不知所云。其实理解Spring Boot的自动配置也不难，基本了解如下几部分差不多就够了：</p><ol><li>@EnableAutoConfiguration注解</li><li>SpringApplication类</li><li>spring-boot-autoconfigure jar包</li><li>spring.factories文件</li></ol><p><strong>@EnableAutoConfiguration注解</strong><br>这个注解的作用是告诉Spring Boot基于添加的jar依赖来自动配置Spring，比如添加了spring-boot-starter-web依赖，则Spring Boot认为你在开发一个web应用，就会自动做好web相应配置。这个注解一般放在主类上。在前面的示例项目中， 我们在主类上都是使用@SpringBootApplication， 查看源码可以知道： </p><ul><li>@SpringBootApplication 这个注解实际上等效于 @SpringBootConfiguration（等效于@Configuration）， </li><li>@EnableAutoConfiguration，启用自动配置 </li><li>@ComponentScan 自动扫描@Component, @Service, @Controller等注解标注的各类组件   </li></ul><p>三者的组合。如果去掉@EnableAutoConfiguration注解，则Spring Boot将不会自动配置Spring（如实例化必要的Bean），将可能导致应用启动失败。</p><p><strong>SpringApplication类</strong><br>在应用主类中，我们是通过SpringApplication的run方法来启动应用的，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看源码，SpringApplication的静态run方法，实际也是通过创建SpringApplication实例，调用实例方法执行，在SpringApplication构造器方法中，调用了getSpringFactoriesInstances 方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span></span></span><br><span class="line"><span class="function"><span class="params">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>)</span></span>;</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">ApplicationContextInitializer.class));</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>追溯下去，最终会调用到SpringFactoriesLoader的loadSpringFactories方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryClassName, factoryName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在该方法中，会从所有的META-INF目录下加载spring.factories文件里配置的各类型的类名称（包括初始化器，监听器，自动配置类等）。然后上层方法中通过反射机制实例化这些初始化器、监听器，自动配置等，从而完成相应Bean的自动化配置与注入。</p><p><strong>spring-boot-autoconfigure</strong></p><p>官方提供的starter，如spring-boot-starter-web， 都依赖了spring-boot-starter， 而spring-boot-starter又依赖了spring-boot-autoconfigure。 在spring-boot-autoconfigure中提供了大量官方提供的自动配置类，并且包含META-INF/spring.factories文件，如下图</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/config1.png" alt="spring-boot-autoconfigure"></p><p><strong>spring.factories</strong></p><p>由上图可看出，spring.factories包含了   </p><ul><li>org.springframework.context.ApplicationContextInitializer  应用初始化器</li><li>org.springframework.context.ApplicationListener 应用监听器</li><li>org.springframework.boot.autoconfigure.AutoConfigurationImportListener 自动配置引入监听器</li><li>org.springframework.boot.autoconfigure.AutoConfigurationImportFilter 自动配置引入过滤器</li><li>org.springframework.boot.autoconfigure.EnableAutoConfiguration 自动配置类</li><li>org.springframework.boot.diagnostics.FailureAnalyzer 失败分析器</li><li>org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider 模板提供者   </li></ul><p>其中org.springframework.boot.autoconfigure.EnableAutoConfiguration即实现自动配置的@Configuration配置类列表。</p><p>Spring Boot就是通过这种自动配置机制，以starter依赖包的方式，使开发者非常方便地使用项目开发中的许多常用功能，如数据库访问、缓存、队列等。同时，用户也可以根据自身需求，自定义自己的starter（后面介绍）。   </p><h3 id="通过注解控制自动配置"><a href="#通过注解控制自动配置" class="headerlink" title="通过注解控制自动配置"></a>通过注解控制自动配置</h3><p>Spring Boot自动配置包含了许多条件类注解及顺序类注解，这些注解可方便地让自动配置按照某种条件或者顺序进行配置。</p><p>其中条件类注解包括：</p><ul><li>类级别条件注解 @ConditionalOnClass： 类路径中存在指定的类才进行该配置；@ConditionalOnMissingClass： 类路径中不存在指定的类才进行该配置 </li><li>实例级别条件注解 @ConditionalOnBean：只有在当前上下文中存在指定Bean时，才进行该配置<br>@ConditionalOnMissingBean： 只有在当前上下文不存在指定Bean时，才进行该配置</li><li>属性级别条件注解 @ConditionalOnProperty：当存在某个指定属性，且值为指定值时，才进行该配置</li><li>资源级别条件注解 @ConditionalOnResource：在类路径下存在指定的Resource时，才进行配置</li><li>Web应用条件注解 @ConditionalOnWebApplication：该应用为Web应用时进行该配置<br>@ConditionalOnNotWebApplication： 该应用不为Web应用时进行该配置</li><li>SpEL（ Spring Expression Language）表达式注解 @ConditionalOnExpression： 计算SpEL表达式值，值为true时才进行该配置</li></ul><p>顺序类注解包括：</p><ul><li>@AutoConfigureAfter： 在指定的配置类初始化后再加载</li><li>@AutoConfigureBefore： 在指定的配置类初始化前加载</li><li>@AutoConfigureOrder： 数值越小越先初始化   </li></ul><blockquote><p>注意：自动配置类不应该位于组件扫描路径（@ComponentScan注解指定的扫描路径）下，否则上述条件注解与顺序注解可能不会生效。建议只在自动配置的类上注解@ConditionalOnBean， @ConditionalOnMissingBean，因为这可以保证在用户定义bean已经添加到ApplicationContext之后才会加载。这两个注解放在class上，则相当于class里面每一个@Bean标注的方法都加上了。</p></blockquote><p>自动配置是非侵入式的，你可以在任何地方自定义配置来覆盖自动配置中的某些内容，比如你在应用中通过@Configuration类注入一个自定义的DataSource，默认的基于内存的DataSource将被覆盖</p><h3 id="禁用某个自动配置类"><a href="#禁用某个自动配置类" class="headerlink" title="禁用某个自动配置类"></a>禁用某个自动配置类</h3><p>有时候引入的自动配置可能包含我们不想让其生效的配置类，这时候可以通过@EnableAutoConfiguration注解的属性进行排除，使其不生效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span>(exclude = &#123;XXAutoConfiguration.class&#125;)</span><br></pre></td></tr></table></figure></p><p>其中XXAutoConfiguration为某个自动配置类，如果该类不在应用的类路径中，则可以通过属性excludeName指定完整类路径来排除。@SpringBootApplicationz注解同样支持<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = &#123;XXAutoConfiguration.class&#125;)</span><br></pre></td></tr></table></figure></p><p>本文示例项目源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-config" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-config</a><br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>——————————————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot之所以受开发者欢迎， 其中最重要的一个因素就是其配置简单。传统的Spring应用需要手动配置各种.xml文件，为数据库访问，事务支持，缓存功能等提供各项繁杂且重复的配置。Spring Boot将这种繁杂且重复的工作通过预定义的启动器（starter）来实现，只要引入即可拥有相应的功能支持，从而将开发者从复杂的配置工作中解放出来，能够更专注于业务逻辑的开发。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战：Spring Boot自定义属性</title>
    <link href="http://blog.jboost.cn/2019/06/10/springboot-properties.html"/>
    <id>http://blog.jboost.cn/2019/06/10/springboot-properties.html</id>
    <published>2019-06-10T10:47:51.000Z</published>
    <updated>2019-06-14T00:15:25.108Z</updated>
    
    <content type="html"><![CDATA[<p>Web项目开发中，经常需要自定义一些属性，如数据库连接，第三方服务接口地址，第三方服务的appKey、appSecret等，以及针对不同环境，这些属性的值还需要有相应的调整，如开发环境、测试环境、生产环境所用数据库不同，则针对不同环境的同一属性需要配置不同的值。<br><a id="more"></a></p><h3 id="传统自定义属性配置及访问（参考Github示例测试类）"><a href="#传统自定义属性配置及访问（参考Github示例测试类）" class="headerlink" title="传统自定义属性配置及访问（参考Github示例测试类）"></a>传统自定义属性配置及访问（参考<a href="https://github.com/ronwxy/springboot-demos/blob/master/springboot-properties/src/test/java/cn/jboost/springboot/properties/TraditionalPropertiesHandleTest.java" target="_blank" rel="noopener">Github示例测试类</a>）</h3><p>在传统的Spring Web应用中，自定义属性一般是通过在类路径中（如resources目录）添加一个类似my.properties配置文件（文件名自定义），然后在xml配置中通过</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"myProps"</span> <span class="attr">location</span>=<span class="string">"classpath:my.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>引入属性文件。再定义一个Bean来读取这些属性，Bean配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"staticMethod"</span> <span class="attr">value</span>=<span class="string">"cn.jboost.springboot.properties.MyPropertiesUtil.init"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arguments"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myProps"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bean定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPropertiesUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line">        properties = props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getValue</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在其它需要访问的地方通过 <code>MyPropertiesUtil.getValue()</code> 方法来访问具体某个属性的值。</p><h3 id="Spring-Boot自定义属性配置及优先级"><a href="#Spring-Boot自定义属性配置及优先级" class="headerlink" title="Spring Boot自定义属性配置及优先级"></a>Spring Boot自定义属性配置及优先级</h3><p>在Spring Boot中，可以在多个地方配置属性，包括.properties文件，.yaml文件，环境变量， 系统属性，命令行参数等， 这些属性都会被Spring Boot加载到Environment中，可通过@Value注解，Environment实例，或 @ConfigurationProperties注解的类来访问。</p><p>属性加载优先级顺序：</p><ol><li>如果有使用devtools，devtools 全局设置的属性（用户目录 ~/.spring-bootdevtools.properties）</li><li>测试类的注解@TestPropertySource</li><li>测试类注解 @SpringBootTest#properties 配置的属性</li><li><strong>命令行参数</strong></li><li>SPRING_APPLICATION_JSON里的属性（环境变量或系统属性）</li><li>ServletConfig初始化参数</li><li>ServletContext初始化参数</li><li>JNDI参数   java:comp/env</li><li><strong>Java系统属性  System.getProperties()</strong></li><li><strong>操作系统环境变量</strong></li><li>RandomValuePropertySource 配置的属性 random.*</li><li>jar包外部的applictaion-{profile}.properties，applictaion-{profile}.yml配置文件</li><li><strong>jar包内部的applictaion-{profile}.properties，applictaion-{profile}.yml配置文件</strong></li><li>jar包外部的applictaion.properties，applictaion.yml配置文件</li><li><strong>jar包内部的applictaion.properties，applictaion.yml配置文件</strong></li><li>@Configuration类上的 @PropertySource注解指定的配置文件</li><li>默认属性： SpringApplication.setDefaultProperties</li></ol><blockquote><p>上述属性配置，除了粗体标注的外，其它一般应用较少。序号低的配置优先级高于序号高的配置，即如果存在相同属性配置 ，则序号低的配置会覆盖序号高的配置。applictaion-{profile}.properties 一般用于具体某个环境特有的属性配置，如application-dev.properties用于开发环境，可通过 spring.profiles.active=dev指定加载dev环境配置</p></blockquote><p>常用属性配置方式</p><ol><li>命令行参数<br>启动Spring Boot应用时，可以指定命令行参数，如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot-properties.jar --my.name=jboost@command_line</span><br></pre></td></tr></table></figure></li></ol><p>该参数值将会覆盖应用在其它地方配置的同名属性值。命令行参数放在xx.jar 的后面。</p><blockquote><p>可以通过SpringApplication.setAddCommandLineProperties(false)  禁用命令行参数配置</p></blockquote><ol start="2"><li>Java系统属性<br>同样在启动Spring Boot应用时，可以指定Java系统属性，一般见于自定义jvm参数，如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dmy.name=jboost@system_properties -jar springboot-properties.jar</span><br></pre></td></tr></table></figure></li></ol><p>Java系统属性放在java命令之后。</p><ol start="3"><li><p>操作系统环境变量（实际应用其实较少）<br>配置过JAVA_HOME的应该理解何为环境变量。某些操作系统可能不支持.分隔的属性名，可以改为以下划线连接。Spring Boot将myName, my.name, MY_NAME视为等效。</p></li><li><p>应用属性配置文件（.properties文件或 .yml文件）<br>.properties文件属性配置格式：  </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my.name=jboost</span><br><span class="line">my.list[0]=aaa  //配置列表</span><br><span class="line">my.list[1]=bbb</span><br></pre></td></tr></table></figure><p>.yml文件属性配置格式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">devlink</span></span><br><span class="line"><span class="attr">  list:</span>   <span class="string">//配置列表</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">aaa</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">bbb</span></span><br></pre></td></tr></table></figure><p>yml中，属性名与值之间冒号后面必须有空格。</p><p>应用属性配置文件位置：</p><ol><li>jar包所在当前目录下的子目录/config（外置属性文件） </li><li>jar包所在当前目录（外置属性文件） </li><li>classpath根目录下的子目录/config（内置属性文件）</li><li>classpath根目录（内置属性文件）</li></ol><blockquote><p>序号低的优先级高于序号高的优先级，即jar包外的配置优先级高于jar包内的配置。同一目录下，.properties文件的优先级高于.yml文件。application-{profile}.properties的优先级高于application.properties。</p></blockquote><h3 id="Spring-Boot自定义属性访问方式（参考Github示例测试类）"><a href="#Spring-Boot自定义属性访问方式（参考Github示例测试类）" class="headerlink" title="Spring Boot自定义属性访问方式（参考Github示例测试类）"></a>Spring Boot自定义属性访问方式（参考<a href="https://github.com/ronwxy/springboot-demos/blob/master/springboot-properties/src/test/java/cn/jboost/springboot/properties/SpringbootPropertiesHandleTest.java" target="_blank" rel="noopener">Github示例测试类</a>）</h3><ol><li>类中属性上添加 @Value(“${xx}”) 注解方式。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;my.name&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ol><p>可以指定默认值，如 @Value(“${my.name:jboost}”)， 当my.name未配置时，默认使用值”jboost”</p><ol start="2"><li>通过@ConfigurationProperties注解的类来访问。如定义：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"my"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了getter、setter函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>然后在需要访问的Bean中，通过@Autowired 注入MyConfigProperties实例，通过getName()方法即可访问my.name属性值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyConfigProperties myConfigProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConfigurationProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test @ConfigurationProperties =========="</span>);</span><br><span class="line">    System.out.println(myConfigProperties.getName());</span><br><span class="line">    System.out.println(myConfigProperties.getWebsite());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>通过Environment 实例访问。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEnvironment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test Environment =========="</span>);</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">"my.name"</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">"my.website"</span>, <span class="string">"default value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>另外也可以通过 spring-boot-starter-actuator 的接口来查看项目加载的属性配置，在pom.xml中加入 spring-boot-starter-actuator 依赖，因为 spring-boot-starter-actuator 在2.x版本中，出于安全性考虑，将actuator 控件中的端口，只默认开放/health 和/info 两个端口，其他端口默认关闭，因此需要添加配置management.endpoints.web.exposure.include= *，<br>management.endpoints.web.exposure.exclude=beans,trace，<br>management.endpoint.health.show-details=ALWAYS，启动项目后，访问 <a href="http://localhost:8080/actuator/env" target="_blank" rel="noopener">http://localhost:8080/actuator/env</a> ，返回的 propertySources 即为加载的所有属性源，优先级从上往下依次降低，与上文所述优先级相符</p></blockquote><p>本文示例项目源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-properties" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-properties</a></p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web项目开发中，经常需要自定义一些属性，如数据库连接，第三方服务接口地址，第三方服务的appKey、appSecret等，以及针对不同环境，这些属性的值还需要有相应的调整，如开发环境、测试环境、生产环境所用数据库不同，则针对不同环境的同一属性需要配置不同的值。&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战：第一个Spring Boot应用</title>
    <link href="http://blog.jboost.cn/2019/06/06/springboot-firstapp.html"/>
    <id>http://blog.jboost.cn/2019/06/06/springboot-firstapp.html</id>
    <published>2019-06-06T12:46:50.000Z</published>
    <updated>2019-06-14T00:15:46.644Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot应用可以通过如下三种方法创建：</p><ol><li>通过 <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 网站创建</li><li>通过 <code>Spring Initializr</code> 创建</li><li>自主创建<a id="more"></a></li></ol><h3 id="推荐开发工具"><a href="#推荐开发工具" class="headerlink" title="推荐开发工具"></a>推荐开发工具</h3><ul><li>JDK 1.8+</li><li>IntelliJ IDEA</li><li>maven 3.3+</li></ul><p>在开始之前，先确认是否安装上述工具，在命令行输入 <code>java -version</code> 查看JDK是否正确安装， 输入 <code>mvn -version</code> 查看maven是否正确安装，如果未正确安装，请先查阅相关文档完成安装。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS D:\&gt; java -version</span><br><span class="line">java version "1.8.0_201"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br><span class="line">PS D:\&gt;</span><br><span class="line">PS D:\&gt;</span><br><span class="line">PS D:\&gt; mvn -version</span><br><span class="line">Apache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)</span><br><span class="line">Maven home: D:\tool\apache-maven-3.6.0\bin\..</span><br><span class="line">Java version: 1.8.0_201, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk1.8.0_201\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: "windows 10", version: "10.0", arch: "amd64", family: "windows"</span><br><span class="line">PS D:\&gt;</span><br></pre></td></tr></table></figure></p><h3 id="1-通过-https-start-spring-io-网站创建"><a href="#1-通过-https-start-spring-io-网站创建" class="headerlink" title="1. 通过 https://start.spring.io/ 网站创建"></a>1. 通过 <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 网站创建</h3><p>进入 <a href="https://start.spring.io/，填写对应的信息，如下图所示" target="_blank" rel="noopener">https://start.spring.io/，填写对应的信息，如下图所示</a><br><img src="http://pso1tuwfq.bkt.clouddn.com/firstapp1.png" alt="项目配置"><br>其中project选 <code>Maven Project</code>， Spring Boot版本选 <code>2.1.5</code> 版， Project Metadata部分， Group一般用你域名的倒序字符串，Artifact即项目名称，选择Packaging类型为Jar，Java版本为8，在Dependencies部分输入Web，选中第一个Spring Web Starter，然后点击“Generate the project”按钮，下载生成的项目。解压项目，在IntelliJ IDEA中 <code>File -&gt; Open</code> 选中项目解压目录打开，即可看到生成的项目结构如下图<br><img src="http://pso1tuwfq.bkt.clouddn.com/firstapp2.png" alt="项目结构"><br>具体各文件含义后面详述。</p><h3 id="2-通过Spring-Initializr创建（推荐）"><a href="#2-通过Spring-Initializr创建（推荐）" class="headerlink" title="2. 通过Spring Initializr创建（推荐）"></a>2. 通过Spring Initializr创建（推荐）</h3><p>IntelliJ IDEA中<code>File -&gt; New -&gt; Project...</code>打开新建项目窗口（这里也可以选择New Module, IDEA的Project类似于Eclipse的Workspace，Module则类似于Eclipse的Project，有时候为了将一些项目统一管理，可以建一个Project，然后在Project内部建立Module），如下图所示<br><img src="http://pso1tuwfq.bkt.clouddn.com/firstapp3.png" alt="新建项目"></p><p>选择<code>Spring Initializr</code>，点击<code>Next</code>，填写相应信息， 如下图所示<br><img src="http://pso1tuwfq.bkt.clouddn.com/firstapp4.png" alt="项目配置"></p><p>点击<code>Next</code>，选择Spring Boot版本以及相应依赖，如下图（这里选择2.1.5版本及Spring Web Starter依赖）<br><img src="http://pso1tuwfq.bkt.clouddn.com/firstapp5.png" alt="项目配置"></p><p>然后依次点击Next, Finish完成项目创建。可以看到创建的项目结构与第一种方法一致。</p><blockquote><p>有的旧IDEA版本下项目可能不能编译，IDE未将其识别为maven项目，只需在pom.xml文件上右键，点击<code>Add as Maven project</code>即可。</p></blockquote><h3 id="3-自主创建"><a href="#3-自主创建" class="headerlink" title="3. 自主创建"></a>3. 自主创建</h3><p>自主创建即像普通Java Maven项目一样，先创建maven项目，然后参考1、2方法中创建的项目结构与目录，手动进行添加。</p><blockquote><p>上述三种创建方法，第1种需要网站生成再下载解压导入，第2种直接基于IDE创建，第3种完全自主手动创建。实际开发中推荐采用第2种创建初始项目原型，再根据具体需求删除或添加相应目录与文件。</p></blockquote><h3 id="4-项目结构"><a href="#4-项目结构" class="headerlink" title="4. 项目结构"></a>4. 项目结构</h3><p>通过上述方法创建的项目，结构如下图所示</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/firstapp6.png" alt="项目结构"></p><p>其中</p><ul><li>SpringbootFirstappApplication 为项目入口类，通过SpringApplication.run()方法来启动项目</li><li>入口类上的注解 @SpringBootApplication 表明，这是一个Spring Boot项目，它会为你自动做一些Spring Boot项目的处理</li><li>resources 下的static目录为静态资源目录，可以放置js，css，img之类的资源，templates目录可放置模板文件，一般做前后端分离开发，这两个目录可删除</li><li>application.properties 文件为项目的配置文件，可在该文件中配置项目所需要的各项配置属性</li><li>SpringbootFirstappApplicationTests 生成的测试类，可基于此进行单元测试编写</li><li>pom.xml即为maven配置文档，可看到项目已继承<code>spring-boot-starter-parent</code>，并且引入了<code>spring-boot-starter-web</code>，<code>spring-boot-starter-test</code>两项依赖，以及<code>spring-boot-maven-plugin</code></li></ul><h3 id="5-运行"><a href="#5-运行" class="headerlink" title="5. 运行　"></a>5. 运行　</h3><p>上述创建的项目可直接运行，大致有如下几种运行方式：</p><ol><li>直接在项目入口类SpringbootFirstappApplication中右键，点击<code>Run &#39;SpringbootFirstappAp...&#39;</code>运行</li><li>在项目根目录下打开终端，或IDEA的Terminal中执行<code>mvn spring-boot:run</code>（前提是项目pom.xml文件中引入了spring-boot-maven-plugin）</li><li>使用<code>mvn package</code>打包，然后通过<code>java -jar target\springboot-firstapp-1.0.0-SNAPSHOT.jar</code> 启动（一般用于远程环境的部署启动）</li><li>如果打包成war，将war包部署到tomcat等Servlet容器运行</li></ol><p>项目启动后，从启动日志可看出默认端口为8080，但打开 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 会显示一个404报错页面，这是因为我们还没有编写任何服务。<br>下面我们添加一个非常简单的Rest服务接口，在项目的根包下（我这里是cn.jboost.springboot.firstapp，实际项目中一般会创建一个controller的子包）添加HelloController类，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>)</span>String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"您好，"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>@RestController</code>注解会将返回结果以字符串的方式解析，<code>@GetMapping</code>等效于<code>@RequestMapping(method = {RequestMethod.GET})</code><br>重启应用，然后浏览器地址栏中输入 <a href="http://localhost:8080/hello?name=jboost，" target="_blank" rel="noopener">http://localhost:8080/hello?name=jboost，</a> 页面输出如下图：</p><p><div align="center"><img src="http://pso1tuwfq.bkt.clouddn.com/firstapp7.png" alt="接口调用"><br></div><br>至此，一个可运行的Web项目即已搭建完成，是不是非常简单。   </p><p>本文示例项目源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-firstapp" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-firstapp</a><br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot应用可以通过如下三种方法创建：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 &lt;a href=&quot;https://start.spring.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://start.spring.io/&lt;/a&gt; 网站创建&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Spring Initializr&lt;/code&gt; 创建&lt;/li&gt;
&lt;li&gt;自主创建
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战：Spring Boot简介</title>
    <link href="http://blog.jboost.cn/2019/06/06/springboot-overview.html"/>
    <id>http://blog.jboost.cn/2019/06/06/springboot-overview.html</id>
    <published>2019-06-06T06:29:02.000Z</published>
    <updated>2019-06-14T00:15:38.150Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot这几年非常流行，差不多是基于Spring框架应用开发的首选，同时在微服务架构领域，如Spring Cloud 框架中，Spring Boot也是基础，因此掌握Spring Boot，应成为Java开发人员必不可少的技能。<br><a id="more"></a></p><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>传统的基于Spring的Java Web应用，需要配置 <code>web.xml</code>, <code>applicationContext.xml</code> 等大量xml配置信息，然后将应用打成war包放入web应用服务器(如Tomcat, Jetty等)中运行。有过实践经验的开发者应能体会到这个过程繁杂且重复。Spring Boot将这种繁杂且重复的工作通过<strong>自动化配置</strong>等手段实现，从而将开发者从复杂的配置工作中解放出来，能够更专注于业务逻辑的开发。因此，Spring Boot并不是Spring的替代解决方案，它本身并不提供Spring框架的核心特性以及扩展功能，而是和Spring框架紧密结合用于提升Spring开发者体验，提高开发效率的的工具框架。截至本文，Spring Boot最新GA版本为2.1.5。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Spring Boot框架大致包括如下特性：</p><ul><li>自动化配置。Spring Boot 通过autoconfiguration的方式（后面会详细讨论何为autoconfiguration）来简化配置管理。比如如果需要访问数据库，则只需要引入相应的starter依赖包，Spring Boot便会自动为你配置访问数据库所需要的Bean，如 DataSource， JdbcTemplate等。使用Spring Boot，项目中几乎不需要任何 xml 配置文件。</li><li>内嵌的Web服务容器。Spring Boot内嵌了Tomcat、Jetty、Undertow。因此，Spring Boot应用可以像普通java应用一样打成jar包直接通过 <code>java -jar</code> 执行，而不需传统web应用一样需要打成war包部署到独立的web服务容器中。</li><li>简化依赖管理。Spring Boot官方提供了大量的starter依赖包，帮你管理了使用某个功能所需要的依赖，开发者只需要引入starter依赖，即可使用对应的功能。如spring-boot-starter-web，spring-boot-starter-jdbc等。同时自己也可以自定义starter，为某些通用功能提供模块化共享支持。</li><li>提供生产环境级的应用配置、度量指标、操作控制接口。Spring Boot的spring-boot-starter-actuator提供了查看应用配置信息，获取应用运行指标，以及控制应用（如关闭应用）三种类型的接口。通过这些接口，可以排查问题，监控服务运行情况等。   </li></ul><p>Spring Boot的这些特性，使得应用Spring Boot开发Web应用非常便捷、高效，因此在快速应用开发（Rapid Application Development）领域以及微服务架构方面，Spring Boot都是比较好的选择。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>该序列涉及的开发工具包括但不限于：</p><ul><li>JDK 1.8+ , 一般用的是1.8</li><li>Maven 3.3+ , 我们用的是Maven3.6.0</li><li>IntelliJ IDEA Ultimate Edition， 需要激活，<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">参考这里</a></li><li>MySQL，可选，数据库访问示例需要 </li><li>Redis， 可选，缓存示例需要</li></ul><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————————————————————</p><p><img src="http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot这几年非常流行，差不多是基于Spring框架应用开发的首选，同时在微服务架构领域，如Spring Cloud 框架中，Spring Boot也是基础，因此掌握Spring Boot，应成为Java开发人员必不可少的技能。&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://blog.jboost.cn/2019/06/05/ahead.html"/>
    <id>http://blog.jboost.cn/2019/06/05/ahead.html</id>
    <published>2019-06-05T08:48:37.000Z</published>
    <updated>2019-06-10T07:36:24.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一点感悟"><a href="#一点感悟" class="headerlink" title="一点感悟"></a>一点感悟</h3><p>在软件与互联网技术领域从业多年，从一个一知半解的职场菜鸟成长为行业“老司机”，也从一个邯郸学步的技术新手晋升成为能带领团队披荆斩棘，在技术范畴能掌握话语权的技术管理者。其间也与大多数同行一样，踩过不少坑，加过不少班，背过不少锅……，但同时，也为自己不断成长、进步——包括技术、能力层面，也包括薪酬、职位层面，而感到欣慰。但技术领域日新月异，接触的越多，越发现自己的无知，因此 <code>Stay hungry，Stay foolish</code>，保持持续学习的热情，永远不要满足于现状，才能保持自身竞争力，不至于在年龄增长时，出现所谓的“中年危机”。</p><h3 id="一点初衷"><a href="#一点初衷" class="headerlink" title="一点初衷"></a>一点初衷</h3><p>大学期间也曾玩过新浪博客，写过一些心路历程与人生感悟（^_^），随着年龄的增长，逐渐失去了用文字来抒发情感的激情。工作后，开始接触技术博客，也断断续续写过一些分享，但终因阶段性忙或懒惰，没能坚持下来。与之前抒发情感与感悟不同，技术博客更多的是一种经验的自我梳理总结与分享。一方面为那些踏入职场不久实践经验较缺乏的同行提供参考，另一方面也是对自我日常技术工作的整理，以达到“好记性不如烂笔头”的效果。<br>因此，虽然现今从事一线编码工作相对较少，心中一直还是有一个将以往及现在所接触的实践经验记录与分享出来的想法。于是，花了点时间整了这个博客，希望能坚持下去。</p><h3 id="一点期望"><a href="#一点期望" class="headerlink" title="一点期望"></a>一点期望</h3><p>凡事做了，总希望有所回报。整理文章其实需要花费不少时间与精力，因此也希望发出来的分享能为大家带来切实的收获，获得大家的肯定与良性反馈。有更好建议，也欢迎大家通过留言或其它方式与我交流。希望这是一个好的开始，加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一点感悟&quot;&gt;&lt;a href=&quot;#一点感悟&quot; class=&quot;headerlink&quot; title=&quot;一点感悟&quot;&gt;&lt;/a&gt;一点感悟&lt;/h3&gt;&lt;p&gt;在软件与互联网技术领域从业多年，从一个一知半解的职场菜鸟成长为行业“老司机”，也从一个邯郸学步的技术新手晋升成为能带领团队披
      
    
    </summary>
    
    
  </entry>
  
</feed>
