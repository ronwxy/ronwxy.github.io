<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半路雨歌</title>
  
  <subtitle>Sing In The Storm</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jboost.cn/"/>
  <updated>2020-11-05T07:26:32.742Z</updated>
  <id>http://blog.jboost.cn/</id>
  
  <author>
    <name>雨歌</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>像程序员一样思考——提高解决问题的能力</title>
    <link href="http://blog.jboost.cn/think-like-a-programmer.html"/>
    <id>http://blog.jboost.cn/think-like-a-programmer.html</id>
    <published>2020-11-04T08:54:41.000Z</published>
    <updated>2020-11-05T07:26:32.742Z</updated>
    
    <content type="html"><![CDATA[<p>在以前的文章中，曾经提过“技术人员的价值，不在于你能写出多么优美的代码，也不在于你能设计出一个多么大而全的高屋建瓴的架构，而在于你实实在在的解决问题的能力，在于你使用技术手段服务于业务的能力”。</p><p>最近一段时间，因工作中遇到一些现象，让我重又想起这句话，并且试图思考如何来提高解决问题的能力，有没有一种方法论的手段或者技术性的框架来实践？</p><a id="more"></a><p>先罗列一两个遇到的现象：</p><ol><li><p>某同事汇报，测试提了一个Bug，当某个用户绑定的卡信息超过50个的时候，后台显示数据就会出现混乱，问能不能限制绑定的卡不超过50个。我问：数据显示出现混乱是什么意思？答：不清楚；我再问：为什么超过50个就会混乱了，少于50个有没有可能出现混乱，造成混乱的原因是什么？答：不知道。我说你先去搞清楚什么叫“混乱”，然后再搞清楚为什么会出现“混乱”再来说解决办法。经过与测试人员的一番沟通后，跟我反馈说不是显示混乱，是显示不全，自己通过查看实现是因为在服务端做了字符串拼接，超过多少就被截断了。</p></li><li><p>某同事在抱怨，这个问题很难复现，我不知道怎么解决，要不要把这块整体优化下算了。我问他你优化的目的是什么，是优化目前实现的流程、结构？还是通过优化来解决这个难以复现的问题？答：来解决这个问题。我说你问题都没定位到，怎么通过优化来解决，不怕老问题没解决，优化出新的问题出来了？</p></li></ol><p>你有没有也曾经说过或听过“这个问题太复杂了， 我解决不了”，“这个功能我没办法实现”，“我也不知道为什么会出现这个问题”之类的话语。</p><p>以上的现象与话语，可能都是一个人解决问题的能力或方式方法还不成熟的体现。那么如何来提高解决问题的能力，我想首先需要先从思维方式或思维习惯上寻求改变。在网上看到有这么一篇文章——《How to think like a programmer — lessons in problem solving》（文章地址见文末参考部分），介绍了通过5个步骤来帮忙人们建立高效解决问题的思维框架。本文以这5个步骤为基础，结合自身的理解与体会进行介绍。</p><p><img src="/assets/Jobs.png" alt="Jobs"></p><p>“这个国家的每个人都应该学计算机编程，因为它会教你如何思考” </p><h2 id="像程序员一样思考"><a href="#像程序员一样思考" class="headerlink" title="像程序员一样思考"></a>像程序员一样思考</h2><p>像程序员一样思考，到底意味着什么，需要如何来做？</p><p>像程序员一样思考本质上来说，是一种更为有效的解决问题的方法。</p><h2 id="解决问题的能力是一项元技能"><a href="#解决问题的能力是一项元技能" class="headerlink" title="解决问题的能力是一项元技能"></a>解决问题的能力是一项元技能</h2><p>什么叫元技能？<br>类比于元数据——描述数据的数据叫元数据，我理解元技能就是提升技能的技能，就是说当你掌握了解决问题的能力，你就可以通过这种能力去提升其它各项专业技能。</p><p>解决问题的能力也是最重要的能力，比精通编程语言，调试能力，以及系统设计能力都更为重要。</p><h2 id="提高解决问题能力的方法"><a href="#提高解决问题能力的方法" class="headerlink" title="提高解决问题能力的方法"></a>提高解决问题能力的方法</h2><p>我们平时解决问题的方式可能是：</p><ol><li>尝试一种解决方案。</li><li>如果这种解决方案无效，再尝试另一种方案。</li><li>如果还是没有用，重复第二步直到你碰巧把问题解决了。</li></ol><p>这种方法被作者 Richard Reis 定义为解决问题最糟糕的方式。因为它不但浪费时间，而且能不能达到目的还得看运气。</p><p>经过对优秀程序员在编程时的思维框架的分析，作者总结出提高解决问题能力的最好方法包括：</p><ol><li>有一个处理问题的框架</li><li>按照这个框架反复练习</li></ol><p>那么，当你遇到一个新的问题时，该如何来解决？</p><h3 id="第一步：理解"><a href="#第一步：理解" class="headerlink" title="第一步：理解"></a>第一步：理解</h3><p>遇到问题时，我们应该先要弄明白问题本身。大部分情况下，问题之所以难解决只是因为你没真正理解它们（很多时候是出于沟通的不充分），理解问题是解决问题的第一步。</p><p>如何确定自己是否真正理解一个问题？</p><p>最有效的方法是，尝试用自己的语言来说出它，看有没有逻辑漏洞。当你能讲清楚一个问题时，说明你理解了它。优秀的程序员编程时，一般都会写下自己遇到的问题，画出流程或序列草图，或同产品经理、其它开发人员、测试人员等一起讨论确认。这个过程，就是在确定自己对问题的理解有没有偏差。</p><p>“如果你不能用简单的语言来解释一个事情，那意味着你根本就没有理解它” —— Richard Feynman</p><p>面对一个新需求时，你应该了解这个需求产生的场景——什么人，在什么时候通过执行什么操作，来达到什么目的？这个场景及其中的行为逻辑是否合理，设计是否存在漏洞，然后带着问题来与需求提出方讨论确认，而不是断章取义或不经任何思考直接编码开干。不做代码的搬运工，要做有思想的程序员。</p><p>同样，面对一个 Bug 时，你应该首先了解这个 Bug 产生的场景——什么人，在什么场景，通过什么操作会产生这个问题？要追本溯源，定位问题的本源在哪里。<br>我认为定位问题的本源比解决问题更重要！因为你只有正确地找到了问题的症结，才有可能去解决它，而解决办法却可能有多种。且从花费的时间来说，定位问题往往会占整个解决问题时间的一半以上。</p><p>如果没有找到问题的本源，只是头痛医头脚痛医脚，那么可能不仅对解决问题无事无补，甚至还可能引进新的问题。常见的头痛医头脚痛医脚的处理方式包括，CPU占用高了，内存溢出了——升级服务器配置（可能过两天又得升级了！）；接口超时了——增大超时时间（可能导致用户投诉或其它依赖的服务级联超时），等等。</p><p>那么日常工作中，如何来定位问题的根源？对于一般问题来说，可能通过查看日志大致就能找到问题所在，对于比较棘手的问题，针对问题的性质一般可通过如下方法进行定位：</p><ul><li>对于易复现的问题： 常用的就是 Debug，通过 IDE 断点来跟踪数据的流转与变更，一个个环节检查数据输入输出是否正确来进行排查。可借助条件断点、异常断点等技巧来提高 Debug 效率。</li><li>对于不易复现的问题：可通过对比法——对比其它地方的类似功能或实现，寻找两者之间的差异，差异之处往往就是问题所在；分析法——走读整体流程代码，捋清各个环节的逻辑，分析定位问题；日志法——在各个关键环节添加日志，将场景镜像下来，当下次复现的时候，通过分析日志定位问题。</li></ul><h3 id="第二步：计划"><a href="#第二步：计划" class="headerlink" title="第二步：计划"></a>第二步：计划</h3><p>理解了问题，接下来就是解决问题的方案。没有明确的方案计划时，不要轻易去着手解决问题，不要寄希望于碰运气蒙混过关。许多开发人员习惯于快速扫一眼需求，就打开 IDE 开始垒代码，垒完发现要么与需求不符，要么漏洞百出。</p><p><img src="/assets/nobug.png" alt="nobug"></p><p>制定计划，就是制定解决问题的战略步骤。</p><p>不论面对需求还是 Bug，都应该好好计划你的解决方案。设计好解决方案中的各个环节，如业务需求的数据表设计、接口设计、流程逻辑，Bug 修复的具体实施步骤。并给自己一点时间思考与预演，该解决方案可能存在的漏洞与影响有哪些，除了这样处理，还有没有另外更好的解决方案。</p><p>在没有想清楚解决方案时，不要直接上来就撸代码，暂停一下，给你的大脑一些分析问题和处理信息的时间。</p><h3 id="第三步：分解"><a href="#第三步：分解" class="headerlink" title="第三步：分解"></a>第三步：分解</h3><p>这是思维框架中最重要的一步。</p><p>分解，就是化繁为简，就是我们常说的分治思想，拆分法——将大问题拆分为若干个小问题，然后逐个击破各个小问题，再合并总结。微服务架构，MapReduce 算法，都是这一思维（或思想）的体现。</p><p>不要尝试一次解决一个复杂的大问题，而应把复杂的大问题分解成若干个简单的小问题（或子问题），从最简单的子问题开始（最简单意味着你知道怎么解决它或它更容易被解决，也或者这个子问题的解决不需要依赖于其它子问题），一个一个逐步解决。一旦你解决了所有的子问题，把它们串联起来，一般就意味着你解决了之前的那个复杂的大问题。</p><p>分解问题的能力是解决问题的基石。这也是优秀的程序员在编程中最常用到的技能，对于他们来说，分解问题的能力，要比编程语言的熟练度、系统设计等技术更为重要。</p><h3 id="第四步：卡壳了怎么办？"><a href="#第四步：卡壳了怎么办？" class="headerlink" title="第四步：卡壳了怎么办？"></a>第四步：卡壳了怎么办？</h3><p>当你理解了问题，做出了解决方案的计划，将复杂问题分解为子问题后，在处理子问题时依然卡壳了怎么办？</p><p>首先，淡定！然后告诉自己，这很正常，每个人都会遇到。</p><p>优秀程序员或解决问题的高手，与普通人之间的差别就在于，他们对问题更有求知欲，更有耐心，他们的注意力更多地是在如何解决问题上，而不是为此恼火或甩锅发牢骚。</p><p>当遇到卡壳的情况时，可以试试这几种方法：</p><ol><li><p>Debug：与前面定位问题一样，一步一步调试，直到找出究竟哪里出错了。<br>“Debug 的艺术关键在于你究竟让软件干了些啥，而不是你以为你让软件干了些啥。”—— Andrew Singer</p></li><li><p>重新评估问题：退回去，从另一个角度重新审视问题，别让自己迷失在细节里，有时候我们容易迷失在具体的细节中而忽略了更一般的原则。重新评估问题的另一种途径是推倒重来，可以删除（回滚）所有已做的事，重新开始，有时这是非常行之有效的方式。</p></li><li><p>搜索解决方案：利用搜索引擎找到类似问题的解决办法，向他们学习。使用搜索引擎需要学会提炼关键字，关键字越有代表性，越容易找到答案。对搜索结果应该抱着参考的态度，而不是照搬，要明白为什么如此这般处理就能解决问题，并在解决问题后能依次延伸了解其上下游或相关知识，比如SQL查询慢，发现是索引未生效，则可以延伸了解都有哪些场景会导致索引失效；比如并发问题，则可以依此了解如何保证线程安全，同步机制，锁机制等相关知识。事实上，即使问题已经解决，你也可以经常这么做，因为这样你可以从其他人的解决方案中及上下游知识中学到更多。</p></li><li><p>寻求支援：当通过以上方法都无法获得解决办法时，向你的同事、上级或朋友求援，如果是开源项目，到开源社区、技术群，或 github 的 issue 列表中发帖求援。</p></li><li><p>记录问题与解决方案：将你本次遇到的问题与最终的解决方案用（电子）笔记本记录下来，便于后面回顾或参考。</p></li></ol><h3 id="第五步：练习"><a href="#第五步：练习" class="headerlink" title="第五步：练习"></a>第五步：练习</h3><p>罗马不是一天建成的，你也不可能期盼通过解决一两个问题就能成为解决问题的高手。但是，如果你能以学习的态度来寻求问题的解决办法，通过以上四个步骤来建立一套解决问题的思维框架，每一个问题的处理都是提高你能力的机会。那么距离成为一个解决问题的高手，就只差一步了，那就是：练习，练习，再练习。在问题中练习，训练你的思维方式与习惯。</p><p><img src="/assets/lixiaolong.png" alt="lixiaolong"><br>“我不害怕一次练习1000个踢打动作的人，但我害怕将一个踢打动作练习1000次的人”</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，解决问题的能力，不论在IT技术领域，还是在其它各个领域，都是一种最基本的技能。当你在说出“这个问题我解决不了”，“这个问题我没办法定位”前，试试本文介绍的理解、计划、分解、卡壳时怎么处理的建议方法，多一些耐心，一步步实践，说不定慢慢就看到曙光了。按照这个处理模式或习惯，在日积月累的问题处理中，你可能已在不知不觉成为了解决问题的高手。</p><p>参考： </p><ol><li><a href="https://www.freecodecamp.org/news/how-to-think-like-a-programmer-lessons-in-problem-solving-d1d8bf1de7d2/" target="_blank" rel="noopener">https://www.freecodecamp.org/news/how-to-think-like-a-programmer-lessons-in-problem-solving-d1d8bf1de7d2/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在以前的文章中，曾经提过“技术人员的价值，不在于你能写出多么优美的代码，也不在于你能设计出一个多么大而全的高屋建瓴的架构，而在于你实实在在的解决问题的能力，在于你使用技术手段服务于业务的能力”。&lt;/p&gt;
&lt;p&gt;最近一段时间，因工作中遇到一些现象，让我重又想起这句话，并且试图思考如何来提高解决问题的能力，有没有一种方法论的手段或者技术性的框架来实践？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Career" scheme="http://blog.jboost.cn/categories/Career/"/>
    
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（八）：K8s中的日志采集实践——使用log-pilot（适配ELK7.x）</title>
    <link href="http://blog.jboost.cn/k8s8-logpilot-2.html"/>
    <id>http://blog.jboost.cn/k8s8-logpilot-2.html</id>
    <published>2020-09-26T02:26:20.000Z</published>
    <updated>2020-09-26T02:42:48.251Z</updated>
    
    <content type="html"><![CDATA[<p>前文<a href="/k8s7-logpilot-1.html">Kubernetes笔记（七）：K8s中的日志采集实践——log-pilot介绍</a>我们对 k8s 集群中常用日志采集模式及阿里开源的 log-pilot 进行了介绍，本文介绍如何使 log-pilot 适配 ELK 7.x 及如何将 log-pilot 部署到 k8s 集群中进行日志采集。</p><a id="more"></a><h2 id="1-下载-log-pilot-源码"><a href="#1-下载-log-pilot-源码" class="headerlink" title="1. 下载 log-pilot 源码"></a>1. 下载 log-pilot 源码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AliyunContainerService/log-pilot</span><br></pre></td></tr></table></figure><p>如果直接使用作者已经调整过的基于 filebeat 7.3.1 的版本或直接使用作者已经构建好的 Docker 镜像，可直接跳到第4步。</p><h2 id="2-升级-filebeat-版本"><a href="#2-升级-filebeat-版本" class="headerlink" title="2. 升级 filebeat 版本"></a>2. 升级 filebeat 版本</h2><p>修改 Dockerfile.filebeat 文件，将</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> FILEBEAT_VERSION=<span class="number">6.1</span>.<span class="number">1</span>-<span class="number">3</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> assets/glibc/glibc-2.26-r0.apk /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; \ </span></span><br><span class="line">    apk <span class="keyword">add</span><span class="bash"> python &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add wget &amp;&amp; \</span></span><br><span class="line"><span class="bash">    update-ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    wget http://acs-logging.oss-cn-hangzhou.aliyuncs.com/beats/filebeat/filebeat-<span class="variable">$&#123;FILEBEAT_VERSION&#125;</span>-linux-x86_64.tar.gz -P /tmp/ &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mkdir -p /etc/filebeat /var/lib/filebeat /var/<span class="built_in">log</span>/filebeat &amp;&amp; \</span></span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> FILEBEAT_VERSION=<span class="number">7.3</span>.<span class="number">1</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> assets/glibc/glibc-2.26-r0.apk /tmp/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> filebeat-<span class="variable">$&#123;FILEBEAT_VERSION&#125;</span>-linux-x86_64.tar.gz /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; \ </span></span><br><span class="line">    apk <span class="keyword">add</span><span class="bash"> python &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add wget &amp;&amp; \</span></span><br><span class="line"><span class="bash">    update-ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mkdir -p /etc/filebeat /var/lib/filebeat /var/<span class="built_in">log</span>/filebeat &amp;&amp; \</span></span><br></pre></td></tr></table></figure><p>这里先将 filebeat 包下载下来放到 log-pilot 目录下，避免打镜像时下载太慢。</p><h2 id="3-更新-filebeat-配置"><a href="#3-更新-filebeat-配置" class="headerlink" title="3. 更新 filebeat 配置"></a>3. 更新 filebeat 配置</h2><p>修改 assets/filebeat/config.filebeat 文件，</p><p>移除 <code>filebeat.registry_file: /var/lib/filebeat/registry</code><br>将 <code>filebeat.config.prospectors:</code> 改为 <code>filebeat.config.inputs:</code></p><p>调整后，配置文件为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">base() &#123;</span><br><span class="line">cat &gt;&gt; $FILEBEAT_CONFIG &lt;&lt; EOF</span><br><span class="line">path.config: &#x2F;etc&#x2F;filebeat</span><br><span class="line">path.logs: &#x2F;var&#x2F;log&#x2F;filebeat</span><br><span class="line">path.data: &#x2F;var&#x2F;lib&#x2F;filebeat&#x2F;data</span><br><span class="line">filebeat.shutdown_timeout: $&#123;FILEBEAT_SHUTDOWN_TIMEOUT:-0&#125;</span><br><span class="line">logging.level: $&#123;FILEBEAT_LOG_LEVEL:-info&#125;</span><br><span class="line">logging.metrics.enabled: $&#123;FILEBEAT_METRICS_ENABLED:-false&#125;</span><br><span class="line">logging.files.rotateeverybytes: $&#123;FILEBEAT_LOG_MAX_SIZE:-104857600&#125;</span><br><span class="line">logging.files.keepfiles: $&#123;FILEBEAT_LOG_MAX_FILE:-10&#125;</span><br><span class="line">logging.files.permissions: $&#123;FILEBEAT_LOG_PERMISSION:-0600&#125;</span><br><span class="line">$&#123;FILEBEAT_MAX_PROCS:+max_procs: $&#123;FILEBEAT_MAX_PROCS&#125;&#125;</span><br><span class="line">setup.template.name: &quot;$&#123;FILEBEAT_INDEX:-filebeat&#125;&quot;</span><br><span class="line">setup.template.pattern: &quot;$&#123;FILEBEAT_INDEX:-filebeat&#125;-*&quot;</span><br><span class="line">filebeat.config.inputs:</span><br><span class="line">        enabled: true</span><br><span class="line">        path: \$&#123;path.config&#125;&#x2F;prospectors.d&#x2F;*.yml</span><br><span class="line">        reload.enabled: true</span><br><span class="line">        reload.period: 10s</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-获取-Docker-镜像"><a href="#4-获取-Docker-镜像" class="headerlink" title="4. 获取 Docker 镜像"></a>4. 获取 Docker 镜像</h2><p>1.如果是自己修改官方源码，则执行 <code>./build-image.sh</code></p><p>2.如果是下载作者源码，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ronwxy/<span class="built_in">log</span>-pilot.git</span></span><br><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> <span class="built_in">cd</span> <span class="built_in">log</span>-pilot/ </span></span><br><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> git checkout filebeat-7.3.1</span></span><br><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> ./build-image.sh</span></span><br></pre></td></tr></table></figure><p>3.直接下载作者已经构建好的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> docker pull registry.cn-hangzhou.aliyuncs.com/jboost/<span class="built_in">log</span>-pilot:filebeat-7.3.1</span></span><br></pre></td></tr></table></figure><h2 id="5-在-k8s-中部署-log-pilot"><a href="#5-在-k8s-中部署-log-pilot" class="headerlink" title="5. 在 k8s 中部署 log-pilot"></a>5. 在 k8s 中部署 log-pilot</h2><p>我们以 DaemonSet 的方式（一个 Node 一个 Pod）将 log-pilot 部署在 k8s 中，部署配置文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">log-pilot-filebeat</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">log-pilot-filebeat</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">log-pilot-filebeat</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-pilot-filebeat</span></span><br><span class="line">        <span class="comment">#image: registry.cn-hangzhou.aliyuncs.com/acs/log-pilot:0.9.7-filebeat</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/jboost/log-pilot:filebeat-7.3.1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"NODE_NAME"</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">spec.nodeName</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"PILOT_LOG_PREFIX"</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"k8s"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"LOGGING_OUTPUT"</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"logstash"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"LOGSTASH_HOST"</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"&#123;your-logstash-host&#125;"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"LOGSTASH_PORT"</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"5044"</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sock</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/host</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlib</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/filebeat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log/filebeat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">localtime</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/localtime</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/pilot/healthz</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">capabilities:</span></span><br><span class="line">            <span class="attr">add:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">SYS_ADMIN</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sock</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlib</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/filebeat</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log/filebeat</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">localtime</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/etc/localtime</span></span><br></pre></td></tr></table></figure><h2 id="6-应用容器部署配置"><a href="#6-应用容器部署配置" class="headerlink" title="6. 应用容器部署配置"></a>6. 应用容器部署配置</h2><p>在部署应用容器时，以声明式的方式在 Deployment 配置文件的容器部分添加配置即可对容器日志进行自动采集， 如下所示，只列出了与日志配置相关部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">      containers:</span><br><span class="line">      - env:</span><br><span class="line">        - name: k8s_logs_frameworktest</span><br><span class="line">          value: &#x2F;mnt&#x2F;logs&#x2F;app*.log</span><br><span class="line"></span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &#x2F;mnt&#x2F;logs</span><br><span class="line">          name: app-log</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - emptyDir: &#123;&#125;</span><br><span class="line">        name: app-log</span><br></pre></td></tr></table></figure><h2 id="7-按环境与应用建立索引"><a href="#7-按环境与应用建立索引" class="headerlink" title="7. 按环境与应用建立索引"></a>7. 按环境与应用建立索引</h2><p>我们可以在 logstash 中根据不同的环境（这里将环境以 namespace 进行划分），及容器名称（即不同的应用）来创建不同的 elasticsearch 的索引。配置参考如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">        if [k8s_pod_namespace] &#x3D;&#x3D; &quot;develop&quot; &#123;</span><br><span class="line">           elasticsearch &#123;</span><br><span class="line">                hosts &#x3D;&gt; &quot;elasticsearch:9200&quot;</span><br><span class="line">                index &#x3D;&gt; &quot;dev-%&#123;[k8s_container_name]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">                user &#x3D;&gt; &quot;elastic&quot;</span><br><span class="line">                password &#x3D;&gt; &quot;xxxxxx&quot;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           elasticsearch &#123;</span><br><span class="line">                hosts &#x3D;&gt; &quot;elasticsearch:9200&quot;</span><br><span class="line">                index &#x3D;&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">                user &#x3D;&gt; &quot;elastic&quot;</span><br><span class="line">                password &#x3D;&gt; &quot;xxxxxx&quot;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-相关源码与镜像"><a href="#8-相关源码与镜像" class="headerlink" title="8. 相关源码与镜像"></a>8. 相关源码与镜像</h2><p>log-pilot 官方源码地址：<a href="https://github.com/AliyunContainerService/log-pilot" target="_blank" rel="noopener">https://github.com/AliyunContainerService/log-pilot</a><br>适配 ELK 7.x 源码地址： <a href="https://github.com/ronwxy/log-pilot/tree/filebeat-7.3.1" target="_blank" rel="noopener">https://github.com/ronwxy/log-pilot/tree/filebeat-7.3.1</a><br>适配 ELK 7.x Docker 镜像地址： registry.cn-hangzhou.aliyuncs.com/jboost/log-pilot:filebeat-7.3.1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文&lt;a href=&quot;/k8s7-logpilot-1.html&quot;&gt;Kubernetes笔记（七）：K8s中的日志采集实践——log-pilot介绍&lt;/a&gt;我们对 k8s 集群中常用日志采集模式及阿里开源的 log-pilot 进行了介绍，本文介绍如何使 log-pilot 适配 ELK 7.x 及如何将 log-pilot 部署到 k8s 集群中进行日志采集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（七）：K8s中的日志采集实践——log-pilot介绍</title>
    <link href="http://blog.jboost.cn/k8s7-logpilot-1.html"/>
    <id>http://blog.jboost.cn/k8s7-logpilot-1.html</id>
    <published>2020-09-25T03:49:52.000Z</published>
    <updated>2020-09-26T02:35:58.064Z</updated>
    
    <content type="html"><![CDATA[<p>日志是应用服务运行过程中的一个关键环节，借助日志，我们可以排查定位问题，也可以借助集中化的日志管理平台（如ELK）来做一些必要的数据统计分析与监控告警。在 K8s 环境中，容器的日志有可能是通过 STDOUT/STDERR 输出（对于标准输出，前面 <a href="/docker-13.html">Docker笔记（十三）：容器日志采集实践</a> 有相关介绍可参考），并且一般也推荐将日志写到标准输出，但是也有一些特殊的场景，应用直接将日志写在容器内部的日志文件。对于容器的标准输出日志来说，Docker Engine 本身就提供了一个很好的日志采集能力，但是对于容器内部的文件日志采集，现在却并没有一个很好的工具能够去动态发现采集。因为在分布式的容器集群中，容器随着 Pod 调度被动态创建或删除，我们无法像虚拟机环境那样事先配置好日志采集路径等信息，目前的采集工具都是需要我们事先手动配置好日志采集方式和路径等信息，它无法自动感知到容器的生命周期变化或者动态漂移（一个 Pod 挂了，可能是在另一个节点上启动一个新的 Pod），无法进行动态的配置。因此，在 K8s 中进行日志采集将变得更为复杂。</p><a id="more"></a><h2 id="1-K8s-的日志采集模式"><a href="#1-K8s-的日志采集模式" class="headerlink" title="1. K8s 的日志采集模式"></a>1. K8s 的日志采集模式</h2><p>综观 K8s 下的日志采集模式，大致有三种：</p><h3 id="1-Node-代理模式"><a href="#1-Node-代理模式" class="headerlink" title="1.Node 代理模式"></a>1.Node 代理模式</h3><p>就是在每个 Node 上部署一个日志采集代理程序（如 filebeat，fluentd，或 logstash 等），一般是以 DaemonSet 的形式在每个 Node 上部署一个 Pod，来采集这个 Node 上所有容器的日志。这种模式的优点是资源消耗少，一个节点一个 Pod， 且对应用无侵入。</p><h3 id="2-SideCar-模式"><a href="#2-SideCar-模式" class="headerlink" title="2.SideCar 模式"></a>2.SideCar 模式</h3><p>这种模式就是在 Pod 中除了运行我们的应用程序容器， 再起一个负责日志采集的容器，比如再起一个 logstash 或 fluentd 容器。当 Pod 数量一多，这种方案资源消耗很大，对日志存储后端也会占用过多的连接数，并且日志不输出到标准输出，不能通过 kubectl logs 命令查看。</p><h3 id="3-应用程序推送模式"><a href="#3-应用程序推送模式" class="headerlink" title="3.应用程序推送模式"></a>3.应用程序推送模式</h3><p>直接在应用程序里将日志内容发送到日志采集服务，比如在程序里将日志发到 kafka， 再使用 logstash 从 kafka 拉取到 elasticsearch。这种方案对应用具有侵入性。</p><p>有没有一种方案或工具，既能采集 k8s 中标准输出日志，又能采集到容器内部的日志文件输出日志，并且资源消耗小，对应用无侵入呢。拒作者了解，阿里开源的 log-pilot 基本能满足要求，只是更新较慢，目前版本基于 ELK 6，如果要适配到 ELK 7 或以上，需进行一些必要的调整。</p><h2 id="2-log-pilot-介绍"><a href="#2-log-pilot-介绍" class="headerlink" title="2. log-pilot 介绍"></a>2. log-pilot 介绍</h2><p>log-pilot 是阿里开源的一个同时支持容器标准输出日志采集与容器内部文件日志动态配置采集的组件。log-pilot 具备如下特性。</p><h3 id="1-采集目标多"><a href="#1-采集目标多" class="headerlink" title="1. 采集目标多"></a>1. 采集目标多</h3><p>log-pilot 同时支持采集标准输出日志和动态发现配置采集容器内部文件日志。</p><h3 id="2-声明式的日志配置"><a href="#2-声明式的日志配置" class="headerlink" title="2. 声明式的日志配置"></a>2. 声明式的日志配置</h3><p>log-pilot 支持声明式日志配置，可以依据容器的 Label 或者 ENV 来动态地生成日志采集的配置文件。这里主要说明两个变量：</p><ul><li>name：我们自定义的一个字符串，它在不同的场景下指代不同的含义。当日志采集到 ElasticSearch 的时候， name 表示的是 Index；当日志采集到 Kafka 的时候， name 表示的是 Topic；当日志采集到阿里云日志服务的时候，name 表示的就是 LogstoreName。</li><li>path：支持两种形式，一种是约定关键字 stdout，表示的是采集容器的标准输出日志，第二种是容器内部的具体文件日志路径，可以支持通配符的方式。比如我们要采集 tomcat 容器日志，我们可以通过配置标签 <code>aliyun.logs.catalina=stdout</code> 来采集 tomcat 标准输出日志，通过配置标签 <code>aliyun.logs.access=/usr/local/tomcat/logs/*.log</code> 来采集 tomcat 容器内部文件日志。</li></ul><p><img src="/assets/log-pilot-1.png" alt="声明式的日志配置"></p><h3 id="3-动态配置的能力"><a href="#3-动态配置的能力" class="headerlink" title="3. 动态配置的能力"></a>3. 动态配置的能力</h3><p>log-pilot 本身分为三部分，其中一部分就是容器的事件管理，它能够动态地监听容器的事件变化（如创建、删除），然后依据容器的标签来进行解析，生成日志采集配置文件，然后交由采集插件来进行日志采集。通过全量扫描加事件监听的方式，比如采集工具进程在起来的时候，注册事件监听，然后全量扫描一遍宿主机上的所有容器列表，然后依据容器的声明式配置来进行日志采集配置文件的动态生成。</p><h3 id="4-防重复和丢失"><a href="#4-防重复和丢失" class="headerlink" title="4. 防重复和丢失"></a>4. 防重复和丢失</h3><p>log-pilot 内部具有 CheckPoint 和句柄保持的机制。</p><ul><li>checkPoint机制： log-pilot 内部会实时跟踪日志采集的偏移量，然后维持日志文件信息与偏移量的映射关系，最后定期地持久化到磁盘中。采用偏移量的方式我们可以避免日志采集丢失和重复的问题，同时即使当采集工具宕掉再起来，它也可以通过加载持久化在磁盘上的元数据信息，从指定的日志偏移位置上继续采集日志。</li><li>句柄保持机制： log-pilot 在监测到配置的日志路径目录下有新的日志文件产生时会主动地打开其句柄，并维持打开状态，这样是为了防止因日志采集工具比较慢或者应用日志输出速率特别大，比如说当前已经生成五个日志文件但只采集到第三个，后面两个还没有开始采集，一旦这个容器退出就可能导致后面两个文件的日志丢失了。</li></ul><h3 id="5-明确日志来源"><a href="#5-明确日志来源" class="headerlink" title="5. 明确日志来源"></a>5. 明确日志来源</h3><p>支持日志自动数据打标。log-pilot 在采集容器日志的时候，同时也会收集容器的元数据信息，包括容器的名称，容器所属的服务名称以及容器所属的应用名称，同时在 Kubernetes 里面也会采集容器所属的 Pod 信息，包括 Pod 的名称，Pod 所属的 namespace 以及 Pod 所在的节点信息。这样排查问题时，就可以很方便地知道这个日志是来源于哪个节点上的哪个应用容器。</p><p><img src="/assets/log-pilot-2.png" alt="自动数据打标"></p><h3 id="6-支持自定义-Tag"><a href="#6-支持自定义-Tag" class="headerlink" title="6. 支持自定义 Tag"></a>6. 支持自定义 Tag</h3><p>log-pilot 支持自定义Tag，我们可以在容器的标签或者环境变量里配置 <code>aliyun.logs.$name.tags: k=v</code>，那么在采集日志的时候就会将k=v采集到容器的日志输出中。比如针对不同的环境（如开发环境、测试环境），可以使用 tag 来进行区分。也可以使用自定义 tag 来进行日志的统计、路由与过滤等。</p><p><img src="/assets/log-pilot-3.png" alt="自定义tag"></p><h3 id="7-支持多种日志解析格式"><a href="#7-支持多种日志解析格式" class="headerlink" title="7. 支持多种日志解析格式"></a>7. 支持多种日志解析格式</h3><p>log-pilot 支持多种日志解析格式，通过 <code>aliyun.logs.$name.format: &lt;format&gt;</code> 标签就可以告诉 log-pilot 在采集日志的时候，同时以什么样的格式来解析日志记录。目前主要支持六种：</p><ul><li>none：默认格式，指不对日志记录做任何解析，整行采集出来直接输出到日志存储后端。</li><li>json：log-pilot 在采集日志的同时会将每一行日志以 json 的方式进行解析，解析出多个 KV 对，然后输出到日志存储后端。</li><li>csv：主要是针对 csv 格式的日志采集配置（需配置 fluentd 插件）。</li><li>nginx：主要是针对 Nginx 的日志采集配置（需配置 fluentd 插件）。</li><li>apache2：主要是针对 Apache 的日志采集配置（需配置 fluentd 插件）。</li><li>regexp：用户可以通过 format 标签来自定义正则表达式，告诉 log-pilot 在解析日志记录的时候以什么样的格式来进行解析（需配置 fluentd 插件）。</li></ul><p><img src="/assets/log-pilot-4.png" alt="多种解析格式"></p><h3 id="8-支持自定义输出Target"><a href="#8-支持自定义输出Target" class="headerlink" title="8. 支持自定义输出Target"></a>8. 支持自定义输出Target</h3><p>假设我们同时有一个生产环境和一个测试环境，应用日志都需要被采集到同一套 Kafka 中，然后由不同的 consumer 去消费。但是我们希望对环境进行区分，某条日志是由生产环境的应用容器产生的，还是测试环境的应用容器产生的，但我们在测试环境中的应用容器已经配置了 aliyun.logs.svc=stdout 标签，那么当这些应用容器的标准输出日志被采集到 kafka 中，它最终会被路由到 topic=svc 的消息队列中，那么订阅了 topic=svc 的 consumer 就能够接收测试环境的应用容器产生的日志。但当我们将该应用发布到生产环境时，希望它产生的日志只能交由生产环境的 consumer 来接收处理，那么我们就可以通过 target 的方式，给生产环境的应用容器额外定义一个 target=pro-svc，那么生产环境的应用日志在被采集到 Kafka 中时，最终会被路由到 topic 为 pro-svc 的消息队列中，那么订阅了 topic =pro-svc 的 consumer 就可以正常地接收到来自于生产环境的容器产生的日志。</p><p>因此这里的 target 本身也有三种含义：</p><ol><li>日志对接到 ElasticeSearch 时，这个 target 字符串是 Index；</li><li>对接到 Kafka 时，它指代的是 topic；</li><li>对接到阿里云日志服务时，它代表的是 Logstore Name。</li></ol><p><img src="/assets/log-pilot-5.png" alt="自定义输出target"></p><h3 id="9-支持多种采集插件"><a href="#9-支持多种采集插件" class="headerlink" title="9. 支持多种采集插件"></a>9. 支持多种采集插件</h3><p>目前 log-pilot 支持两种采集插件：一个是 CNCF 社区的 Fluentd 插件，一个是 Elastic 的 Filebeat 插件；同时支持对接多种存储后端，目前 Fluentd 和 Filebeat 都支持 Elasticsearch、Kafka、File、Console 作为日志存储后端，而 Fluentd 还支持 Graylog、阿里云日志服务 以及 Mongodb 作为存储后端。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>本文对 k8s 集群中日志采集的常见模式，及阿里开源的 log-pilot 支持的特性进行了介绍。但 log-pilot 目前基于 ELK 6 版本， 如果需要适配 ELK 7 或以上版本，需要对其进行必要的调整。下文将介绍如何进行适配调整及如何将 log-pilot 部署到 k8s 集群中进行日志采集。</p><p>参考：</p><p>容器日志采集利器 Log-Pilot： <a href="https://developer.aliyun.com/article/674327" target="_blank" rel="noopener">https://developer.aliyun.com/article/674327</a><br>log-pilot 官方源码地址：<a href="https://github.com/AliyunContainerService/log-pilot" target="_blank" rel="noopener">https://github.com/AliyunContainerService/log-pilot</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志是应用服务运行过程中的一个关键环节，借助日志，我们可以排查定位问题，也可以借助集中化的日志管理平台（如ELK）来做一些必要的数据统计分析与监控告警。在 K8s 环境中，容器的日志有可能是通过 STDOUT/STDERR 输出（对于标准输出，前面 &lt;a href=&quot;/docker-13.html&quot;&gt;Docker笔记（十三）：容器日志采集实践&lt;/a&gt; 有相关介绍可参考），并且一般也推荐将日志写到标准输出，但是也有一些特殊的场景，应用直接将日志写在容器内部的日志文件。对于容器的标准输出日志来说，Docker Engine 本身就提供了一个很好的日志采集能力，但是对于容器内部的文件日志采集，现在却并没有一个很好的工具能够去动态发现采集。因为在分布式的容器集群中，容器随着 Pod 调度被动态创建或删除，我们无法像虚拟机环境那样事先配置好日志采集路径等信息，目前的采集工具都是需要我们事先手动配置好日志采集方式和路径等信息，它无法自动感知到容器的生命周期变化或者动态漂移（一个 Pod 挂了，可能是在另一个节点上启动一个新的 Pod），无法进行动态的配置。因此，在 K8s 中进行日志采集将变得更为复杂。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（六）：了解控制器 —— Deployment</title>
    <link href="http://blog.jboost.cn/k8s6-deploy.html"/>
    <id>http://blog.jboost.cn/k8s6-deploy.html</id>
    <published>2020-08-21T03:49:52.000Z</published>
    <updated>2020-08-26T01:44:35.532Z</updated>
    
    <content type="html"><![CDATA[<p>Pod（容器组）是 Kubernetes 中最小的调度单元，可以通过 yaml 定义文件直接创建一个 Pod。但 Pod 本身并不具备自我恢复（self-healing）功能。如果一个 Pod 所在的节点出现故障，或者调度程序自身出现问题，以及节点资源不够或节点进入维护而驱逐 Pod 时，Pod 将被删除，且不能自我恢复。</p><p>因此，Kubernetes 中我们一般不直接创建 Pod， 而是通过 Controller（控制器）来管理 Pod。</p><a id="more"></a><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>Controller 能为 Pod 提供如下特性：</p><ul><li>水平扩展，控制 Pod 运行的副本数</li><li>rollout，即版本更新</li><li>self-healing，即自我恢复。当节点出现故障时，控制器可以自动地在另一个节点调度一个配置完全一样的 Pod，以替换故障节点上的 Pod。</li></ul><p>Kubernetes 中支持的控制器包括：</p><ul><li>ReplicationController：用来维护一个数量稳定的 Pod 副本集合的控制器</li><li>ReplicaSet：是 ReplicationController 的升级版，比 ReplicationController 多一个特性：支持基于集合的选择器。 不支持滚动更新（RollingUpdate）</li><li>Deployment：包含了 ReplicaSet，可通过声明式、滚动更新的方式更新 ReplicaSet 及其 Pod。对于无状态应用，推荐使用 Deployment 部署</li><li>StatefulSet：用于管理有状态的应用程序</li><li>DaemonSet：在节点上以守护进程的方式运行一个指定的 Pod 副本，例如监控节点、收集节点上的日志时，可使用 DaemonSet</li><li>CronJob：按照预定的时间计划创建 Job，类似于 linux 的crontab</li><li>Job：使用 Job 执行任务，执行完后结束</li></ul><h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><p>Kubernetes 中，虽然一般使用 Deployment 来管理 Pod， 但 Deployment 中也是通过 ReplicaSet 来维护 Pod 的副本集合的，因此此处也对 ReplicaSet 进行简单介绍。</p><p>在 ReplicaSet 的定义中，包含三部分：</p><ol><li>selector： 标签选择器，用于指定哪些 Pod 归该 ReplicaSet 管理，通过 <code>matchLabels</code> 来与 Pod 的 label 匹配。</li><li>replicas： 期望的 Pod 副本数，指定该 ReplicaSet 应该维持多少个 Pod 副本，默认为1。</li><li>template： Pod 定义模板，ReplicaSet 使用该模板的定义来创建 Pod。</li></ol><p>ReplicaSet 的示例定义文档如下所示，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  <span class="comment"># api版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span>     <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span>            <span class="comment"># 元数据定义</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ds</span>     <span class="comment"># ReplicaSet 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span>        <span class="comment"># Pod 副本数量，默认1</span></span><br><span class="line">  <span class="attr">selector:</span>          <span class="comment"># 标签选择器</span></span><br><span class="line">     <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span>          <span class="comment"># Pod 定义模板</span></span><br><span class="line">    <span class="attr">metadata:</span>        <span class="comment"># Pod 元数据定义</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># Pod 标签</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span>    <span class="comment"># 容器定义</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>ReplicaSet 通过创建、删除 Pod 容器组来确保符合 selector 选择器的 Pod 数量等于 replicas 指定的数量。 ReplicaSet 创建的 Pod 中，都有一个字段 <code>metadata.ownerReferences</code> 用于标识该 Pod 从属于哪一个 ReplicaSet。可通过 <code>kubectl get pod pod-name -o yaml</code> 来查看 Pod 的 ownerReference。</p><p>ReplicaSet 通过 selector 字段的定义，识别哪些 Pod 应该由其管理， 不论该 Pod 是否由该 ReplicaSet 创建，即只要 selector 匹配， 通过外部定义创建的 Pod 也会被该 ReplicaSet 管理。因此需要注意 <code>.spec.selector.matchLabels</code> 与 <code>.spec.template.metadata.labels</code> 的定义一致， 且避免与其他控制器的 selector 重合，造成混乱。</p><p>ReplicaSet 不支持滚动更新，所以对于无状态应用，一般使用 Deployment来部署， 而不直接使用 ReplicaSet。ReplicaSet 主要是被用作 Deployment 中负责 Pod 创建、删除、更新的一种手段。</p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>Deployment 对象包含 ReplicaSet 作为从属对象，并且可通过声明式、滚动更新的方式来更新 ReplicaSet 及其 Pod。ReplicaSet 现在主要是被用作 Deployment 中负责 Pod 创建、删除、更新的一种手段。使用 Deployment 时，无需关心由 Deployment 创建的 ReplicaSet，Deployment 将处理所有与之相关的细节。同时，Deployment 还能以“声明式”的方式管理 Pod 和 ReplicaSet （其本质是将一些特定场景的一系列运维步骤固化下来，以便快速准确无误的执行），并提供版本（revision）回退功能。</p><p>Deployment 定义示例，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>        <span class="comment"># 对象类型，固定为 Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span>    <span class="comment"># Deployment 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>    <span class="comment"># 命名空间，默认为 default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>          <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span>           <span class="comment"># Pod 副本数，默认1</span></span><br><span class="line">  <span class="attr">strategy:</span>  </span><br><span class="line">    <span class="attr">rollingUpdate:</span>      <span class="comment"># 升级策略为滚动升级，由于replicas为4,则整个升级过程pod个数在3-5个之间</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span>       <span class="comment"># 滚动升级时超过 replicas 的最大 pod 数，也可以为百分比（replicas的百分比），默认为1</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 滚动升级时不可用的最大 pod 数，也可为百分比（replicas的百分比），默认为1</span></span><br><span class="line">  <span class="attr">selector:</span>             <span class="comment"># 标签选择器，通过标签选择该 Deployment 管理的 Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span>             <span class="comment"># Pod 定义模板</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>      <span class="comment"># Pod 标签</span></span><br><span class="line">    <span class="attr">spec:</span>               <span class="comment"># 定义容器模板，可以包含多个容器</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>可通过 <code>kubectl explain xxx</code> 来查看支持哪些配置选项，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 deployment 配置项</span></span><br><span class="line">[root@kmaster ~]# kubectl explain deployment</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 deployment.spec 模块的配置项</span></span><br><span class="line">[root@kmaster ~]# kubectl explain deployment.spec</span><br><span class="line">KIND:     Deployment</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">RESOURCE: spec &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     Specification of the desired behavior of the Deployment.</span><br><span class="line"></span><br><span class="line">     DeploymentSpec is the specification of the desired behavior of the</span><br><span class="line">     Deployment.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   minReadySeconds&lt;integer&gt;</span><br><span class="line">     Minimum number of seconds for which a newly created pod should be ready</span><br><span class="line">     without any of its container crashing, for it to be considered available.</span><br><span class="line">     Defaults to 0 (pod will be considered available as soon as it is ready)</span><br><span class="line"></span><br><span class="line">   paused&lt;boolean&gt;</span><br><span class="line">     Indicates that the deployment is paused.</span><br><span class="line"></span><br><span class="line">   progressDeadlineSeconds&lt;integer&gt;</span><br><span class="line">     The maximum time in seconds for a deployment to make progress before it is</span><br><span class="line">     considered to be failed. The deployment controller will continue to process</span><br><span class="line">     failed deployments and a condition with a ProgressDeadlineExceeded reason</span><br><span class="line">     will be surfaced in the deployment status. Note that progress will not be</span><br><span class="line">     estimated during the time a deployment is paused. Defaults to 600s.</span><br><span class="line"></span><br><span class="line">   replicas&lt;integer&gt;</span><br><span class="line">     Number of desired pods. This is a pointer to distinguish between explicit</span><br><span class="line">     zero and not specified. Defaults to 1.</span><br><span class="line"></span><br><span class="line">   revisionHistoryLimit&lt;integer&gt;</span><br><span class="line">     The number of old ReplicaSets to retain to allow rollback. This is a</span><br><span class="line">     pointer to distinguish between explicit zero and not specified. Defaults to</span><br><span class="line">     10.</span><br><span class="line"></span><br><span class="line">   selector&lt;Object&gt; -required-</span><br><span class="line">     Label selector for pods. Existing ReplicaSets whose pods are selected by</span><br><span class="line">     this will be the ones affected by this deployment. It must match the pod</span><br><span class="line">     template's labels.</span><br><span class="line"></span><br><span class="line">   strategy&lt;Object&gt;</span><br><span class="line">     The deployment strategy to use to replace existing pods with new ones.</span><br><span class="line"></span><br><span class="line">   template&lt;Object&gt; -required-</span><br></pre></td></tr></table></figure><p>其它配置项说明：</p><ul><li><code>.spec.minReadySeconds</code>：用来控制应用升级的速度。升级过程中，新创建的 Pod 一旦成功响应了就绪探测即被认为是可用状态，然后进行下一轮的替换。 <code>.spec.minReadySeconds</code> 定义了在新的 Pod 对象创建后至少需要等待多长的时间才能会被认为其就绪，在该段时间内，更新操作会被阻塞。</li><li><code>.spec.progressDeadlineSeconds</code>：用来指定在系统报告 Deployment 失败 —— 表现为状态中的 <code>type=Progressing、Status=False、 Reason=ProgressDeadlineExceeded</code> 前可以等待的 Deployment 进行的秒数。Deployment controller 会继续重试该 Deployment。如果设置该参数，该值必须大于 <code>.spec.minReadySeconds</code>。</li><li><code>.spec.revisionHistoryLimit</code>：用来指定可以保留的旧的 ReplicaSet 或 revision（版本） 的数量。默认所有旧的 Replicaset 都会被保留。如果删除了一个旧的 RepelicaSet，则 Deployment 将无法再回退到那个 revison。如果将该值设置为0，所有具有0个 Pod 副本的 ReplicaSet 都会被删除，这时候 Deployment 将无法回退，因为 revision history 都被清理掉了。</li></ul><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl apply -f nginx-deploy.yaml --record</span><br></pre></td></tr></table></figure><p><code>--record</code> 会将此次命令写入 Deployment 的 kubernetes.io/change-cause 注解中。可在后面查看某一个 Deployment 版本变化的原因。</p><h3 id="2-查看"><a href="#2-查看" class="headerlink" title="2. 查看"></a>2. 查看</h3><p>创建 Deployment 后，Deployment 控制器将立刻创建一个 ReplicaSet，并由 ReplicaSet 创建所需要的 Pod。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 Deployment</span></span><br><span class="line">[root@kmaster test]# kubectl get deploy</span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deploy   0/2     2            0           64s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 ReplicaSet</span></span><br><span class="line">[root@kmaster test]# kubectl get rs</span><br><span class="line">NAME                     DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-59c9f8dff   2         2         1       2m16s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Pod，显示调度的节点，及标签</span></span><br><span class="line">[root@kmaster test]# kubectl get pod -o wide --show-labels</span><br><span class="line">NAME                           READY   STATUS      RESTARTS   AGE     IP            NODE     NOMINATED NODE   READINESS GATES   LABELS</span><br><span class="line">nginx-deploy-59c9f8dff-47bgd   1/1     Running     0          5m14s   10.244.1.91   knode2   &lt;none&gt;           &lt;none&gt;            app=nginx,pod-template-hash=59c9f8dff</span><br><span class="line">nginx-deploy-59c9f8dff-q4zb8   1/1     Running     0          5m14s   10.244.3.47   knode3   &lt;none&gt;           &lt;none&gt;            app=nginx,pod-template-hash=59c9f8dff</span><br></pre></td></tr></table></figure><p><code>pod-template-hash</code> 标签是 Deployment 创建 ReplicaSet 时添加到 ReplicaSet 上的，ReplicaSet 进而将此标签添加到 Pod 上。这个标签用于区分 Deployment 中哪个 ReplicaSet 创建了哪些 Pod。该标签的值是 <code>.spec.template</code> 的 hash 值，不要去修改这个标签。由上可看出 ReplicaSet、 Pod 的命名分别遵循 <code>&lt;Deployment-name&gt;-&lt;Pod-template-hash&gt;</code>、<code>&lt;Deployment-name&gt;-&lt;Pod-template-hash&gt;-xxx</code> 的格式。</p><h3 id="3-发布更新（rollout）"><a href="#3-发布更新（rollout）" class="headerlink" title="3. 发布更新（rollout）"></a>3. 发布更新（rollout）</h3><p>当且仅当 Deployment 的 Pod template（<code>.spec.template</code>）字段中的内容发生变更时（例如标签或容器的镜像被改变），Deployment 的发布更新（rollout）才会被触发。Deployment 中其他字段的变化（例如修改 <code>.spec.replicas</code> 字段）将不会触发 Deployment 的发布更新。</p><p>更新 Deployment 中 Pod 的定义（例如，发布新版本的容器镜像）。此时 Deployment 控制器将为该 Deployment 创建一个新的 ReplicaSet，并且逐步在新的 ReplicaSet 中创建 Pod，在旧的 ReplicaSet 中删除 Pod，以达到滚动更新的效果。</p><p>比如我们将上面 Deployment 的容器镜像进行修改，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式一：直接使用 kubectl 命令设置修改 </span></span><br><span class="line">[root@kmaster ~]# kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record</span><br><span class="line">deployment.apps/nginx-deploy image updated</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二：使用 kubectl edit 编辑yaml修改</span></span><br><span class="line">[root@kmaster ~]# kubectl edit deploy nginx-deploy</span><br></pre></td></tr></table></figure><p>查看发布更新（rollout）的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl rollout status deploy nginx-deploy</span><br><span class="line">Waiting for deployment "nginx-deploy" rollout to finish: 2 out of 4 new replicas have been updated...</span><br></pre></td></tr></table></figure><p>查看 ReplicaSet，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl get rs</span><br><span class="line">NAME                     DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-59c9f8dff   1         1         1       3d6h</span><br><span class="line">nginx-deploy-d47dbbb7c   4         4         2       3m41s</span><br></pre></td></tr></table></figure><p>我们可以看到 Deployment 的更新是通过创建一个新的4个副本的 ReplicaSet，并同时将旧的 ReplicaSet 的副本数缩容到0个副本来达成的。</p><p>因为前面我们将 maxSurge， 与 maxUnavailable 都设置为了1， 因此在更新的过程中，任何时刻两个 ReplicaSet 的 Pod 数至多为5个（4 replicas +1 maxSurge），且可用的 Pod 数至少为3个（4 replicas - 1 maxUnavailable）。</p><p>使用 <code>kubectl describe</code> 命令查看 Deployment 的事件部分，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl describe deploy nginx-deploy</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age    From                   Message</span><br><span class="line">  ----    ------             ----   ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  12m    deployment-controller  Scaled up replica set nginx-deploy-d47dbbb7c to 1</span><br><span class="line">  Normal  ScalingReplicaSet  12m    deployment-controller  Scaled down replica set nginx-deploy-59c9f8dff to 3</span><br><span class="line">  Normal  ScalingReplicaSet  12m    deployment-controller  Scaled up replica set nginx-deploy-d47dbbb7c to 2</span><br><span class="line">  Normal  ScalingReplicaSet  10m    deployment-controller  Scaled down replica set nginx-deploy-59c9f8dff to 2</span><br><span class="line">  Normal  ScalingReplicaSet  10m    deployment-controller  Scaled up replica set nginx-deploy-d47dbbb7c to 3</span><br><span class="line">  Normal  ScalingReplicaSet  8m56s  deployment-controller  Scaled down replica set nginx-deploy-59c9f8dff to 1</span><br><span class="line">  Normal  ScalingReplicaSet  8m56s  deployment-controller  Scaled up replica set nginx-deploy-d47dbbb7c to 4</span><br><span class="line">  Normal  ScalingReplicaSet  5m55s  deployment-controller  Scaled down replica set nginx-deploy-59c9f8dff to 0</span><br></pre></td></tr></table></figure><p>当更新了 Deployment 的 Pod Template 时，Deployment Controller 会创建一个新的 ReplicaSet (nginx-deploy-d47dbbb7c) ，并将其 scale up 到 1 个副本，同时将旧的 ReplicaSet（nginx-deploy-59c9f8dff） scale down 到3个副本。接下来 Deployment Controller 继续 scale up 新的 ReplicaSet 并 scale down 旧的 ReplicaSet，直到新的 ReplicaSet 拥有 replicas 个数的 Pod， 旧的 ReplicaSet Pod 数缩放到0。这个过程称为 rollout（发布更新）。</p><p>通过 <code>.spec.strategy</code> 字段，可以指定更新策略，除了上述使用的 RollingUpdate（滚动更新），另一个可取的值为 Recreate（重新创建）。选择重新创建，Deployment 将先删除原有 ReplicaSet 中的所有 Pod，然后再创建新的 ReplicaSet 和新的 Pod，更新过程中将出现一段应用程序不可用的情况。因此，线上环境一般使用 RollingUpdate。</p><h3 id="4-回滚"><a href="#4-回滚" class="headerlink" title="4. 回滚"></a>4. 回滚</h3><p>默认情况下，kubernetes 将保存 Deployment 的所有更新（rollout）历史。可以通过设定 revision history limit（<code>.spec.revisionHistoryLimit</code> 配置项）来指定保存的历史版本数量。</p><p>当且仅当 Deployment 的 <code>.spec.template</code> 字段被修改时（例如修改容器的镜像），kubernetes 才为其创建一个 Deployment revision（版本）。Deployment 的其他更新（例如：修改 <code>.spec.replicas</code> 字段）将不会创建新的 Deployment revision（版本）。</p><p>查看 Deployment 的 revision，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br><span class="line">2         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br></pre></td></tr></table></figure><p>如果前面更新 Deployment 时没有添加 <code>--record=true</code>，则此处 CHANGE-CAUSE 将为空。</p><p>我们通过将镜像修改为一个不存在的版本来模拟一次失败的更新，并回滚到前一个版本的场景，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 修改镜像版本到一个不存在的值</span></span><br><span class="line">[root@kmaster ~]# kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record</span><br><span class="line">deployment.apps/nginx-deploy image updated</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看 ReplicaSet</span></span><br><span class="line">[root@kmaster ~]# kubectl  get rs</span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-58f69cfc57   2         2         0       2m7s</span><br><span class="line">nginx-deploy-59c9f8dff    0         0         0       3d7h</span><br><span class="line">nginx-deploy-d47dbbb7c    3         3         3       81m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看 Pod 状态</span></span><br><span class="line">[root@kmaster ~]# kubect get pod</span><br><span class="line">NAME                            READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-deploy-58f69cfc57-5968g   0/1     ContainerCreating   0          42s</span><br><span class="line">nginx-deploy-58f69cfc57-tk7c5   0/1     ErrImagePull        0          42s</span><br><span class="line">nginx-deploy-d47dbbb7c-2chgx    1/1     Running             0          77m</span><br><span class="line">nginx-deploy-d47dbbb7c-8fcb9    1/1     Running             0          80m</span><br><span class="line">nginx-deploy-d47dbbb7c-gnwjj    1/1     Running             0          78m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 查看 Deployment 详情</span></span><br><span class="line">[root@kmaster ~]# kubectl describe deploy nginx-deploy</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age    From                   Message</span><br><span class="line">  ----    ------             ----   ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  3m57s  deployment-controller  Scaled up replica set nginx-deploy-58f69cfc57 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  3m57s  deployment-controller  Scaled down replica set nginx-deploy-d47dbbb7c to 3</span><br><span class="line">  Normal  ScalingReplicaSet  3m57s  deployment-controller  Scaled up replica set nginx-deploy-58f69cfc57 to 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看 Deployment 的历史版本</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br><span class="line">2         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br><span class="line">3         kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 查看某个版本的详情</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy --revision=3</span><br><span class="line">deployment.apps/nginx-deploy with revision #3</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:app=nginx</span><br><span class="line">pod-template-hash=58f69cfc57</span><br><span class="line">  Annotations:kubernetes.io/change-cause: kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:nginx:1.161</span><br><span class="line">    Port:80/TCP</span><br><span class="line">    Host Port:0/TCP</span><br><span class="line">    Environment:&lt;none&gt;</span><br><span class="line">    Mounts:&lt;none&gt;</span><br><span class="line">  Volumes:&lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 回滚到前一个版本</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout undo deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy rolled back</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 回滚到指定的版本</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout undo deploy nginx-deploy --to-revision=1</span><br><span class="line">deployment.apps/nginx-deploy rolled back</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. 查看历史版本信息</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">3         kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line">4         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br><span class="line">5         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br></pre></td></tr></table></figure><p>通过 <code>kubectl rollout undo</code> 命令可回滚到上一个版本或指定的版本，上述示例也可看出，回滚到历史版本，会将历史版本的序号设置为最新序号。如前所述，我们可以通过设置 Deployment 的 <code>.spec.revisionHistoryLimit</code> 来指定保留多少个旧的 ReplicaSet（或 revision），超出该数字的将在后台进行垃圾回收。如果该字段被设为 0，Kubernetes 将清理掉该 Deployment 的所有历史版本（revision），此时，将无法对该 Deployment 执行回滚操作了。</p><h3 id="5-伸缩"><a href="#5-伸缩" class="headerlink" title="5. 伸缩"></a>5. 伸缩</h3><p>可以通过 <code>kubectl scale</code> 命令或 <code>kubectl edit</code> 修改定义的方式来对 Deployment 进行伸缩，增加或减少 Pod 的副本数，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 Pod 数缩放到2个</span></span><br><span class="line">[root@kmaster ~]# kubectl scale deploy nginx-deploy --replicas=2</span><br><span class="line">deployment.apps/nginx-deploy scaled</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Pod</span></span><br><span class="line">[root@kmaster ~]# kubectl  get pod</span><br><span class="line">NAME                           READY   STATUS        RESTARTS   AGE</span><br><span class="line">nginx-deploy-59c9f8dff-7bpjp   1/1     Running       0          9m48s</span><br><span class="line">nginx-deploy-59c9f8dff-tpxzf   0/1     Terminating   0          8m57s</span><br><span class="line">nginx-deploy-59c9f8dff-v8fgz   0/1     Terminating   0          10m</span><br><span class="line">nginx-deploy-59c9f8dff-w8s9z   1/1     Running       0          10m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 ReplicaSet，DESIRED 变为2了</span></span><br><span class="line">[root@kmaster ~]# kubectl get rs</span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-58f69cfc57   0         0         0       22m</span><br><span class="line">nginx-deploy-59c9f8dff    2         2         2       3d8h</span><br><span class="line">nginx-deploy-d47dbbb7c    0         0         0       102m</span><br></pre></td></tr></table></figure><h3 id="6-自动伸缩（HPA）"><a href="#6-自动伸缩（HPA）" class="headerlink" title="6. 自动伸缩（HPA）"></a>6. 自动伸缩（HPA）</h3><p>如果集群启用了自动伸缩（HPA —— Horizontal Pod Autoscaling），则可以基于 CPU、 内存的使用率在一个最大和最小的区间对 Deployment 实现自动伸缩，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个 HPA</span></span><br><span class="line">[root@kmaster ~]# kubectl autoscale deploy nginx-deploy --min=2 --max=4 --cpu-percent=80</span><br><span class="line">horizontalpodautoscaler.autoscaling/nginx-deploy autoscaled</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 HPA</span></span><br><span class="line">[root@kmaster ~]# kubectl get hpa</span><br><span class="line">NAME           REFERENCE                 TARGETS         MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">nginx-deploy   Deployment/nginx-deploy   &lt;unknown&gt;/80%   2         4         2          16s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 HPA</span></span><br><span class="line">[root@kmaster ~]# kubectl delete hpa nginx-deploy</span><br><span class="line">horizontalpodautoscaler.autoscaling "nginx-deploy" deleted</span><br></pre></td></tr></table></figure><h3 id="7-暂停与恢复"><a href="#7-暂停与恢复" class="headerlink" title="7. 暂停与恢复"></a>7. 暂停与恢复</h3><p>我们可以将一个 Deployment 暂停（pause），然后在它上面做一个或多个更新，此时 Deployment 并不会触发更新，只有再恢复（resume）该 Deployment，才会执行该时间段内的所有更新。这种做法可以在暂停和恢复中间对 Deployment 做多次更新，而不会触发不必要的滚动更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 暂停 Deployment</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout pause deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy paused</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 更新容器镜像</span></span><br><span class="line">[root@kmaster ~]# kubectl set image deploy nginx-deploy nginx=nginx:1.9.1 --record</span><br><span class="line">deployment.apps/nginx-deploy image updated</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看版本历史， 此时并没有触发更新</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">3         kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line">4         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br><span class="line">5         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 更新 Resource 限制，同样并不会触发更新</span></span><br><span class="line">[root@kmaster ~]# kubectl set resources deploy nginx-deploy -c=nginx --limits=memory=512Mi,cpu=500m</span><br><span class="line">deployment.apps/nginx-deploy resource requirements updated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看修改，Pod 定义已被更新</span></span><br><span class="line">[root@kmaster ~]# kubectl describe deploy nginx-deploy</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:      nginx:1.9.1</span><br><span class="line">    Port:       80/TCP</span><br><span class="line">    Host Port:  0/TCP</span><br><span class="line">    Limits:</span><br><span class="line">      cpu:        500m</span><br><span class="line">      memory:     512Mi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 恢复 Deployment</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout resume deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy resumed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 查看版本历史，可见两次修改只做了一次 rollout</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">3         kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line">4         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br><span class="line">5         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br><span class="line">6         kubectl set image deploy nginx-deploy nginx=nginx:1.9.1 --record=true</span><br></pre></td></tr></table></figure><p>在更新容器镜像时，因为 Deployment 处于暂停状态，所以并不会生成新的版本（Revision），当 Deployment 恢复时，才将这段时间的更新生效，执行滚动更新，生成新的版本。在暂停中的 Deployment 上做的更新， 因为没有生成版本，因此也不能回滚（rollback）。也不能对处于暂停状态的 Deployment 执行回滚操作，只有在恢复（Resume）之后才能执行回滚操作。</p><h3 id="8-金丝雀发布"><a href="#8-金丝雀发布" class="headerlink" title="8. 金丝雀发布"></a>8. 金丝雀发布</h3><p>金丝雀发布也叫灰度发布。当我们需要发布新版本时，可以针对新版本新建一个 Deployment，与旧版本的 Deployment 同时挂在一个 Service 下（通过 label match）， 通过 Service 的负载均衡将用户请求流量分发到新版 Deployment 的 Pod 上，观察新版运行情况，如果没有问题再将旧版 Deployment 的版本更新到新版完成滚动更新，最后删除新建的 Deployment。很明显这种金丝雀发布具有一定的局限性，无法根据用户或地域来分流，如果要更充分地实现金丝雀发布，则可能需要引入 Istio 等。</p><blockquote><p>金丝雀发布名称的由来： 以前，旷工在下矿洞时面临的一个重要危险是矿井中的毒气，他们想到一个办法来辨别矿井中是否有毒气，矿工们随身携带一只金丝雀下矿井，金丝雀对毒气的抵抗能力比人类要弱，在毒气环境下会先挂掉从而起到预警的作用。它背后的原理是：用较小的代价试错，即使出现了严重的错误（出现了毒气），系统总体的损失也是可承受的或者是非常小的（失去了一只金丝雀）。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kubernetes 中最小的调度单元是 Pod， 负载创建 Pod 并控制其按一定的副本数运行的是 ReplicaSet， 而 Deployment 可以以“声明式”的方式来管理 Pod 和 ReplicaSet，并提供滚动更新与版本（revision）回退功能。所以，一般使用 Deployment 来部署应用， 而不直接操作 ReplicaSet 或 Pod。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pod（容器组）是 Kubernetes 中最小的调度单元，可以通过 yaml 定义文件直接创建一个 Pod。但 Pod 本身并不具备自我恢复（self-healing）功能。如果一个 Pod 所在的节点出现故障，或者调度程序自身出现问题，以及节点资源不够或节点进入维护而驱逐 Pod 时，Pod 将被删除，且不能自我恢复。&lt;/p&gt;
&lt;p&gt;因此，Kubernetes 中我们一般不直接创建 Pod， 而是通过 Controller（控制器）来管理 Pod。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>在 Kubernetes Ingress 中支持 Websocket/Socket 服务</title>
    <link href="http://blog.jboost.cn/k8s-tcp-service.html"/>
    <id>http://blog.jboost.cn/k8s-tcp-service.html</id>
    <published>2020-08-05T07:50:08.000Z</published>
    <updated>2020-08-26T01:44:01.286Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes Ingress 可将集群内部的 Service 通过 HTTP/HTTPS 的方式暴露供外部访问，并通过路径匹配规则定义服务的路由。但是 Ingress 对 TCP/UDP 的服务却支持的不那么好。如果我们服务中有使用 Websocket 或 Socket， 需要暴露给外部访问，在 Kubernetes 中该如何配置呢？</p><a id="more"></a><p>大致有两种方式[见参考文档1]：</p><ol><li>使用 NodePort， 使用节点 IP 与 NodePort 暴露的端口访问</li><li>使用 ClusterIp + Ingress + ConfigMap</li></ol><p>使用 NodePort 将端口直接暴露，需要节点有外网 IP，且该方式可能绕过现有的 TLS， 存在安全性的问题。</p><p>ClusterIp 只能在集群内部访问，由 Ingress 进行代理对外暴露，但对于 TCP/UDP， Ingress 不支持直接代理， 需要借助 ConfigMap 进行映射。 </p><p>NodePort 的方式比较简单， 本文介绍 ClusterIp + Ingress + ConfigMap 的方式。</p><h2 id="创建-ClusterIp-服务"><a href="#创建-ClusterIp-服务" class="headerlink" title="创建 ClusterIp 服务"></a>创建 ClusterIp 服务</h2><p>假设有一个 Websocket/Socket 服务，暴露端口 8828， 针对该服务定义 ClusterIp 配置如下（不声明 type， 默认即为 ClusterIp），</p><figure class="highlight yaml"><figcaption><span>my-websocket-svc.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-websocket-svc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">develop</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">socket</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8828</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8828</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-websocket</span></span><br></pre></td></tr></table></figure><p>创建 ClusterIp，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl apply -f my-websocket-svc.yaml</span><br></pre></td></tr></table></figure><h2 id="创建-ConfigMap"><a href="#创建-ConfigMap" class="headerlink" title="创建 ConfigMap"></a>创建 ConfigMap</h2><p>在 ingress-nginx-controller 所在的 namespace 下创建 ConfigMap（如果已经有 ConfigMap 了， 则可在已有 ConfigMap 的 data 部分添加下面配置中的 data 条目）</p><figure class="highlight yaml"><figcaption><span>tcp-service-configmap.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcp-services</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">8828:</span> <span class="string">"develop/my-websocket-svc:8828"</span></span><br></pre></td></tr></table></figure><p>data 部分的格式为： <code>&lt;namespace/service name&gt;:&lt;service port&gt;:[PROXY]:[PROXY]</code>， <code>[PROXY]:[PROXY]</code> 部分为可选。 上述配置表示将宿主机的 8828 端口 映射到 develop namespace 下 my-websocket-svc 服务的 8828 端口上。</p><p>创建 ConfigMap，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl apply -f tcp-service-configmap.yaml</span><br></pre></td></tr></table></figure><h2 id="配置-ingress-nginx-controller"><a href="#配置-ingress-nginx-controller" class="headerlink" title="配置 ingress-nginx-controller"></a>配置 ingress-nginx-controller</h2><p>修改 ingress-nginx-controller 的配置，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl edit deploy ingress-nginx-controller -n ingress-nginx</span><br></pre></td></tr></table></figure><p>在 <code>.spec.template.spec.containers[].args[]</code> 部分添加 <code>--tcp-services-configmap=$(POD_NAMESPACE)/tcp-services</code> （或针对 UDP， <code>--udp-services-configmap=$(POD_NAMESPACE)/udp-services</code>）， 如下图所示</p><p><img src="/assets/ingress-tcp.png" alt="ingress-tcp"></p><p>在<code>.spec.template.spec.containers[].ports[]</code> 部分添加 port 映射，如图</p><p><img src="/assets/ingress-tcp-port.png" alt="ingress-tcp-port"></p><blockquote><p>经验证，不加该部分 port 映射配置也没问题</p></blockquote><p>保存，应用配置更新，nginx-ingress-controller 将会自动重启 Pod，使配置生效。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在 nginx-ingress-controller Pod 所在节点上执行如下命令查看是否监听了 TCP 端口，</p><p><img src="/assets/ingress-tcp-check.png" alt="ingress-tcp-check"></p><p>如上，8828 端口已被 nginx-ingress 监听。</p><p>对于 Websocket 应用， 可使用 wscat 进行调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;wscat -c ws://域名:8828</span><br><span class="line">Connected (press CTRL+C to quit)</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>wscat 安装： <code>npm install -g wscat</code></p></blockquote><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li>注意 ConfigMap 的 namesapce 与 nginx-ingress-controller 一致，否则将 <code>--tcp-services-configmap=$(POD_NAMESPACE)/tcp-services</code> 中的 <code>$(POD_NAMESPACE)</code> 改为 ConfigMap 具体的 namesapce</li><li>如果将 nginx-ingress-controller 绑定了节点，则重启可能导致失败（因为端口分配冲突），可先删除（<code>kubectl delete deploy ingress-nginx-controller -n ingress-nginx</code>），再新建（<code>kubectl apply -f nginx-ingress.yaml</code>），该操作会影响服务可用性，生产环境需慎重</li><li>如果配置后未生效，可通过查看 nginx-ingress-controller Pod 的日志定位原因 <code>kubectl logs ingress-nginx-controller-58fdbbc68d-wqtlr -n ingress-nginx</code></li></ol><p><em>参考文档：</em></p><ol><li><a href="https://www.ibm.com/support/knowledgecenter/en/SSSHTQ/omnibus/helms/all_helms/wip/reference/hlm_expose_probe.html" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/en/SSSHTQ/omnibus/helms/all_helms/wip/reference/hlm_expose_probe.html</a></li><li><a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/exposing-tcp-udp-services.md" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/exposing-tcp-udp-services.md</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes Ingress 可将集群内部的 Service 通过 HTTP/HTTPS 的方式暴露供外部访问，并通过路径匹配规则定义服务的路由。但是 Ingress 对 TCP/UDP 的服务却支持的不那么好。如果我们服务中有使用 Websocket 或 Socket， 需要暴露给外部访问，在 Kubernetes 中该如何配置呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（五）：了解Pod（容器组）</title>
    <link href="http://blog.jboost.cn/k8s5-pod.html"/>
    <id>http://blog.jboost.cn/k8s5-pod.html</id>
    <published>2020-07-28T09:17:37.000Z</published>
    <updated>2020-08-26T01:44:23.358Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes 中， 容器总是以 Pod（容器组）的方式进行调度与运行。因此对 Pod 的理解与掌握是学习 Kubernetes 的基础。</p><a id="more"></a><h2 id="理解-Pod"><a href="#理解-Pod" class="headerlink" title="理解 Pod"></a>理解 Pod</h2><p>Pod（容器组）是 Kubernetes 中最小的调度单元，每一个Pod都是某个应用程序的一个运行实例。以前我们的 Web 应用都是以 Tomcat 等 Web 容器进程的形式运行在操作系统中，在 Kubernetes 中，我们需要将 Web 应用打成镜像，以容器的方式运行在 Pod 中。</p><p>Kubernetes 不会直接管理容器，而是通过 Pod 来管理。一个Pod包含如下内容：</p><ol><li>一个或多个容器， 一般是一个，除非多个容器紧密耦合共享资源才放在一个 Pod 中；</li><li>共享的存储资源（如数据卷），一个 Pod 中的容器是可以共享存储空间的；</li><li>一个共享的 IP 地址，Pod 中容器之间可以通过 localhost:port 彼此访问；</li><li>定义容器该如何运行的选项。</li></ol><p>Pod 中的容器可包括两种类型：</p><ol><li>工作容器：就是我们通常运行服务进程的容器</li><li>初始化容器：完成一些初始化操作的容器，初始化容器在工作容器之前运行，所有的初始化容器成功执行后，才开始启动工作容器</li></ol><h2 id="管理-Pod"><a href="#管理-Pod" class="headerlink" title="管理 Pod"></a>管理 Pod</h2><h3 id="创建-Pod"><a href="#创建-Pod" class="headerlink" title="创建 Pod"></a>创建 Pod</h3><p>在 Kubernetes 中，我们一般不直接创建 Pod，而是通过控制器来调度管理（Deployment，StatefulSet，DaemonSet 等），这里为了便于了解，先通过 yaml 配置文件的方式定义 Pod 来直接创建 Pod。定义配置文件 pod-test.yaml 如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-test</span>  <span class="comment"># pod 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># pod 创建的 namespace</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span>     <span class="comment"># pod 中容器定义</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span> <span class="comment"># 重启策略</span></span><br><span class="line">  <span class="attr">volumes:</span>                 <span class="comment"># 数据卷定义</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><p>其中 spec 部分的 containers 定义了该 Pod 中运行的容器，从 containers 的复数形式也可以看出一个 Pod 中是可以运行多个容器的。</p><p>执行 <code>kubectl create</code> 或 <code>kubectl apply</code> 命令创建 Pod，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl create -f pod-test.yaml</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">[root@kmaster test]# kubectl apply -f pod-test.yaml</span><br></pre></td></tr></table></figure><p>该 Pod 创建后将会拉取一个最新的 nginx 镜像，运行一个 nginx 容器，并将容器的 80 端口映射到宿主机的 8081 端口。</p><h3 id="查看-Pod"><a href="#查看-Pod" class="headerlink" title="查看 Pod"></a>查看 Pod</h3><p>可使用 <code>kubectl get pods</code> 命令查看当前 namesapce 下的所有 Pod，加 Pod 名称查看具体某个 Pod。 如果需要查看 Pod 调度到了哪个节点，可加 <code>-o wide</code> 选项，如果查看 yaml 文件信息则可加 <code>-o yaml</code> 选项， 如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl get pods</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-test                       1/1     Running   0          116s</span><br><span class="line"></span><br><span class="line">[root@kmaster test]# kubectl get pods pod-test -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE     IP            NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">pod-test                       1/1     Running   0          2m19s   10.244.1.42   knode2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">[root@kmaster test]# kubectl get pods pod-test -o yaml</span><br></pre></td></tr></table></figure><p>如果要查看更多的信息，可使用 <code>kubectl describe</code> 命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl describe pod pod-test</span><br></pre></td></tr></table></figure><p>该命令输出内容如下图，</p><p><img src="/assets/describe-pod.png" alt="describe-pod"></p><p>各部分说明：</p><ol><li>Status: Pending， 表示 Pod 的整体状态，当前处于 Pending 状态；</li><li>State: Waiting，Pod 中每个容器都有一个自己的状态 State， 当前容器 nginx 处于 Waiting 状态，Reason: ContainerCreating 表示容器还处于创建中，Ready：False 表明容器还未就绪，还不能对外提供服务；</li><li>Conditions， 这部分聚合了一些状态，第一个 Initialized：True，表明已经完成了初始化；而第二个 Ready：False，表明 Pod 还未就绪；ContainersReady：False，表明容器还未就绪；  PodScheduled：True，表明 Pod 已经被调度到某个具体的节点上了；</li><li>3中不同的状态之间的转换都会发生相应的事件，事件类型包括 Normal 与 Warning 两种， 从上图可看到一个 Pulling image 的 Normal 事件，表示当前正在拉取 Pod 中容器的镜像。</li></ol><p>当 Pod 在调度或运行中出现问题时，我们都可以使用 <code>kubectl describe</code> 命令来进行排查，通过其中的状态及事件来判断问题产生的可能原因。</p><h3 id="进入-Pod-容器"><a href="#进入-Pod-容器" class="headerlink" title="进入 Pod 容器"></a>进入 Pod 容器</h3><p>通过 <code>kubectl exec</code> 命令可进入 Pod， 类似于 <code>docker exec</code>， 如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果 Pod 中只有一个容器</span></span><br><span class="line">[root@kmaster test]# kubectl exec -it pod-test bash</span><br><span class="line">root@pod-test:/#</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果 Pod 中有多个容器</span></span><br><span class="line">kubectl exec -it pod-name -c container-name /bin/bash</span><br></pre></td></tr></table></figure><p>如果一个 Pod 中有多个容器，则需要通过 <code>-c</code> 指定进入哪个容器。</p><h3 id="更新-删除-Pod"><a href="#更新-删除-Pod" class="headerlink" title="更新/删除 Pod"></a>更新/删除 Pod</h3><p>Kubernetes 对 Pod 的更新做了限制，除了更改 Pod 中容器（包括工作容器与初始化容器）的镜像，以及 activeDeadlineSeconds （对 Job 类型的 Pod 定义失败重试的最大时间）， tolerations （Pod 对污点的容忍），修改其它部分将不会产生作用，如我们可以尝试在前面 Pod 定义文档 pod-test.yaml 中将宿主机端口 8081 改为 8082，重新执行 <code>kubectl apply</code>， 将提示如下错误，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl apply -f pod-test.yaml</span><br><span class="line">The Pod "pod-test" is invalid: spec: Forbidden: pod updates may not change fields other than `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds` or `spec.tolerations` (only additions to existing tolerations)</span><br></pre></td></tr></table></figure><p>通过 <code>kubectl delete</code> 命令可删除一个 Pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl delete pod pod-test</span><br></pre></td></tr></table></figure><p>在 Kubernetes 中，一般不直接创建，更新或删除单个 Pod，而是通过 Kubernetes 的 Controller（控制器）来管理 Pod，包括 ReplicSet（一般也不直接用，推荐Deployment方式）， Deployment，StatefulSet，DaemonSet 等。</p><p>控制器提供如下功能：</p><ol><li>水平伸缩，控制运行 Pod 指定个数的副本</li><li>rollout，即版本更新</li><li>故障恢复，当一个节点出现故障，或资源不够，或进入维护中，控制器会自动在另一个合适的节点调度一个一样的 Pod，以保障 Pod 以一定的副本数运行</li></ol><h2 id="Pod-状态"><a href="#Pod-状态" class="headerlink" title="Pod 状态"></a>Pod 状态</h2><p>Pod状态并不是容器的状态，容器的状态一般包括：</p><p>Waiting： 容器的初始状态，处于 Waiting 状态的容器，表示仍然有对应的操作在执行，例如：拉取镜像、应用 Secrets等<br>Running： 容器处于正常运行的状态<br>Terminated： 容器处于结束运行的状态</p><p>而Pod的状态一般包括：</p><ul><li>Pending： Kubernetes 已经创建并确认该 Pod，可能两种情况： 1. Pod 还未完成调度（例如没有合适的节点）；2. 正在从 docker registry 下载镜像</li><li>Running： 该 Pod 已经被绑定到一个节点，并且该 Pod 所有的容器都已经成功创建，其中至少有一个容器正在运行，或者正在启动/重启</li><li>Succeeded：Pod 中的所有容器都已经成功终止，并且不会再被重启</li><li>Failed：Pod 中的所有容器都已经终止，至少一个容器终止于失败状态：容器的进程退出码不是 0，或者被系统 kill</li><li>Unknown： 因为某些未知原因，不能确定 Pod 的状态，通常的原因是 master 与 Pod 所在节点之间的通信故障</li></ul><p>状态之间的变迁关系如图</p><p><img src="/assets/pod-status-trans.png" alt="pod-status-trans"></p><p>Pod 刚开始处于 Pending 的状态，接下来可能会转换到 Running，也可能转换到 Unknown，甚至可能转换到 Failed。然后，当 Running 执行了一段时间之后，它可以转换到类似像 Successded 或者是 Failed。 当出现 Unknown 这个状态时，可能由于一些状态的恢复，它会重新恢复到 Running 或者 Successded 或者是 Failed。</p><h2 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h2><p>定义 Pod 或工作负载时，可以指定 restartPolicy，可选的值有：</p><ol><li>Always：默认值，只要退出就重启</li><li>OnFailure：失败退出时（exit code 不为 0）才重启</li><li>Never： 永远不重启</li></ol><p>restartPolicy 作用于 Pod 中的所有容器。kubelete 将在五分钟内，按照递延的时间间隔（10s, 20s, 40s …）尝试重启已退出的容器，并在十分钟后再次启动这个循环，直到容器成功启动，或者 Pod 被删除。在控制器 Deployment/StatefulSet/DaemonSet 中，只支持 Always 这一个选项，不支持 OnFailure 和 Never 选项。</p><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>提高应用服务的可用性与稳定性，一般可从两个方面来进行：</p><ol><li>首先是提高应用的可观测性，如对应用的健康状态，资源的使用情况，应用日志等可进行实时的观测</li><li>第二是提高应用的可恢复能力，在应用出现故障时，能通过自动重启等方式进行恢复</li></ol><p>Kubernetes 中对 Pod 的健康检查提供了两种方式：</p><ol><li>Readiness probe，就绪探测，用来判断一个 Pod 是否处于就绪状态，是否能对外提供相应服务了。当Pod处于就绪状态时，负载均衡器才会将流量打到这个 Pod，否则将把流量从这个 Pod 上面摘除。</li><li>Liveness probe，存活探测，用来判断一个 Pod 是否处于存活状态，如果一个 Pod 被探测到不处于存活状态，则由上层判断机制来处理，如果上层配置重启策略为 restart always 的话，Pod 就会被重启。</li></ol><p>Liveness probe 适用场景是支持那些可以重新拉起的应用，而 Readiness probe 主要应对的是启动之后无法立即对外提供服务的应用。</p><p>就绪探测、存活探测目前支持三种不同的探测方式：</p><ol><li>httpGet，通过发送http Get请求来判断，返回状态码在 200-399之间，认为是探测成功</li><li>Exec，通过执行容器中的一个命令来判断服务是否正常，如果命令的退出状态码为 0，表示成功</li><li>tcpSocket，通过容器的IP，端口来进行TCP连接检查，如果TCP连接能被正常建立，则认为成功</li></ol><p>以 httpGet 为例，示例配置文件如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="comment"># ... 与前同</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">httpHeaders:</span> <span class="comment"># 此处header无意义，仅作示例</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">purpose</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">for-test</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="comment"># ... 与前同</span></span><br></pre></td></tr></table></figure><p>删除之前的 Pod， 重新创建，使用 <code>kubectl describe</code> 查看，可看到 Events 部分如下图，</p><p><img src="/assets/liveness-probe.png" alt="liveness-probe"></p><p>Http 存活探测失败，状态码返回 403， 导致容器重启。出现这个错误的原因是前面做目录挂载时将 nginx 的 html 目录挂载到了宿主机的 /tmp 目录， 而 /tmp 目录没有 index.html 文件，导致请求返回403， 在 Pod 调度到的宿主机 /tmp 目录下创建 index.html 文件即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo '&lt;h1&gt;Hello, K8s!&lt;/h1&gt;' &gt; /tmp/index.html</span><br></pre></td></tr></table></figure><p>其它 Exec，tcpSocket 探测的配置示例如下（配置在 containers 元素下），</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec</span></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tcpSocket</span></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">tcpSocket:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>支持的参数说明：</p><ul><li>initialDelaySeconds：延迟探测时间，表示 Pod 启动延迟多久后进行一次检查，比如某个应用启动时间如果较长的话，可以设置该值为略大于启动时间；</li><li>periodSeconds：探测频率，表示探测的时间间隔，正常默认的这个值是 10 秒；</li><li>timeoutSeconds：超时时间，表示探测的超时时间，当超时时间之内没有检测成功，那会认为失败；</li><li>successThreshold：健康阈值，表示当这个 Pod 从探测失败到再一次判断探测成功，所需要的阈值次数，默认情况下是 1 次。如果之前探测失败，接下来的一次探测成功了，就会认为这个 Pod 是处在一个正常的状态；</li><li>failureThreshold： 不健康阈值，与 successThreshold 相对，表示认为探测失败需要重试的次数，默认值是 3。意思是当从一个健康的状态连续探测到 3 次失败，就会认为Pod 的状态处在一个失败的状态。</li></ul><p>readinessProbe 配置与 livenessProbe 类似。阿里云上配置就绪检查如图所示：</p><p><img src="/assets/aliyun-readiness-probe.png" alt="aliyun-readiness-probe"></p><p>健康检查的结果分为三种：</p><ol><li>Success，表示 container 通过了健康检查，也就是 Liveness probe 或 Readiness probe 是正常的一个状态；</li><li>Failure，表示 container 没有通过健康检查。针对 Readiness probe，service 层就会将没有通过 Readiness probe 的 pod 进行摘除，不再分发请求到该 Pod；针对 Liveness probe，就会将这个 pod 进行重新拉起，或者是删除。</li><li>Unknown，表示当前的执行机制没有进行完整的一个执行，可能是因为类似像超时或者像一些脚本没有及时返回，此时 Readiness probe 或 Liveness probe 不做任何操作，会等待下一次的机制来进行检查。</li></ol><p>健康检查的一些实践建议：</p><ol><li>如果容器中的进程在碰到问题时可以自己 crash，就不需要执行存活探测，因为 kubelet 可以自动的根据 Pod 的 restartPolicy（重启策略）来执行对应的动作；</li><li>如果希望在容器的进程无响应后，将容器重启，则指定一个存活探测 livenessProbe，并同时指定 restartPolicy（重启策略）为 Always 或者 OnFailure；</li><li>如果希望在 Pod 确实就绪之后才向其分发服务请求，就指定一个就绪检查 readinessProbe；</li><li>适当调大 exec 探测的超时阈值，因为在容器里面执行一个 shell 脚本，它的执行时长是非常长的，平时在一台虚机上执行可能 3 秒返回的一个脚本在容器里面可能需要 30 秒。可以适当调大超时阈值，来防止由于容器压力比较大的时候出现偶发的超时；</li><li>调整失败判断的次数，3 次的默认值有时候可能不一定是最佳实践，适当调整一下判断的次数也是一个比较好的方式；</li><li>使用 tcpSocket 方式进行判断的时候，如果遇到了 TLS 的服务，那可能会造成后边 TLS 里面有很多这种未鉴权的 tcp 连接，这时候需要自己针对业务场景判断这种连接是否会对业务造成影响。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对 Pod 的概念与基本的管理操作，Pod 的状态变迁机制与重启策略进行了介绍，对 Pod 的健康检查进行了详细的了解。但在 Kubernetes 中，我们一般不直接创建 Pod，而是通过控制器，如Deployment，StatefulSet，DaemonSet， 因为控制器能为我们提供水平伸缩，rollout（版本更新），self-healing（故障恢复）等能力。我们将在接下来的文章了解控制器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 中， 容器总是以 Pod（容器组）的方式进行调度与运行。因此对 Pod 的理解与掌握是学习 Kubernetes 的基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存常用策略及Vue应用的Nginx缓存设置</title>
    <link href="http://blog.jboost.cn/browser-cache.html"/>
    <id>http://blog.jboost.cn/browser-cache.html</id>
    <published>2020-07-22T05:59:42.000Z</published>
    <updated>2020-08-26T01:40:38.768Z</updated>
    
    <content type="html"><![CDATA[<p>最近一次移动端Vue应用的上线，导致某些用户使用某些功能时出现问题，经主动清空缓存后恢复。有时候清空微信应用的存储空间缓存仍不能解决问题，此时安卓机可借助微信TBS调试工具 <a href="http://debugx5.qq.com" target="_blank" rel="noopener">http://debugx5.qq.com</a> （微信中打开页面，勾选最下面四个选项清除缓存），但该工具目前只支持安卓手机，苹果机就比较麻烦了。为了找到问题的本质，从根本上避免问题，最近浏览了一些文章，其中有一篇对浏览器缓存的分析及在Nginx中对应的处理策略总结的比较好，这里分享给大家。</p><a id="more"></a><ul><li>原文标题：http常用缓存策略及vue-cli单页面应用服务器端(nginx)如何设置缓存</li><li>原文地址：<a href="http://www.shanhuxueyuan.com/news/detail/125.html" target="_blank" rel="noopener">http://www.shanhuxueyuan.com/news/detail/125.html</a></li></ul><p><em>以下为原文。</em></p><p>关于http或者是浏览器缓存策略，我认为可以分为这三种：</p><ul><li>不使用缓存</li><li>强制使用缓存</li><li>协商使用缓存</li></ul><h2 id="不使用缓存"><a href="#不使用缓存" class="headerlink" title="不使用缓存"></a>不使用缓存</h2><p>有时，我们希望浏览器永远都不要使用缓存，全部到服务器拉取数据，此时即为不使用缓存，我们可以在服务端通过Cache-Control为 no-store实现。</p><p><img src="/assets/httpcache1.png" alt="httpcache1"></p><p>服务器端针对上面文件设置了no-store，可以看到在请求的时候，无论怎么刷新，都是返回200，不会显示304，也不会显示“memory cache”或“disk cache”，说明真的都是从服务器重新拉取数据。</p><p>比如我们想设置html文件不缓存，可以在域名的解析配置中如下设置，当文件后缀为html或htm时add_header Cache-Control “no-store”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name yourdomain.com;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    root &#x2F;yourdir&#x2F;;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    if ($request_filename ~* .*\.(?:htm|html)$)</span><br><span class="line">    &#123;</span><br><span class="line">        add_header Cache-Control &quot;no-store&quot;;  &#x2F;&#x2F;对html文件设置永远不缓存</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式缺点就是每次都要去服务端拉取文件，即使文件没有更新，很明显这样增加了不必要的带宽消耗。</p><p>如果文件没有更新，我们就使用缓存，只有更新了才去拉取最新文件，这样多好，这就是协商缓存。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是浏览器携带文件缓存标识（如Last-Modified或ETag），向服务器发送请求，由服务器根据文件缓存标识来决定是否使用缓存，如果文件没有更新，则告诉浏览器使用本地缓存，如果文件更新了，则直接返回新文件内容。</p><p>可以看出，相比不使用缓存，协商缓存是会大大减少带宽消耗的。</p><ul><li>协商缓存生效，返回304 和 Not Modified</li></ul><p><img src="/assets/httpcache2.png" alt="httpcache2"></p><ul><li>协商缓存无效，返回200和请求文件</li></ul><p><img src="/assets/httpcache3.png" alt="httpcache3"></p><p>我们在浏览器调试页面，可以看到有304的，即是使用了协商缓存</p><p><img src="/assets/httpcache4.png" alt="httpcache4"></p><p>服务器返回的header中会有Last-Modified和ETag标识，而浏览器请求header中会包含If-Modified-Since和If-None-Match</p><p><img src="/assets/httpcache5.png" alt="httpcache5"></p><h3 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h3><p>在 http 1.0 版本中，第一次请求资源时服务器通过 Last-Modified 来设置响应头的缓存标识，并且把资源最后修改的时间作为值填入，然后将资源返回给浏览器。在第二次请求时，浏览器会首先带上 If-Modified-Since 请求头去访问服务器，服务器会将 If-Modified-Since 中携带的时间与资源修改的时间匹配，如果时间不一致，服务器会返回新的资源，并且将 Last-Modified 值更新，作为响应头返回给浏览器。如果时间一致，表示资源没有更新，服务器返回 304 状态码，浏览器拿到响应状态码后从本地缓存数据库中读取缓存资源。</p><p>这种方式有2个弊端，第一个就是当服务器中的资源增加了一个字符，后来又把这个字符删掉，本身资源文件并没有发生变化，但修改时间发生了变化。当下次请求过来时，服务器也会把这个本来没有变化的资源重新返回给浏览器；第二个就是修改时间的单位为秒，所以存在1s的间隙，即使更新了，也会认为没有更新。</p><h3 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h3><p>在 http 1.1 版本中，服务器通过 Etag 来设置响应头缓存标识。Etag 的值由服务端生成，可以认为是文件内容的hash值。在第一次请求时，服务器会将资源和 Etag 一并返回给浏览器，浏览器将两者缓存到本地缓存数据库。在第二次请求时，浏览器会将 Etag 信息放到 If-None-Match 请求头去访问服务器，服务器收到请求后，会将服务器中的文件标识与浏览器发来的标识进行对比，如果不相同，服务器返回更新的资源和新的 Etag ，如果相同，服务器返回 304 状态码，浏览器读取缓存。</p><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ul><li>首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</li><li>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</li><li>第三在优先级上，服务器校验优先考虑Etag</li></ul><h3 id="协商缓存服务端配置"><a href="#协商缓存服务端配置" class="headerlink" title="协商缓存服务端配置"></a>协商缓存服务端配置</h3><p>可以在服务端通过设置Cache-Control为 no-cache或者max-age=0来实现</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>有时我们希望文件强制使用缓存，比如通过vue-cli产生的js和css，文件名上带有hash值，所以如果文件名没有变的时候，我们希望文件永久缓存，这样可以减少网络请求。</p><p>强制缓存整体流程比较简单，就是在第一次访问服务器取到数据之后，在过期时间之内不会再去重复请求。实现这个流程的核心就是如何知道当前时间是否超过了过期时间。</p><p>强制缓存的过期时间通过第一次访问服务器时返回的响应头获取。在 http 1.0 和 http 1.1 版本中通过不同的响应头字段实现。</p><p>在 http 1.0 版本中，强制缓存通过 Expires 响应头来实现。 expires 表示未来资源会过期的时间。也就是说，当发起请求的时间超过了 expires 设定的时间，即表示资源缓存时间到期，会发送请求到服务器重新获取资源。而如果发起请求的时间在 expires 限定的时间之内，浏览器会直接读取本地缓存数据库中的信息（from memory or from disk），两种方式根据浏览器的策略随机获取。</p><p>在 http 1.1 版本中，可以设置Cache-Control中的 max-age=xxx ，来表示缓存的资源将在 xxx 秒后过期。一般来说，为了兼容，两个版本的强制缓存都会被实现。</p><p>为什么有了Expires，后来又增加了max-age呢，这是因为Expires是一个绝对时间，有可能客户端的时间和服务器不一致，导致缓存不能按照预期进行，而max-age则是个相对时间，比如3600s，自浏览器请求后3600s之内，都使用本地缓存，和客户端的时间没关系。</p><h2 id="vue-cli缓存策略"><a href="#vue-cli缓存策略" class="headerlink" title="vue-cli缓存策略"></a>vue-cli缓存策略</h2><p>由于打包后的js、css和图片，一般名称都带有hash值，名称中的hash变了，自然会拉取新文件，所以我们可以将这类文件设置为强制缓存，只要文件名不变，就一直缓存，比如缓存100天或者一年。</p><p>而html文件则不能设为强制缓存，一般html名称是没法带hash值的，所以html如果设置了强制缓存，则永远也没法更新，html不更新，其引用的js、css等名称也不会更新，则整个服务都没有更新，只能让用户清除缓存了。所以针对html文件，我们可以设置协商缓存或者直接不使用缓存，本身html文件都比较小，我是直接使用了不缓存，nginx配置如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name yourdomain.com;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    root &#x2F;yourdir&#x2F;;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    if ($request_filename ~* .*\.(js|css|woff|png|jpg|jpeg)$)</span><br><span class="line">    &#123;</span><br><span class="line">        expires    100d;  &#x2F;&#x2F;js、css、图片缓存100天</span><br><span class="line">        #add_header Cache-Control &quot;max-age &#x3D; 8640000&quot;; &#x2F;&#x2F;或者设置max-age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($request_filename ~* .*\.(?:htm|html)$)</span><br><span class="line">    &#123;</span><br><span class="line">        add_header Cache-Control &quot;no-store&quot;;  &#x2F;&#x2F;html不缓存</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一次移动端Vue应用的上线，导致某些用户使用某些功能时出现问题，经主动清空缓存后恢复。有时候清空微信应用的存储空间缓存仍不能解决问题，此时安卓机可借助微信TBS调试工具 &lt;a href=&quot;http://debugx5.qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://debugx5.qq.com&lt;/a&gt; （微信中打开页面，勾选最下面四个选项清除缓存），但该工具目前只支持安卓手机，苹果机就比较麻烦了。为了找到问题的本质，从根本上避免问题，最近浏览了一些文章，其中有一篇对浏览器缓存的分析及在Nginx中对应的处理策略总结的比较好，这里分享给大家。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="nginx" scheme="http://blog.jboost.cn/tags/nginx/"/>
    
      <category term="vue" scheme="http://blog.jboost.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>一个轻量级的基于RateLimiter的分布式限流实现</title>
    <link href="http://blog.jboost.cn/distributedratelimiter.html"/>
    <id>http://blog.jboost.cn/distributedratelimiter.html</id>
    <published>2020-07-13T03:21:43.000Z</published>
    <updated>2020-08-26T01:39:49.568Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章（<a href="http://blog.jboost.cn/ratelimiter.html">限流算法与Guava RateLimiter解析</a>）对常用的限流算法及Google Guava基于令牌桶算法的实现RateLimiter进行了介绍。RateLimiter通过线程锁控制同步，只适用于单机应用，在分布式环境下，虽然有像阿里Sentinel的限流开源框架，但对于一些小型应用来说未免过重，但限流的需求在小型项目中也是存在的，比如获取手机验证码的控制，对资源消耗较大操作的访问频率控制等。本文介绍最近写的一个基于RateLimiter，适用于分布式环境下的限流实现，并使用spring-boot-starter的形式发布，比较轻量级且“开箱即用”。</p><a id="more"></a><p>本文限流实现包括两种形式：</p><ol><li>基于RateLimiter令牌桶算法的限速控制（严格限制访问速度）</li><li>基于Lua脚本的限量控制（限制一个时间窗口内的访问量，对访问速度没有严格限制）</li></ol><h2 id="限速控制"><a href="#限速控制" class="headerlink" title="限速控制"></a>限速控制</h2><h3 id="1-令牌桶模型"><a href="#1-令牌桶模型" class="headerlink" title="1. 令牌桶模型"></a>1. 令牌桶模型</h3><p>首先定义令牌桶模型，与RateLimiter中类似，包括几个关键属性与关键方法。其中关键属性定义如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPermits</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大存储令牌数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> maxPermits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前存储令牌数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> storedPermits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加令牌的时间间隔/毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> intervalMillis;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下次请求可以获取令牌的时间，可以是过去（令牌积累）也可以是将来的时间（令牌预消费）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextFreeTicketMillis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>关键方法定义与RateLimiter也大同小异，方法注释基本已描述各方法用途，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建Redis令牌数据模型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permitsPerSecond     每秒放入的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxBurstSeconds      maxPermits由此字段计算，最大存储maxBurstSeconds秒生成的令牌</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextFreeTicketMillis 下次请求可以获取令牌的起始时间，默认当前系统时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisPermits</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> maxBurstSeconds, Long nextFreeTicketMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.maxPermits = permitsPerSecond * maxBurstSeconds;</span><br><span class="line">    <span class="keyword">this</span>.storedPermits = maxPermits;</span><br><span class="line">    <span class="keyword">this</span>.intervalMillis = TimeUnit.SECONDS.toMillis(<span class="number">1</span>) / permitsPerSecond;</span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMillis = nextFreeTicketMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于当前时间，若当前时间晚于nextFreeTicketMicros，则计算该段时间内可以生成多少令牌，将生成的令牌加入令牌桶中并更新数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMillis &gt; nextFreeTicketMillis) &#123;</span><br><span class="line">        <span class="keyword">double</span> newPermits = (nowMillis - nextFreeTicketMillis) / intervalMillis;</span><br><span class="line">        storedPermits = Math.min(maxPermits, storedPermits + newPermits);</span><br><span class="line">        nextFreeTicketMillis = nowMillis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 保留指定数量令牌，并返回需要等待的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">long</span> nowMillis, <span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    resync(nowMillis);</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = Math.min(permits, storedPermits); <span class="comment">// 可以消耗的令牌数</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = permits - storedPermitsToSpend; <span class="comment">// 需要等待的令牌数</span></span><br><span class="line">    <span class="keyword">long</span> waitMillis = (<span class="keyword">long</span>) (freshPermits * intervalMillis); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    nextFreeTicketMillis = LongMath.saturatedAdd(nextFreeTicketMillis, waitMillis);</span><br><span class="line">    storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> waitMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在超时时间内，是否有指定数量的令牌可用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAcquire</span><span class="params">(<span class="keyword">long</span> nowMillis, <span class="keyword">int</span> permits, <span class="keyword">long</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryEarliestAvailable(nowMillis, permits) &lt;= timeoutMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定数量令牌数可用需等待的时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits 需保留的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定数量令牌可用的等待时间，如果为0或负数，表示当前可用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">queryEarliestAvailable</span><span class="params">(<span class="keyword">long</span> nowMillis, <span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    resync(nowMillis);</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = Math.min(permits, storedPermits); <span class="comment">// 可以消耗的令牌数</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = permits - storedPermitsToSpend; <span class="comment">// 需要等待的令牌数</span></span><br><span class="line">    <span class="keyword">long</span> waitMillis = (<span class="keyword">long</span>) (freshPermits * intervalMillis); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LongMath.saturatedAdd(nextFreeTicketMillis - nowMillis, waitMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-令牌桶控制类"><a href="#2-令牌桶控制类" class="headerlink" title="2. 令牌桶控制类"></a>2. 令牌桶控制类</h3><p>Guava RateLimiter中的控制都在RateLimiter及其子类中（如SmoothBursty），本处涉及到分布式环境下的同步，因此将其解耦，令牌桶模型存储于Redis中，对其同步操作的控制放置在如下控制类，其中同步控制使用到了前面介绍的分布式锁（参考<a href="http://blog.jboost.cn/distributedlock.html">基于Redis分布式锁的正确打开方式</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRateLimiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个令牌，阻塞一直到获取令牌，返回阻塞等待时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 阻塞等待时间/毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">acquire</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> acquire(key, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定数量的令牌，如果令牌数不够，则一直阻塞，返回阻塞等待的时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需要获取的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 等待的时间/毫秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens值不能为负数或零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">acquire</span><span class="params">(String key, <span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> millisToWait = reserve(key, permits);</span><br><span class="line">        log.info(<span class="string">"acquire &#123;&#125; permits for key[&#123;&#125;], waiting for &#123;&#125;ms"</span>, permits, key, millisToWait);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(millisToWait);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Interrupted when trying to acquire &#123;&#125; permits for key[&#123;&#125;]"</span>, permits, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> millisToWait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定时间内获取一个令牌，如果获取不到则一直阻塞，直到超时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 最大等待时间（超时时间），为0则不等待立即返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取到令牌则true，否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(String key, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(key, <span class="number">1</span>, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定时间内获取指定数量的令牌，如果在指定时间内获取不到指定数量的令牌，则直接返回false，</span></span><br><span class="line"><span class="comment">     * 否则阻塞直到能获取到指定数量的令牌</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需要获取的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 最大等待时间（超时时间）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果在指定时间内能获取到指定令牌数，则true,否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens为负数或零，抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(String key, <span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timeoutMillis = Math.max(unit.toMillis(timeout), <span class="number">0</span>);</span><br><span class="line">        checkPermits(permits);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> millisToWait;</span><br><span class="line">        <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.lock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId(), <span class="number">60</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                <span class="keyword">long</span> nowMillis = getNowMillis();</span><br><span class="line">                RedisPermits permit = getPermits(key, nowMillis);</span><br><span class="line">                <span class="keyword">if</span> (!permit.canAcquire(nowMillis, permits, timeoutMillis)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    millisToWait = permit.reserveAndGetWaitLength(nowMillis, permits);</span><br><span class="line">                    permitsRedisTemplate.opsForValue().set(key, permit, expire, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//超时获取不到锁，也返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                lock.unLock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (millisToWait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(millisToWait);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保留指定的令牌数待用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需保留的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 令牌可用的等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens不能为负数或零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(String key, <span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        checkPermits(permits);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId(), <span class="number">60</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">long</span> nowMillis = getNowMillis();</span><br><span class="line">            RedisPermits permit = getPermits(key, nowMillis);</span><br><span class="line">            <span class="keyword">long</span> waitMillis = permit.reserveAndGetWaitLength(nowMillis, permits);</span><br><span class="line">            permitsRedisTemplate.opsForValue().set(key, permit, expire, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> waitMillis;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unLock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌桶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisPermits <span class="title">getPermits</span><span class="params">(String key, <span class="keyword">long</span> nowMillis)</span> </span>&#123;</span><br><span class="line">        RedisPermits permit = permitsRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (permit == <span class="keyword">null</span>) &#123;</span><br><span class="line">            permit = <span class="keyword">new</span> RedisPermits(permitsPerSecond, maxBurstSeconds, nowMillis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> permit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取redis服务器时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNowMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">"return redis.call('time')"</span>;</span><br><span class="line">        DefaultRedisScript&lt;List&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(luaScript, List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;String&gt; now = (List&lt;String&gt;)stringRedisTemplate.execute(redisScript, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> now == <span class="keyword">null</span> ? System.currentTimeMillis() : Long.valueOf(now.get(<span class="number">0</span>))*<span class="number">1000</span>+Long.valueOf(now.get(<span class="number">1</span>))/<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>acquire 是阻塞方法，如果没有可用的令牌，则一直阻塞直到获取到令牌。</li><li>tryAcquire 则是非阻塞方法，如果在指定超时时间内获取不到指定数量的令牌，则直接返回false，不阻塞等待。</li><li>getNowMillis 获取Redis服务器时间，避免业务服务器时间不一致导致的问题，如果业务服务器能保障时间同步，则可从本地获取提高效率。</li></ol><h3 id="3-令牌桶控制工厂类"><a href="#3-令牌桶控制工厂类" class="headerlink" title="3. 令牌桶控制工厂类"></a>3. 令牌桶控制工厂类</h3><p>工厂类负责管理令牌桶控制类，将其缓存在本地，这里使用了Guava中的Cache，一方面避免每次都新建控制类提高效率，另一方面通过控制缓存的最大容量来避免像用户粒度的限流占用过多的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRateLimiterFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PermitsRedisTemplate permitsRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> DistributedLock distributedLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String, RedisRateLimiter&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            .initialCapacity(<span class="number">100</span>)  <span class="comment">//初始大小</span></span><br><span class="line">            .maximumSize(<span class="number">10000</span>) <span class="comment">// 缓存的最大容量</span></span><br><span class="line">            .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES) <span class="comment">// 缓存在最后一次访问多久之后失效</span></span><br><span class="line">            .concurrencyLevel(Runtime.getRuntime().availableProcessors()) <span class="comment">// 设置并发级别</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisRateLimiterFactory</span><span class="params">(PermitsRedisTemplate permitsRedisTemplate, StringRedisTemplate stringRedisTemplate, DistributedLock distributedLock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.permitsRedisTemplate = permitsRedisTemplate;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="keyword">this</span>.distributedLock = distributedLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建RateLimiter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key              RedisRateLimiter本地缓存key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permitsPerSecond 每秒放入的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxBurstSeconds  最大存储maxBurstSeconds秒生成的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire           该令牌桶的redis tty/秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RateLimiter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisRateLimiter <span class="title">build</span><span class="params">(String key, <span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> maxBurstSeconds, <span class="keyword">int</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.getIfPresent(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache.getIfPresent(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cache.put(key, <span class="keyword">new</span> RedisRateLimiter(permitsRedisTemplate, stringRedisTemplate, distributedLock, permitsPerSecond,</span><br><span class="line">                            maxBurstSeconds, expire));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注解支持"><a href="#4-注解支持" class="headerlink" title="4. 注解支持"></a>4. 注解支持</h3><p>定义注解 @RateLimit 如下，表示以每秒rate的速率放置令牌，最多保留burst秒的令牌，取令牌的超时时间为timeout，limitType用于控制key类型，目前支持：</p><ol><li>IP, 根据客户端IP限流</li><li>USER, 根据用户限流，对于Spring Security可从SecurityContextHolder中获取当前用户信息，如userId</li><li>METHOD, 根据方法名全局限流，className.methodName，注意避免同时对同一个类中的同名方法做限流控制，否则需要修改获取key的逻辑</li><li>CUSTOM，自定义，支持表达式解析，如#{id}, #{user.id}</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimit &#123;</span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> "rateLimit:"</span>; <span class="comment">//key前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expire</span><span class="params">()</span> <span class="keyword">default</span> 60</span>; <span class="comment">// 表示令牌桶模型RedisPermits redis key的过期时间/秒</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> <span class="keyword">default</span> 1.0</span>; <span class="comment">// permitsPerSecond值</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">burst</span><span class="params">()</span> <span class="keyword">default</span> 1.0</span>; <span class="comment">// maxBurstSeconds值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; <span class="comment">// 超时时间/秒</span></span><br><span class="line">    <span class="function">LimitType <span class="title">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitType.METHOD</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过切面的前置增强来为添加了 @RateLimit 注解的方法提供限流控制，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLimitAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"@annotation(rateLimit)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rateLimit</span><span class="params">(JoinPoint  point, RateLimit rateLimit)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String key = getKey(point, rateLimit.limitType(), rateLimit.key(), rateLimit.prefix());</span><br><span class="line">        RedisRateLimiter redisRateLimiter = redisRateLimiterFactory.build(key, rateLimit.rate(), rateLimit.burst(), rateLimit.expire());</span><br><span class="line">        <span class="keyword">if</span>(!redisRateLimiter.tryAcquire(key, rateLimit.timeout(), TimeUnit.SECONDS))&#123;</span><br><span class="line">            ExceptionUtil.rethrowClientSideException(LIMIT_MESSAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><h2 id="限量控制"><a href="#限量控制" class="headerlink" title="限量控制"></a>限量控制</h2><h3 id="1-限量控制类"><a href="#1-限量控制类" class="headerlink" title="1. 限量控制类"></a>1. 限量控制类</h3><p>限制一个时间窗口内的访问量，可使用计数器算法，借助Lua脚本执行的原子性来实现。</p><p>Lua脚本逻辑：</p><ol><li>以需要控制的对象为key（如方法，用户ID，或IP等），当前访问次数为Value，时间窗口值为缓存的过期时间</li><li>如果key存在则将其增1，判断当前值是否大于访问量限制值，如果大于则返回0，表示该时间窗口内已达访问量上限，如果小于则返回1表示允许访问</li><li>如果key不存在，则将其初始化为1，并设置过期时间，返回1表示允许访问</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCountLimiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LUA_SCRIPT = <span class="string">"local c \nc = redis.call('get',KEYS[1]) \nif c and redis.call('incr',KEYS[1]) &gt; tonumber(ARGV[1]) then return 0 end"</span></span><br><span class="line">            + <span class="string">" \nif c then return 1 else \nredis.call('set', KEYS[1], 1) \nredis.call('expire', KEYS[1], tonumber(ARGV[2])) \nreturn 1 end"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUCCESS_RESULT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FAIL_RESULT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCountLimiter</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否允许访问</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key redis key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit 限制次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 时间段/秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取成功true，否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(String key, <span class="keyword">int</span> limit, <span class="keyword">int</span> expire)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        RedisScript&lt;Number&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(LUA_SCRIPT, Number<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Number result = stringRedisTemplate.execute(redisScript, Collections.singletonList(key), String.valueOf(limit), String.valueOf(expire));</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="keyword">null</span> &amp;&amp; result.intValue() == SUCCESS_RESULT) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-注解支持"><a href="#2-注解支持" class="headerlink" title="2. 注解支持"></a>2. 注解支持</h3><p>定义注解 @CountLimit 如下，表示在period时间窗口内，最多允许访问limit次，limitType用于控制key类型，取值与 @RateLimit 同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CountLimit &#123;</span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> "countLimit:"</span>; <span class="comment">//key前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;  <span class="comment">// expire时间段内限制访问次数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">period</span><span class="params">()</span> <span class="keyword">default</span> 1</span>; <span class="comment">// 表示时间段/秒</span></span><br><span class="line">    <span class="function">LimitType <span class="title">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitType.METHOD</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样采用前值增强来为添加了 @CountLimit 注解的方法提供限流控制，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"@annotation(countLimit)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countLimit</span><span class="params">(JoinPoint  point, CountLimit countLimit)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String key = getKey(point, countLimit.limitType(), countLimit.key(), countLimit.prefix());</span><br><span class="line">    <span class="keyword">if</span> (!redisCountLimiter.tryAcquire(key, countLimit.limit(), countLimit.period())) &#123;</span><br><span class="line">        ExceptionUtil.rethrowClientSideException(LIMIT_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>1.添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>limiter-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置redis相关参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">limiter-demo</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment">#数据库索引</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.92</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">    <span class="comment">#连接超时时间</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>3.测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"limiter"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimiterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/count"</span>)</span><br><span class="line">    <span class="meta">@CountLimit</span>(key = <span class="string">"#&#123;key&#125;"</span>, limit = <span class="number">2</span>, period = <span class="number">10</span>, limitType = LimitType.CUSTOM)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testCountLimit</span><span class="params">(@RequestParam(<span class="string">"key"</span>)</span> String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test count limiter..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/rate"</span>)</span><br><span class="line">    <span class="meta">@RateLimit</span>(rate = <span class="number">1.0</span>/<span class="number">5</span>, burst = <span class="number">5.0</span>, expire = <span class="number">120</span>, timeout = <span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRateLimit</span><span class="params">(@RequestParam(<span class="string">"key"</span>)</span> String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test rate limiter..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisRateLimiterFactory redisRateLimiterFactory;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码段形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/rate2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRateLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RedisRateLimiter limiter = redisRateLimiterFactory.build(<span class="string">"LimiterController.testRateLimit"</span>, <span class="number">1.0</span>/<span class="number">30</span>, <span class="number">30</span>, <span class="number">120</span>);</span><br><span class="line">        <span class="keyword">if</span>(!limiter.tryAcquire(<span class="string">"app.limiter"</span>, <span class="number">0</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            System.out.println(LocalDateTime.now());</span><br><span class="line">            ExceptionUtil.rethrowClientSideException(<span class="string">"您的访问过于频繁，请稍后重试"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test rate limiter 2..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.验证</p><p>启动测试项目，浏览器中访问 <a href="http://localhost:8080/limiter/rate?key=test" target="_blank" rel="noopener">http://localhost:8080/limiter/rate?key=test</a> ，第一次访问成功，如图</p><p><img src="/assets/ratelimiter1.png" alt="ratelimiter1"></p><p>持续刷新，将返回如下错误，直到5s之后再返回成功，限制5秒1次的访问速度</p><p><img src="/assets/ratelimiter2.png" alt="ratelimiter2"></p><p>注解的使用</p><ol><li>限流类型LimitType支持IP（客户端IP）、用户（userId）、方法（className.methodName）、自定义（CUSTOM）几种形式，默认为METHOD</li><li>LimitType为CUSTOM时，需要手动指定key（其它key自动为ip，userid，或methodname），key支持表达式形式，如#{id}, #{user.id}</li><li>针对某个时间窗口内限制访问一次的场景，既可以使用 @CountLimit， 也可以使用 @RateLimit，比如验证码一分钟内只允许获取一次，以下两种形式都能达到目的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同一个手机号码60s内最多访问一次</span></span><br><span class="line"><span class="meta">@CountLimit</span>(key = <span class="string">"#&#123;params.phone&#125;"</span>, limit = <span class="number">1</span>, period = <span class="number">60</span>, limitType = LimitType.CUSTOM)</span><br><span class="line"><span class="comment">//以1/60的速度放置令牌，最多保存60s的令牌（也就是最多保存一个），控制访问速度为1/60个每秒（1个每分钟）</span></span><br><span class="line"><span class="meta">@RateLimit</span>(key = <span class="string">"#&#123;params.phone&#125;"</span>, rate = <span class="number">1.0</span>/<span class="number">60</span>, burst = <span class="number">60</span>, expire = <span class="number">120</span>, limitType = LimitType.CUSTOM)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了适用于分布式环境的基于RateLimiter令牌桶算法的限速控制与基于计数器算法的限量控制，可应用于中小型项目中有相关需求的场景（注：本实现未做压力测试，如果用户并发量较大需验证效果）。</p><ul><li>本文完整代码见：<a href="https://github.com/ronwxy/base-spring-boot" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot</a> ，目录 spring-boot-autoconfigure/src/main/java/cn/jboost/springboot/autoconfig/limiter</li><li>示例项目代码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-limiter" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-limiter</a></li></ul><p>如果觉得有帮助，别忘了给个star ^_^。作者公众号：半路雨歌，欢迎关注查看更多干货文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章（&lt;a href=&quot;http://blog.jboost.cn/ratelimiter.html&quot;&gt;限流算法与Guava RateLimiter解析&lt;/a&gt;）对常用的限流算法及Google Guava基于令牌桶算法的实现RateLimiter进行了介绍。RateLimiter通过线程锁控制同步，只适用于单机应用，在分布式环境下，虽然有像阿里Sentinel的限流开源框架，但对于一些小型应用来说未免过重，但限流的需求在小型项目中也是存在的，比如获取手机验证码的控制，对资源消耗较大操作的访问频率控制等。本文介绍最近写的一个基于RateLimiter，适用于分布式环境下的限流实现，并使用spring-boot-starter的形式发布，比较轻量级且“开箱即用”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="redis" scheme="http://blog.jboost.cn/tags/redis/"/>
    
      <category term="RateLimiter" scheme="http://blog.jboost.cn/tags/RateLimiter/"/>
    
  </entry>
  
  <entry>
    <title>限流算法与Guava RateLimiter解析</title>
    <link href="http://blog.jboost.cn/ratelimiter.html"/>
    <id>http://blog.jboost.cn/ratelimiter.html</id>
    <published>2020-07-08T03:06:17.000Z</published>
    <updated>2020-08-26T01:36:12.561Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，应对高并发访问时，缓存、限流、降级是保护系统正常运行的常用方法。当请求量突发暴涨时，如果不加以限制访问，则可能导致整个系统崩溃，服务不可用。同时有一些业务场景，比如短信验证码，或者其它第三方API调用，也需要提供必要的访问限制支持。还有一些资源消耗过大的请求，比如数据导出等（参考 <a href="http://blog.jboost.cn/issue-cpu-high.html">记一次线上Java服务CPU 100%处理过程</a> ），也有限制访问频率的需求。</p><a id="more"></a><p>常见的限流算法有令牌桶算法，漏桶算法，与计数器算法。本文主要对三个算法的基本原理及Google Guava包中令牌桶算法的实现RateLimiter进行介绍，下一篇文章介绍最近写的一个以RateLimiter为参考的分布式限流实现及计数器限流实现。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法的原理就是以一个恒定的速度往桶里放入令牌，每一个请求的处理都需要从桶里先获取一个令牌，当桶里没有令牌时，则请求不会被处理，要么排队等待，要么降级处理，要么直接拒绝服务。当桶里令牌满时，新添加的令牌会被丢弃或拒绝。</p><p>令牌桶算法的处理示意图如下（图片来自网络）</p><p><img src="/assets/token-bucket.png" alt="token-bucket"></p><p>令牌桶算法主要是可以控制请求的平均处理速率，它允许预消费，即可以提前消费令牌，以应对突发请求，但是后面的请求需要为预消费买单（等待更长的时间），以满足请求处理的平均速率是一定的。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法的原理是水（请求）先进入漏桶中，漏桶以一定的速度出水（处理请求），当水流入速度大于流出速度导致水在桶内逐渐堆积直到桶满时，水会溢出（请求被拒绝）。</p><p>漏桶算法的处理示意图如下（图片来自网络）</p><p><img src="/assets/leaky-bucket.png" alt="leaky-bucket"></p><p>漏桶算法主要是控制请求的处理速率，平滑网络上的突发流量，请求可以以任意速度进入漏桶中，但请求的处理则以恒定的速度进行。</p><h2 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h2><p>计数器算法是限流算法中最简单的一种算法，限制在一个时间窗口内，至多处理多少个请求。比如每分钟最多处理10个请求，则从第一个请求进来的时间为起点，60s的时间窗口内只允许最多处理10个请求。下一个时间窗口又以前一时间窗口过后第一个请求进来的时间为起点。常见的比如一分钟内只能获取一次短信验证码的功能可以通过计数器算法来实现。</p><h2 id="Guava-RateLimiter解析"><a href="#Guava-RateLimiter解析" class="headerlink" title="Guava RateLimiter解析"></a>Guava RateLimiter解析</h2><p>Guava是Google开源的一个工具包，其中的RateLimiter是实现了令牌桶算法的一个限流工具类。在pom.xml中添加guava依赖，即可使用RateLimiter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下测试代码示例了RateLimiter的用法,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = RateLimiter.create(<span class="number">1</span>); <span class="comment">//创建一个每秒产生一个令牌的令牌桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> waitTime = rateLimiter.acquire(i); <span class="comment">//一次获取i个令牌</span></span><br><span class="line">        System.out.println(<span class="string">"acquire:"</span> + i + <span class="string">" waitTime:"</span> + waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，输出如下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acquire:1 waitTime:0.0</span><br><span class="line">acquire:2 waitTime:0.997729</span><br><span class="line">acquire:3 waitTime:1.998076</span><br><span class="line">acquire:4 waitTime:3.000303</span><br><span class="line">acquire:5 waitTime:4.000223</span><br></pre></td></tr></table></figure><p>第一次获取一个令牌时，等待0s立即可获取到（这里之所以不需要等待是因为令牌桶的预消费特性），第二次获取两个令牌，等待时间1s，这个1s就是前面获取一个令牌时因为预消费没有等待延到这次来等待的时间，这次获取两个又是预消费，所以下一次获取（取3个时）就要等待这次预消费需要的2s了，依此类推。可见预消费不需要等待的时间都由下一次来买单，以保障一定的平均处理速率（上例为1s一次）。</p><p>RateLimiter有两种实现：</p><ol><li>SmoothBursty： 令牌的生成速度恒定。使用 <code>RateLimiter.create(double permitsPerSecond)</code> 创建的是 SmoothBursty 实例。</li><li>SmoothWarmingUp：令牌的生成速度持续提升，直到达到一个稳定的值。WarmingUp，顾名思义就是有一个热身的过程。使用 <code>RateLimiter.create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)</code> 时创建就是 SmoothWarmingUp 实例，其中 warmupPeriod 就是热身达到稳定速度的时间。</li></ol><p>类结构如下</p><p><img src="/assets/ratelimiter-struct.png" alt="ratelimiter-struct"></p><p>关键属性及方法解析（以 SmoothBursty 为例）</p><p>1.关键属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 桶中当前拥有的令牌数. */</span></span><br><span class="line"><span class="keyword">double</span> storedPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 桶中最多可以保存多少秒存入的令牌数 */</span></span><br><span class="line"><span class="keyword">double</span> maxBurstSeconds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 桶中能存储的最大令牌数，等于storedPermits*maxBurstSeconds. */</span></span><br><span class="line"><span class="keyword">double</span> maxPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 放入令牌的时间间隔*/</span></span><br><span class="line"><span class="keyword">double</span> stableIntervalMicros;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 下次可获取令牌的时间点，可以是过去也可以是将来的时间点*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nextFreeTicketMicros = <span class="number">0L</span>;</span><br></pre></td></tr></table></figure><p>2.关键方法</p><p>调用 <code>RateLimiter.create(double permitsPerSecond)</code> 方法时，创建的是 SmoothBursty 实例，默认设置 maxBurstSeconds 为1s。SleepingStopwatch 是guava中的一个时钟类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, SleepingStopwatch stopwatch)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmoothBursty(SleepingStopwatch stopwatch, <span class="keyword">double</span> maxBurstSeconds) &#123;</span><br><span class="line">  <span class="keyword">super</span>(stopwatch);</span><br><span class="line">  <span class="keyword">this</span>.maxBurstSeconds = maxBurstSeconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并通过调用 <code>SmoothBursty.doSetRate(double, long)</code> 方法进行初始化，该方法中:</p><ol><li>调用 <code>resync(nowMicros)</code> 对 storedPermits 与 nextFreeTicketMicros 进行了调整——如果当前时间晚于 nextFreeTicketMicros，则计算这段时间内产生的令牌数，累加到 storedPermits 上，并更新下次可获取令牌时间 nextFreeTicketMicros 为当前时间。</li><li>计算 stableIntervalMicros 的值，1/permitsPerSecond。</li><li>调用 <code>doSetRate(double, double)</code> 方法计算 maxPermits 值（maxBurstSeconds*permitsPerSecond），并根据旧的 maxPermits 值对 storedPermits 进行调整。</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Updates &#123;<span class="doctag">@code</span> storedPermits&#125; and &#123;<span class="doctag">@code</span> nextFreeTicketMicros&#125; based on the current time. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">    <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">    storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">    nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don't special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = maxPermits;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">                ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">                : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>acquire(int)</code> 方法获取指定数量的令牌时，</p><ol><li>调用 <code>reserve(int)</code> 方法，该方法最终调用 <code>reserveEarliestAvailable(int, long)</code> 来更新下次可取令牌时间点与当前存储的令牌数，并返回本次可取令牌的时间点，根据该时间点计算需要等待的时间</li><li>阻塞等待1中返回的等待时间</li><li>返回等待的时间（秒）</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 获取指定数量（permits）的令牌，阻塞直到获取到令牌，返回等待的时间*/</span></span><br><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> microsToWait = reserve(permits);</span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">        <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回需要等待的时间*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 针对此次需要获取的令牌数更新下次可取令牌时间点与存储的令牌数，返回本次可取令牌的时间点*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros); <span class="comment">// 更新当前数据</span></span><br><span class="line">    <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits); <span class="comment">// 本次可消费的令牌数</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend; <span class="comment">// 需要新增的令牌数</span></span><br><span class="line">    <span class="keyword">long</span> waitMicros =</span><br><span class="line">        storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">            + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros); <span class="comment">// 更新下次可取令牌的时间点</span></span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend; <span class="comment">// 更新当前存储的令牌数</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire(int)</code> 方法是获取不到令牌时一直阻塞，直到获取到令牌，<code>tryAcquire(int,long,TimeUnit)</code> 方法则是在指定超时时间内尝试获取令牌，如果获取到或超时时间到则返回是否获取成功</p><ol><li>先判断是否能在指定超时时间内获取到令牌，通过 <code>nextFreeTicketMicros &lt;= timeoutMicros + nowMicros</code> 是否为true来判断，即可取令牌时间早于当前时间加超时时间则可取（预消费的特性），否则不可获取。</li><li>如果不可获取，立即返回false。</li><li>如果可获取，则调用 <code>reserveAndGetWaitLength(permits, nowMicros)</code> 来更新下次可取令牌时间点与当前存储的令牌数，返回等待时间（逻辑与前面相同），并阻塞等待相应的时间，返回true。</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timeoutMicros = max(unit.toMicros(timeout), <span class="number">0</span>);</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">long</span> microsToWait;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">        <span class="keyword">long</span> nowMicros = stopwatch.readMicros();</span><br><span class="line">        <span class="keyword">if</span> (!canAcquire(nowMicros, timeoutMicros)) &#123; <span class="comment">//判断是否能在超时时间内获取指定数量的令牌</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            microsToWait = reserveAndGetWaitLength(permits, nowMicros);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canAcquire</span><span class="params">(<span class="keyword">long</span> nowMicros, <span class="keyword">long</span> timeoutMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryEarliestAvailable(nowMicros) - timeoutMicros &lt;= nowMicros; <span class="comment">//只要可取时间小于当前时间+超时时间，则可获取（可预消费的特性！）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">queryEarliestAvailable</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextFreeTicketMicros;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 SmoothBursty 实现的基本处理流程。注意两点：</p><ol><li>RateLimiter 通过限制后面请求的等待时间，来支持一定程度的突发请求——预消费的特性。</li><li>RateLimiter 令牌桶的实现并不是起一个线程不断往桶里放令牌，而是以一种延迟计算的方式（参考<code>resync</code>函数），在每次获取令牌之前计算该段时间内可以产生多少令牌，将产生的令牌加入令牌桶中并更新数据来实现，比起一个线程来不断往桶里放令牌高效得多。（想想如果需要针对每个用户限制某个接口的访问，则针对每个用户都得创建一个RateLimiter，并起一个线程来控制令牌存放的话，如果在线用户数有几十上百万，起线程来控制是一件多么恐怖的事情）</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了限流的三种基本算法，其中令牌桶算法与漏桶算法主要用来限制请求处理的速度，可将其归为限速，计数器算法则是用来限制一个时间窗口内请求处理的数量，可将其归为限量（对速度不限制）。Guava 的 RateLimiter 是令牌桶算法的一种实现，但 RateLimiter 只适用于单机应用，在分布式环境下就不适用了。虽然已有一些开源项目可用于分布式环境下的限流管理，如阿里的Sentinel，但对于小型项目来说，引入Sentinel可能显得有点过重，但限流的需求在小型项目中也是存在的，下一篇文章就介绍下基于 RateLimiter 的分布式下的限流实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分布式系统中，应对高并发访问时，缓存、限流、降级是保护系统正常运行的常用方法。当请求量突发暴涨时，如果不加以限制访问，则可能导致整个系统崩溃，服务不可用。同时有一些业务场景，比如短信验证码，或者其它第三方API调用，也需要提供必要的访问限制支持。还有一些资源消耗过大的请求，比如数据导出等（参考 &lt;a href=&quot;http://blog.jboost.cn/issue-cpu-high.html&quot;&gt;记一次线上Java服务CPU 100%处理过程&lt;/a&gt; ），也有限制访问频率的需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="redis" scheme="http://blog.jboost.cn/tags/redis/"/>
    
      <category term="限流" scheme="http://blog.jboost.cn/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>基于Redis分布式锁的正确打开方式</title>
    <link href="http://blog.jboost.cn/distributedlock.html"/>
    <id>http://blog.jboost.cn/distributedlock.html</id>
    <published>2020-07-01T06:18:15.000Z</published>
    <updated>2020-08-26T01:39:56.844Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁是在分布式环境下（多个JVM进程）控制多个客户端对某一资源的同步访问的一种实现，与之相对应的是线程锁，线程锁控制的是同一个JVM进程内多个线程之间的同步。分布式锁的一般实现方法是在应用服务器之外通过一个共享的存储服务器存储锁资源，同一时刻只有一个客户端能占有锁资源来完成。通常有基于Zookeeper，Redis，或数据库三种实现形式。本文介绍基于Redis的实现方案。</p><a id="more"></a><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>基于Redis实现分布式锁需要满足如下几点要求：</p><ol><li>在分布式集群中，被分布式锁控制的方法或代码段同一时刻只能被一个客户端上面的一个线程执行，也就是互斥</li><li>锁信息需要设置过期时间，避免一个线程长期占有（比如在做解锁操作前异常退出）而导致死锁</li><li>加锁与解锁必须一致，谁加的锁，就由谁来解（或过期超时），一个客户端不能解开另一个客户端加的锁</li><li>加锁与解锁的过程必须保证原子性</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-加锁实现"><a href="#1-加锁实现" class="headerlink" title="1. 加锁实现"></a>1. 加锁实现</h3><p>基于Redis的分布式锁加锁操作一般使用 <code>SETNX</code> 命令，其含义是“将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作”。<br>在 Spring Boot 中，可以使用 StringRedisTemplate 来实现，如下，一行代码即可实现加锁过程。（下列代码给出两种调用形式——立即返回加锁结果与给定超时时间获取加锁结果）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取锁（立即返回）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key  锁的redis key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 锁的value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expire 过期时间/秒</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stringRedisTemplate.opsForValue().setIfAbsent(key, value, expire, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取锁，并至多等待timeout时长</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key  锁的redis key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 锁的value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expire 过期时间/秒</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> timeout 超时时长</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit    时间单位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value, <span class="keyword">long</span> expire, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> waitMillis = unit.toMillis(timeout);</span><br><span class="line">    <span class="keyword">long</span> waitAlready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stringRedisTemplate.opsForValue().setIfAbsent(key, value, expire, TimeUnit.SECONDS) &amp;&amp; waitAlready &lt; waitMillis) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(waitMillisPer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Interrupted when trying to get a lock. key: &#123;&#125;"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        waitAlready += waitMillisPer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitAlready &lt; waitMillis) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.warn(<span class="string">"&lt;====== lock &#123;&#125; failed after waiting for &#123;&#125; ms"</span>, key, waitAlready);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现如何满足前面提到的几点要求：</p><ol><li>客户端互斥： 可以将expire过期时间设置为大于同步代码的执行时间，比如同步代码块执行时间为1s，则可将expire设置为3s或5s。避免同步代码执行过程中expire时间到，其它客户端又可以获取锁执行同步代码块。</li><li>通过设置过期时间expire来避免某个客户端长期占有锁。</li><li>通过value来控制谁加的锁，由谁解的逻辑，比如可以使用requestId作为value，requestId唯一标记一次请求。</li><li>setIfAbsent方法 底层通过调用 Redis 的 <code>SETNX</code> 命令，操作具备原子性。</li></ol><p><strong>错误示例：</strong></p><p>网上有如下实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = stringRedisTemplate.opsForValue().setIfAbsent(key, value);</span><br><span class="line">    <span class="keyword">if</span>(result) &#123;</span><br><span class="line">        stringRedisTemplate.expire(key, expire, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现的问题是如果在result为true，但还没成功设置expire时，程序异常退出了，将导致该锁一直被占用而导致死锁，不满足第二点要求。</p><h3 id="2-解锁实现"><a href="#2-解锁实现" class="headerlink" title="2. 解锁实现"></a>2. 解锁实现</h3><p>解锁也需要满足前面所述的四个要求，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RELEASE_LOCK_LUA_SCRIPT = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_LOCK_SUCCESS_RESULT = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 释放锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key  锁的redis key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 锁的value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(RELEASE_LOCK_LUA_SCRIPT, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">long</span> result = stringRedisTemplate.execute(redisScript, Collections.singletonList(key), value);</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(result, RELEASE_LOCK_SUCCESS_RESULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段实现使用一个Lua脚本来实现解锁操作，保证操作的原子性。传入的value值需与该线程加锁时的value一致，可以使用requestId（具体实现下面给出）。</p><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        String oldValue = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(value.equals(oldValue)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现先获取锁的当前值，判断两值相等则删除。考虑一种极端情况，如果在判断为true时，刚好该锁过期时间到，另一个客户端加锁成功，则接下来的delete将不管三七二十一将别人加的锁直接删掉了，不满足第三点要求。该示例主要是因为没有保证解锁操作的原子性导致。</p><h3 id="3-注解支持"><a href="#3-注解支持" class="headerlink" title="3. 注解支持"></a>3. 注解支持</h3><p>为了方便使用，添加一个注解，可以放于方法上控制方法在分布式环境中的同步执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 标注在方法上的分布式锁注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DistributedLockable &#123;</span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> "disLock:"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">expire</span><span class="params">()</span> <span class="keyword">default</span> 10L</span>; <span class="comment">// 默认10s过期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一个切面来解析注解的处理，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分布式锁注解处理切面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLockAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DistributedLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedLockAspect</span><span class="params">(DistributedLock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在方法上执行同步锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"@annotation(lockable)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">distLock</span><span class="params">(ProceedingJoinPoint point, DistributedLockable lockable)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">        String key = lockable.prefix() + lockable.key();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.lock(key, WebUtil.getRequestId(), lockable.expire());</span><br><span class="line">            <span class="keyword">if</span>(locked) &#123;</span><br><span class="line">                <span class="keyword">return</span> point.proceed();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"Did not get a lock for key &#123;&#125;"</span>, key);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(locked) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!lock.unLock(key, WebUtil.getRequestId()))&#123;</span><br><span class="line">                    log.warn(<span class="string">"Unlock &#123;&#125; failed, maybe locked by another client already. "</span>, lockable.key());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestId 的实现如下，通过注册一个Filter，在请求开始时生成一个uuid存于ThreadLocal中，在请求返回时清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_ID_HEADER = <span class="string">"Req-Id"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; reqIdThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        reqIdThreadLocal.set(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRequestId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String requestId = reqIdThreadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(requestId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestId = ObjectId.next();</span><br><span class="line">            reqIdThreadLocal.set(requestId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reqIdThreadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestIdFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">        String reqId = httpServletRequest.getHeader(WebUtil.REQ_ID_HEADER);</span><br><span class="line">        <span class="comment">//没有则生成一个</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(reqId)) &#123;</span><br><span class="line">            reqId = ObjectId.next();</span><br><span class="line">        &#125;</span><br><span class="line">        WebUtil.setRequestId(reqId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            WebUtil.removeRequestId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在配置类中注册Filter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加RequestId</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">requestIdFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestIdFilter reqestIdFilter = <span class="keyword">new</span> RequestIdFilter();</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setFilter(reqestIdFilter);</span><br><span class="line">    List&lt;String&gt; urlPatterns = Collections.singletonList(<span class="string">"/*"</span>);</span><br><span class="line">    registrationBean.setUrlPatterns(urlPatterns);</span><br><span class="line">    registrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用注解"><a href="#4-使用注解" class="headerlink" title="4. 使用注解"></a>4. 使用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DistributedLockable</span>(key = <span class="string">"test"</span>, expire = <span class="number">10</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"线程-"</span>+Thread.currentThread().getName()+<span class="string">"开始执行..."</span> + LocalDateTime.now());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"线程-"</span>+Thread.currentThread().getName()+<span class="string">"结束执行..."</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文给出了基于Redis的分布式锁的实现方案与常见的错误示例。要保障分布式锁的正确运行，需满足本文所提的四个要求，尤其注意保证加锁解锁操作的原子性，设置过期时间，及对同一个锁的加锁解锁线程一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式锁是在分布式环境下（多个JVM进程）控制多个客户端对某一资源的同步访问的一种实现，与之相对应的是线程锁，线程锁控制的是同一个JVM进程内多个线程之间的同步。分布式锁的一般实现方法是在应用服务器之外通过一个共享的存储服务器存储锁资源，同一时刻只有一个客户端能占有锁资源来完成。通常有基于Zookeeper，Redis，或数据库三种实现形式。本文介绍基于Redis的实现方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="redis" scheme="http://blog.jboost.cn/tags/redis/"/>
    
      <category term="RateLimiter" scheme="http://blog.jboost.cn/tags/RateLimiter/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上Java服务CPU 100%处理过程</title>
    <link href="http://blog.jboost.cn/issue-cpu-high.html"/>
    <id>http://blog.jboost.cn/issue-cpu-high.html</id>
    <published>2020-06-16T05:56:05.000Z</published>
    <updated>2020-08-26T01:39:15.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><p>正在开会，突然钉钉告警声响个不停，同时市场人员反馈客户在投诉系统登不进了，报504错误。查看钉钉上的告警信息，几台业务服务器节点全部报CPU超过告警阈值，达100%。</p><p>赶紧从会上下来，SSH登录服务器，使用 <code>top</code> 命令查看，几个Java进程CPU占用达到180%，190%，这几个Java进程对应同一个业务服务的几个Pod（或容器）。</p><a id="more"></a><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ol><li><p>使用 <code>docker stats</code> 命令查看本节点容器资源使用情况，对占用CPU很高的容器使用 <code>docker exec -it &lt;容器ID&gt; bash</code> 进入。</p></li><li><p>在容器内部执行 <code>top</code> 命令查看，定位到占用CPU高的进程ID，使用 <code>top -Hp &lt;进程ID&gt;</code> 定位到占用CPU高的线程ID。</p></li><li><p>使用 <code>jstack &lt;进程ID&gt; &gt; jstack.txt</code> 将进程的线程栈打印输出。</p></li><li><p>退出容器， 使用 <code>docker cp &lt;容器ID&gt;:/usr/local/tomcat/jstack.txt ./</code> 命令将jstack文件复制到宿主机，便于查看。获取到jstack信息后，赶紧重启服务让服务恢复可用。</p></li><li><p>将2中占用CPU高的线程ID使用 <code>pringf &#39;%x\n&#39; &lt;线程ID&gt;</code> 命令将线程ID转换为十六进制形式。假设线程ID为133，则得到十六进制85。在jstack.txt文件中定位到 <code>nid=0x85</code>的位置，该位置即为占用CPU高线程的执行栈信息。如下图所示，</p></li></ol><p><img src="/assets/jstack.png" alt="jstack"></p><ol start="6"><li>与同事确认，该处为使用一个框架的excel导出功能，并且，导出excel时没有分页，没有限制！！！查看SQL查询记录，该导出功能一次导出50w条数据，并且每条数据都需要做转换计算，更为糟糕的是，操作者因为导出时久久没有响应，于是连续点击，几分钟内发起了10多次的导出请求。。。于是，CPU被打满，服务崩溃了，我也崩溃了。。</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>对于此类耗资源的操作，一定要做好相应的限制。比如可以限制请求量，控制最大分页大小，同时可以限制访问频率，比如同一用户一分钟内最多请求多少次。</p><h2 id="再发"><a href="#再发" class="headerlink" title="再发"></a>再发</h2><p>服务重启后恢复。到了下午，又一台服务器节点CPU告警，依前面步骤定位到占用CPU高的线程，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00007fa114020800 nid=0x10 runnable </span><br><span class="line"></span><br><span class="line">"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00007fa114022000 nid=0x11 runnable</span><br></pre></td></tr></table></figure><p>使用命令 <code>jstat -gcutil &lt;进程ID&gt; 2000 10</code> 查看GC情况，如图</p><p><img src="/assets/jstat.png" alt="jstat"></p><p>发现Full GC次数达到1000多次，且还在不断增长，同时Eden区，Old区已经被占满（也可使用<code>jmap -heap &lt;进程ID&gt;</code>查看堆内存各区的占用情况），使用jmap将内存使用情况dump出来，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=./jmap.dump 13</span><br></pre></td></tr></table></figure><p>退出容器，使用 <code>docker cp &lt;容器ID&gt;:/usr/local/tomcat/jmap.dump ./</code> 将dump文件复制到宿主机目录，下载到本地，使用 MemoryAnalyzer（下载地址：<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a> ）打开，如图</p><p><img src="/assets/jmap-mat.png" alt="jmap-mat"></p><blockquote><p>如果dump文件比较大，需要增大MemoryAnalyzer.ini配置文件中的-Xmx值</p></blockquote><p>发现占用内存最多的是char[], String对象，通过右键可以查看引用对象，但点开貌似也看不出所以然来，进入内存泄露报告页面，如图</p><p><img src="/assets/mat-leak-suspects.png" alt="mat-leak-suspects"></p><p>该页面统计了堆内存的占用情况，并且给出疑似泄露点，在上图中点开“see stacktrace”链接，进入线程栈页面，</p><p><img src="/assets/mat-thread-stack.png" alt="mat-thread-stack"></p><p>似曾熟悉的画面，还是跟excel导出有关，数据太多，导致内存溢出。。。于是GC频繁，于是CPU爆了。根源还是同一个。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文以处理一次线上服务CPU 100%的实战过程示例了在遇到Java服务造成服务器CPU消耗过高或内存溢出的一般处理方法，希望对大家定位线上类似问题提供参考。同时，开发实现功能时需要考虑的更深远一些，不能停留在解决当前的场景，需要考虑数据量不断增大时，你的实现是否还能适用。俗话说，初级程序员解决当前问题，中级程序员解决两年后的问题，高级程序员解决五年后的问题，^_^。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;告警&quot;&gt;&lt;a href=&quot;#告警&quot; class=&quot;headerlink&quot; title=&quot;告警&quot;&gt;&lt;/a&gt;告警&lt;/h2&gt;&lt;p&gt;正在开会，突然钉钉告警声响个不停，同时市场人员反馈客户在投诉系统登不进了，报504错误。查看钉钉上的告警信息，几台业务服务器节点全部报CPU超过告警阈值，达100%。&lt;/p&gt;
&lt;p&gt;赶紧从会上下来，SSH登录服务器，使用 &lt;code&gt;top&lt;/code&gt; 命令查看，几个Java进程CPU占用达到180%，190%，这几个Java进程对应同一个业务服务的几个Pod（或容器）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="cpu100%" scheme="http://blog.jboost.cn/tags/cpu100/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理导致session失效的问题处理</title>
    <link href="http://blog.jboost.cn/nginx-proxy.html"/>
    <id>http://blog.jboost.cn/nginx-proxy.html</id>
    <published>2020-06-02T01:50:00.000Z</published>
    <updated>2020-08-26T01:36:55.493Z</updated>
    
    <content type="html"><![CDATA[<p>一同事求援：后台系统的登录成功了，但不能成功登进系统，仍然跳转到登录页，但同一套代码另一个环境却没有问题。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>经了解，他对同一个项目使用tomcat部署了两个环境，一个在开发服务器上，一个在他本机，两个环境代码配置完全相同。两边通过同一个nginx进行反向代理，nginx配置大致如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;health&#x2F; &#123;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;192.168.40.159:8081&#x2F;health&#x2F;;  #无问题的配置</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;health-dev&#x2F; &#123;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;192.168.40.202:8080&#x2F;health&#x2F;;  #有问题的配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个反向代理到开发环境，一个反向代理到本机服务。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>既然代码配置完全相同，那么问题很大可能就出现在nginx的反向代理上。</p><p>因为两边location路径不同（即浏览器路径不同），但是反向代理的服务端路径却相同，结合session的基本原理，如下图，</p><p><img src="/assets/httpsession.png" alt="httpsession"></p><ol><li>当浏览器第一次打开页面时，服务端会为这次会话创建一个session，并将session id通过response的header传递给浏览器，header一般为 <code>Set-Cookie: JSESSIONID=xxxxx; Path=xxxx</code></li><li>浏览器接收到响应后，如果header Set-Cookie 中path的值与浏览器地址路径匹配，则将该header值存于浏览器的Cookie中</li><li>浏览器在下次请求服务器时，将Cookie中的JSESSIONID值通过request的header上报给服务端，header一般为 <code>Cookie: JSESSIONID=xxxx;</code></li><li>服务端可通过该JSESSIONID来定位到对应的session</li></ol><p>nginx反向代理按这种方式配置时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;health-dev&#x2F; &#123;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;192.168.40.202:8080&#x2F;health&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 <code>http://www.domian.com/health-dev</code> 时，服务端返回的 <code>Set-Cookie</code> 的 Path 值为 <code>/health</code>（因为中间有反向代理，服务端并不知道代理前的路径是啥，是按最终请求服务端的路径设置），如图</p><p><img src="/assets/nginx-proxy-cookie-1.png" alt="nginx-proxy-cookie-1"></p><p>因为浏览器访问地址的路径 <code>/health-dev</code> 与 <code>Set-Cookie</code> 的 Path <code>/health</code> 不匹配，所以浏览器并不会将其值存入Cookie中，如图</p><p><img src="/assets/nginx-proxy-cookie-2.png" alt="nginx-proxy-cookie-2"></p><p>因此在下次请求服务器时，浏览器无法设置request <code>Cookie</code> header的 <code>JSESSIONID</code> 值，服务器无法定位到对应的session，因此会将其当做第一次请求，创建一个新的session，如此反复，因此就算你登录认证通过了，但服务器返回的登录凭证（JSESSIONID）浏览器不会保存，并在下次请求时携带，导致服务器认为你是一个新的请求，当然就会又跳到登录页面了。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>nginx有一个命令 <code>proxy_cookie_path</code>（参考： <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_path" target="_blank" rel="noopener">proxy_cookie_path</a>）可将服务器返回的 <code>Set-Cookie</code> 中的path进行修改，格式为 <code>proxy_cookie_path 原路径 目标路径</code>，我们在配置中添加 <code>proxy_cookie_path</code> 如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;health-dev&#x2F; &#123;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;192.168.40.202:8080&#x2F;health&#x2F;;</span><br><span class="line">    proxy_cookie_path  &#x2F;health &#x2F;health-dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx，问题解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一同事求援：后台系统的登录成功了，但不能成功登进系统，仍然跳转到登录页，但同一套代码另一个环境却没有问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="nginx" scheme="http://blog.jboost.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（四）：详解Namespace与资源限制ResourceQuota，LimitRange</title>
    <link href="http://blog.jboost.cn/k8s4-namespace.html"/>
    <id>http://blog.jboost.cn/k8s4-namespace.html</id>
    <published>2020-05-27T05:20:25.000Z</published>
    <updated>2020-08-26T01:44:31.062Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们对K8s的基本组件与概念有了个大致的印象，并且基于K8s实现了一个初步的CI/CD流程，但对里面涉及的各个对象（如Namespace, Pod, Deployment, Service, Ingress, PVC等）及各对象的管理可能还缺乏深入的理解与实践，接下来的文章就让我们一起深入K8s的各组件内部来一探究竟吧。下图是基于个人的理解梳理的一个K8s结构图，示例了各个组件（只包含了主要组件）如何协同。</p><a id="more"></a><p><img src="/assets/k8s-struct.png" alt="k8s-struct"></p><p>后续几篇文章围绕该图涉及组件进行整理介绍，本文主要探究Namespace及与Namespace管理相关的资源限制ResourceQuota/LimitRange部分。</p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>Namespace即命名空间，主要有两个方面的作用：</p><ol><li>资源隔离：可为不同的团队/用户（或项目）提供虚拟的集群空间，共享同一个Kubernetes集群的资源。比如可以为团队A创建一个Namespace ns-a，团队A的项目都部署运行在 ns-a 中，团队B创建另一个Namespace ns-b，其项目都部署运行在 ns-b 中，或者为开发、测试、生产环境创建不同的Namespace，以做到彼此之间相互隔离，互不影响。我们可以使用 ResourceQuota 与 Resource LimitRange 来指定与限制 各个namesapce的资源分配与使用</li><li>权限控制：可以指定某个namespace哪些用户可以访问，哪些用户不能访问</li></ol><p>Kubernetes 安装成功后，默认会创建三个namespace：</p><ul><li>default：默认的namespace，如果创建Kubernetes对象时不指定 metadata.namespace，该对象将在default namespace下创建</li><li>kube-system：Kubernetes系统创建的对象放在此namespace下，我们前面说的kube-apiserver，etcd，kube-proxy等都在该namespace下</li><li>kube-public：顾名思义，共享的namespace，所有用户对该namespace都是可读的。主要是为集群做预留，一般都不在该namespace下创建对象</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1.查看namesapce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespaces</span><br><span class="line">kubectl get namesapce</span><br><span class="line">kubectl get ns               # 三个操作等效</span><br><span class="line">kubectl get ns --show-labels # 显示namespace的label</span><br></pre></td></tr></table></figure><p>使用namesapces,namesapce,ns都是可以的。如下列出了当前集群中的所有namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl get ns</span><br><span class="line">NAME                   STATUS   AGE</span><br><span class="line">default                Active   34d</span><br><span class="line">develop                Active   17d</span><br><span class="line">ingress-nginx          Active   33d</span><br><span class="line">kube-node-lease        Active   34d</span><br><span class="line">kube-public            Active   34d</span><br><span class="line">kube-system            Active   34d</span><br><span class="line">kubernetes-dashboard   Active   31d</span><br><span class="line">pre-release            Active   17d</span><br></pre></td></tr></table></figure><p>可以使用 <code>kubectl describe</code> 命令来查看某个namespace的概要信息，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl describe ns default</span><br><span class="line">Name:         default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active</span><br><span class="line"></span><br><span class="line">No resource quota.</span><br><span class="line"></span><br><span class="line">No resource limits.</span><br></pre></td></tr></table></figure><p>2.创建namespace</p><p>有两种方式：通过yaml定义文件创建或直接使用命令创建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式1. 通过yaml定义文件创建</span></span><br><span class="line">[root@kmaster ~]# vim test-namespace.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: test     # namespace的名称</span><br><span class="line">  labels:</span><br><span class="line">    name: ns-test</span><br><span class="line">[root@kmaster ~]# kubectl create -f ./test-namespace.yaml  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式2. 直接使用命令创建</span></span><br><span class="line">[root@kmaster ~]# kubectl create ns test</span><br></pre></td></tr></table></figure><p>3.在namesapce中创建对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 在yaml中通过metadata.namesapce 指定</span></span><br><span class="line">[root@kmaster ~]# kubectl get deploy my-nginx -o yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    run: my-nginx</span><br><span class="line">  name: my-nginx</span><br><span class="line">  namespace: test  # 指定namespace</span><br><span class="line">spec:</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 在命令中通过 -n 或 --namesapce 指定</span></span><br><span class="line">[root@kmaster ~]# kubectl run dev-nginx --image=nginx:latest --replicas=3 -n test</span><br></pre></td></tr></table></figure><p>4.设定kubectl namesapce上下文</p><p>kubectl上下文即集群、namespace、用户的组合，设定kubectl上下文，即可以以上下文指定的用户，在上下文指定的集群与namespace中进行操作管理。查看当前集群kubectl上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前kubectl上下文</span></span><br><span class="line">[root@kmaster ~]# kubectl config view</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: DATA+OMITTED</span><br><span class="line">    server: https://192.168.40.111:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: kubernetes-admin</span><br><span class="line">  name: kubernetes-admin@kubernetes</span><br><span class="line">current-context: kubernetes-admin@kubernetes</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: kubernetes-admin</span><br><span class="line">  user:</span><br><span class="line">    client-certificate-data: REDACTED</span><br><span class="line">    client-key-data: REDACTED</span><br></pre></td></tr></table></figure><p>可见当前上下文为kubernetes-admin@kubernetes (current-context: kubernetes-admin@kubernetes)。</p><p>创建一个kubectl上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl config set-context test --namespace=test --cluster=kubernetes --user=kubernetes-admin</span><br><span class="line">Context "test" created.</span><br></pre></td></tr></table></figure><p>再次执行 <code>kubectl config view</code> 将可以看到上面创建的test上下文。</p><p>切换上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置当前上下文</span></span><br><span class="line">[root@kmaster ~]# kubectl config use-context test</span><br><span class="line">Switched to context "test".</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前所在的上下文</span></span><br><span class="line">[root@kmaster ~]# kubectl config current-context</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>指定了上下文，后续操作都在该上下文对应的namespace中进行，不需要再显式指定namespace。在上下文中创建对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前上下文中创建对象</span></span><br><span class="line">[root@kmaster ~]# kubectl run my-nginx --image=nginx:latest --replicas=2</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/my-nginx created</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看创建的对象，不需要指定namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl get deploy</span><br><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">my-nginx   2/2     2            2           25m</span><br><span class="line">[root@kmaster ~]# kubectl get pod</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">my-nginx-667764d77b-ldb78   1/1     Running   0          24m</span><br><span class="line">my-nginx-667764d77b-wpgxw   1/1     Running   0          24m</span><br></pre></td></tr></table></figure><p>删除上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl config delete-context test</span><br><span class="line">deleted context test from /root/.kube/config</span><br></pre></td></tr></table></figure><p>也可以使用如下命令直接切换默认的namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将默认namespace设置为<span class="built_in">test</span></span></span><br><span class="line">[root@kmaster ~]# kubectl config set-context --current --namespace=test</span><br></pre></td></tr></table></figure><p>5.删除namesapce</p><p>可以使用 <code>kubectl delete ns &lt;namespace名称&gt;</code> 来删除一个namesapce，该操作会删除namespace中的所有内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl delete ns test</span><br></pre></td></tr></table></figure><h2 id="Resource-Quota"><a href="#Resource-Quota" class="headerlink" title="Resource Quota"></a>Resource Quota</h2><p>Resource Quota即资源配额，限定单个namespace中可使用集群资源的总量，包括两个维度：</p><ol><li>限定某个对象类型（如Pod）可创建对象的总数；</li><li>限定某个对象类型可消耗的计算资源（CPU、内存）与存储资源（存储卷声明）总数</li></ol><p>如果在 namespace 中为计算资源 CPU 和内存设定了 ResourceQuota，用户在创建对象（Pod、Service等）时，必须指定 requests 和 limits；如果在创建或更新对象时申请的资源与 namespace 的 ResourceQuota 冲突，则 apiserver 会返回 HTTP 状态码 403，以及对应的错误提示信息。当集群中总的容量小于各个 namespace 资源配额的总和时，可能会发生资源争夺，此时 Kubernetes 将按照先到先得的方式分配资源。</p><h3 id="对象数量限制"><a href="#对象数量限制" class="headerlink" title="对象数量限制"></a>对象数量限制</h3><p>声明格式为： <code>count/&lt;resource&gt;.&lt;group&gt;</code>， 如下列出各类对象的声明格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">count&#x2F;persistentvolumeclaims </span><br><span class="line">count&#x2F;services</span><br><span class="line">count&#x2F;secrets</span><br><span class="line">count&#x2F;configmaps</span><br><span class="line">count&#x2F;replicationcontrollers</span><br><span class="line">count&#x2F;deployments.apps</span><br><span class="line">count&#x2F;replicasets.apps</span><br><span class="line">count&#x2F;statefulsets.apps</span><br><span class="line">count&#x2F;jobs.batch</span><br><span class="line">count&#x2F;cronjobs.batch</span><br><span class="line">count&#x2F;deployments.extensions</span><br></pre></td></tr></table></figure><h3 id="计算资源限制"><a href="#计算资源限制" class="headerlink" title="计算资源限制"></a>计算资源限制</h3><p>定义CPU、内存请求（requests）、限制（limits）使用的总量，包括</p><ul><li>limits.cpu：namespace中，所有非终止状态的 Pod 的 CPU 限制 resources.limits.cpu 总和不能超过该值</li><li>limits.memory：namespace中，所有非终止状态的 Pod 的内存限制 resources.limits.memory 总和不能超过该值</li><li>requests.cpu：namespace中，所有非终止状态的 Pod 的 CPU 请求 resources.requrest.cpu 总和不能超过该值</li><li>requests.memory：namespace中，所有非终止状态的 Pod 的 CPU 请求 resources.requests.memory 总和不能超过该值</li></ul><h3 id="存储资源限制"><a href="#存储资源限制" class="headerlink" title="存储资源限制"></a>存储资源限制</h3><p>定义存储卷声明请求的存储总量或创建存储卷声明数量的限制，包括</p><ul><li>requests.storage：namespace中，所有存储卷声明（PersistentVolumeClaim）请求的存储总量不能超过该值</li><li>persistentvolumeclaims：namespace中，可以创建的存储卷声明的总数不能超过该值</li><li><code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/requests.storage</code>：namespace中，所有与指定存储类（StorageClass）关联的存储卷声明请求的存储总量不能超过该值</li><li><code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/persistentvolumeclaims</code>：namespace中，所有与指定存储类关联的存储卷声明的总数不能超过该值</li></ul><p>除此之外，还可以对本地临时存储资源进行限制定义</p><ul><li>requests.ephemeral-storage：namespace中，所有 Pod 的本地临时存储（local ephemeral storage）请求的总和不能超过该值</li><li>limits.ephemeral-storage：namespace中，所有 Pod 的本地临时存储限定的总和不能超过此值</li></ul><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>查看是否开启 Resource Quota 支持，默认一般是开启的。如果没有，可在启动 apiserver 时为参数 –enable-admission-plugins 添加 ResourceQuota 配置项。<br><img src="/assets/resource-quota.png" alt="resource-quota.png"></p><p>1.创建ResourceQuota</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl create namespace test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑ResourceQuota定义文档</span></span><br><span class="line">[root@kmaster ~]# vim quota-test.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ResourceQuota</span><br><span class="line">metadata:</span><br><span class="line">  name: quota-test</span><br><span class="line">  namespace: test</span><br><span class="line">spec:</span><br><span class="line">  hard:</span><br><span class="line">    requests.cpu: "2"</span><br><span class="line">    requests.memory: 2Gi</span><br><span class="line">    limits.cpu: "4"</span><br><span class="line">    limits.memory: 4Gi</span><br><span class="line">    requests.nvidia.com/gpu: 4</span><br><span class="line">    pods: "3"</span><br><span class="line">    services: "6"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建ResourceQuota</span></span><br><span class="line">[root@kmaster ~]# kubectl apply -f quota-test.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@kmaster ~]# kubectl get quota -n test</span><br><span class="line">NAME         CREATED AT</span><br><span class="line">quota-test   2020-05-26T10:31:10Z</span><br><span class="line">[root@kmaster ~]# kubectl describe quota quota-test -n test</span><br><span class="line">Name:                    quota-test</span><br><span class="line">Namespace:               test</span><br><span class="line">Resource                 Used  Hard</span><br><span class="line">--------                 ----  ----</span><br><span class="line">limits.cpu               0     4</span><br><span class="line">limits.memory            0     4Gi</span><br><span class="line">pods                     0     3</span><br><span class="line">requests.cpu             0     2</span><br><span class="line">requests.memory          0     2Gi</span><br><span class="line">requests.nvidia.com/gpu  0     4</span><br><span class="line">services                 0     6</span><br></pre></td></tr></table></figure><p>或者使用kubectl命令，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl create quota quota-test --hard=count/deployments.extensions=2,count/replicasets.extensions=4,count/pods=3,count/secrets=4 --namespace=test</span><br></pre></td></tr></table></figure><p>我们在namespace test中创建了一个ResourceQuota，限制CPU、内存请求为2、2GB，限制CPU、内存限定使用为4、4GB，限制Pod个数为3 等。</p><p>我们来尝试创建一个如下定义的Deployment来测试一下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个测试deploy</span></span><br><span class="line">[root@kmaster ~]# vim quota-test-deploy.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: quota-test-deploy</span><br><span class="line">spec:</span><br><span class="line"> selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      purpose: quota-test</span><br><span class="line"> replicas: 3</span><br><span class="line"> template:</span><br><span class="line">   metadata:</span><br><span class="line">     labels:</span><br><span class="line">       purpose: quota-test</span><br><span class="line">   spec:</span><br><span class="line">     containers:</span><br><span class="line">     - name: quota-test</span><br><span class="line">       image: nginx</span><br><span class="line">       resources:</span><br><span class="line">         limits:</span><br><span class="line">           memory: "2Gi"</span><br><span class="line">           cpu: "1"</span><br><span class="line">         requests:</span><br><span class="line">           memory: "500Mi"</span><br><span class="line">           cpu: "500m"</span><br><span class="line">[root@kmaster ~]# kubectl apply -f quota-test-deploy.yaml -n test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@kmaster ~]# kubectl get pod -n test</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">quota-test-deploy-6b89fdc686-2dthq   1/1     Running   0          3m54s</span><br><span class="line">quota-test-deploy-6b89fdc686-9m2qw   1/1     Running   0          3m54s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看deploy状态</span></span><br><span class="line">[root@kmaster ~]# kubectl get deploy quota-test-deploy -n test -o yaml</span><br><span class="line">  message: 'pods "quota-test-deploy-6b89fdc686-rmktq" is forbidden: exceeded quota:</span><br><span class="line">        quota-test, requested: limits.memory=2Gi, used: limits.memory=4Gi, limited:</span><br><span class="line">        limits.memory=4Gi'</span><br></pre></td></tr></table></figure><p> replicas: 3定义创建三个Pod副本，但只成功创建了两个Pod，在deploy的status部分（最后一条命令结果），我们可以看到message提示第三个Pod创建时被拒绝，因为内存已达到限定。我们也可以将limits.memory调整为1Gi，将replicas调整为4，来验证对Pod个数的限制。可看到最终只起了三个Pod，status部分message提示 <code>pods &quot;quota-test-deploy-9dc54f95c-gzqw7&quot; is forbidden: exceeded quota:quota-test, requested: pods=1, used: pods=3, limited: pods=3</code>。</p><h2 id="Resource-Limit-Range"><a href="#Resource-Limit-Range" class="headerlink" title="Resource Limit Range"></a>Resource Limit Range</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>Resource Quota 是对namespace中总体的资源使用进行限制，Resource Limit Range 则是对具体某个Pod或容器的资源使用进行限制。默认情况下，namespace中Pod或容器的资源消耗是不受限制的，这就可能导致某个容器应用内存泄露耗尽资源影响其它应用的情况。Limit Range可以用来限定namespace内Pod（或容器）可以消耗资源的数量。</p><p>使用LimitRange对象，我们可以：</p><ol><li>限制namespace中每个Pod或容器的最小与最大计算资源</li><li>限制namespace中每个Pod或容器计算资源request、limit之间的比例</li><li>限制namespace中每个存储卷声明（PersistentVolumeClaim）可使用的最小与最大存储空间</li><li>设置namespace中容器默认计算资源的request、limit，并在运行时自动注入到容器中</li></ol><p>如果创建或更新对象（Pod、容器、PersistentVolumeClaim）对资源的请求与LimitRange相冲突，apiserver会返回HTTP状态码403，以及相应的错误提示信息；如果namespace中定义了LimitRange 来限定CPU与内存等计算资源的使用，则用户创建Pod、容器时，必须指定CPU或内存的request与limit，否则将被系统拒绝；当namespace总的limit小于其中Pod、容器的limit之和时，将发生资源争夺，Pod或者容器将不能创建，但不影响已经创建的Pod或容器。</p><h3 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h3><p>创建一个测试namespace test-limitrange，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建测试namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl create namespace test-limitrange</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换默认的namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl config set-context --current --namespace=test-limitrange</span><br></pre></td></tr></table></figure><p>创建LimitRange定义文件 lr-test.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lr-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Container</span>       <span class="comment">#资源类型</span></span><br><span class="line">    <span class="attr">max:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"1"</span>            <span class="comment">#限定最大CPU</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"1Gi"</span>       <span class="comment">#限定最大内存</span></span><br><span class="line">    <span class="attr">min:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"100m"</span>         <span class="comment">#限定最小CPU</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"100Mi"</span>     <span class="comment">#限定最小内存</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"900m"</span>         <span class="comment">#默认CPU限定</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"800Mi"</span>     <span class="comment">#默认内存限定</span></span><br><span class="line">    <span class="attr">defaultRequest:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"200m"</span>         <span class="comment">#默认CPU请求</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"200Mi"</span>     <span class="comment">#默认内存请求</span></span><br><span class="line">    <span class="attr">maxLimitRequestRatio:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="number">2</span>              <span class="comment">#限定CPU limit/request比值最大为2  </span></span><br><span class="line">      <span class="attr">memory:</span> <span class="number">1.5</span>         <span class="comment">#限定内存limit/request比值最大为1.5</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pod</span></span><br><span class="line">    <span class="attr">max:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"2"</span>            <span class="comment">#限定Pod最大CPU</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"2Gi"</span>       <span class="comment">#限定Pod最大内存</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line">    <span class="attr">max:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">2Gi</span>        <span class="comment">#限定PVC最大的requests.storage</span></span><br><span class="line">    <span class="attr">min:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span>        <span class="comment">#限定PVC最小的requests.storage</span></span><br></pre></td></tr></table></figure><p>该文件定义了在namespace <code>test-limitrange</code> 中，容器、Pod、PVC的资源限制，在该namesapce中，只有满足如下条件，对象才能创建成功</p><ul><li>容器的<code>resources.limits</code>部分CPU必须在100m-1之间，内存必须在100Mi-1Gi之间，否则创建失败</li><li>容器的<code>resources.limits</code>部分CPU与<code>resources.requests</code>部分CPU的比值最大为2，memory比值最大为1.5，否则创建失败</li><li>Pod内所有容器的<code>resources.limits</code>部分CPU总和最大为2，内存总和最大为2Gi，否则创建失败</li><li>PVC的<code>resources.requests.storage</code>最大为2Gi，最小为1Gi，否则创建失败</li></ul><blockquote><p>如果容器定义了<code>resources.requests</code>没有定义<code>resources.limits</code>，则LimitRange中的default部分将作为limit注入到容器中；如果容器定义了<code>resources.limits</code>却没有定义<code>resources.requests</code>，则将requests值也设置为limits的值；如果容器两者都没有定义，则使用LimitRange中default作为limits，defaultRequest作为requests值</p></blockquote><p>创建与查看LimitRange，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建LimitRange</span></span><br><span class="line">[root@kmaster ~]# kubectl apply -f lr-test.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@kmaster ~]# kubectl describe limits lr-test</span><br><span class="line">Name:                  lr-test</span><br><span class="line">Namespace:             test-limitrange</span><br><span class="line">Type                   Resource  Min    Max  Default Request  Default Limit  Max Limit/Request Ratio</span><br><span class="line">----                   --------  ---    ---  ---------------  -------------  -----------------------</span><br><span class="line">Container              cpu       100m   1    200m             900m           2</span><br><span class="line">Container              memory    100Mi  1Gi  200Mi            800Mi          1500m</span><br><span class="line">Pod                    cpu       -      2    -                -              -</span><br><span class="line">Pod                    memory    -      2Gi  -                -              -</span><br><span class="line">PersistentVolumeClaim  storage   1Gi    2Gi  -                -              -</span><br></pre></td></tr></table></figure><p>我们可以创建不同配置的容器或Pod对象来验证，出于篇幅不再列出验证步骤。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对K8s的Namespace及针对Namespace的资源限制管理ResourceQuota，LimitRange进行了较为深入的探索，其中ResourceQuota对整个Namespace的资源使用情况进行限制，LimitRange则对单个的Pod或容器的资源使用进行限制。Namespace的权限控制可基于RBAC来实现，后续再单独进行梳理介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们对K8s的基本组件与概念有了个大致的印象，并且基于K8s实现了一个初步的CI/CD流程，但对里面涉及的各个对象（如Namespace, Pod, Deployment, Service, Ingress, PVC等）及各对象的管理可能还缺乏深入的理解与实践，接下来的文章就让我们一起深入K8s的各组件内部来一探究竟吧。下图是基于个人的理解梳理的一个K8s结构图，示例了各个组件（只包含了主要组件）如何协同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>解决K8s “kernel:unregister_netdevice:waiting for vethxxx to become free. Usage count=1” 的问题（Kernel升级）</title>
    <link href="http://blog.jboost.cn/k8s-netdevice-issue.html"/>
    <id>http://blog.jboost.cn/k8s-netdevice-issue.html</id>
    <published>2020-05-22T03:35:05.000Z</published>
    <updated>2020-08-26T01:43:56.751Z</updated>
    
    <content type="html"><![CDATA[<p>k8s集群运行过程中，经常出现节点上报出类似 “kernel:unregister_netdevice:waiting for vethxxx to become free. Usage count=1” 的错误信息，一方面影响交互，另一方面，对于有些操作比如 <code>docker stop</code>，半天没有响应，处于hang住的状态。</p><a id="more"></a><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>操作系统及内核版本为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-2 ~]# cat /etc/redhat-release </span><br><span class="line">CentOS Linux release 7.6.1810 (Core) </span><br><span class="line"></span><br><span class="line">[root@dev-server-2 ~]# uname -a</span><br><span class="line">Linux dev-server-2 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>经常有节点报出类似如下错误</p><p><img src="/assets/docker-bug.png" alt="docker-bug"></p><p>查看一些网上资料，一般都说是Kernel的Bug，并且虽然有些地方说在先前版本已经修复，但是在较高版本上仍有出现。</p><p>有一些解决办法是停止syslog服务，让其不将错误信息显示到控制台，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-2 ~]# systemctl stop rsyslog</span><br></pre></td></tr></table></figure><p>但这只能解决影响交互的问题，对于容器引擎被hang住的问题并没有解决，治标不治本。</p><p>也有人对此Bug的原因进行了追踪分析，判断可能是net_device引用计数器泄露的原因（参考：<a href="https://zhuanlan.zhihu.com/p/66895097" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66895097</a> ），并给出了修复补丁，尝试着安装给出的补丁，但没有成功。</p><p>查看了目前elrepo的kernel的ml（mainline stable，稳定的主线版本）版本已经到了 5.6.14-1.el7.elrepo， 于是尝试着对kernel进行升级。</p><h2 id="升级Kernel"><a href="#升级Kernel" class="headerlink" title="升级Kernel"></a>升级Kernel</h2><ol><li>更新yum仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-2 ~]# yum -y update</span><br></pre></td></tr></table></figure><ol start="2"><li>导入elrepo仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">导入elrepo仓库的公钥</span></span><br><span class="line">[root@dev-server-2 ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"><span class="meta">#</span><span class="bash">安装ELRepo仓库的yum源</span></span><br><span class="line">[root@dev-server-2 ~]# rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash">查看可用的kerner版本</span></span><br><span class="line">[root@dev-server-2 ~]# yum --disablerepo="*" --enablerepo="elrepo-kernel" list available</span><br></pre></td></tr></table></figure><ol start="3"><li>升级内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装最新版的内核</span></span><br><span class="line">[root@dev-server-2 ~]# yum --enablerepo=elrepo-kernel install kernel-ml</span><br></pre></td></tr></table></figure><ol start="4"><li>设置默认启动内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看系统已有内核</span></span><br><span class="line">[root@dev-server-2 ~]# sudo awk -F\' '$1=="menuentry " &#123;print i++ " : " $2&#125;' /etc/grub2.cfg</span><br><span class="line">0 : CentOS Linux (5.6.14-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">1 : CentOS Linux (3.10.0-957.el7.x86_64) 7 (Core)</span><br><span class="line">2 : CentOS Linux (0-rescue-f638aa03cdcf42998b077254bde50b53) 7 (Core)</span><br><span class="line"><span class="meta">#</span><span class="bash">设置默认启动内核，其中0为上述查出内核的索引</span></span><br><span class="line">grub2-set-default 0</span><br><span class="line"><span class="meta">#</span><span class="bash">生成grub配置文件</span></span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><ol start="5"><li>重启验证</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">[root@dev-server-2 devuser]# reboot</span><br><span class="line"><span class="meta">#</span><span class="bash">查看当前内核版本</span></span><br><span class="line">[root@dev-server-2 devuser]# uname -a</span><br><span class="line">Linux dev-server-2 5.6.14-1.el7.elrepo.x86_64 #1 SMP Tue May 19 12:17:13 EDT 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><ol start="6"><li>删除旧内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看现有内核</span></span><br><span class="line">[root@dev-server-2 devuser]# rpm -qa | grep kernel</span><br><span class="line">kernel-tools-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-headers-3.10.0-1062.1.1.el7.x86_64</span><br><span class="line">kernel-debuginfo-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-tools-libs-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-debuginfo-common-x86_64-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-ml-5.6.14-1.el7.elrepo.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash">删除旧的内核</span></span><br><span class="line">[root@dev-server-2 devuser]# yum remove ernel-tools-3.10.0-957.el7.x86_64 kernel-headers-3.10.0-1062.1.1.el7.x86_64 kernel-debuginfo-3.10.0-957.el7.x86_64 kernel-tools-libs-3.10.0-957.el7.x86_64 kernel-debuginfo-common-x86_64-3.10.0-957.el7.x86_64 kernel-3.10.0-957.el7.x86_64</span><br></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>通过升级内核重启后，问题目前没有再复现。但是否彻底解决该Bug待进一步跟进（至少不需要重装系统了）。</p><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/66895097" target="_blank" rel="noopener">诊断修复 TiDB Operator 在 K8s 测试中遇到的 Linux 内核问题</a></li><li><a href="https://www.cnblogs.com/xzkzzz/p/9627658.html" target="_blank" rel="noopener">Centos7 升级内核版本</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;k8s集群运行过程中，经常出现节点上报出类似 “kernel:unregister_netdevice:waiting for vethxxx to become free. Usage count=1” 的错误信息，一方面影响交互，另一方面，对于有些操作比如 &lt;code&gt;docker stop&lt;/code&gt;，半天没有响应，处于hang住的状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>面试官：请写一个你认为比较“完美”的单例</title>
    <link href="http://blog.jboost.cn/patterns-singleton.html"/>
    <id>http://blog.jboost.cn/patterns-singleton.html</id>
    <published>2020-05-12T03:50:21.000Z</published>
    <updated>2020-08-26T01:36:48.632Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是保证一个类的实例有且只有一个，在需要控制资源（如数据库连接池），或资源共享（如有状态的工具类）的场景中比较适用。如果让我们写一个单例实现，估计绝大部分人都觉得自己没问题，但如果需要实现一个比较完美的单例，可能并没有你想象中简单。本文以主人公小雨的一次面试为背景，循序渐进地讨论如何实现一个较为“完美”的单例。本文人物与场景皆为虚构，如有雷同，纯属捏造。</p><a id="more"></a><p>小雨计算机专业毕业三年，对设计模式略有涉猎，能写一些简单的实现，掌握一些基本的JVM知识。在某次面试中，面试官要求现场写代码：请写一个你认为比较“完美”的单例。</p><h2 id="简单的单例实现"><a href="#简单的单例实现" class="headerlink" title="简单的单例实现"></a>简单的单例实现</h2><p>凭借着对单例的理解与印象，小雨写出了下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完后小雨审视了一遍，总觉得有点太简单了，离“完美”貌似还相差甚远。对，在多线程并发环境下，这个实现就玩不转了，如果两个线程同时调用 getInstance() 方法，同时执行到了 if 判断，则两边都认为 instance 实例为空，都会实例化一个 Singleton 对象，就会导致至少产生两个实例了，小雨心想。嗯，需要解决多线程并发环境下的同步问题，保证单例的线程安全。</p><h2 id="线程安全的单例"><a href="#线程安全的单例" class="headerlink" title="线程安全的单例"></a>线程安全的单例</h2><p>一提到并发同步问题，小雨就想到了锁。加个锁还不简单，synchronized 搞起，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小雨再次审视了一遍，发现貌似每次 getInstance() 被调用时，其它线程必须等待这个线程调用完才能执行（因为有锁锁住了嘛），但是加锁其实是想避免多个线程同时执行实例化操作导致产生多个实例，在单例被实例化后，后续调用 getInstance() 直接返回就行了，每次都加锁释放锁造成了不必要的开销。</p><p>经过一阵思索与回想之后，小雨记起了曾经看过一个叫 Double-Checked Locking 的东东，双重检查锁，嗯，再优化一下,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例在完成第一次实例化，后续再调用 getInstance() 先判空，如果不为空则直接返回，如果为空，就算两个线程同时判断为空，在同步块中还做了一次双重检查，可以确保只会实例化一次，省去了不必要的加锁开销，同时也保证了线程安全。并且令小雨感到自我满足的是他基于对JVM的一些了解加上了 volatile 关键字来避免实例化时由于指令重排序优化可能导致的问题，真是画龙点睛之笔啊。 简直——完美！</p><div class="note quote">            <p class='p subtitle'>Tips: volatile关键字的语义</p><ol><li>保证变量对所有线程的可见性。对变量写值的时候JMM（Java内存模型）会将当前线程的工作内存值刷新到主内存，读的时候JMM会从主内存读取变量的值而不是从工作内存读取，确保一个变量值被一个线程更新后，另一个线程能立即读取到更新后的值。</li><li>禁止指令重排序优化。JVM在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序，使用 volatile 可以禁止进行指令重排序优化。</li></ol><p>JVM创建一个新的实例时，主要需三步：</p><ol><li>分配内存</li><li>初始化构造器</li><li>将对象引用指向分配的内存地址</li></ol><p>如果一个线程在实例化时JVM做了指令重排，比如先执行了1，再执行3，最后执行2，则另一个线程可能获取到一个还没有完成初始化的对象引用，调用时可能导致问题，使用volatile可以禁止指令重排，避免这种问题。</p>          </div><p>小雨将答案交给面试官，面试官瞄了一眼说道：“基本可用了，但如果我用反射直接调用这个类的构造函数，是不是就不能保证单例了。”  小雨挠挠头，对哦，如果使用反射就可以在运行时改变单例构造器的可见性，直接调用构造器来创建一个新的实例了，比如通过下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;Singleton&gt; constructor = Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Singleton singleton = constructor.newInstance();</span><br></pre></td></tr></table></figure><p>小雨再次陷入了思考。</p><h2 id="反射安全的单例"><a href="#反射安全的单例" class="headerlink" title="反射安全的单例"></a>反射安全的单例</h2><p>怎么避免反射破坏单例呢，或许可以加一个静态变量来控制,让构造器只有从 getInstance() 内部调用才有效，不通过 getInstance() 直接调用则抛出异常，小雨按这个思路做了一番改造，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Please use getInstance() method to get the single instance."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态变量 flag 来控制，只有从 getInstance() 调用构造器才能正常实例化，否则抛出异常。但马上小雨就发现了存在的问题：既然可以通过反射来调用构造器，那么也可以通过反射来改变 flag 的值，这样苦心设置的 flag 控制逻辑不就被打破了吗。看来也没那么“完美”。虽然并不那么完美，但也一定程度上规避了使用反射直接调用构造器的场景，并且貌似也想不出更好的办法了，于是小雨提交了答案。</p><p>面试官露出迷之微笑：“想法挺好，反射的问题基本解决了，但如果我序列化这个单例对象，然后再反序列化出来一个对象，这两个对象还一样吗，还能保证单例吗。如果不能，怎么解决这个问题？”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SerializationSafeSingleton s1 = SerializationSafeSingleton.getInstance();</span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">oos.writeObject(s1);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">SerializationSafeSingleton s2 = (SerializationSafeSingleton) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>s1 == s2 吗？ 答案是否，如何解决呢。</p><h2 id="序列化安全的单例"><a href="#序列化安全的单例" class="headerlink" title="序列化安全的单例"></a>序列化安全的单例</h2><p>小雨思考了一会，想起了曾经学习序列化知识时接触的 readResolve() 方法，该方法在ObjectInputStream已经读取一个对象并在准备返回前调用，可以用来控制反序列化时直接返回一个对象，替换从流中读取的对象，于是在前面实现的基础上，小雨添加了一个 readResolve() 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Please use getInstance() method to get the single instance."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法代替了从流中读取对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过几个步骤的逐步改造优化，小雨完成了一个基本具备线程安全、反射安全、序列化安全的单例实现，心想这下应该足够完美了吧。面试官脸上继续保持着迷之微笑：“这个实现看起来还是显得有点复杂，并且也不能完全解决反射安全的问题，想想看还有其它实现方案吗。”</p><h2 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h2><p>小雨反复思考，前面的实现是通过加锁来实现线程安全，除此之外，还可以通过类的加载机制来实现线程安全——类的静态属性只会在第一次加载类时初始化，并且在初始化的过程中，JVM是不允许其它线程来访问的，于是又写出了下面两个版本</p><ol><li>静态初始化版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该版本借助JVM的类加载机制，本身线程安全，但只要 Singleton 类的某个静态对象（方法或属性）被访问，就会造成实例的初始化，而该实例可能根本不会被用到，造成资源浪费，另一方面也存在反射与序列化的安全性问题，也需要进行相应的处理。</p><ol start="2"><li>静态内部类版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该版本只有在调用 getInstance() 才会进行实例化，即延迟加载，避免资源浪费的问题，同时也能保障线程安全，但是同样存在反射与序列化的安全性问题，需要相应处理。</p><p>这貌似跟前面版本的复杂性差不多啊，依然都需要解决反射与安全性的问题，小雨心想，有没有一种既简单又能避免这些问题的方案呢。</p><h2 id="“完美”方案"><a href="#“完美”方案" class="headerlink" title="“完美”方案"></a>“完美”方案</h2><p>一阵苦思冥想之后，小雨突然脑中灵光闪现，枚举！（这也是《Effective Java》的作者推荐的方式啊）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接通过 Singleton.INSTANCE 来引用单例，非常简单的实现，并且既是线程安全的，同时也能应对反射与序列化的问题，面试官想要的估计就是它了吧。小雨再次提交了答案，这一次，面试官脸上的迷之微笑逐渐消失了……</p><div class="note quote">            <p class='p subtitle'>Tips：为什么枚举是线程、反射、序列化安全的？</p><ol><li>枚举实际是通过一个继承自Enum的final类来实现（通过反编译class文件可看到具体实现），在static代码块中对其成员进行初始化，因此借助类加载机制来保障其线程安全</li><li>枚举是不支持通过反射实例化的，在Constructor类的newInstance方法中可看到</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br></pre></td></tr></table></figure>3. 枚举在序列化的时候仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。并且，编译器是不允许任何对这种序列化机制的定制的，禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。枚举通过这种机制保障了序列化安全。          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>枚举方案近乎“完美”，但实际中，大部分情况下，我们使用双重检查锁方案或静态内部类方案基本都能满足我们的场景并能很好地运行。并且方案从来没有“完美”，只有更好或更合适。本文只是从单例实现的不断演进的过程中，了解或回顾如反射、序列化、线程安全、Java内存模型（volatile语义）、JVM类加载机制、JVM指令重排序优化等方面的知识，同时也是启示我们在设计或实现的过程中，多从各个角度思考，尽可能全面地考虑问题。或者，在相关面试中能更好地迎合面试官的“完美”期望。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是保证一个类的实例有且只有一个，在需要控制资源（如数据库连接池），或资源共享（如有状态的工具类）的场景中比较适用。如果让我们写一个单例实现，估计绝大部分人都觉得自己没问题，但如果需要实现一个比较完美的单例，可能并没有你想象中简单。本文以主人公小雨的一次面试为背景，循序渐进地讨论如何实现一个较为“完美”的单例。本文人物与场景皆为虚构，如有雷同，纯属捏造。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="设计模式" scheme="http://blog.jboost.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（三）：Gitlab+Jenkins Pipeline+Docker+k8s+Helm自动化部署实践（干货！）</title>
    <link href="http://blog.jboost.cn/k8s3-cd.html"/>
    <id>http://blog.jboost.cn/k8s3-cd.html</id>
    <published>2020-05-09T03:53:23.000Z</published>
    <updated>2020-08-26T01:44:17.155Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面两篇文章，我们已经有了一个“嗷嗷待哺”的K8s集群环境，也对相关的概念与组件有了一个基本了解（前期对概念有个印象即可，因为只有实践了才能对其有深入理解，所谓“纸上得来终觉浅，绝知此事要躬行”），本文从实践角度介绍如何结合我们常用的Gitlab与Jenkins，通过K8s来实现项目的自动化部署，示例将包括基于SpringBoot的服务端项目与基于Vue.js的Web项目。</p><a id="more"></a><p>本文涉及到的工具与技术包括：</p><ul><li>Gitlab —— 常用的源代码管理系统</li><li>Jenkins, Jenkins Pipeline —— 常用的自动化构建、部署工具，Pipeline以流水线的方式将构建、部署的各个步骤组织起来</li><li>Docker，Dockerfile —— 容器引擎，所有应用最终都要以Docker容器运行，Dockerfile是Docker镜像定义文件</li><li>Kubernetes —— Google开源的容器编排管理系统</li><li>Helm —— Kubernetes的包管理工具，类似Linux的yum，apt，或Node的npm等包管理工具，能将Kubernetes中的应用及相关依赖服务以包（Chart）的形式组织管理</li></ul><p>环境背景：</p><ol><li>已使用Gitlab做源码管理，源码按不同的环境建立了develop（对应开发环境），pre-release（对应测试环境），master（对应生产环境）分支</li><li>已搭建了Jenkins服务</li><li>已有Docker Registry服务，用于Docker镜像存储（基于Docker Registry或Harbor自建，或使用云服务，本文使用阿里云容器镜像服务）</li><li>已搭建了K8s集群</li></ol><p>预期效果：</p><ol><li>分环境部署应用，开发环境、测试环境、生产环境分开来，部署在同一集群的不同namespace，或不同集群中（比如开发测试部署在本地集群的不同namespace中，生产环境部署在云端集群）</li><li>配置尽可能通用化，只需要通过修改少量配置文件的少量配置属性，就能完成新项目的自动化部署配置</li><li>开发测试环境在push代码时自动触发构建与部署，生产环境在master分支上添加版本tag并且push tag后触发自动部署</li><li>整体交互流程如下图</li></ol><p><img src="http://blog.jboost.cn/assets/jenkins-cicd.png" alt="jenkins-cicd"></p><h2 id="项目配置文件"><a href="#项目配置文件" class="headerlink" title="项目配置文件"></a>项目配置文件</h2><p>首先我们需要在项目的根路径中添加一些必要的配置文件，如下图所示</p><p><img src="http://blog.jboost.cn/assets/springboot-ci-structure.png" alt="springboot-ci-structure"></p><p>包括：</p><ol><li>Dockerfile文件，用于构建Docker镜像的文件（参考 <a href="http://blog.jboost.cn/docker-11.html">Docker笔记（十一）：Dockerfile详解与最佳实践</a>）</li><li>Helm相关配置文件，Helm是Kubernetes的包管理工具，可以将应用部署相关的Deployment，Service，Ingress等打包进行发布与管理（Helm的具体介绍我们后面再补充）</li><li>Jenkinsfile文件，Jenkins的pipeline定义文件，定义了各个阶段需执行的任务</li></ol><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>在项目根目录中添加一个Dockerfile文件（文件名就叫Dockerfile），定义如何构建Docker镜像，以Spring Boot项目为例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM frolvlad&#x2F;alpine-java:jdk8-slim</span><br><span class="line">#在build镜像时可以通过 --build-args profile&#x3D;xxx 进行修改</span><br><span class="line">ARG profile</span><br><span class="line">ENV SPRING_PROFILES_ACTIVE&#x3D;$&#123;profile&#125;</span><br><span class="line">#项目的端口</span><br><span class="line">EXPOSE 8000 </span><br><span class="line">WORKDIR &#x2F;mnt</span><br><span class="line"></span><br><span class="line">#修改时区</span><br><span class="line">RUN sed -i &#39;s&#x2F;dl-cdn.alpinelinux.org&#x2F;mirrors.ustc.edu.cn&#x2F;g&#39; &#x2F;etc&#x2F;apk&#x2F;repositories \</span><br><span class="line">    &amp;&amp; apk add --no-cache tzdata \</span><br><span class="line">    &amp;&amp; ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime \</span><br><span class="line">    &amp;&amp; echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone \</span><br><span class="line">    &amp;&amp; apk del tzdata \</span><br><span class="line">    &amp;&amp; rm -rf &#x2F;var&#x2F;cache&#x2F;apk&#x2F;* &#x2F;tmp&#x2F;* &#x2F;var&#x2F;tmp&#x2F;* $HOME&#x2F;.cache</span><br><span class="line"></span><br><span class="line">COPY .&#x2F;target&#x2F;your-project-name-1.0-SNAPSHOT.jar .&#x2F;app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;&#x2F;mnt&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>将SPRING_PROFILES_ACTIVE通过参数profile暴露出来，在构建的时候可以通过 –build-args profile=xxx 来进行动态设定，以满足不同环境的镜像构建要求。</p><blockquote><p>SPRING_PROFILES_ACTIVE本可以在Docker容器启动时通过<code>docker run -e SPRING_PROFILES_ACTIVE=xxx</code>来设定，因这里使用Helm进行部署不直接通过<code>docker run</code>运行，因此通过ARG在镜像构建时指定</p></blockquote><h3 id="Helm配置文件"><a href="#Helm配置文件" class="headerlink" title="Helm配置文件"></a>Helm配置文件</h3><p>Helm是Kubernetes的包管理工具，将应用部署相关的Deployment，Service，Ingress等打包进行发布与管理（可以像Docker镜像一样存储于仓库中）。如上图中Helm的配置文件包括：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">helm                                    - chart包的目录名</span><br><span class="line">├── templates                           - k8s配置模版目录</span><br><span class="line">│   ├── deployment.yaml                 - Deployment配置模板，定义如何部署Pod</span><br><span class="line">│   ├── _helpers.tpl                    - 以下划线开头的文件，helm视为公共库定义文件，用于定义通用的子模版、函数、变量等</span><br><span class="line">│   ├── ingress.yaml                    - Ingress配置模板，定义外部如何访问Pod提供的服务，类似于Nginx的域名路径配置</span><br><span class="line">│   ├── NOTES.txt                       - chart包的帮助信息文件，执行helm install命令成功后会输出这个文件的内容</span><br><span class="line">│   └── service.yaml                    - Service配置模板，配置访问Pod的服务抽象，有NodePort与ClusterIp等</span><br><span class="line">|── values.yaml                         - chart包的参数配置文件，各模版文件可以引用这里的参数</span><br><span class="line">├── Chart.yaml                          - chart定义，可以定义chart的名字，版本号等信息</span><br><span class="line">├── charts                              - 依赖的子包目录，里面可以包含多个依赖的chart包，一般不存在依赖，我这里将其删除了</span><br></pre></td></tr></table></figure><p>我们可以在Chart.yaml中定义每个项目的chart名称（类似安装包名），如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v2</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">your-chart-name</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">Helm</span> <span class="string">chart</span> <span class="string">for</span> <span class="string">Kubernetes</span></span><br><span class="line"></span><br><span class="line"><span class="attr">type:</span> <span class="string">application</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="number">1.16</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>在values.yaml中定义模板文件中需要用到的变量，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#部署Pod的副本数，即运行多少个容器</span></span><br><span class="line"><span class="attr">replicaCount:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#容器镜像配置</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/demo/demo</span></span><br><span class="line">  <span class="attr">pullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="comment"># Overrides the image tag whose default is the chart version.</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">"dev"</span></span><br><span class="line"><span class="comment">#镜像仓库访问凭证</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun-registry-secret</span></span><br><span class="line"><span class="comment">#覆盖启动容器名称</span></span><br><span class="line"><span class="attr">nameOverride:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">fullnameOverride:</span> <span class="string">""</span></span><br><span class="line"><span class="comment">#容器的端口暴露及环境变量配置</span></span><br><span class="line"><span class="attr">container:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">  <span class="attr">env:</span> <span class="string">[]</span></span><br><span class="line"><span class="comment">#ServiceAccount，默认不创建</span></span><br><span class="line"><span class="attr">serviceAccount:</span></span><br><span class="line">  <span class="comment"># Specifies whether a service account should be created</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Annotations to add to the service account</span></span><br><span class="line">  <span class="attr">annotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="attr">podAnnotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">podSecurityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># fsGroup: 2000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">securityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># capabilities:</span></span><br><span class="line">  <span class="comment">#   drop:</span></span><br><span class="line">  <span class="comment">#   - ALL</span></span><br><span class="line">  <span class="comment"># readOnlyRootFilesystem: true</span></span><br><span class="line">  <span class="comment"># runAsNonRoot: true</span></span><br><span class="line">  <span class="comment"># runAsUser: 1000</span></span><br><span class="line"><span class="comment">#使用NodePort的service，默认为ClusterIp</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="comment">#外部访问Ingress配置，需要配置hosts部分</span></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">annotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">    <span class="comment"># kubernetes.io/ingress.class: nginx</span></span><br><span class="line">    <span class="comment"># kubernetes.io/tls-acme: "true"</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">demo.com</span></span><br><span class="line">      <span class="attr">paths:</span> <span class="string">["/demo"]</span></span><br><span class="line">  <span class="attr">tls:</span> <span class="string">[]</span></span><br><span class="line">  <span class="comment">#  - secretName: chart-example-tls</span></span><br><span class="line">  <span class="comment">#    hosts:</span></span><br><span class="line">  <span class="comment">#      - chart-example.local</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#.... 省略了其它默认参数配置</span></span><br></pre></td></tr></table></figure><p>这里在默认生成的基础上添加了container部分，可以在这里指定容器的端口号而不用去改模板文件（让模板文件在各个项目通用，通常不需要做更改），同时添加env的配置，可以在helm部署时往容器里传入环境变量。将Service type从默认的ClusterIp改为了NodePort。部署同类型的不同项目时，只需要根据项目情况配置Chart.yaml与values.yaml两个文件的少量配置项，templates目录下的模板文件可直接复用。</p><p>部署时需要在K8s环境中从Docker镜像仓库拉取镜像，因此需要在K8s中创建镜像仓库访问凭证（imagePullSecrets）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录Docker Registry生成/root/.docker/config.json文件</span></span><br><span class="line">sudo docker login --username=your-username registry.cn-shenzhen.aliyuncs.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建namespace develop（我这里是根据项目的环境分支名称建立namespace）</span></span><br><span class="line">kubectl create namespace develop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在namespace develop中创建一个secret</span></span><br><span class="line">kubectl create secret generic aliyun-registry-secret --from-file=.dockerconfigjson=/root/.docker/config.json  --type=kubernetes.io/dockerconfigjson --namespace=develop</span><br></pre></td></tr></table></figure><h3 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h3><p>Jenkinsfile是Jenkins pipeline配置文件，遵循Groovy语法，对于Spring Boot项目的构建部署， 编写Jenkinsfile脚本文件如下，</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">image_tag = <span class="string">"default"</span>  <span class="comment">//定一个全局变量，存储Docker镜像的tag（版本）</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        GIT_REPO = <span class="string">"$&#123;env.gitlabSourceRepoName&#125;"</span>  <span class="comment">//从Jenkins Gitlab插件中获取Git项目的名称</span></span><br><span class="line">        GIT_BRANCH = <span class="string">"$&#123;env.gitlabTargetBranch&#125;"</span>  <span class="comment">//项目的分支</span></span><br><span class="line">        GIT_TAG = sh(<span class="string">returnStdout:</span> <span class="literal">true</span>,<span class="string">script:</span> <span class="string">'git describe --tags --always'</span>).trim()  <span class="comment">//commit id或tag名称</span></span><br><span class="line">        DOCKER_REGISTER_CREDS = credentials(<span class="string">'aliyun-docker-repo-creds'</span>) <span class="comment">//docker registry凭证</span></span><br><span class="line">        KUBE_CONFIG_LOCAL = credentials(<span class="string">'local-k8s-kube-config'</span>)  <span class="comment">//开发测试环境的kube凭证</span></span><br><span class="line">        KUBE_CONFIG_PROD = <span class="string">""</span> <span class="comment">//credentials('prod-k8s-kube-config') //生产环境的kube凭证</span></span><br><span class="line"></span><br><span class="line">        DOCKER_REGISTRY = <span class="string">"registry.cn-hangzhou.aliyuncs.com"</span> <span class="comment">//Docker仓库地址</span></span><br><span class="line">        DOCKER_NAMESPACE = <span class="string">"your-namespace"</span>  <span class="comment">//命名空间</span></span><br><span class="line">        DOCKER_IMAGE = <span class="string">"$&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_NAMESPACE&#125;/$&#123;GIT_REPO&#125;"</span> <span class="comment">//Docker镜像地址</span></span><br><span class="line"></span><br><span class="line">        INGRESS_HOST_DEV = <span class="string">"dev.your-site.com"</span>    <span class="comment">//开发环境的域名</span></span><br><span class="line">        INGRESS_HOST_TEST = <span class="string">"test.your-site.com"</span>  <span class="comment">//测试环境的域名</span></span><br><span class="line">        INGRESS_HOST_PROD = <span class="string">"prod.your-site.com"</span>  <span class="comment">//生产环境的域名</span></span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'ingress_path'</span>, <span class="string">defaultValue:</span> <span class="string">'/your-path'</span>, <span class="string">description:</span> <span class="string">'服务上下文路径'</span>)</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'replica_count'</span>, <span class="string">defaultValue:</span> <span class="string">'1'</span>, <span class="string">description:</span> <span class="string">'容器副本数量'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Code Analyze'</span>) &#123;</span><br><span class="line">            agent any</span><br><span class="line">            steps &#123;</span><br><span class="line">               echo <span class="string">"1. 代码静态检查"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Maven Build'</span>) &#123;</span><br><span class="line">            agent &#123;</span><br><span class="line">                docker &#123;</span><br><span class="line">                    image <span class="string">'maven:3-jdk-8-alpine'</span></span><br><span class="line">                    args <span class="string">'-v $HOME/.m2:/root/.m2'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"2. 代码编译打包"</span></span><br><span class="line">                sh <span class="string">'mvn clean package -Dfile.encoding=UTF-8 -DskipTests=true'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Docker Build'</span>) &#123;</span><br><span class="line">            agent any</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"3. 构建Docker镜像"</span></span><br><span class="line">                echo <span class="string">"镜像地址： $&#123;DOCKER_IMAGE&#125;"</span></span><br><span class="line">                <span class="comment">//登录Docker仓库</span></span><br><span class="line">                sh <span class="string">"sudo docker login -u $&#123;DOCKER_REGISTER_CREDS_USR&#125; -p $&#123;DOCKER_REGISTER_CREDS_PSW&#125; $&#123;DOCKER_REGISTRY&#125;"</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> profile = <span class="string">"dev"</span></span><br><span class="line">                    <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"develop"</span>) &#123;</span><br><span class="line">                        image_tag = <span class="string">"dev."</span> + env.GIT_TAG</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"pre-release"</span>) &#123;</span><br><span class="line">                        image_tag = <span class="string">"test."</span> + env.GIT_TAG</span><br><span class="line">                        profile = <span class="string">"test"</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"master"</span>)&#123;</span><br><span class="line">                        <span class="comment">// master分支则直接使用Tag</span></span><br><span class="line">                        image_tag = env.GIT_TAG</span><br><span class="line">                        profile = <span class="string">"prod"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//通过--build-arg将profile进行设置，以区分不同环境进行镜像构建</span></span><br><span class="line">                    sh <span class="string">"docker build  --build-arg profile=$&#123;profile&#125; -t $&#123;DOCKER_IMAGE&#125;:$&#123;image_tag&#125; ."</span></span><br><span class="line">                    sh <span class="string">"sudo docker push $&#123;DOCKER_IMAGE&#125;:$&#123;image_tag&#125;"</span></span><br><span class="line">                    sh <span class="string">"docker rmi $&#123;DOCKER_IMAGE&#125;:$&#123;image_tag&#125;"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Helm Deploy'</span>) &#123;</span><br><span class="line">            agent &#123;</span><br><span class="line">                docker &#123;</span><br><span class="line">                    image <span class="string">'lwolf/helm-kubectl-docker'</span></span><br><span class="line">                    args <span class="string">'-u root:root'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"4. 部署到K8s"</span></span><br><span class="line">                sh <span class="string">"mkdir -p /root/.kube"</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> kube_config = env.KUBE_CONFIG_LOCAL</span><br><span class="line">                    <span class="keyword">def</span> ingress_host = env.INGRESS_HOST_DEV</span><br><span class="line">                    <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"pre-release"</span>) &#123;</span><br><span class="line">                        ingress_host = env.INGRESS_HOST_TEST</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"master"</span>)&#123;</span><br><span class="line">                        ingress_host = env.INGRESS_HOST_PROD</span><br><span class="line">                        kube_config = env.KUBE_CONFIG_PROD</span><br><span class="line">                    &#125;</span><br><span class="line">                    sh <span class="string">"echo $&#123;kube_config&#125; | base64 -d &gt; /root/.kube/config"</span></span><br><span class="line">                    <span class="comment">//根据不同环境将服务部署到不同的namespace下，这里使用分支名称</span></span><br><span class="line">                    sh <span class="string">"helm upgrade -i --namespace=$&#123;env.gitlabTargetBranch&#125; --set replicaCount=$&#123;params.replica_count&#125; --set image.repository=$&#123;DOCKER_IMAGE&#125; --set image.tag=$&#123;image_tag&#125; --set nameOverride=$&#123;GIT_REPO&#125; --set ingress.hosts[0].host=$&#123;ingress_host&#125; --set ingress.hosts[0].paths=&#123;$&#123;params.ingress_path&#125;&#125; $&#123;GIT_REPO&#125; ./helm/"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jenkinsfile定义了整个自动化构建部署的流程：</p><ol><li>Code Analyze，可以使用SonarQube之类的静态代码分析工具完成代码检查，这里先忽略</li><li>Maven Build，启动一个Maven的Docker容器来完成项目的maven构建打包，挂载maven本地仓库目录到宿主机，避免每次都需要重新下载依赖包</li><li>Docker Build，构建Docker镜像，并推送到镜像仓库，不同环境的镜像通过tag区分，开发环境使用dev.commitId的形式，如dev.88f5822，测试环境使用test.commitId，生产环境可以将webhook事件设置为tag push event，直接使用tag名称</li><li>Helm Deploy，使用helm完成新项目的部署，或已有项目的升级，不同环境使用不同的参数配置，如访问域名，K8s集群的访问凭证kube_config等</li></ol><h2 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h2><h3 id="Jenkins任务配置"><a href="#Jenkins任务配置" class="headerlink" title="Jenkins任务配置"></a>Jenkins任务配置</h3><p>在Jenkins中创建一个pipeline的任务，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-pipeline-pro.png" alt="jenkins-pipeline-pro"></p><p>配置构建触发器，将目标分支设置为develop分支，生成一个token，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-pipeline-config1.png" alt="jenkins-pipeline-config1"></p><p>记下这里的“GitLab webhook URL”及token值，在Gitlab配置中使用。</p><p>配置流水线，选择“Pipeline script from SCM”从项目源码中获取pipeline脚本文件，配置项目Git地址，拉取源码凭证等，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-pipeline-config2.png" alt="jenkins-pipeline-config2.png"></p><p>保存即完成了项目开发环境的Jenkins配置。测试环境只需将对应的分支修改为pre-release即可</p><h3 id="Jenkins凭据配置"><a href="#Jenkins凭据配置" class="headerlink" title="Jenkins凭据配置"></a>Jenkins凭据配置</h3><p>在Jenkinsfile文件中，我们使用到了两个访问凭证——Docker Registry凭证与本地K8s的kube凭证，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_REGISTER_CREDS = credentials('aliyun-docker-repo-creds') //docker registry凭证</span><br><span class="line">KUBE_CONFIG_LOCAL = credentials('local-k8s-kube-config')  //开发测试环境的kube凭证</span><br></pre></td></tr></table></figure><p>这两个凭证需要在Jenkins中创建。</p><p>添加Docker Registry登录凭证,在Jenkins 凭据页面，添加一个用户名密码类型的凭据，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-cred.png" alt="jenkins-cred"></p><p><img src="http://blog.jboost.cn/assets/jenkins-cred2.png" alt="jenkins-cred2"></p><p>添加K8s集群的访问凭证，在master节点上将/root/.kube/config文件内容进行base64编码，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base64 /root/.kube/config &gt; kube-config-base64.txt</span><br><span class="line">cat kube-config-base64.txt</span><br></pre></td></tr></table></figure><p>使用编码后的内容在Jenkins中创建一个Secret text类型的凭据，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-cred3.png" alt="jenkins-cred3"></p><p>在Secret文本框中输入base64编码后的内容。</p><h2 id="Gitlab配置"><a href="#Gitlab配置" class="headerlink" title="Gitlab配置"></a>Gitlab配置</h2><p>在Gitlab项目的 Settings - Integrations 页面配置一个webhook，在URL与Secret Token中填入前面Jenkins触发器部分的“GitLab webhook URL”及token值，选中“Push events”作为触发事件，如图</p><p><img src="http://blog.jboost.cn/assets/gitlab-webhook-config.png" alt="gitlab-webhook-config"></p><p>开发、测试环境选择“Push events”则在开发人员push代码，或merge代码到develop，pre-release分支时，就会触发开发或测试环境的Jenkins pipeline任务完成自动化构建；生产环境选择“Tag push events”，在往master分支push tag时触发自动化构建。如图为pipeline构建视图</p><p><img src="http://blog.jboost.cn/assets/jenkins-build.png" alt="jenkins-build"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍使用Gitlab+Jenkins Pipeline+Docker+Kubernetes+Helm来实现Spring Boot项目的自动化部署，只要稍加修改即可应用于其它基于Spring Boot的项目（具体修改的地方在源码的Readme文件中说明）。</p><p>本文涉及的所有配置文件（包括基于Spring Boot的服务端项目与基于Vue.js的Web项目）可在源码项目中获取（源码地址获取办法：关注公众号“半路雨歌”，首页输入“k8sops”即可）。</p><p>原文地址：<a href="http://blog.jboost.cn/k8s3-cd.html">http://blog.jboost.cn/k8s3-cd.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前面两篇文章，我们已经有了一个“嗷嗷待哺”的K8s集群环境，也对相关的概念与组件有了一个基本了解（前期对概念有个印象即可，因为只有实践了才能对其有深入理解，所谓“纸上得来终觉浅，绝知此事要躬行”），本文从实践角度介绍如何结合我们常用的Gitlab与Jenkins，通过K8s来实现项目的自动化部署，示例将包括基于SpringBoot的服务端项目与基于Vue.js的Web项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
      <category term="helm" scheme="http://blog.jboost.cn/tags/helm/"/>
    
      <category term="jenkins" scheme="http://blog.jboost.cn/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（二）：了解k8s的基本组件与概念</title>
    <link href="http://blog.jboost.cn/k8s2-concept.html"/>
    <id>http://blog.jboost.cn/k8s2-concept.html</id>
    <published>2020-05-06T13:13:53.000Z</published>
    <updated>2020-08-26T01:44:14.116Z</updated>
    
    <content type="html"><![CDATA[<p>前文 <a href="/k8s1-installation.html">Kubernetes笔记（一）：十分钟部署一套K8s环境</a> 介绍了如何快速搭建一个k8s系统。为了继续使用k8s来部署我们的应用，需要先对k8s中的一些基本组件与概念有个了解。</p><a id="more"></a><h2 id="Kubernetes是什么"><a href="#Kubernetes是什么" class="headerlink" title="Kubernetes是什么"></a>Kubernetes是什么</h2><p>Kubernetes是Google于2014年基于其内部Brog系统开源的一个容器编排管理系统，可使用声明式的配置（以yaml文件的形式）自动地执行容器化应用程序的管理，包括部署、伸缩、负载均衡、回滚等。</p><p>kubernetes提供的功能：</p><ul><li>自动发布与伸缩：可以通过声明式的配置文件定义想要部署的容器，Kubernetes将自动进行容器的部署，达到期望的结果；通过指定容器副本数，或者设置根据资源负载情况（如CPU、内存使用率），自动对容器组进行快速的伸缩——增大或缩小容器数量</li><li>滚动升级与灰度发布：采用逐步替换的策略实现滚动升级，使用Kubernetes也可以很轻易地管理系统的灰度发布</li><li>服务发现与负载均衡：Kubernetes通过DNS名称或IP地址暴露容器的访问方式，并且可在同一容器组内实现负载分发与均衡</li><li>存储编排：Kubernetes可以自动挂载指定的存储系统，如local storage/nfs/云存储等</li><li>故障恢复：Kubernetes自动重启已经停机的容器，替换不满足健康检查的容器</li><li>密钥与配置管理：Kubernetes可以存储与管理敏感信息，如Docker Registry的登录凭证，密码，ssh密钥等</li></ul><h2 id="Kubernetes架构"><a href="#Kubernetes架构" class="headerlink" title="Kubernetes架构"></a>Kubernetes架构</h2><p>我们先来看一张Kubernetes的架构图</p><p><img src="/assets/k8s-arch.png" alt="k8s-arch"></p><p>Kubernetes是一套分布式系统， 与大多数分布式系统类似，包含控制节点（master node）与工作节点（worker node）。</p><h3 id="master-node"><a href="#master-node" class="headerlink" title="master node"></a>master node</h3><p>控制节点就是指挥官，负责发号施令的，其上运行一些管理服务来对整个系统进行管理与控制，包括</p><ul><li>apiserver：作为整个系统的对外接口，提供一套Restful API供客户端调用，任何的资源请求/调用操作都是通过kube-apiserver提供的接口进行,如kubectl、kubernetes dashboard等管理工具就是通过apiserver来实现对集群的管理</li><li>kube-scheduler：资源调度器，负责将容器组分配到哪些节点上</li><li>kube-controller-manager：管理控制器，集群中处理常规任务的后台线程，包括节点控制器（负责监听节点停机的事件并作出对应响应）、endpoint-controller（刷新服务与容器组的关联信息）、replication-controller（维护容器组的副本数为指定的数值）、Service Account &amp; Token控制器（负责为新的命名空间创建默认的 Service Account 以及 API Access Token）</li><li>etcd：数据存储，存储集群所有的配置信息</li><li>coredns：实现集群内部通过服务名称进行容器组访问的功能</li></ul><h3 id="worker-node"><a href="#worker-node" class="headerlink" title="worker node"></a>worker node</h3><p>工作节点就是具体干活的小兵，其上也运行一些服务来执行指挥官分派的任务，包括</p><ul><li>kubelet：是工作节点上执行操作的代理程序，负责容器的生命周期管理，定期执行容器健康检查，并上报容器的运行状态</li><li>kube-proxy：是一个具有负载均衡能力的简单的网络访问代理，负责将访问某个服务的请求分配到工作节点的具体某个容器上（kube-proxy也运行于master node上）</li><li>Docker Daemon：这个不难理解，所有服务或容器组都要以Docker容器的形式来运行（但Kubernetes其实不局限于Docker，它支持任何实现了Kubernetes容器引擎接口的容器引擎，如containerd、rktlet）</li></ul><p>另外还有既在master node上也在worker node上运行的网络通信组件 kube-flannel。这些服务组件一般运行在kube-system的命名空间中，如图</p><p><img src="/assets/kube-system.png" alt="kube-system"></p><h2 id="Kubernetes基本概念"><a href="#Kubernetes基本概念" class="headerlink" title="Kubernetes基本概念"></a>Kubernetes基本概念</h2><p>我们再来看第二张图</p><p><img src="/assets/k8s.png" alt="k8s"></p><p>功能组件在上面已经做了介绍。Kubernetes的操作对象主要包括容器组（Pod），服务（Service），副本控制器（replication-controller），及围绕这些的其它辅助对象</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是Kubernetes创建或部署的最小基本单元。一个Pod封装一个或多个应用容器、存储资源、一个独立的网络IP以及管理控制容器运行方式的策略选项。Pod中的每个容器共享网络命名空间（包括IP与端口），Pod内的容器可以使用localhost相互通信。Pod可以指定一组共享存储卷Volumes，Pod中所有容器都可以访问共享的Volumes，Volumes用于数据持久化，防止容器重启丢失数据。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Kubernetes使用Volume来解决Pod中容器重启数据丢失的问题，以及Pod中多个容器间数据共享的问题。Kubernetes支持的Volume类型包括：</p><ul><li>emptyDir：当Pod分配到Node上时，将会创建emptyDir，只要Node上的Pod一直运行，Volume就会一直存在。当Pod（不管任何原因）从Node上被删除时，emptyDir也同时会删除，存储的数据也将永久删除，但删除容器不影响emptyDir</li><li>hostPath：hostPath允许挂载Node上的文件系统到Pod里面去。如果Pod需要使用Node上的文件，可以使用hostPath</li><li>nfs: 使用nfs网络文件系统提供的共享目录</li></ul><h3 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h3><p>ReplicationController确保在任何时候都有按配置的Pod副本数在运行。现在推荐使用配置ReplicaSet（下一代ReplicationController）的Deployment来建立副本管理机制。</p><h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><p>ReplicaSet是下一代ReplicationController，两者的唯一区别是ReplicaSet支持新的基于集合的选择器，而ReplicationController仅支持基于相等选择器的需求。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment为Pod与ReplicaSet提供了声明式的定义，描述你想要的目标状态是什么，Deployment controller就会帮你将Pod与ReplicaSet的实际状态改变到你想要的目标状态。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>一个Service可以看做一组提供相同服务的Pod的对外访问接口。Kubernetes提供两种类型的Service：</p><ul><li>NodePort： 集群外部可以通过Node IP与Node Port来访问具体某个Pod</li><li>ClusterIP：指通过集群的内部IP暴露服务，服务只能够在集群内部可以访问，这也是默认的 ServiceType</li></ul><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Label就是一对key/value，可以附加到各种资源对象上，如Node、Pod、Service等，一个资源对象可以定义任意数量的Label。可以通过Label选择器来选择具备某个（些）Label的资源。</p><h3 id="PV-amp-PVC"><a href="#PV-amp-PVC" class="headerlink" title="PV &amp; PVC"></a>PV &amp; PVC</h3><p>PersistentVolume（PV） 为用户提供了一个存储抽象，由管理员设置，它是集群的一部分。就像节点是集群中的资源一样，PV也是集群中的资源。 PV是Volume之类的卷插件，但具有独立于Pod的生命周期。</p><p>PersistentVolumeClaim（PVC）是用户存储的请求。它与Pod相似。Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源（CPU和内存）。PVC可以请求特定大小和访问模式的存储资源（例如，可以以读/写或只读模式挂载）。</p><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><p>Secret解决了密码、token、密钥等敏感数据的存储问题，Secret的三种类型：</p><ul><li>Service Account ：用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中</li><li>Opaque ：Base64编码格式的Secret，用来存储密码、密钥等</li><li>kubernetes.io/dockerconfigjson ：用来存储docker registry的认证信息</li></ul><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>ConfigMap用来保存key/value对的配置数据，这个数据可以在Pods里使用，或者被用来为像controller一样的系统组件存储配置数据。ConfigMap可以方便的处理不含敏感信息的字符串（敏感信息可使用Secret）。</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace类似于Kubernetes中的虚拟集群，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。比如我们如果开发测试共用一个Kubernetes集群，则可以将开发环境的服务部署到dev的namespace，测试环境的部署到test的namespace。</p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>为集群服务提供外部访问，包括基于Nginx与Traefik两个版本，为服务提供域名绑定访问与路径路由功能。也可以基于Ingress实现服务的灰度发布。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对Kubernetes中涉及的基本组件与概念进行了整理，对其基本构成有了一个大致的理解与印象。下一篇将从一个实践出发，实现一个基于Gitlab+Jenkins+K8s的CI/CD流程，以对涉及的各个组件进行深入了解与学习。</p><hr><p>相关阅读：</p><ul><li><a href="/k8s1-installation.html">Kubernetes笔记（一）：十分钟部署一套K8s环境</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文 &lt;a href=&quot;/k8s1-installation.html&quot;&gt;Kubernetes笔记（一）：十分钟部署一套K8s环境&lt;/a&gt; 介绍了如何快速搭建一个k8s系统。为了继续使用k8s来部署我们的应用，需要先对k8s中的一些基本组件与概念有个了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（一）：十分钟部署一套K8s环境</title>
    <link href="http://blog.jboost.cn/k8s1-installation.html"/>
    <id>http://blog.jboost.cn/k8s1-installation.html</id>
    <published>2020-04-28T00:21:03.000Z</published>
    <updated>2020-08-26T01:44:10.469Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes是Goole开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理 —— 百度百科。</p><p>接触K8s也有半年多了，也基于阿里云平台搭建了包含多级服务、目前运行较为稳定的K8s集群（感兴趣的可参考 <a href="https://mp.weixin.qq.com/s/8s-OUUsZI0UyyyTgruEO1A" target="_blank" rel="noopener">k8s云集群混搭模式，可能帮你节省50%以上的服务成本</a>， <a href="https://mp.weixin.qq.com/s/VuSWn7cWacW6i_MtpvQ5Sw" target="_blank" rel="noopener">k8s云集群混搭模式落地分享</a>），但一直没来得及对其进行系统的学习，本系列文章还像以前Docker系列一样，以笔记的形式进行记录与分享，会包括理论与实践，感兴趣的同学可以关注，一起探索下目前较为流行的容器化及服务编排解决方案。</p><a id="more"></a><p>工欲善其事，必先利其器，本文先介绍如何在本地自行搭建一套k8s集群，并且采用我们前面介绍过的Ansible来提高效率（参考 <a href="https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw" target="_blank" rel="noopener">Ansible简明教程</a>）</p><p>本文所涉及的所有配置文件可在这里找到 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation" target="_blank" rel="noopener">github</a></p><h2 id="一-准备服务器节点"><a href="#一-准备服务器节点" class="headerlink" title="一. 准备服务器节点"></a>一. 准备服务器节点</h2><p>如果还没有服务器，可以参考 <a href="https://mp.weixin.qq.com/s/FVyzPVwwQ85AC4jlVZvF4g" target="_blank" rel="noopener">ubuntu18.04上搭建KVM虚拟机环境超完整过程</a> 创建虚拟服务器。</p><p>服务器节点IP（hostname）：</p><ul><li>192.168.40.111 (kmaster)</li><li>192.168.40.112 (knode1)</li><li>192.168.40.113 (knode2)</li><li>192.168.40.114 (knode3)</li></ul><p>操作系统版本：</p><ul><li><code>cat /etc/redhat-release</code> : CentOS Linux release 7.6.1810 (Core)</li><li><code>uname -a</code> : 3.10.0-957.el7.x86_64</li></ul><h2 id="二-配置Ansible"><a href="#二-配置Ansible" class="headerlink" title="二. 配置Ansible"></a>二. 配置Ansible</h2><p>如果还没有Ansible环境，可以参考 [Ansible简明教程]<a href="https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw</a>) 搭建。</p><p>1.在Ansible服务器上的/etc/hosts文件中添加k8s服务器节点信息(参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/hosts" target="_blank" rel="noopener">hosts</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.40.111 kmaster</span><br><span class="line">192.168.40.112 knode1</span><br><span class="line">192.168.40.113 knode2</span><br><span class="line">192.168.40.114 knode3</span><br></pre></td></tr></table></figure><p>2.在Ansible服务器上的/etc/ansible/hosts文件中添加k8s服务器节点（参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/ansible_hosts" target="_blank" rel="noopener">ansible_hosts</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[k8s-all]</span><br><span class="line">kmaster</span><br><span class="line">knode1</span><br><span class="line">knode2</span><br><span class="line">knode3</span><br><span class="line"></span><br><span class="line">[k8s-master]</span><br><span class="line">kmaster</span><br><span class="line"></span><br><span class="line">[k8s-nodes]</span><br><span class="line">knode1</span><br><span class="line">knode2</span><br><span class="line">knode3</span><br></pre></td></tr></table></figure><h2 id="三-修改k8s集群各节点-etc-hosts（非必须）"><a href="#三-修改k8s集群各节点-etc-hosts（非必须）" class="headerlink" title="三. 修改k8s集群各节点/etc/hosts（非必须）"></a>三. 修改k8s集群各节点/etc/hosts（非必须）</h2><p>修改所有主机/etc/hosts文件，添加IP/主机名映射，方便通过主机名ssh访问</p><p>1.创建playbook文件（参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/set_hosts_playbook.yml" target="_blank" rel="noopener">set_hosts_playbook.yml</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim set_hosts_playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: k8s-all</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: backup /etc/hosts</span><br><span class="line">      shell: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">    - name: copy local hosts file to remote</span><br><span class="line">      copy: src=/etc/hosts dest=/etc/ owner=root group=root mode=0644</span><br></pre></td></tr></table></figure><p>2.执行ansible-playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook set_hosts_playbook.yml</span><br></pre></td></tr></table></figure><h2 id="四-安装Docker"><a href="#四-安装Docker" class="headerlink" title="四. 安装Docker"></a>四. 安装Docker</h2><p>在所有主机上安装Docker</p><p>1.创建playbook文件（参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/install_docker_playbook.yml" target="_blank" rel="noopener">install_docker_playbook.yml</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vim install_docker_playbook.yml</span><br><span class="line">- hosts: k8s-all</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars: </span><br><span class="line">     docker_version: 18.09.2</span><br><span class="line"></span><br><span class="line">  tasks: </span><br><span class="line">     - name: install dependencies</span><br><span class="line">       #shell: yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br><span class="line">       yum: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">       with_items:</span><br><span class="line">          - yum-utils</span><br><span class="line">          - device-mapper-persistent-data</span><br><span class="line">          - lvm2</span><br><span class="line"></span><br><span class="line">     - name: config yum repo</span><br><span class="line">       shell: yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">     - name: install docker</span><br><span class="line">       yum: name=docker-ce-&#123;&#123;docker_version&#125;&#125; state=present</span><br><span class="line"></span><br><span class="line">     - name: start docker</span><br><span class="line">       shell: systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure><p>2.执行ansible-playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook install_docker_playbook.yml</span><br></pre></td></tr></table></figure><h2 id="五-部署k8s-master"><a href="#五-部署k8s-master" class="headerlink" title="五. 部署k8s master"></a>五. 部署k8s master</h2><p>1.开始部署之前，需要做一些初始化处理：关闭防火墙、关闭selinux、禁用swap、配置k8s阿里云yum源等，所有操作放在脚本 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/pre-setup.sh" target="_blank" rel="noopener">pre-setup.sh</a> 中，并在2中playbook中通过script模块执行</p><p>2.创建playbook文件 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/deploy_master_playbook.yml" target="_blank" rel="noopener">deploy_master_playbook.yml</a>，只针对master节点，安装kubectl，kubeadm，kubelet，以及flannel（将kube-flannel.yml文件里镜像地址的quay.io改为quay-mirror.qiniu.com避免超时，参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/kube-flannel.yml" target="_blank" rel="noopener">kube-flannel.yml</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vim deploy_master_playbook.yml</span><br><span class="line">- hosts: k8s-master</span><br><span class="line">  remote_user: root：q</span><br><span class="line">  vars:</span><br><span class="line">    kube_version: 1.16.0-0</span><br><span class="line">    k8s_version: v1.16.0</span><br><span class="line">    k8s_master: 192.168.40.111 </span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: prepare env</span><br><span class="line">      script: ./pre-setup.sh      </span><br><span class="line"></span><br><span class="line">    - name: install kubectl,kubeadm,kubelet</span><br><span class="line">      yum: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - kubectl-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">        - kubeadm-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">        - kubelet-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    - name: init k8s</span><br><span class="line">      shell: kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version &#123;&#123;k8s_version&#125;&#125; --apiserver-advertise-address &#123;&#123;k8s_master&#125;&#125;  --pod-network-cidr=10.244.0.0/16 --token-ttl 0</span><br><span class="line">    </span><br><span class="line">    - name: config kube</span><br><span class="line">      shell: mkdir -p $HOME/.kube &amp;&amp; cp -i /etc/kubernetes/admin.conf $HOME/.kube/config &amp;&amp; chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">    </span><br><span class="line">    - name: copy flannel yaml file</span><br><span class="line">      copy: src=./kube-flannel.yml dest=/tmp/ owner=root group=root mode=0644 </span><br><span class="line">    </span><br><span class="line">    - name: install flannel</span><br><span class="line">      shell: kubectl apply -f /tmp/kube-flannel.yml</span><br><span class="line"></span><br><span class="line">    - name: get join command</span><br><span class="line">      shell: kubeadm token create --print-join-command </span><br><span class="line">      register: join_command</span><br><span class="line">    - name: show join command</span><br><span class="line">      debug: var=join_command verbosity=0</span><br></pre></td></tr></table></figure><p>3.执行ansible-playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook deploy_master_playbook.yml</span><br></pre></td></tr></table></figure><p>4.上述命令执行完成会输出节点加入k8s集群的命令，如下图。记下该命令，后面部署node时会用到</p><p><img src="http://blog.jboost.cn/assets/join-command.png" alt="图片"></p><h2 id="六-部署k8s-node"><a href="#六-部署k8s-node" class="headerlink" title="六. 部署k8s node"></a>六. 部署k8s node</h2><p>1.同master一样，开始部署之前，需要做一些初始化处理：关闭防火墙、关闭selinux、禁用swap、配置k8s阿里云yum源等，所有操作放在脚本  <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/pre-setup.sh" target="_blank" rel="noopener">pre-setup.sh</a> 中，并在2中playbook中通过script模块执行</p><p>2.创建playbook文件 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/deploy_nodes_playbook.yml" target="_blank" rel="noopener">deploy_nodes_playbook.yml</a>，针对除master外的其它集群节点，安装kubeadm，kubelet，并将节点加入到k8s集群中，使用的是前面部署master时输出的加入集群命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vim deploy_nodes_playbook.yml</span><br><span class="line">- hosts: k8s-nodes</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">     kube_version: 1.16.0-0</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: prepare env</span><br><span class="line">      script: ./pre-setup.sh</span><br><span class="line"></span><br><span class="line">    - name: install kubeadm,kubelet</span><br><span class="line">      yum: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - kubeadm-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">        - kubelet-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    - name: start kubelt</span><br><span class="line">      shell: systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line">   </span><br><span class="line">    - name: join cluster</span><br><span class="line">      shell: kubeadm join 192.168.40.111:6443 --token zgx3ov.zlq3jh12atw1zh8r --discovery-token-ca-cert-hash sha256:60b7c62687974ec5803e0b69cfc7ccc2c4a8236e59c8e8b8a67f726358863fa7</span><br></pre></td></tr></table></figure><p>3.执行ansible-playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook deploy_nodes_playbook.yml</span><br></pre></td></tr></table></figure><p>4.稍等片刻，即可在master节点上通过<code>kubectl get nodes</code>看到加入到集群中的节点，并且status为Ready状态，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES    AGE     VERSION</span><br><span class="line">kmaster   Ready    master   37m     v1.16.0</span><br><span class="line">knode1    Ready    &lt;none&gt;   7m1s    v1.16.0</span><br><span class="line">knode2    Ready    &lt;none&gt;   7m1s    v1.16.0</span><br><span class="line">knode3    Ready    &lt;none&gt;   4m12s   v1.16.0</span><br></pre></td></tr></table></figure><p>至此，k8s集群基本部署完成。接下来可安装Ingress与Dashboard。</p><h2 id="七-安装Ingress"><a href="#七-安装Ingress" class="headerlink" title="七. 安装Ingress"></a>七. 安装Ingress</h2><p>Ingress为集群内服务提供外网访问，包括基于Nginx与Traefik两个版本，这里使用比较熟悉的Nginx版本。安装Ingress的操作在master节点进行（因为前面在master节点安装并配置了kubectl，也可在其它安装并配置好了kubectl的节点进行）</p><p>1.下载yaml文件（此目录已包含 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/ingress/nginx-ingress.yaml" target="_blank" rel="noopener">nginx-ingress.yaml</a>，并修改了镜像地址，可直接进入第3步） </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O nginx-ingress.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/deploy.yaml</span><br></pre></td></tr></table></figure><p>2.将里面的quay.io修改为quay-mirror.qiniu.com，避免镜像拉取超时。同时在nginx-ingress-controller的Deployment上添加hostNetwork为true及nginx-ingress的标签，以使用宿主机网络与控制Ingress部署的节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim nginx-ingress.yaml</span><br><span class="line">:s/quay.io/quay-mirror.qiniu.com/g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim nginx-ingress.yaml</span><br><span class="line"></span><br><span class="line">    spec:</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      nodeSelector:</span><br><span class="line">        nginx-ingress: "true"</span><br></pre></td></tr></table></figure><p>3.部署Ingress</p><p>首先在knode1节点上打标签nginx-ingress=true，控制Ingress部署到knode1上，保持IP固定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl label node knode1 nginx-ingress=true</span><br><span class="line">node/knode1 labeled</span><br></pre></td></tr></table></figure><p>然后完成nginx-ingress的部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-ingress.yaml</span><br></pre></td></tr></table></figure><p>4.部署完成，稍等片刻等Pod创建完成，可通过如下命令查看ingress相关Pod情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl get pods -n ingress-nginx -o wide</span><br><span class="line">NAME                                        READY   STATUS      RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">ingress-nginx-admission-create-drpg5        0/1     Completed   0          79m   10.244.2.2       knode1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-admission-patch-db2rt         0/1     Completed   1          79m   10.244.3.2       knode3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-controller-575cffb49c-4xm55   1/1     Running     0          79m   192.168.40.112   knode1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><h2 id="八-安装Kubernetes-Dashboard"><a href="#八-安装Kubernetes-Dashboard" class="headerlink" title="八. 安装Kubernetes Dashboard"></a>八. 安装Kubernetes Dashboard</h2><p>1.下载yaml文件（此目录已包含 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/dashboard/kubernetes-dashboard.yaml" target="_blank" rel="noopener">kubernetes-dashboard.yaml</a> 文件，可直接进入第3步）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O kubernetes-dashboard.yaml  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta5/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure><p>2.修改kubernetes-dashboard.yaml</p><p>将Service type改为NodePort，使得可通过IP访问Dashboard。注释掉默认的Secret（默认的secret权限很有限，看不到多少数据）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30443</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure><p>3.部署Dashboard，并创建绑定cluster-admin角色的ServiceAccount —— admin-user (参考 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/dashboard/kubernetes-dashboard-auth.yaml" target="_blank" rel="noopener">auth.yaml</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f kubernetes-dashboard.yaml</span><br><span class="line">kubectl apply -f kubernetes-dashboard-auth.yaml</span><br></pre></td></tr></table></figure><p>4.访问Dashboard</p><p>访问 https://集群任意节点IP:30443，打开Dashboard登录页面，执行如下命令获取登录token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '&#123;print $1&#125;')</span><br></pre></td></tr></table></figure><p>使用token完成登录，如图</p><p><img src="http://blog.jboost.cn/assets/dashboard-login.png" alt="图片"></p><h2 id="九-解决证书无效问题"><a href="#九-解决证书无效问题" class="headerlink" title="九. 解决证书无效问题"></a>九. 解决证书无效问题</h2><p>安装完后，默认的证书可能无效，在Chrome浏览中无法打开Dashboard，可通过重新生成证书解决。</p><p>1.创建自定义证书 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# cd /etc/kubernetes/pki/</span><br><span class="line"><span class="meta">#</span><span class="bash">生成私钥</span></span><br><span class="line">[root@kmaster pki]# openssl genrsa -out dashboard.key 2048</span><br><span class="line"><span class="meta">#</span><span class="bash">生成证书</span></span><br><span class="line">[root@kmaster pki]# openssl req -new -key dashboard.key -out dashboard.csr -subj "/O=JBST/CN=kubernetes-dashboard"</span><br><span class="line"><span class="meta">#</span><span class="bash">使用集群的CA来签署证书</span></span><br><span class="line">[root@kmaster pki]# openssl x509 -req -in dashboard.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out dashboard.crt -days 3650</span><br><span class="line"><span class="meta">#</span><span class="bash">查看自创证书</span></span><br><span class="line">[root@kmaster pki]# openssl x509 -in dashboard.crt -noout -text</span><br></pre></td></tr></table></figure><p>2.注释 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/dashboard/kubernetes-dashboard.yaml" target="_blank" rel="noopener">kubernetes-dashboard.yaml</a> 中默认的Secret，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#apiVersion: v1</span></span><br><span class="line"><span class="comment">#kind: Secret</span></span><br><span class="line"><span class="comment">#metadata:</span></span><br><span class="line"><span class="comment">#  labels:</span></span><br><span class="line"><span class="comment">#    k8s-app: kubernetes-dashboard</span></span><br><span class="line"><span class="comment">#  name: kubernetes-dashboard-certs</span></span><br><span class="line"><span class="comment">#  namespace: kubernetes-dashboard</span></span><br><span class="line"><span class="comment">#type: Opaque</span></span><br></pre></td></tr></table></figure><p>3.重新部署Dashboard，并通过自定义证书创建新的Secret</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl delete -f kubernetes-dashboard.yaml</span><br><span class="line">[root@kmaster k8s-deploy]# kubectl apply -f kubernetes-dashboard.yaml </span><br><span class="line">[root@kmaster k8s-deploy]# kubectl create secret generic kubernetes-dashboard-certs --from-file=dashboard.crt=/etc/kubernetes/pki/dashboard.crt --from-file=dashboard.key=/etc/kubernetes/pki/dashboard.key  -n kubernetes-dashboard</span><br></pre></td></tr></table></figure><h2 id="十-在本地（win10）管理k8s集群"><a href="#十-在本地（win10）管理k8s集群" class="headerlink" title="十. 在本地（win10）管理k8s集群"></a>十. 在本地（win10）管理k8s集群</h2><p>1.下载kubectl windows版本： <a href="https://storage.googleapis.com/kubernetes-release/release/v1.16.0/bin/windows/amd64/kubectl.exe" target="_blank" rel="noopener">https://storage.googleapis.com/kubernetes-release/release/v1.16.0/bin/windows/amd64/kubectl.exe</a></p><p>2.将kubectl.exe文件所在目录加入系统环境变量的Path中</p><p>3.将master节点上 /etc/kubernetes/admin.conf 的内容拷贝到本地用户目录的 .kube/config 文件中，如 <code>C:\Users\Administrator\.kube\config</code></p><p>4.验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES    AGE     VERSION</span><br><span class="line">kmaster   Ready    master   4d19h   v1.16.0</span><br><span class="line">knode1    Ready    &lt;none&gt;   4d19h   v1.16.0</span><br><span class="line">knode2    Ready    &lt;none&gt;   4d19h   v1.16.0</span><br><span class="line">knode3    Ready    &lt;none&gt;   4d19h   v1.16.0</span><br></pre></td></tr></table></figure><p>本文所涉及的所有配置文件可在这里找到 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation" target="_blank" rel="noopener">github</a></p><hr><p>相关阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s/8s-OUUsZI0UyyyTgruEO1A" target="_blank" rel="noopener">k8s云集群混搭模式，可能帮你节省50%以上的服务成本</a></li><li><a href="https://mp.weixin.qq.com/s/VuSWn7cWacW6i_MtpvQ5Sw" target="_blank" rel="noopener">k8s云集群混搭模式落地分享</a></li><li><a href="https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw" target="_blank" rel="noopener">Ansible简明教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes是Goole开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理 —— 百度百科。&lt;/p&gt;
&lt;p&gt;接触K8s也有半年多了，也基于阿里云平台搭建了包含多级服务、目前运行较为稳定的K8s集群（感兴趣的可参考 &lt;a href=&quot;https://mp.weixin.qq.com/s/8s-OUUsZI0UyyyTgruEO1A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;k8s云集群混搭模式，可能帮你节省50%以上的服务成本&lt;/a&gt;， &lt;a href=&quot;https://mp.weixin.qq.com/s/VuSWn7cWacW6i_MtpvQ5Sw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;k8s云集群混搭模式落地分享&lt;/a&gt;），但一直没来得及对其进行系统的学习，本系列文章还像以前Docker系列一样，以笔记的形式进行记录与分享，会包括理论与实践，感兴趣的同学可以关注，一起探索下目前较为流行的容器化及服务编排解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
      <category term="ansible" scheme="http://blog.jboost.cn/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Ansible简明教程</title>
    <link href="http://blog.jboost.cn/ansible.html"/>
    <id>http://blog.jboost.cn/ansible.html</id>
    <published>2020-04-17T00:39:52.000Z</published>
    <updated>2020-04-18T06:28:32.952Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible是当下比较流行的自动化运维工具，可通过SSH协议对远程服务器进行集中化的配置管理、应用部署等，常结合Jenkins来实现自动化部署。</p><a id="more"></a><p>除了Ansible，还有像SaltStack、Fabric（曾经管理100多台服务器上的应用时也曾受益于它）、Puppet等自动化工具。相比之下，Ansible最大的优势就是无需在被管理主机端部署任何客户端代理程序，通过SSH通道就可以进行远程命令的执行或配置的下发，足够轻量级，但同时功能非常强大，且各项功能通过模块来实现，具备良好的扩展性。不足之处是Ansible只支持在Linux系统上安装，不支持Windows。</p><p>如果你需要在多于一台服务器上做相同的操作，那么建议你使用Ansible之类的自动化工具，这将极大提高你的操作效率。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>1.找一台主机用于做管理服务器，在其上安装Ansible</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ansible</span><br></pre></td></tr></table></figure><p>Ansible基于Python实现，一般Linux系统都自带Python，所以可以直接使用yum安装或pip安装。</p><p>安装完后，在/etc/ansible/目录下生成三个主要的文件或目录，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# ll /etc/ansible/</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r--. 1 root root 19179 Jan 30  2018 ansible.cfg</span><br><span class="line">-rw-r--r--. 1 root root  1136 Apr 17 15:17 hosts</span><br><span class="line">drwxr-xr-x. 2 root root     6 Jan 30  2018 roles</span><br></pre></td></tr></table></figure><ul><li>ansible.cfg： Ansible的配置文件</li><li>hosts：登记被管理的主机</li><li>roles：角色项目定义目录，主要用于代码复用</li></ul><p>2.在/etc/ansible/hosts文件中添加需要被管理的服务器节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# vim /etc/ansible/hosts</span><br><span class="line">[k8s]</span><br><span class="line">192.168.40.201</span><br><span class="line">192.168.40.202</span><br><span class="line">192.168.40.205</span><br><span class="line">192.168.40.206</span><br></pre></td></tr></table></figure><p><code>[k8s]</code>表示将下面的服务器节点分到k8s的组中，后面执行命令时可指定针对某个组执行。</p><p>3.生成SSH KEY，并copy到被管理节点上，实现免密SSH访问</p><p>在管理节点执行 <code>ssh-keygen</code> 生成SSH KEY，然后copy到各被管理节点上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.40.201</span><br></pre></td></tr></table></figure><p>上面命令将<code>~/.ssh/id_rsa.pub</code>文件内容添加到被管理节点的/root/.ssh/authorized_keys文件中，实现管理节点到被管理节点的免密SSH访问。</p><p>4.调试Ansible</p><p>针对k8s服务器组执行ping，验证Ansible到各被管理节点的连通性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# ansible k8s -m ping</span><br><span class="line">192.168.40.201 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.40.205 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.40.202 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.40.206 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ansible只需要在管理主机上安装，然后打通管理主机到各被管理主机的SSH免密访问即可进行集中化的管理控制，不需在被管理主机安装任何代理程序。</p><h2 id="Ansible命令"><a href="#Ansible命令" class="headerlink" title="Ansible命令"></a>Ansible命令</h2><p>Ansible的命令格式为， <code>ansible 主机群组名 -m 命令模块名 -a &quot;批量执行的操作&quot;</code></p><p>其中-m不是必须的，默认为command模块，-a也不是必须的，表示命令模块的参数，比如前面的ping模块就没有参数。</p><p>可以使用 <code>ansible-doc -l</code> 列出所有可用的命令模块， <code>ansible-doc -s 模块名</code> 查看指定模块的参数信息</p><p>常用命令模块</p><p>1.command<br>command是Ansible的默认模块，不指定-m参数时默认使用command。command可以运行远程主机权限范围内的所有shell命令，但不支持管道操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看k8s分组主机内存使用情况</span></span><br><span class="line">ansible k8s -m command -a "free -g"</span><br></pre></td></tr></table></figure><p>2.shell<br>shell基本与command相同，但shell支持管道操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">shell支持管道操作 |grep Mem</span></span><br><span class="line">ansible k8s -m shell -a "free -g|grep Mem"</span><br></pre></td></tr></table></figure><p>3.script<br>script就是在远程主机上执行管理端存储的shell脚本文件，相当于scp+shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /root/echo.sh为管理端本地shell脚本</span></span><br><span class="line">ansible k8s -m script -a "/root/echo.sh"</span><br></pre></td></tr></table></figure><p>4.copy<br>copy实现管理端到远程主机的文件拷贝，相当于scp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拷贝本地echo.sh文件到k8s组中远程主机的/tmp目录下，所属用户、组为 root ，权限为 0755</span></span><br><span class="line">ansible k8s -m copy -a "src=/root/echo.sh dest=/tmp/ owner=root group=root mode=0755"</span><br></pre></td></tr></table></figure><p>5.yum<br>软件包安装或删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m yum -a "name=wget state=latest"</span><br></pre></td></tr></table></figure><p>其中state有如下取值：</p><ul><li>针对安装，可取值“present，installed，latest”，present，installed即普通安装，两者无区别，latest是使用yum mirror上最新的版本进行安装</li><li>针对删除，可取值“absent，removed”，两者无差别</li></ul><p>6.service<br>对远程主机的服务进行管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m service -a "name=nginx state=stoped"</span><br></pre></td></tr></table></figure><p>state可取值“started/stopped/restarted/reloaded”。</p><p>7.get_url<br>在远程主机上下载指定URL到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m get_url -a "url=http://www.baidu.com dest=/tmp/index.html mode=0440 force=yes"</span><br></pre></td></tr></table></figure><p>8.setup<br>获取远程主机的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m setup</span><br></pre></td></tr></table></figure><p>9.file<br>管理远程主机的文件或目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m file -a "dest=/opt/test state=touch"</span><br></pre></td></tr></table></figure><p>state可取值</p><ul><li>directory：创建目录</li><li>file：如果文件不存在，则创建</li><li>link：创建symbolic link</li><li>absent：删除文件或目录</li><li>touch： 创建一个不存在的空文件</li></ul><p>10.cron<br>管理远程主机的crontab定时任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m cron -a "name='backup servcie' minute=*/5 job='/usr/sbin/ntpdate  time.nist.gov &gt;/dev/null 2&gt;&amp;1'"</span><br></pre></td></tr></table></figure><p>支持的参数</p><ul><li>state： 取值present表示创建定时任务，absent表示删除定时任务</li><li>disabled： yes表示注释掉定时任务，no表示接触注释</li></ul><h2 id="Ansible-playbook"><a href="#Ansible-playbook" class="headerlink" title="Ansible playbook"></a>Ansible playbook</h2><p>Ansible的playbook由一个或多个play组成，play的功能就是为归为一组的主机编排要执行的一系列task，其中每一个task就是调用Ansible的一个命令模块。</p><p>playbook的核心元素包括：</p><ul><li>hosts：执行任务的远程主机组或列表</li><li>tasks：要执行的任务列表</li><li>variables：内置变量或自定义的变量</li><li>templates：使用模板语法的文件，通常为配置文件</li><li>handlers：和notify结合使用，由特定条件触发，一般用于配置文件变更触发服务重启</li><li>tags：标签，可在运行时通过标签指定运行playbook中的部分任务</li><li>roles：</li></ul><p>playbook文件遵循yaml的语法格式，运行命令的格式为 <code>ansible-playbook &lt;filename.yml&gt; ... [options]</code>， 常用options包括</p><ul><li>–syntax        检查playbook文件语法是否正确</li><li>–check 或 -C   只检测可能会发生的改变，但不真正执行操作</li><li>–list-hosts    列出运行任务的主机</li><li>–list-tags     列出playbook文件中定义所有的tags</li><li>–list-tasks    列出playbook文件中定义的所有任务集</li><li>–limit         只针对主机列表中的某个主机或者某个组执行</li><li>-f              指定并发数，默认为5个</li><li>-t              指定某个或多个tags运行（前提playbook中有定义tags）</li><li>-v              显示过程 -vv -vvv更详细</li></ul><p>下面以批量安装Nginx为例，尽可能介绍playbook各核心元素的用法。</p><p>定义palybook yaml文件nginx_playbook.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">,192.168.40.205</span> <span class="comment"># 主机列表，也可以是/etc/ansible/hosts中定义的主机分组名</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> <span class="comment"># 远程用户</span></span><br><span class="line">  <span class="attr">vars:</span>             <span class="comment"># 自定义变量</span></span><br><span class="line">     <span class="attr">version:</span> <span class="number">1.16</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">vars_files:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./templates/nginx_locations_vars.yml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">dependencies</span>          <span class="comment"># 定义任务的名称</span></span><br><span class="line">       <span class="attr">yum:</span> <span class="string">name=&#123;&#123;item&#125;&#125;</span> <span class="string">state=installed</span>  <span class="comment"># 调用模块，具体要做的事情，这里使用with_items迭代多个yum任务安装必要的依赖</span></span><br><span class="line">       <span class="attr">with_items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">gcc</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">gcc-c++</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pcre</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pcre-devel</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">zlib</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">zlib-devel</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">openssl</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">openssl-devel</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">download</span> <span class="string">nginx</span>                <span class="comment"># 通过get_url模块下载nginx</span></span><br><span class="line">       <span class="attr">get_url:</span> <span class="string">url=http://nginx.org/download/nginx-&#123;&#123;version&#125;&#125;.tar.gz</span> <span class="string">dest=/tmp/</span> <span class="string">mode=0755</span> <span class="string">force=no</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">unarchive</span>                     <span class="comment"># 通过unarchive模块解压nginx</span></span><br><span class="line">       <span class="attr">unarchive:</span> <span class="string">src=/tmp/nginx-&#123;&#123;version&#125;&#125;.tar.gz</span> <span class="string">dest=/tmp/</span> <span class="string">mode=0755</span> <span class="string">copy=no</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">configure,make</span> <span class="string">and</span> <span class="string">install</span>    <span class="comment"># 通过shell模块执行shell命令编译安装</span></span><br><span class="line">       <span class="attr">shell:</span> <span class="string">cd</span> <span class="string">/tmp/nginx-&#123;&#123;version&#125;&#125;</span> <span class="string">&amp;&amp;</span> <span class="string">./configure</span> <span class="string">--prefix=/usr/local/nginx</span> <span class="string">&amp;&amp;</span> <span class="string">make</span> <span class="string">&amp;&amp;</span> <span class="string">make</span> <span class="string">install</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span> <span class="string">nginx</span>                   <span class="comment"># 通过shell模块执行shell命令启动nginx</span></span><br><span class="line">       <span class="attr">shell:</span> <span class="string">/usr/local/nginx/sbin/nginx</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">update</span> <span class="string">config</span>                 <span class="comment"># 通过template模块动态生成配置文件下发到远程主机目录</span></span><br><span class="line">       <span class="attr">template:</span> <span class="string">src=nginx.conf.j2</span> <span class="string">dest=/usr/local/nginx/conf/nginx.conf</span></span><br><span class="line">       <span class="attr">notify:</span> <span class="string">reload</span> <span class="string">nginx</span>                <span class="comment"># 在结束时触发一个操作，具体操作通过handlers来定义</span></span><br><span class="line">       <span class="attr">tags:</span> <span class="string">reload</span>                        <span class="comment"># 对任务定义一个标签，运行时通过-t执行带指定标签的任务</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">reload</span> <span class="string">nginx</span>                  <span class="comment"># 与notify定义的内容对应</span></span><br><span class="line">       <span class="attr">shell:</span> <span class="string">/usr/local/nginx/sbin/nginx</span> <span class="string">-s</span> <span class="string">reload</span></span><br></pre></td></tr></table></figure><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><p>在上面的示例中使用vars定义了变量version，在tasks中通过进行引用。Ansible支持如下几种定义变量的方式</p><p>1.在playbook文件中定义<br>前面示例已经说明</p><p>2.命令行指定<br>在执行playbook时通过-e指定，如<code>ansible-playbook -e &quot;version=1.17.9&quot; nginx_playbook.yml</code>， 这里指定的变量将覆盖playbook中定义的同名变量的值</p><p>3.hosts文件中定义变量<br>在/etc/ansible/hosts文件中也可以定义针对单个主机或主机组的变量，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">192.168.40.201 version=1.17.9 # 定义单个主机的变量</span><br><span class="line">192.168.40.205 </span><br><span class="line">[nginx:vars]  # 定义整个组的统一变量</span><br><span class="line">version=1.16.1</span><br></pre></td></tr></table></figure><p>4.在独立的yaml文件中定义变量<br>专门定义一个yaml变量文件，然后在playbook文件中通过var_files引用，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义存放变量的文件</span></span><br><span class="line">[root@ansible ]# cat var.yml</span><br><span class="line">version: 1.16.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写playbook</span></span><br><span class="line">[root@ansible ]# cat nginx_playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: nginx</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars_files:     # 引用变量文件</span><br><span class="line">    - ./var.yml   # 指定变量文件的path（这里可以是绝对路径，也可以是相对路径）</span><br></pre></td></tr></table></figure><p>5.使用setup模块获取到的变量<br>前面介绍setup模块可获取远程主机的信息，可在playbook中直接引用setup模块获取到的属性，比如系统版本： ansible_distribution_major_version</p><h3 id="2-模板"><a href="#2-模板" class="headerlink" title="2. 模板"></a>2. 模板</h3><p>playbook模板为我们提供了动态的配置服务，使用jinja2语言，支持多种条件判断、循环、逻辑运算、比较操作等。应用场景就是定义一个模板配置文件，然后在执行的时候动态生成最终的配置文件下发到远程主机。一般将模板文件放在playbook文件同级的templates目录下，这样在playbook文件中可以直接引用，否则需要通过绝对路径指定，模板文件后缀名一般为 .j2。</p><p>本例中，我们将nginx.conf配置文件作为模板文件，添加需要动态配置的内容，并定义一个变量文件，通过vars_files引入：<code>vars_files: ./templates/nginx_locations_vars.yml</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 模板文件</span></span><br><span class="line">[root@tool-server nginx-deploy]# vim templates/nginx.conf.j2</span><br><span class="line"> ...</span><br><span class="line"> server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        # 这里的内容动态生成</span><br><span class="line">        &#123;% for location in nginx_locations %&#125;</span><br><span class="line">        location &#123;&#123;location.path&#125;&#125; &#123;</span><br><span class="line">           proxy_pass &#123;&#123;location.proxy&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"> ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 独立的自定义变量文件，用于填充模板文件中的变量</span></span><br><span class="line">[root@tool-server nginx-deploy]# vim templates/nginx_locations_vars.yml</span><br><span class="line"></span><br><span class="line">nginx_locations:</span><br><span class="line">  - &#123;"path": "/cns", "proxy": "http://192.168.40.202/cns"&#125;</span><br><span class="line">  - &#123;"path": "/admin", "proxy": "http://192.168.40.202/admin"&#125;</span><br></pre></td></tr></table></figure><h3 id="3-handlers"><a href="#3-handlers" class="headerlink" title="3. handlers"></a>3. handlers</h3><p>handlers和notify结合使用，由特定条件触发，一般用于配置文件变更触发服务重启。在本例中我们在配置文件变更时，通过notify定义了一个“reload nginx”的操作，然后在handlers部分定义“reload nginx”操作——通过shell模块调用nginx的reload来重新加载配置。</p><h3 id="4-标签"><a href="#4-标签" class="headerlink" title="4. 标签"></a>4. 标签</h3><p>playbook文件中，如果只想执行某一个或几个任务，则可以给任务打标签，在运行的时候通过 -t 选择带指定标签的任务执行，也可以通过 –skip-tags 选择不带指定标签的任务执行。比如在本例中，我们在“update config”的task上加了“reload”的标签，如果后面再修改配置，我们只需要执行“update config”的task并触发reload nginx就行了，可以这么执行playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server nginx-deploy]# ansible-playbook -t reload nginx_playbook.yml</span><br></pre></td></tr></table></figure><h3 id="5-when"><a href="#5-when" class="headerlink" title="5. when"></a>5. when</h3><p>可以在task上添加when表示当某个条件达到了该任务才执行，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">nginx</span></span><br><span class="line">     <span class="attr">yum:</span> <span class="string">name=nginx</span> <span class="string">state=installed</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">update</span> <span class="string">config</span> <span class="string">for</span> <span class="string">system6</span></span><br><span class="line">     <span class="attr">template:</span> <span class="string">src=nginx.conf.j2</span> <span class="string">dest=/usr/local/nginx/conf/nginx.conf</span></span><br><span class="line">     <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">"6"</span>   <span class="comment"># 判断系统版本，为6才执行上面的template配置的文件</span></span><br></pre></td></tr></table></figure><h3 id="6-roles"><a href="#6-roles" class="headerlink" title="6. roles"></a>6. roles</h3><p>roles就是将变量、文件、任务、模板及处理器放置在单独的目录中，并可以在playbook中include的一种机制，一般用于主机构建服务的场景中，但也可以是用于构建守护进程等场景。</p><p>roles的目录结构，默认的roles目录为/etc/ansible/roles</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">roles:</span>          <span class="comment"># 所有的角色项目必须放在roles目录下</span></span><br><span class="line">  <span class="attr">project:</span>      <span class="comment"># 具体的角色项目名称，比如nginx、tomcat</span></span><br><span class="line">    <span class="string">files：</span>     <span class="comment"># 用来存放由copy或script模块调用的文件</span></span><br><span class="line">    <span class="string">templates：</span> <span class="comment"># 用来存放jinjia2模板，template模块会自动在此目录中寻找jinjia2模板文件</span></span><br><span class="line">    <span class="string">tasks：</span>     <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色的任务列表，此文件可以使用include包含其它的位于此目录的task文件。</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">handlers：</span>  <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色中触发条件时执行的动作</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">vars：</span>      <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色用到的变量</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">defaults：</span>  <span class="comment"># 此目录应当包含一个main.yml文件，用于为当前角色设定默认变量</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">meta：</span>      <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系</span></span><br><span class="line">      <span class="string">main.yml</span></span><br></pre></td></tr></table></figure><p>我们将上面的例子通过roles改造一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# cd /etc/ansible/roles/</span><br><span class="line">[root@tool-server roles]# mkdir -p nginx/&#123;tasks,vars,templates,handlers&#125;</span><br><span class="line">...#创建各目录的mian.yml文件，并将对应的内容加入文件中</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">最终目录结构</span></span><br><span class="line">[root@tool-server roles]# tree  .</span><br><span class="line">.</span><br><span class="line">└── nginx</span><br><span class="line">    ├── handlers</span><br><span class="line">    │   └── main.yml # 上例handlers部分的内容，直接 -name开头，不需要再加 `handlers：`</span><br><span class="line">    ├── tasks</span><br><span class="line">    │   └── main.yml # tasks部分内容，直接-name开头，不需要加tasks，可以将各个task拆分为多个文件，然后在main.yml中通过 `- include: install.yml` 形式的列表引入</span><br><span class="line">    ├── templates</span><br><span class="line">    │   └── main.yml # templates/nginx.conf.j2的内容</span><br><span class="line">    └── vars</span><br><span class="line">        └── main.yml # templates/nginx_locations_vars.yml的内容</span><br><span class="line"></span><br><span class="line">5 directories, 4 files</span><br></pre></td></tr></table></figure><p>最后，在playbook中通过roles引入，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible roles]# vim nginx_playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: nginx</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - role: nginx # 指定角色名称</span><br></pre></td></tr></table></figure><p>roles将playbook的各个部分进行拆分组织，主要用于代码复用度较高的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ansible是功能强大但又很轻量级的自动化运维工具，基于SSH协议批量对远程主机进行管理，不仅可用于日常的服务维护，也可与Jenkins等CI/CD工具结合实现自动化部署。如果你需要在多于一台服务器上做重复又稍显复杂的操作，那么建议你使用Ansible，这将极大提高你的操作效率，并且所有操作文档化，更易维护与迁移。</p><hr><p>如果你对Java、Spring Boot、Spring Cloud、Docker，技术管理心得等感兴趣<br>欢迎关注作者微信公众号：空山新雨的技术空间，一起学习成长  </p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ansible是当下比较流行的自动化运维工具，可通过SSH协议对远程服务器进行集中化的配置管理、应用部署等，常结合Jenkins来实现自动化部署。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="ansible" scheme="http://blog.jboost.cn/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（十三）：容器日志采集实践</title>
    <link href="http://blog.jboost.cn/docker-13.html"/>
    <id>http://blog.jboost.cn/docker-13.html</id>
    <published>2020-04-01T06:08:12.000Z</published>
    <updated>2020-08-26T01:32:01.275Z</updated>
    
    <content type="html"><![CDATA[<p>日志是服务运行过程中的一个关键环节，借助日志，我们可以排查定位问题，也可以借助集中化的日志管理平台（如ELK）来做一些必要的数据统计分析。在Docker环境中，日志的采集比传统环境更为复杂，因此了解Docker日志的管理机制，及基于此熟悉日志采集的最佳实践对于开发运维人员来说也是避不开的一个知识点。那就开始吧。</p><a id="more"></a><h2 id="Docker容器的日志管理机制"><a href="#Docker容器的日志管理机制" class="headerlink" title="Docker容器的日志管理机制"></a>Docker容器的日志管理机制</h2><h3 id="1-Docker-Daemon日志"><a href="#1-Docker-Daemon日志" class="headerlink" title="1. Docker Daemon日志"></a>1. Docker Daemon日志</h3><p>Docker Daemon在Linux中本身作为systemd service启动，因此可以通过 <code>sudo journalctl -u docker</code> 命令来查看Daemon本身的日志。</p><h3 id="2-Docker容器日志"><a href="#2-Docker容器日志" class="headerlink" title="2. Docker容器日志"></a>2. Docker容器日志</h3><p>通过 <code>docker logs container_id|container_name</code> 可以查看Docker容器的输出日志，但这里的日志只包含容器的标准输出（STDOUT）与标准错误输出（STDERR），适用于一些将日志输出到STDOUT的容器,比如Nginx，查看nginx的dockerfile可发现其是将日志文件链接到了STDOUT与STDERR来实现的，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN ln -sf /dev/stdout /var/log/nginx/access.log</span><br><span class="line">&amp;&amp; ln -sf /dev/stderr /var/log/nginx/error.log</span><br></pre></td></tr></table></figure><p>但如果容器内部应用日志是输出到日志文件（比如Spring Boot项目或Tomcat容器，一般将日志输出到日志文件中），则无法通过 <code>docker logs</code> 命令查看。</p><blockquote><p><code>docker logs</code> 会显示历史日志，日志太多的话要等半天才能看到最新日志，同时也对Docker Daemon造成一定的压力，可使用 <code>docker logs --tail 200 container_id</code>来查看最新的N条或使用<code>docker logs -f container_id</code>（类似于tail -f）</p></blockquote><h3 id="3-Docker日志处理机制"><a href="#3-Docker日志处理机制" class="headerlink" title="3. Docker日志处理机制"></a>3. Docker日志处理机制</h3><p>当我们启动一个容器时，其实是作为Docker Daemon的一个子进程运行，Docker Daemon可以拿到容器里进程的标准输出与标准错误输出，然后通过Docker的Log Driver模块来处理。如下图所示</p><p><img src="/assets/docker-log-driver.png" alt="docker-log-driver.png"></p><p>目前支持的Log Drvier包括：</p><ul><li>none：容器没有日志，<code>docker logs</code>不输出任何内容</li><li>local：日志以自定义格式存储</li><li>json-file：日志以json格式存储，默认的Log Driver</li><li>syslog：将日志写入syslog。syslog守护程序必须在主机上运行</li><li>journald：将日志写入journald。journald守护程序必须在主机上运行</li><li>gelf：将日志写入Graylog Extended Log Format端点，如Graylog或Logstash</li><li>fluentd：将日志写入fluentd。fluentd守护程序必须在主机上运行</li><li>awslogs：将日志写入Amazon CloudWatch Logs</li><li>splunk：通过HTTP Event Collector将日志写入splunk</li><li>etwlogs：将日志作为ETW（Event Tracing for Windows）事件写入。只在Windows平台可用</li><li>gcplogs：将日志写入Google Cloud Platform Logging</li><li>logentries：将日志写入Rapid7 Logentries</li></ul><p>使用Docker-CE版本时，<strong><code>docker logs</code>命令仅适用于 local， json-file， journald 三种Log Driver</strong>。</p><p>可通过<code>docker info</code>来查看Docker Daemon（针对所有容器）或<code>docker inspect</code>来查看单个容器所使用的Log Driver</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Docker Daemon</span></span><br><span class="line">[devuser@test-server-1 ~]$ docker  info |grep  "Logging Driver"</span><br><span class="line">Logging Driver: json-file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 单个Docker 容器</span></span><br><span class="line">[devuser@test-server-1 ~]$ docker inspect  -f '&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;'  76f82aa32468</span><br><span class="line">json-file</span><br></pre></td></tr></table></figure><p>修改Docker Daemon使用的Log Driver可通过修改配置文件 /etc/docker/daemon.json 进行，重启Docker后该配置对该Docker Daemon管理的所有容器生效， 如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"log-driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">    <span class="attr">"log-opts"</span>: &#123;</span><br><span class="line">        <span class="attr">"max-size"</span>: <span class="string">"10m"</span>,</span><br><span class="line">        <span class="attr">"max-file"</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置单个容器的Log Driver则可以在容器运行时通过参数指定，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# docker run -d --name nginx -p 80:80 --log-driver local  --log-opt max-size=10m  --log-opt max-file=3  --restart=always nginx</span><br><span class="line">63155291e724276d6154a26958b0e523a003958b1cdf7df9f1f0903bfc989b99</span><br><span class="line"></span><br><span class="line">[root@tool-server ~]# tail -f /var/lib/docker/containers/63155291e724276d6154a26958b0e523a003958b1cdf7df9f1f0903bfc989b99/local-logs/container.log</span><br><span class="line">stdoutҭʡ󹾖ā192.168.40.160 - - [02/Apr/2020:06:05:56 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" "-"ܻ </span><br><span class="line">stdout򪸶¡󹾖㿱92.168.40.160 - - [02/Apr/2020:06:05:56 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://192.168.40.110/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" "-"</span><br></pre></td></tr></table></figure><p>以下对常用的几种Log Driver进行详细介绍</p><ol><li>local</li></ol><p>local Log Driver会将容器的STDOUT/STDERR输出写到宿主机的磁盘。前面示例了将Docker Daemon或单个容器的Log Driver设置为local，可以看到local的日志保存路径为 <code>/var/lib/docker/containers/{container_id}/local-logs/container.log</code></p><p>local Log Driver支持的配置属性如下</p><table><thead><tr><th align="left">配置属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">max-size</td><td align="left">单个日志文件的最大大小，默认为20m（单位可为k,m,g）</td></tr><tr><td align="left">max-file</td><td align="left">最多存在多少个日志文件，文件数超过该值则会删除最旧的文件，默认为5</td></tr><tr><td align="left">compress</td><td align="left">是否对切割文件进行压缩，默认为true</td></tr></tbody></table><ol start="2"><li>json-file</li></ol><p>json-file Log Driver是Docker默认启用的Driver，将容器的STDOUT/STDERR输出以json的格式写到宿主机的磁盘，日志文件路径为 <code>/var/lib/docker/containers/{container_id}/{container_id}-json.log</code></p><p>格式如下，包含三个字段： log, stream, time。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# tail -f /var/lib/docker/containers/2cef9daeac7b009c636ed2b1a7ad8fe3342bc0d5dcd55e69d7a45a586d7abc47/2cef9daeac7b009c636ed2b1a7ad8fe3342bc0d5dcd55e69d7a45a586d7abc47-json.log</span><br><span class="line">&#123;"log":"2020-03-31T10:27:30.639+0000 I  SHARDING [conn4] Marking collection yapi.project as collection version: \u003cunsharded\u003e\n","stream":"stdout","time":"2020-03-31T10:27:30.639749587Z"&#125;</span><br><span class="line">&#123;"log":"2020-03-31T10:27:30.756+0000 I  SHARDING [conn2] Marking collection yapi.log as collection version: \u003cunsharded\u003e\n","stream":"stdout","time":"2020-03-31T10:27:30.756744876Z"&#125;</span><br></pre></td></tr></table></figure><p>json-file将日志的每一行封装到一个json串中，因此像Java的异常栈日志将会被拆分为多条json，在导入到ELK日志管理系统中时需要做合并处理。</p><p>json-file Log Driver支持的配置属性如下</p><table><thead><tr><th align="left">配置属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">max-size</td><td align="left">单个日志文件的最大大小，单位可为k,m,g。默认-1，表示无限制</td></tr><tr><td align="left">max-file</td><td align="left">最多存在多少个日志文件，文件数超过该值则会删除最旧的文件，默认为1</td></tr><tr><td align="left">labels</td><td align="left">在启动Docker容器时以逗号分隔的与日志相关的标签列表</td></tr><tr><td align="left">env</td><td align="left">在启动Docker容器时以逗号分隔的与日志相关的环境变量列表</td></tr><tr><td align="left">env-regex</td><td align="left">类似于env，用于匹配与日志相关的环境变量的正则表达式</td></tr><tr><td align="left">compress</td><td align="left">是否对切割文件进行压缩，默认为disabled</td></tr></tbody></table><ol start="3"><li>journald</li></ol><p>journald Log Driver将容器的STDOUT/STDERR发送到systemd journal，与local，json-file一样可以使用 <code>docker logs</code> 来查看。也可以使用 journalctl命令来查看，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# docker run -d --name nginx -p 80:80 --log-driver journald  --log-opt labels=profile  --log-opt env=ONLINE --label profile=dev --env "ONLINE=false"  --restart=always nginx</span><br><span class="line">2011dc967d7e068b14d974bdc083d072fd09498a7de74984d482897d1b5c4200</span><br><span class="line"></span><br><span class="line">[root@tool-server ~]# journalctl -f CONTAINER_NAME=nginx</span><br><span class="line">-- Logs begin at Tue 2020-03-31 18:24:36 CST. --</span><br><span class="line"></span><br><span class="line">Apr 02 18:20:05 tool-server 2011dc967d7e[3655]: 192.168.40.160 - - [02/Apr/2020:10:20:05 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" "-"</span><br></pre></td></tr></table></figure><p>journalctl的命令形式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">journalctl CONTAINER_NAME=nginx # 输出指定容器的日志</span><br><span class="line">journalctl -b CONTAINER_NAME=nginx # 输出从上次启动以来的所有日志</span><br><span class="line">journalctl -o json CONTAINER_NAME=nginx # 以json格式显示日志，包含了label，env中指定的属性值</span><br><span class="line">journalctl -f CONTAINER_NAME=nginx  # 类似于tail -f</span><br></pre></td></tr></table></figure><p>journald Log Driver支持的配置属性如下</p><table><thead><tr><th align="left">配置属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">tag</td><td align="left">指定要在日志中设置CONTAINER_TAG与SYSLOG_IDENTIFIER值的模板</td></tr><tr><td align="left">labels</td><td align="left">定义一个标签列表，可在后面通过 –label 设置标签的值，该标签值会包含在日志体中</td></tr><tr><td align="left">env</td><td align="left">定义一个环境变量列表，可在后面通过 –env 指定环境变量的值，并且值会包含在日志体重</td></tr><tr><td align="left">env-regex</td><td align="left">与env类似，用于匹配与日志相关的环境变量的正则表达式</td></tr></tbody></table><p>下图是使用 <code>journalctl -o json CONTAINER_NAME=nginx</code> 命令输出的完整json格式日志，其中包含了前面设置的profile标签与ONLINE环境变量。<br><img src="/assets/docker-journald-log.png" alt="docker-journald-log"></p><p>除此之外，journald日志体中还会加上下面的数据</p><ul><li>CONTAINER_ID： 容器ID，12位</li><li>CONTAINER_ID_FULL：完整的容器ID，64位</li><li>CONTAINER_NAME：容器名称</li><li>CONTAINER_TAG，SYSLOG_IDENTIFIER：容器的tag</li></ul><p>具体从上图也可以看出。</p><ol start="4"><li>syslog</li></ol><p>syslog Log Driver将日志发送到syslog的服务器，在Linux中，一般使用rsyslog服务。</p><p>修改rsyslog配置，打开udp或tcp监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# vim /etc/rsyslog.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides UDP syslog reception</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ModLoad imudp</span></span><br><span class="line"><span class="meta">$</span><span class="bash">UDPServerRun 514</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides TCP syslog reception</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ModLoad</span> imtcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$InputTCPServerRun</span> 514</span></span><br></pre></td></tr></table></figure><p>重启rsyslog</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# systemctl restart  rsyslog</span><br><span class="line"></span><br><span class="line">[root@tool-server ~]# netstat -ano|grep 514</span><br><span class="line">udp        0      0 0.0.0.0:514             0.0.0.0:*                           off (0.00/0/0)</span><br><span class="line">udp6       0      0 :::514                  :::*                                off (0.00/0/0)</span><br></pre></td></tr></table></figure><p>以syslog Log Driver启动nginx容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# docker run -d --name nginx -p 80:80 --log-driver syslog --log-opt syslog-address=udp://127.0.0.1:514  --restart=always nginx</span><br><span class="line">989db94a01c36b7ea767bcb8db8ccc64bd558291ef7bcb364efa1352c78b8878</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看syslog日志</span></span><br><span class="line">[root@tool-server ~]# tail -f /var/log/messages</span><br><span class="line">Apr  2 18:58:06 localhost 989db94a01c3[3655]: 192.168.40.160 - - [02/Apr/2020:10:58:06 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" "-"</span><br></pre></td></tr></table></figure><h2 id="容器日志采集实践"><a href="#容器日志采集实践" class="headerlink" title="容器日志采集实践"></a>容器日志采集实践</h2><ol><li><p>对于使用STDOUT/STDERR输出日志的容器，比如nginx，可通过默认的json-file，从前文提到的目录下通过filebeat或logstash进行监听采集</p></li><li><p>对于使用日志文件记录的容器，比如tomcat，可通过目录挂载的方式将容器日志目录挂载到宿主机目录，然后监听宿主机目录进行日志采集，比如启动时指定参数 <code>-v /data/tomcat/logs:/usr/local/tomcat/logs</code>。但这种方式如果同一应用的容器在一个服务器节点上启动多个时，会造成日志文件名相同产生冲突，对于这种情况，如果使用的是logback日志框架，之前的文章<a href="https://mp.weixin.qq.com/s/ql22PC_PJQ-0SuJyXpf4TQ" target="_blank" rel="noopener">自定义logback日志文件的名称</a> 提供了一种方案</p></li><li><p>如果既有标准输出又有日志文件输出，可考虑第三方日志采集框架，比如阿里巴巴开源的log-pilot</p></li><li><p>如果是Serverless环境，即没有具体的物理机或虚拟机，通过云容器服务部署的情况，则可以通过挂载云盘的方式，将容器日志目录挂载到云盘目录下，通过监听云盘目录进行日志采集</p></li></ol><p>出于篇幅与时间关系，这里只列出几种不同场景的日志采集方案，1,2场景比较好理解，对于4一般云平台都有相关的文档可查阅，场景3后续可再整理一篇实操文来补充说明。</p><hr><p>作者：空山新雨<br>近期作者写了几十篇技术博客，内容包括Java、Spring Boot、Spring Cloud、Docker，技术管理心得等<br>欢迎关注作者微信公众号：空山新雨的技术空间，一起学习成长  </p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志是服务运行过程中的一个关键环节，借助日志，我们可以排查定位问题，也可以借助集中化的日志管理平台（如ELK）来做一些必要的数据统计分析。在Docker环境中，日志的采集比传统环境更为复杂，因此了解Docker日志的管理机制，及基于此熟悉日志采集的最佳实践对于开发运维人员来说也是避不开的一个知识点。那就开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://blog.jboost.cn/categories/Docker/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
      <category term="log-pilot" scheme="http://blog.jboost.cn/tags/log-pilot/"/>
    
  </entry>
  
</feed>
