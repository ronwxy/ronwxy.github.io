<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半路雨歌</title>
  
  <subtitle>Sing In The Storm</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jboost.cn/"/>
  <updated>2020-05-27T03:55:16.157Z</updated>
  <id>http://blog.jboost.cn/</id>
  
  <author>
    <name>雨歌</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes笔记（四）：详解Namespace与资源限制ResourceQuota，LimitRange</title>
    <link href="http://blog.jboost.cn/k8s4-namespace.html"/>
    <id>http://blog.jboost.cn/k8s4-namespace.html</id>
    <published>2020-05-27T05:20:25.000Z</published>
    <updated>2020-05-27T03:55:16.157Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们对K8s的基本组件与概念有了个大致的印象，并且基于K8s实现了一个初步的CI/CD流程，但对里面涉及的各个对象（如Namespace, Pod, Deployment, Service, Ingress, PVC等）及各对象的管理可能还缺乏深入的理解与实践，接下来的文章就让我们一起深入K8s的各组件内部来一探究竟吧。下图是基于个人的理解梳理的一个K8s结构图，示例了各个组件（只包含了主要组件）如何协同。</p><a id="more"></a><p><img src="/assets/k8s-struct.png" alt="k8s-struct"></p><p>后续几篇文章围绕该图涉及组件进行整理介绍，本文主要探究Namespace及与Namespace管理相关的资源限制ResourceQuota/LimitRange部分。</p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>Namespace即命名空间，主要有两个方面的作用：</p><ol><li>资源隔离：可为不同的团队/用户（或项目）提供虚拟的集群空间，共享同一个Kubernetes集群的资源。比如可以为团队A创建一个Namespace ns-a，团队A的项目都部署运行在 ns-a 中，团队B创建另一个Namespace ns-b，其项目都部署运行在 ns-b 中，或者为开发、测试、生产环境创建不同的Namespace，以做到彼此之间相互隔离，互不影响。我们可以使用 ResourceQuota 与 Resource LimitRange 来指定与限制 各个namesapce的资源分配与使用</li><li>权限控制：可以指定某个namespace哪些用户可以访问，哪些用户不能访问</li></ol><p>Kubernetes 安装成功后，默认会创建三个namespace：</p><ul><li>default：默认的namespace，如果创建Kubernetes对象时不指定 metadata.namespace，该对象将在default namespace下创建</li><li>kube-system：Kubernetes系统创建的对象放在此namespace下，我们前面说的kube-apiserver，etcd，kube-proxy等都在该namespace下</li><li>kube-public：顾名思义，共享的namespace，所有用户对该namespace都是可读的。主要是为集群做预留，一般都不在该namespace下创建对象</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1.查看namesapce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespaces</span><br><span class="line">kubectl get namesapce</span><br><span class="line">kubectl get ns               # 三个操作等效</span><br><span class="line">kubectl get ns --show-labels # 显示namespace的label</span><br></pre></td></tr></table></figure><p>使用namesapces,namesapce,ns都是可以的。如下列出了当前集群中的所有namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl get ns</span><br><span class="line">NAME                   STATUS   AGE</span><br><span class="line">default                Active   34d</span><br><span class="line">develop                Active   17d</span><br><span class="line">ingress-nginx          Active   33d</span><br><span class="line">kube-node-lease        Active   34d</span><br><span class="line">kube-public            Active   34d</span><br><span class="line">kube-system            Active   34d</span><br><span class="line">kubernetes-dashboard   Active   31d</span><br><span class="line">pre-release            Active   17d</span><br></pre></td></tr></table></figure><p>可以使用 <code>kubectl describe</code> 命令来查看某个namespace的概要信息，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl describe ns default</span><br><span class="line">Name:         default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active</span><br><span class="line"></span><br><span class="line">No resource quota.</span><br><span class="line"></span><br><span class="line">No resource limits.</span><br></pre></td></tr></table></figure><p>2.创建namespace</p><p>有两种方式：通过yaml定义文件创建或直接使用命令创建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式1. 通过yaml定义文件创建</span></span><br><span class="line">[root@kmaster ~]# vim test-namespace.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: test     # namespace的名称</span><br><span class="line">  labels:</span><br><span class="line">    name: ns-test</span><br><span class="line">[root@kmaster ~]# kubectl create -f ./test-namespace.yaml  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式2. 直接使用命令创建</span></span><br><span class="line">[root@kmaster ~]# kubectl create ns test</span><br></pre></td></tr></table></figure><p>3.在namesapce中创建对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 在yaml中通过metadata.namesapce 指定</span></span><br><span class="line">[root@kmaster ~]# kubectl get deploy my-nginx -o yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    run: my-nginx</span><br><span class="line">  name: my-nginx</span><br><span class="line">  namespace: test  # 指定namespace</span><br><span class="line">spec:</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 在命令中通过 -n 或 --namesapce 指定</span></span><br><span class="line">[root@kmaster ~]# kubectl run dev-nginx --image=nginx:latest --replicas=3 -n test</span><br></pre></td></tr></table></figure><p>4.设定kubectl namesapce上下文</p><p>kubectl上下文即集群、namespace、用户的组合，设定kubectl上下文，即可以以上下文指定的用户，在上下文指定的集群与namespace中进行操作管理。查看当前集群kubectl上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前kubectl上下文</span></span><br><span class="line">[root@kmaster ~]# kubectl config view</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: DATA+OMITTED</span><br><span class="line">    server: https://192.168.40.111:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: kubernetes-admin</span><br><span class="line">  name: kubernetes-admin@kubernetes</span><br><span class="line">current-context: kubernetes-admin@kubernetes</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: kubernetes-admin</span><br><span class="line">  user:</span><br><span class="line">    client-certificate-data: REDACTED</span><br><span class="line">    client-key-data: REDACTED</span><br></pre></td></tr></table></figure><p>可见当前上下文为kubernetes-admin@kubernetes (current-context: kubernetes-admin@kubernetes)。</p><p>创建一个kubectl上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl config set-context test --namespace=test --cluster=kubernetes --user=kubernetes-admin</span><br><span class="line">Context "test" created.</span><br></pre></td></tr></table></figure><p>再次执行 <code>kubectl config view</code> 将可以看到上面创建的test上下文。</p><p>切换上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置当前上下文</span></span><br><span class="line">[root@kmaster ~]# kubectl config use-context test</span><br><span class="line">Switched to context "test".</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前所在的上下文</span></span><br><span class="line">[root@kmaster ~]# kubectl config current-context</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>指定了上下文，后续操作都在该上下文对应的namespace中进行，不需要再显式指定namespace。在上下文中创建对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前上下文中创建对象</span></span><br><span class="line">[root@kmaster ~]# kubectl run my-nginx --image=nginx:latest --replicas=2</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/my-nginx created</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看创建的对象，不需要指定namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl get deploy</span><br><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">my-nginx   2/2     2            2           25m</span><br><span class="line">[root@kmaster ~]# kubectl get pod</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">my-nginx-667764d77b-ldb78   1/1     Running   0          24m</span><br><span class="line">my-nginx-667764d77b-wpgxw   1/1     Running   0          24m</span><br></pre></td></tr></table></figure><p>删除上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl config delete-context test</span><br><span class="line">deleted context test from /root/.kube/config</span><br></pre></td></tr></table></figure><p>也可以使用如下命令直接切换默认的namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将默认namespace设置为<span class="built_in">test</span></span></span><br><span class="line">[root@kmaster ~]# kubectl config set-context --current --namespace=test</span><br></pre></td></tr></table></figure><p>5.删除namesapce</p><p>可以使用 <code>kubectl delete ns &lt;namespace名称&gt;</code> 来删除一个namesapce，该操作会删除namespace中的所有内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl delete ns test</span><br></pre></td></tr></table></figure><h2 id="Resource-Quota"><a href="#Resource-Quota" class="headerlink" title="Resource Quota"></a>Resource Quota</h2><p>Resource Quota即资源配额，限定单个namespace中可使用集群资源的总量，包括两个维度：</p><ol><li>限定某个对象类型（如Pod）可创建对象的总数；</li><li>限定某个对象类型可消耗的计算资源（CPU、内存）与存储资源（存储卷声明）总数</li></ol><p>如果在 namespace 中为计算资源 CPU 和内存设定了 ResourceQuota，用户在创建对象（Pod、Service等）时，必须指定 requests 和 limits；如果在创建或更新对象时申请的资源与 namespace 的 ResourceQuota 冲突，则 apiserver 会返回 HTTP 状态码 403，以及对应的错误提示信息。当集群中总的容量小于各个 namespace 资源配额的总和时，可能会发生资源争夺，此时 Kubernetes 将按照先到先得的方式分配资源。</p><h3 id="对象数量限制"><a href="#对象数量限制" class="headerlink" title="对象数量限制"></a>对象数量限制</h3><p>声明格式为： <code>count/&lt;resource&gt;.&lt;group&gt;</code>， 如下列出各类对象的声明格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">count&#x2F;persistentvolumeclaims </span><br><span class="line">count&#x2F;services</span><br><span class="line">count&#x2F;secrets</span><br><span class="line">count&#x2F;configmaps</span><br><span class="line">count&#x2F;replicationcontrollers</span><br><span class="line">count&#x2F;deployments.apps</span><br><span class="line">count&#x2F;replicasets.apps</span><br><span class="line">count&#x2F;statefulsets.apps</span><br><span class="line">count&#x2F;jobs.batch</span><br><span class="line">count&#x2F;cronjobs.batch</span><br><span class="line">count&#x2F;deployments.extensions</span><br></pre></td></tr></table></figure><h3 id="计算资源限制"><a href="#计算资源限制" class="headerlink" title="计算资源限制"></a>计算资源限制</h3><p>定义CPU、内存请求（requests）、限制（limits）使用的总量，包括</p><ul><li>limits.cpu：namespace中，所有非终止状态的 Pod 的 CPU 限制 resources.limits.cpu 总和不能超过该值</li><li>limits.memory：namespace中，所有非终止状态的 Pod 的内存限制 resources.limits.memory 总和不能超过该值</li><li>requests.cpu：namespace中，所有非终止状态的 Pod 的 CPU 请求 resources.requrest.cpu 总和不能超过该值</li><li>requests.memory：namespace中，所有非终止状态的 Pod 的 CPU 请求 resources.requests.memory 总和不能超过该值</li></ul><h3 id="存储资源限制"><a href="#存储资源限制" class="headerlink" title="存储资源限制"></a>存储资源限制</h3><p>定义存储卷声明请求的存储总量或创建存储卷声明数量的限制，包括</p><ul><li>requests.storage：namespace中，所有存储卷声明（PersistentVolumeClaim）请求的存储总量不能超过该值</li><li>persistentvolumeclaims：namespace中，可以创建的存储卷声明的总数不能超过该值</li><li><code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/requests.storage</code>：namespace中，所有与指定存储类（StorageClass）关联的存储卷声明请求的存储总量不能超过该值</li><li><code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/persistentvolumeclaims</code>：namespace中，所有与指定存储类关联的存储卷声明的总数不能超过该值</li></ul><p>除此之外，还可以对本地临时存储资源进行限制定义</p><ul><li>requests.ephemeral-storage：namespace中，所有 Pod 的本地临时存储（local ephemeral storage）请求的总和不能超过该值</li><li>limits.ephemeral-storage：namespace中，所有 Pod 的本地临时存储限定的总和不能超过此值</li></ul><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>查看是否开启 Resource Quota 支持，默认一般是开启的。如果没有，可在启动 apiserver 时为参数 –enable-admission-plugins 添加 ResourceQuota 配置项。<br><img src="/assets/resource-quota.png" alt="resource-quota.png"></p><p>1.创建ResourceQuota</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl create namespace test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑ResourceQuota定义文档</span></span><br><span class="line">[root@kmaster ~]# vim quota-test.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ResourceQuota</span><br><span class="line">metadata:</span><br><span class="line">  name: quota-test</span><br><span class="line">  namespace: test</span><br><span class="line">spec:</span><br><span class="line">  hard:</span><br><span class="line">    requests.cpu: "2"</span><br><span class="line">    requests.memory: 2Gi</span><br><span class="line">    limits.cpu: "4"</span><br><span class="line">    limits.memory: 4Gi</span><br><span class="line">    requests.nvidia.com/gpu: 4</span><br><span class="line">    pods: "3"</span><br><span class="line">    services: "6"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建ResourceQuota</span></span><br><span class="line">[root@kmaster ~]# kubectl apply -f quota-test.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@kmaster ~]# kubectl get quota -n test</span><br><span class="line">NAME         CREATED AT</span><br><span class="line">quota-test   2020-05-26T10:31:10Z</span><br><span class="line">[root@kmaster ~]# kubectl describe quota quota-test -n test</span><br><span class="line">Name:                    quota-test</span><br><span class="line">Namespace:               test</span><br><span class="line">Resource                 Used  Hard</span><br><span class="line">--------                 ----  ----</span><br><span class="line">limits.cpu               0     4</span><br><span class="line">limits.memory            0     4Gi</span><br><span class="line">pods                     0     3</span><br><span class="line">requests.cpu             0     2</span><br><span class="line">requests.memory          0     2Gi</span><br><span class="line">requests.nvidia.com/gpu  0     4</span><br><span class="line">services                 0     6</span><br></pre></td></tr></table></figure><p>或者使用kubectl命令，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl create quota quota-test --hard=count/deployments.extensions=2,count/replicasets.extensions=4,count/pods=3,count/secrets=4 --namespace=test</span><br></pre></td></tr></table></figure><p>我们在namespace test中创建了一个ResourceQuota，限制CPU、内存请求为2、2GB，限制CPU、内存限定使用为4、4GB，限制Pod个数为3 等。</p><p>我们来尝试创建一个如下定义的Deployment来测试一下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个测试deploy</span></span><br><span class="line">[root@kmaster ~]# vim quota-test-deploy.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: quota-test-deploy</span><br><span class="line">spec:</span><br><span class="line"> selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      purpose: quota-test</span><br><span class="line"> replicas: 3</span><br><span class="line"> template:</span><br><span class="line">   metadata:</span><br><span class="line">     labels:</span><br><span class="line">       purpose: quota-test</span><br><span class="line">   spec:</span><br><span class="line">     containers:</span><br><span class="line">     - name: quota-test</span><br><span class="line">       image: nginx</span><br><span class="line">       resources:</span><br><span class="line">         limits:</span><br><span class="line">           memory: "2Gi"</span><br><span class="line">           cpu: "1"</span><br><span class="line">         requests:</span><br><span class="line">           memory: "500Mi"</span><br><span class="line">           cpu: "500m"</span><br><span class="line">[root@kmaster ~]# kubectl apply -f quota-test-deploy.yaml -n test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@kmaster ~]# kubectl get pod -n test</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">quota-test-deploy-6b89fdc686-2dthq   1/1     Running   0          3m54s</span><br><span class="line">quota-test-deploy-6b89fdc686-9m2qw   1/1     Running   0          3m54s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看deploy状态</span></span><br><span class="line">[root@kmaster ~]# kubectl get deploy quota-test-deploy -n test -o yaml</span><br><span class="line">  message: 'pods "quota-test-deploy-6b89fdc686-rmktq" is forbidden: exceeded quota:</span><br><span class="line">        quota-test, requested: limits.memory=2Gi, used: limits.memory=4Gi, limited:</span><br><span class="line">        limits.memory=4Gi'</span><br></pre></td></tr></table></figure><p> replicas: 3定义创建三个Pod副本，但只成功创建了两个Pod，在deploy的status部分（最后一条命令结果），我们可以看到message提示第三个Pod创建时被拒绝，因为内存已达到限定。我们也可以将limits.memory调整为1Gi，将replicas调整为4，来验证对Pod个数的限制。可看到最终只起了三个Pod，status部分message提示 <code>pods &quot;quota-test-deploy-9dc54f95c-gzqw7&quot; is forbidden: exceeded quota:quota-test, requested: pods=1, used: pods=3, limited: pods=3</code>。</p><h2 id="Resource-Limit-Range"><a href="#Resource-Limit-Range" class="headerlink" title="Resource Limit Range"></a>Resource Limit Range</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>Resource Quota 是对namespace中总体的资源使用进行限制，Resource Limit Range 则是对具体某个Pod或容器的资源使用进行限制。默认情况下，namespace中Pod或容器的资源消耗是不受限制的，这就可能导致某个容器应用内存泄露耗尽资源影响其它应用的情况。Limit Range可以用来限定namespace内Pod（或容器）可以消耗资源的数量。</p><p>使用LimitRange对象，我们可以：</p><ol><li>限制namespace中每个Pod或容器的最小与最大计算资源</li><li>限制namespace中每个Pod或容器计算资源request、limit之间的比例</li><li>限制namespace中每个存储卷声明（PersistentVolumeClaim）可使用的最小与最大存储空间</li><li>设置namespace中容器默认计算资源的request、limit，并在运行时自动注入到容器中</li></ol><p>如果创建或更新对象（Pod、容器、PersistentVolumeClaim）对资源的请求与LimitRange相冲突，apiserver会返回HTTP状态码403，以及相应的错误提示信息；如果namespace中定义了LimitRange 来限定CPU与内存等计算资源的使用，则用户创建Pod、容器时，必须指定CPU或内存的request与limit，否则将被系统拒绝；当namespace总的limit小于其中Pod、容器的limit之和时，将发生资源争夺，Pod或者容器将不能创建，但不影响已经创建的Pod或容器。</p><h3 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h3><p>创建一个测试namespace test-limitrange，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建测试namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl create namespace test-limitrange</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换默认的namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl config set-context --current --namespace=test-limitrange</span><br></pre></td></tr></table></figure><p>创建LimitRange定义文件 lr-test.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lr-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Container</span>       <span class="comment">#资源类型</span></span><br><span class="line">    <span class="attr">max:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"1"</span>            <span class="comment">#限定最大CPU</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"1Gi"</span>       <span class="comment">#限定最大内存</span></span><br><span class="line">    <span class="attr">min:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"100m"</span>         <span class="comment">#限定最小CPU</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"100Mi"</span>     <span class="comment">#限定最小内存</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"900m"</span>         <span class="comment">#默认CPU限定</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"800Mi"</span>     <span class="comment">#默认内存限定</span></span><br><span class="line">    <span class="attr">defaultRequest:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"200m"</span>         <span class="comment">#默认CPU请求</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"200Mi"</span>     <span class="comment">#默认内存请求</span></span><br><span class="line">    <span class="attr">maxLimitRequestRatio:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="number">2</span>              <span class="comment">#限定CPU limit/request比值最大为2  </span></span><br><span class="line">      <span class="attr">memory:</span> <span class="number">1.5</span>         <span class="comment">#限定内存limit/request比值最大为1.5</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pod</span></span><br><span class="line">    <span class="attr">max:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"2"</span>            <span class="comment">#限定Pod最大CPU</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"2Gi"</span>       <span class="comment">#限定Pod最大内存</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line">    <span class="attr">max:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">2Gi</span>        <span class="comment">#限定PVC最大的requests.storage</span></span><br><span class="line">    <span class="attr">min:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span>        <span class="comment">#限定PVC最小的requests.storage</span></span><br></pre></td></tr></table></figure><p>该文件定义了在namespace <code>test-limitrange</code> 中，容器、Pod、PVC的资源限制，在该namesapce中，只有满足如下条件，对象才能创建成功</p><ul><li>容器的<code>resources.limits</code>部分CPU必须在100m-1之间，内存必须在100Mi-1Gi之间，否则创建失败</li><li>容器的<code>resources.limits</code>部分CPU与<code>resources.requests</code>部分CPU的比值最大为2，memory比值最大为1.5，否则创建失败</li><li>Pod内所有容器的<code>resources.limits</code>部分CPU总和最大为2，内存总和最大为2Gi，否则创建失败</li><li>PVC的<code>resources.requests.storage</code>最大为2Gi，最小为1Gi，否则创建失败</li></ul><blockquote><p>如果容器定义了<code>resources.requests</code>没有定义<code>resources.limits</code>，则LimitRange中的default部分将作为limit注入到容器中；如果容器定义了<code>resources.limits</code>却没有定义<code>resources.requests</code>，则将requests值也设置为limits的值；如果容器两者都没有定义，则使用LimitRange中default作为limits，defaultRequest作为requests值</p></blockquote><p>创建与查看LimitRange，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建LimitRange</span></span><br><span class="line">[root@kmaster ~]# kubectl apply -f lr-test.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@kmaster ~]# kubectl describe limits lr-test</span><br><span class="line">Name:                  lr-test</span><br><span class="line">Namespace:             test-limitrange</span><br><span class="line">Type                   Resource  Min    Max  Default Request  Default Limit  Max Limit/Request Ratio</span><br><span class="line">----                   --------  ---    ---  ---------------  -------------  -----------------------</span><br><span class="line">Container              cpu       100m   1    200m             900m           2</span><br><span class="line">Container              memory    100Mi  1Gi  200Mi            800Mi          1500m</span><br><span class="line">Pod                    cpu       -      2    -                -              -</span><br><span class="line">Pod                    memory    -      2Gi  -                -              -</span><br><span class="line">PersistentVolumeClaim  storage   1Gi    2Gi  -                -              -</span><br></pre></td></tr></table></figure><p>我们可以创建不同配置的容器或Pod对象来验证，出于篇幅不再列出验证步骤。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对K8s的Namespace及针对Namespace的资源限制管理ResourceQuota，LimitRange进行了较为深入的探索，其中ResourceQuota对整个Namespace的资源使用情况进行限制，LimitRange则对单个的Pod或容器的资源使用进行限制。Namespace的权限控制可基于RBAC来实现，后续再单独进行梳理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们对K8s的基本组件与概念有了个大致的印象，并且基于K8s实现了一个初步的CI/CD流程，但对里面涉及的各个对象（如Namespace, Pod, Deployment, Service, Ingress, PVC等）及各对象的管理可能还缺乏深入的理解与实践，接下来的文章就让我们一起深入K8s的各组件内部来一探究竟吧。下图是基于个人的理解梳理的一个K8s结构图，示例了各个组件（只包含了主要组件）如何协同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
      <category term="ResourceQuota" scheme="http://blog.jboost.cn/tags/ResourceQuota/"/>
    
      <category term="LimitRange" scheme="http://blog.jboost.cn/tags/LimitRange/"/>
    
  </entry>
  
  <entry>
    <title>解决K8s “kernel:unregister_netdevice:waiting for vethxxx to become free. Usage count=1” 的问题（Kernel升级）</title>
    <link href="http://blog.jboost.cn/k8s-netdevice-issue.html"/>
    <id>http://blog.jboost.cn/k8s-netdevice-issue.html</id>
    <published>2020-05-22T03:35:05.000Z</published>
    <updated>2020-05-22T04:53:29.445Z</updated>
    
    <content type="html"><![CDATA[<p>k8s集群运行过程中，经常出现节点上报出类似 “kernel:unregister_netdevice:waiting for vethxxx to become free. Usage count=1” 的错误信息，一方面影响交互，另一方面，对于有些操作比如 <code>docker stop</code>，半天没有响应，处于hang住的状态。</p><a id="more"></a><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>操作系统及内核版本为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-2 ~]# cat /etc/redhat-release </span><br><span class="line">CentOS Linux release 7.6.1810 (Core) </span><br><span class="line"></span><br><span class="line">[root@dev-server-2 ~]# uname -a</span><br><span class="line">Linux dev-server-2 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>经常有节点报出类似如下错误</p><p><img src="/assets/docker-bug.png" alt="docker-bug"></p><p>查看一些网上资料，一般都说是Kernel的Bug，并且虽然有些地方说在先前版本已经修复，但是在较高版本上仍有出现。</p><p>有一些解决办法是停止syslog服务，让其不将错误信息显示到控制台，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-2 ~]# systemctl stop rsyslog</span><br></pre></td></tr></table></figure><p>但这只能解决影响交互的问题，对于容器引擎被hang住的问题并没有解决，治标不治本。</p><p>也有人对此Bug的原因进行了追踪分析，判断可能是net_device引用计数器泄露的原因（参考：<a href="https://zhuanlan.zhihu.com/p/66895097" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66895097</a> ），并给出了修复补丁，尝试着安装给出的补丁，但没有成功。</p><p>查看了目前elrepo的kernel的ml（mainline stable，稳定的主线版本）版本已经到了 5.6.14-1.el7.elrepo， 于是尝试着对kernel进行升级。</p><h2 id="升级Kernel"><a href="#升级Kernel" class="headerlink" title="升级Kernel"></a>升级Kernel</h2><ol><li>更新yum仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-2 ~]# yum -y update</span><br></pre></td></tr></table></figure><ol start="2"><li>导入elrepo仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">导入elrepo仓库的公钥</span></span><br><span class="line">[root@dev-server-2 ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"><span class="meta">#</span><span class="bash">安装ELRepo仓库的yum源</span></span><br><span class="line">[root@dev-server-2 ~]# rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash">查看可用的kerner版本</span></span><br><span class="line">[root@dev-server-2 ~]# yum --disablerepo="*" --enablerepo="elrepo-kernel" list available</span><br></pre></td></tr></table></figure><ol start="3"><li>升级内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装最新版的内核</span></span><br><span class="line">[root@dev-server-2 ~]# yum --enablerepo=elrepo-kernel install kernel-ml</span><br></pre></td></tr></table></figure><ol start="4"><li>设置默认启动内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看系统已有内核</span></span><br><span class="line">[root@dev-server-2 ~]# sudo awk -F\' '$1=="menuentry " &#123;print i++ " : " $2&#125;' /etc/grub2.cfg</span><br><span class="line">0 : CentOS Linux (5.6.14-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">1 : CentOS Linux (3.10.0-957.el7.x86_64) 7 (Core)</span><br><span class="line">2 : CentOS Linux (0-rescue-f638aa03cdcf42998b077254bde50b53) 7 (Core)</span><br><span class="line"><span class="meta">#</span><span class="bash">设置默认启动内核，其中0为上述查出内核的索引</span></span><br><span class="line">grub2-set-default 0</span><br><span class="line"><span class="meta">#</span><span class="bash">生成grub配置文件</span></span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><ol start="5"><li>重启验证</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">[root@dev-server-2 devuser]# reboot</span><br><span class="line"><span class="meta">#</span><span class="bash">查看当前内核版本</span></span><br><span class="line">[root@dev-server-2 devuser]# uname -a</span><br><span class="line">Linux dev-server-2 5.6.14-1.el7.elrepo.x86_64 #1 SMP Tue May 19 12:17:13 EDT 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><ol start="6"><li>删除旧内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看现有内核</span></span><br><span class="line">[root@dev-server-2 devuser]# rpm -qa | grep kernel</span><br><span class="line">kernel-tools-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-headers-3.10.0-1062.1.1.el7.x86_64</span><br><span class="line">kernel-debuginfo-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-tools-libs-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-debuginfo-common-x86_64-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-ml-5.6.14-1.el7.elrepo.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash">删除旧的内核</span></span><br><span class="line">[root@dev-server-2 devuser]# yum remove ernel-tools-3.10.0-957.el7.x86_64 kernel-headers-3.10.0-1062.1.1.el7.x86_64 kernel-debuginfo-3.10.0-957.el7.x86_64 kernel-tools-libs-3.10.0-957.el7.x86_64 kernel-debuginfo-common-x86_64-3.10.0-957.el7.x86_64 kernel-3.10.0-957.el7.x86_64</span><br></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>通过升级内核重启后，问题目前没有再复现。但是否彻底解决该Bug待进一步跟进（至少不需要重装系统了）。</p><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/66895097" target="_blank" rel="noopener">诊断修复 TiDB Operator 在 K8s 测试中遇到的 Linux 内核问题</a></li><li><a href="https://www.cnblogs.com/xzkzzz/p/9627658.html" target="_blank" rel="noopener">Centos7 升级内核版本</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;k8s集群运行过程中，经常出现节点上报出类似 “kernel:unregister_netdevice:waiting for vethxxx to become free. Usage count=1” 的错误信息，一方面影响交互，另一方面，对于有些操作比如 &lt;code&gt;docker stop&lt;/code&gt;，半天没有响应，处于hang住的状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>面试官：请写一个你认为比较“完美”的单例</title>
    <link href="http://blog.jboost.cn/patterns-singleton.html"/>
    <id>http://blog.jboost.cn/patterns-singleton.html</id>
    <published>2020-05-12T03:50:21.000Z</published>
    <updated>2020-05-14T00:23:05.949Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是保证一个类的实例有且只有一个，在需要控制资源（如数据库连接池），或资源共享（如有状态的工具类）的场景中比较适用。如果让我们写一个单例实现，估计绝大部分人都觉得自己没问题，但如果需要实现一个比较完美的单例，可能并没有你想象中简单。本文以主人公小雨的一次面试为背景，循序渐进地讨论如何实现一个较为“完美”的单例。本文人物与场景皆为虚构，如有雷同，纯属捏造。</p><a id="more"></a><p>小雨计算机专业毕业三年，对设计模式略有涉猎，能写一些简单的实现，掌握一些基本的JVM知识。在某次面试中，面试官要求现场写代码：请写一个你认为比较“完美”的单例。</p><h2 id="简单的单例实现"><a href="#简单的单例实现" class="headerlink" title="简单的单例实现"></a>简单的单例实现</h2><p>凭借着对单例的理解与印象，小雨写出了下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完后小雨审视了一遍，总觉得有点太简单了，离“完美”貌似还相差甚远。对，在多线程并发环境下，这个实现就玩不转了，如果两个线程同时调用 getInstance() 方法，同时执行到了 if 判断，则两边都认为 instance 实例为空，都会实例化一个 Singleton 对象，就会导致至少产生两个实例了，小雨心想。嗯，需要解决多线程并发环境下的同步问题，保证单例的线程安全。</p><h2 id="线程安全的单例"><a href="#线程安全的单例" class="headerlink" title="线程安全的单例"></a>线程安全的单例</h2><p>一提到并发同步问题，小雨就想到了锁。加个锁还不简单，synchronized 搞起，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小雨再次审视了一遍，发现貌似每次 getInstance() 被调用时，其它线程必须等待这个线程调用完才能执行（因为有锁锁住了嘛），但是加锁其实是想避免多个线程同时执行实例化操作导致产生多个实例，在单例被实例化后，后续调用 getInstance() 直接返回就行了，每次都加锁释放锁造成了不必要的开销。</p><p>经过一阵思索与回想之后，小雨记起了曾经看过一个叫 Double-Checked Locking 的东东，双重检查锁，嗯，再优化一下,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例在完成第一次实例化，后续再调用 getInstance() 先判空，如果不为空则直接返回，如果为空，就算两个线程同时判断为空，在同步块中还做了一次双重检查，可以确保只会实例化一次，省去了不必要的加锁开销，同时也保证了线程安全。并且令小雨感到自我满足的是他基于对JVM的一些了解加上了 volatile 关键字来避免实例化时由于指令重排序优化可能导致的问题，真是画龙点睛之笔啊。 简直——完美！</p><div class="note quote">            <p class='p subtitle'>Tips: volatile关键字的语义</p><ol><li>保证变量对所有线程的可见性。对变量写值的时候JMM（Java内存模型）会将当前线程的工作内存值刷新到主内存，读的时候JMM会从主内存读取变量的值而不是从工作内存读取，确保一个变量值被一个线程更新后，另一个线程能立即读取到更新后的值。</li><li>禁止指令重排序优化。JVM在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序，使用 volatile 可以禁止进行指令重排序优化。</li></ol><p>JVM创建一个新的实例时，主要需三步：</p><ol><li>分配内存</li><li>初始化构造器</li><li>将对象引用指向分配的内存地址</li></ol><p>如果一个线程在实例化时JVM做了指令重排，比如先执行了1，再执行3，最后执行2，则另一个线程可能获取到一个还没有完成初始化的对象引用，调用时可能导致问题，使用volatile可以禁止指令重排，避免这种问题。</p>          </div><p>小雨将答案交给面试官，面试官瞄了一眼说道：“基本可用了，但如果我用反射直接调用这个类的构造函数，是不是就不能保证单例了。”  小雨挠挠头，对哦，如果使用反射就可以在运行时改变单例构造器的可见性，直接调用构造器来创建一个新的实例了，比如通过下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;Singleton&gt; constructor = Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Singleton singleton = constructor.newInstance();</span><br></pre></td></tr></table></figure><p>小雨再次陷入了思考。</p><h2 id="反射安全的单例"><a href="#反射安全的单例" class="headerlink" title="反射安全的单例"></a>反射安全的单例</h2><p>怎么避免反射破坏单例呢，或许可以加一个静态变量来控制,让构造器只有从 getInstance() 内部调用才有效，不通过 getInstance() 直接调用则抛出异常，小雨按这个思路做了一番改造，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Please use getInstance() method to get the single instance."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态变量 flag 来控制，只有从 getInstance() 调用构造器才能正常实例化，否则抛出异常。但马上小雨就发现了存在的问题：既然可以通过反射来调用构造器，那么也可以通过反射来改变 flag 的值，这样苦心设置的 flag 控制逻辑不就被打破了吗。看来也没那么“完美”。虽然并不那么完美，但也一定程度上规避了使用反射直接调用构造器的场景，并且貌似也想不出更好的办法了，于是小雨提交了答案。</p><p>面试官露出迷之微笑：“想法挺好，反射的问题基本解决了，但如果我序列化这个单例对象，然后再反序列化出来一个对象，这两个对象还一样吗，还能保证单例吗。如果不能，怎么解决这个问题？”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SerializationSafeSingleton s1 = SerializationSafeSingleton.getInstance();</span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">oos.writeObject(s1);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">SerializationSafeSingleton s2 = (SerializationSafeSingleton) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>s1 == s2 吗？ 答案是否，如何解决呢。</p><h2 id="序列化安全的单例"><a href="#序列化安全的单例" class="headerlink" title="序列化安全的单例"></a>序列化安全的单例</h2><p>小雨思考了一会，想起了曾经学习序列化知识时接触的 readResolve() 方法，该方法在ObjectInputStream已经读取一个对象并在准备返回前调用，可以用来控制反序列化时直接返回一个对象，替换从流中读取的对象，于是在前面实现的基础上，小雨添加了一个 readResolve() 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Please use getInstance() method to get the single instance."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法代替了从流中读取对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过几个步骤的逐步改造优化，小雨完成了一个基本具备线程安全、反射安全、序列化安全的单例实现，心想这下应该足够完美了吧。面试官脸上继续保持着迷之微笑：“这个实现看起来还是显得有点复杂，并且也不能完全解决反射安全的问题，想想看还有其它实现方案吗。”</p><h2 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h2><p>小雨反复思考，前面的实现是通过加锁来实现线程安全，除此之外，还可以通过类的加载机制来实现线程安全——类的静态属性只会在第一次加载类时初始化，并且在初始化的过程中，JVM是不允许其它线程来访问的，于是又写出了下面两个版本</p><ol><li>静态初始化版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该版本借助JVM的类加载机制，本身线程安全，但只要 Singleton 类的某个静态对象（方法或属性）被访问，就会造成实例的初始化，而该实例可能根本不会被用到，造成资源浪费，另一方面也存在反射与序列化的安全性问题，也需要进行相应的处理。</p><ol start="2"><li>静态内部类版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该版本只有在调用 getInstance() 才会进行实例化，即延迟加载，避免资源浪费的问题，同时也能保障线程安全，但是同样存在反射与序列化的安全性问题，需要相应处理。</p><p>这貌似跟前面版本的复杂性差不多啊，依然都需要解决反射与安全性的问题，小雨心想，有没有一种既简单又能避免这些问题的方案呢。</p><h2 id="“完美”方案"><a href="#“完美”方案" class="headerlink" title="“完美”方案"></a>“完美”方案</h2><p>一阵苦思冥想之后，小雨突然脑中灵光闪现，枚举！（这也是《Effective Java》的作者推荐的方式啊）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接通过 Singleton.INSTANCE 来引用单例，非常简单的实现，并且既是线程安全的，同时也能应对反射与序列化的问题，面试官想要的估计就是它了吧。小雨再次提交了答案，这一次，面试官脸上的迷之微笑逐渐消失了……</p><div class="note quote">            <p class='p subtitle'>Tips：为什么枚举是线程、反射、序列化安全的？</p><ol><li>枚举实际是通过一个继承自Enum的final类来实现（通过反编译class文件可看到具体实现），在static代码块中对其成员进行初始化，因此借助类加载机制来保障其线程安全</li><li>枚举是不支持通过反射实例化的，在Constructor类的newInstance方法中可看到</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br></pre></td></tr></table></figure>3. 枚举在序列化的时候仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。并且，编译器是不允许任何对这种序列化机制的定制的，禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。枚举通过这种机制保障了序列化安全。          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>枚举方案近乎“完美”，但实际中，大部分情况下，我们使用双重检查锁方案或静态内部类方案基本都能满足我们的场景并能很好地运行。并且方案从来没有“完美”，只有更好或更合适。本文只是从单例实现的不断演进的过程中，了解或回顾如反射、序列化、线程安全、Java内存模型（volatile语义）、JVM类加载机制、JVM指令重排序优化等方面的知识，同时也是启示我们在设计或实现的过程中，多从各个角度思考，尽可能全面地考虑问题。或者，在相关面试中能更好地迎合面试官的“完美”期望。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是保证一个类的实例有且只有一个，在需要控制资源（如数据库连接池），或资源共享（如有状态的工具类）的场景中比较适用。如果让我们写一个单例实现，估计绝大部分人都觉得自己没问题，但如果需要实现一个比较完美的单例，可能并没有你想象中简单。本文以主人公小雨的一次面试为背景，循序渐进地讨论如何实现一个较为“完美”的单例。本文人物与场景皆为虚构，如有雷同，纯属捏造。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://blog.jboost.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://blog.jboost.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（三）：Gitlab+Jenkins Pipeline+Docker+k8s+Helm自动化部署实践（干货！）</title>
    <link href="http://blog.jboost.cn/k8s3-cd.html"/>
    <id>http://blog.jboost.cn/k8s3-cd.html</id>
    <published>2020-05-09T03:53:23.000Z</published>
    <updated>2020-05-12T00:53:26.937Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面两篇文章，我们已经有了一个“嗷嗷待哺”的K8s集群环境，也对相关的概念与组件有了一个基本了解（前期对概念有个印象即可，因为只有实践了才能对其有深入理解，所谓“纸上得来终觉浅，绝知此事要躬行”），本文从实践角度介绍如何结合我们常用的Gitlab与Jenkins，通过K8s来实现项目的自动化部署，示例将包括基于SpringBoot的服务端项目与基于Vue.js的Web项目。</p><a id="more"></a><p>本文涉及到的工具与技术包括：</p><ul><li>Gitlab —— 常用的源代码管理系统</li><li>Jenkins, Jenkins Pipeline —— 常用的自动化构建、部署工具，Pipeline以流水线的方式将构建、部署的各个步骤组织起来</li><li>Docker，Dockerfile —— 容器引擎，所有应用最终都要以Docker容器运行，Dockerfile是Docker镜像定义文件</li><li>Kubernetes —— Google开源的容器编排管理系统</li><li>Helm —— Kubernetes的包管理工具，类似Linux的yum，apt，或Node的npm等包管理工具，能将Kubernetes中的应用及相关依赖服务以包（Chart）的形式组织管理</li></ul><p>环境背景：</p><ol><li>已使用Gitlab做源码管理，源码按不同的环境建立了develop（对应开发环境），pre-release（对应测试环境），master（对应生产环境）分支</li><li>已搭建了Jenkins服务</li><li>已有Docker Registry服务，用于Docker镜像存储（基于Docker Registry或Harbor自建，或使用云服务，本文使用阿里云容器镜像服务）</li><li>已搭建了K8s集群</li></ol><p>预期效果：</p><ol><li>分环境部署应用，开发环境、测试环境、生产环境分开来，部署在同一集群的不同namespace，或不同集群中（比如开发测试部署在本地集群的不同namespace中，生产环境部署在云端集群）</li><li>配置尽可能通用化，只需要通过修改少量配置文件的少量配置属性，就能完成新项目的自动化部署配置</li><li>开发测试环境在push代码时自动触发构建与部署，生产环境在master分支上添加版本tag并且push tag后触发自动部署</li><li>整体交互流程如下图</li></ol><p><img src="http://blog.jboost.cn/assets/jenkins-cicd.png" alt="jenkins-cicd"></p><h2 id="项目配置文件"><a href="#项目配置文件" class="headerlink" title="项目配置文件"></a>项目配置文件</h2><p>首先我们需要在项目的根路径中添加一些必要的配置文件，如下图所示</p><p><img src="http://blog.jboost.cn/assets/springboot-ci-structure.png" alt="springboot-ci-structure"></p><p>包括：</p><ol><li>Dockerfile文件，用于构建Docker镜像的文件（参考 <a href="http://blog.jboost.cn/docker-11.html">Docker笔记（十一）：Dockerfile详解与最佳实践</a>）</li><li>Helm相关配置文件，Helm是Kubernetes的包管理工具，可以将应用部署相关的Deployment，Service，Ingress等打包进行发布与管理（Helm的具体介绍我们后面再补充）</li><li>Jenkinsfile文件，Jenkins的pipeline定义文件，定义了各个阶段需执行的任务</li></ol><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>在项目根目录中添加一个Dockerfile文件（文件名就叫Dockerfile），定义如何构建Docker镜像，以Spring Boot项目为例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM frolvlad&#x2F;alpine-java:jdk8-slim</span><br><span class="line">#在build镜像时可以通过 --build-args profile&#x3D;xxx 进行修改</span><br><span class="line">ARG profile</span><br><span class="line">ENV SPRING_PROFILES_ACTIVE&#x3D;$&#123;profile&#125;</span><br><span class="line">#项目的端口</span><br><span class="line">EXPOSE 8000 </span><br><span class="line">WORKDIR &#x2F;mnt</span><br><span class="line"></span><br><span class="line">#修改时区</span><br><span class="line">RUN sed -i &#39;s&#x2F;dl-cdn.alpinelinux.org&#x2F;mirrors.ustc.edu.cn&#x2F;g&#39; &#x2F;etc&#x2F;apk&#x2F;repositories \</span><br><span class="line">    &amp;&amp; apk add --no-cache tzdata \</span><br><span class="line">    &amp;&amp; ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime \</span><br><span class="line">    &amp;&amp; echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone \</span><br><span class="line">    &amp;&amp; apk del tzdata \</span><br><span class="line">    &amp;&amp; rm -rf &#x2F;var&#x2F;cache&#x2F;apk&#x2F;* &#x2F;tmp&#x2F;* &#x2F;var&#x2F;tmp&#x2F;* $HOME&#x2F;.cache</span><br><span class="line"></span><br><span class="line">COPY .&#x2F;target&#x2F;your-project-name-1.0-SNAPSHOT.jar .&#x2F;app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;&#x2F;mnt&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>将SPRING_PROFILES_ACTIVE通过参数profile暴露出来，在构建的时候可以通过 –build-args profile=xxx 来进行动态设定，以满足不同环境的镜像构建要求。</p><blockquote><p>SPRING_PROFILES_ACTIVE本可以在Docker容器启动时通过<code>docker run -e SPRING_PROFILES_ACTIVE=xxx</code>来设定，因这里使用Helm进行部署不直接通过<code>docker run</code>运行，因此通过ARG在镜像构建时指定</p></blockquote><h3 id="Helm配置文件"><a href="#Helm配置文件" class="headerlink" title="Helm配置文件"></a>Helm配置文件</h3><p>Helm是Kubernetes的包管理工具，将应用部署相关的Deployment，Service，Ingress等打包进行发布与管理（可以像Docker镜像一样存储于仓库中）。如上图中Helm的配置文件包括：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">helm                                    - chart包的目录名</span><br><span class="line">├── templates                           - k8s配置模版目录</span><br><span class="line">│   ├── deployment.yaml                 - Deployment配置模板，定义如何部署Pod</span><br><span class="line">│   ├── _helpers.tpl                    - 以下划线开头的文件，helm视为公共库定义文件，用于定义通用的子模版、函数、变量等</span><br><span class="line">│   ├── ingress.yaml                    - Ingress配置模板，定义外部如何访问Pod提供的服务，类似于Nginx的域名路径配置</span><br><span class="line">│   ├── NOTES.txt                       - chart包的帮助信息文件，执行helm install命令成功后会输出这个文件的内容</span><br><span class="line">│   └── service.yaml                    - Service配置模板，配置访问Pod的服务抽象，有NodePort与ClusterIp等</span><br><span class="line">|── values.yaml                         - chart包的参数配置文件，各模版文件可以引用这里的参数</span><br><span class="line">├── Chart.yaml                          - chart定义，可以定义chart的名字，版本号等信息</span><br><span class="line">├── charts                              - 依赖的子包目录，里面可以包含多个依赖的chart包，一般不存在依赖，我这里将其删除了</span><br></pre></td></tr></table></figure><p>我们可以在Chart.yaml中定义每个项目的chart名称（类似安装包名），如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v2</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">your-chart-name</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">Helm</span> <span class="string">chart</span> <span class="string">for</span> <span class="string">Kubernetes</span></span><br><span class="line"></span><br><span class="line"><span class="attr">type:</span> <span class="string">application</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="number">1.16</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>在values.yaml中定义模板文件中需要用到的变量，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#部署Pod的副本数，即运行多少个容器</span></span><br><span class="line"><span class="attr">replicaCount:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#容器镜像配置</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/demo/demo</span></span><br><span class="line">  <span class="attr">pullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="comment"># Overrides the image tag whose default is the chart version.</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">"dev"</span></span><br><span class="line"><span class="comment">#镜像仓库访问凭证</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun-registry-secret</span></span><br><span class="line"><span class="comment">#覆盖启动容器名称</span></span><br><span class="line"><span class="attr">nameOverride:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">fullnameOverride:</span> <span class="string">""</span></span><br><span class="line"><span class="comment">#容器的端口暴露及环境变量配置</span></span><br><span class="line"><span class="attr">container:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">  <span class="attr">env:</span> <span class="string">[]</span></span><br><span class="line"><span class="comment">#ServiceAccount，默认不创建</span></span><br><span class="line"><span class="attr">serviceAccount:</span></span><br><span class="line">  <span class="comment"># Specifies whether a service account should be created</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Annotations to add to the service account</span></span><br><span class="line">  <span class="attr">annotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="attr">podAnnotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">podSecurityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># fsGroup: 2000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">securityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># capabilities:</span></span><br><span class="line">  <span class="comment">#   drop:</span></span><br><span class="line">  <span class="comment">#   - ALL</span></span><br><span class="line">  <span class="comment"># readOnlyRootFilesystem: true</span></span><br><span class="line">  <span class="comment"># runAsNonRoot: true</span></span><br><span class="line">  <span class="comment"># runAsUser: 1000</span></span><br><span class="line"><span class="comment">#使用NodePort的service，默认为ClusterIp</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="comment">#外部访问Ingress配置，需要配置hosts部分</span></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">annotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">    <span class="comment"># kubernetes.io/ingress.class: nginx</span></span><br><span class="line">    <span class="comment"># kubernetes.io/tls-acme: "true"</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">demo.com</span></span><br><span class="line">      <span class="attr">paths:</span> <span class="string">["/demo"]</span></span><br><span class="line">  <span class="attr">tls:</span> <span class="string">[]</span></span><br><span class="line">  <span class="comment">#  - secretName: chart-example-tls</span></span><br><span class="line">  <span class="comment">#    hosts:</span></span><br><span class="line">  <span class="comment">#      - chart-example.local</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#.... 省略了其它默认参数配置</span></span><br></pre></td></tr></table></figure><p>这里在默认生成的基础上添加了container部分，可以在这里指定容器的端口号而不用去改模板文件（让模板文件在各个项目通用，通常不需要做更改），同时添加env的配置，可以在helm部署时往容器里传入环境变量。将Service type从默认的ClusterIp改为了NodePort。部署同类型的不同项目时，只需要根据项目情况配置Chart.yaml与values.yaml两个文件的少量配置项，templates目录下的模板文件可直接复用。</p><p>部署时需要在K8s环境中从Docker镜像仓库拉取镜像，因此需要在K8s中创建镜像仓库访问凭证（imagePullSecrets）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录Docker Registry生成/root/.docker/config.json文件</span></span><br><span class="line">sudo docker login --username=your-username registry.cn-shenzhen.aliyuncs.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建namespace develop（我这里是根据项目的环境分支名称建立namespace）</span></span><br><span class="line">kubectl create namespace develop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在namespace develop中创建一个secret</span></span><br><span class="line">kubectl create secret generic aliyun-registry-secret --from-file=.dockerconfigjson=/root/.docker/config.json  --type=kubernetes.io/dockerconfigjson --namespace=develop</span><br></pre></td></tr></table></figure><h3 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h3><p>Jenkinsfile是Jenkins pipeline配置文件，遵循Groovy语法，对于Spring Boot项目的构建部署， 编写Jenkinsfile脚本文件如下，</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">image_tag = <span class="string">"default"</span>  <span class="comment">//定一个全局变量，存储Docker镜像的tag（版本）</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        GIT_REPO = <span class="string">"$&#123;env.gitlabSourceRepoName&#125;"</span>  <span class="comment">//从Jenkins Gitlab插件中获取Git项目的名称</span></span><br><span class="line">        GIT_BRANCH = <span class="string">"$&#123;env.gitlabTargetBranch&#125;"</span>  <span class="comment">//项目的分支</span></span><br><span class="line">        GIT_TAG = sh(<span class="string">returnStdout:</span> <span class="literal">true</span>,<span class="string">script:</span> <span class="string">'git describe --tags --always'</span>).trim()  <span class="comment">//commit id或tag名称</span></span><br><span class="line">        DOCKER_REGISTER_CREDS = credentials(<span class="string">'aliyun-docker-repo-creds'</span>) <span class="comment">//docker registry凭证</span></span><br><span class="line">        KUBE_CONFIG_LOCAL = credentials(<span class="string">'local-k8s-kube-config'</span>)  <span class="comment">//开发测试环境的kube凭证</span></span><br><span class="line">        KUBE_CONFIG_PROD = <span class="string">""</span> <span class="comment">//credentials('prod-k8s-kube-config') //生产环境的kube凭证</span></span><br><span class="line"></span><br><span class="line">        DOCKER_REGISTRY = <span class="string">"registry.cn-hangzhou.aliyuncs.com"</span> <span class="comment">//Docker仓库地址</span></span><br><span class="line">        DOCKER_NAMESPACE = <span class="string">"your-namespace"</span>  <span class="comment">//命名空间</span></span><br><span class="line">        DOCKER_IMAGE = <span class="string">"$&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_NAMESPACE&#125;/$&#123;GIT_REPO&#125;"</span> <span class="comment">//Docker镜像地址</span></span><br><span class="line"></span><br><span class="line">        INGRESS_HOST_DEV = <span class="string">"dev.your-site.com"</span>    <span class="comment">//开发环境的域名</span></span><br><span class="line">        INGRESS_HOST_TEST = <span class="string">"test.your-site.com"</span>  <span class="comment">//测试环境的域名</span></span><br><span class="line">        INGRESS_HOST_PROD = <span class="string">"prod.your-site.com"</span>  <span class="comment">//生产环境的域名</span></span><br><span class="line">    &#125;</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'ingress_path'</span>, <span class="string">defaultValue:</span> <span class="string">'/your-path'</span>, <span class="string">description:</span> <span class="string">'服务上下文路径'</span>)</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'replica_count'</span>, <span class="string">defaultValue:</span> <span class="string">'1'</span>, <span class="string">description:</span> <span class="string">'容器副本数量'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Code Analyze'</span>) &#123;</span><br><span class="line">            agent any</span><br><span class="line">            steps &#123;</span><br><span class="line">               echo <span class="string">"1. 代码静态检查"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Maven Build'</span>) &#123;</span><br><span class="line">            agent &#123;</span><br><span class="line">                docker &#123;</span><br><span class="line">                    image <span class="string">'maven:3-jdk-8-alpine'</span></span><br><span class="line">                    args <span class="string">'-v $HOME/.m2:/root/.m2'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"2. 代码编译打包"</span></span><br><span class="line">                sh <span class="string">'mvn clean package -Dfile.encoding=UTF-8 -DskipTests=true'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Docker Build'</span>) &#123;</span><br><span class="line">            agent any</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"3. 构建Docker镜像"</span></span><br><span class="line">                echo <span class="string">"镜像地址： $&#123;DOCKER_IMAGE&#125;"</span></span><br><span class="line">                <span class="comment">//登录Docker仓库</span></span><br><span class="line">                sh <span class="string">"sudo docker login -u $&#123;DOCKER_REGISTER_CREDS_USR&#125; -p $&#123;DOCKER_REGISTER_CREDS_PSW&#125; $&#123;DOCKER_REGISTRY&#125;"</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> profile = <span class="string">"dev"</span></span><br><span class="line">                    <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"develop"</span>) &#123;</span><br><span class="line">                        image_tag = <span class="string">"dev."</span> + env.GIT_TAG</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"pre-release"</span>) &#123;</span><br><span class="line">                        image_tag = <span class="string">"test."</span> + env.GIT_TAG</span><br><span class="line">                        profile = <span class="string">"test"</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"master"</span>)&#123;</span><br><span class="line">                        <span class="comment">// master分支则直接使用Tag</span></span><br><span class="line">                        image_tag = env.GIT_TAG</span><br><span class="line">                        profile = <span class="string">"prod"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//通过--build-arg将profile进行设置，以区分不同环境进行镜像构建</span></span><br><span class="line">                    sh <span class="string">"docker build  --build-arg profile=$&#123;profile&#125; -t $&#123;DOCKER_IMAGE&#125;:$&#123;image_tag&#125; ."</span></span><br><span class="line">                    sh <span class="string">"sudo docker push $&#123;DOCKER_IMAGE&#125;:$&#123;image_tag&#125;"</span></span><br><span class="line">                    sh <span class="string">"docker rmi $&#123;DOCKER_IMAGE&#125;:$&#123;image_tag&#125;"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Helm Deploy'</span>) &#123;</span><br><span class="line">            agent &#123;</span><br><span class="line">                docker &#123;</span><br><span class="line">                    image <span class="string">'lwolf/helm-kubectl-docker'</span></span><br><span class="line">                    args <span class="string">'-u root:root'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"4. 部署到K8s"</span></span><br><span class="line">                sh <span class="string">"mkdir -p /root/.kube"</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> kube_config = env.KUBE_CONFIG_LOCAL</span><br><span class="line">                    <span class="keyword">def</span> ingress_host = env.INGRESS_HOST_DEV</span><br><span class="line">                    <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"pre-release"</span>) &#123;</span><br><span class="line">                        ingress_host = env.INGRESS_HOST_TEST</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env.gitlabTargetBranch == <span class="string">"master"</span>)&#123;</span><br><span class="line">                        ingress_host = env.INGRESS_HOST_PROD</span><br><span class="line">                        kube_config = env.KUBE_CONFIG_PROD</span><br><span class="line">                    &#125;</span><br><span class="line">                    sh <span class="string">"echo $&#123;kube_config&#125; | base64 -d &gt; /root/.kube/config"</span></span><br><span class="line">                    <span class="comment">//根据不同环境将服务部署到不同的namespace下，这里使用分支名称</span></span><br><span class="line">                    sh <span class="string">"helm upgrade -i --namespace=$&#123;env.gitlabTargetBranch&#125; --set replicaCount=$&#123;params.replica_count&#125; --set image.repository=$&#123;DOCKER_IMAGE&#125; --set image.tag=$&#123;image_tag&#125; --set nameOverride=$&#123;GIT_REPO&#125; --set ingress.hosts[0].host=$&#123;ingress_host&#125; --set ingress.hosts[0].paths=&#123;$&#123;params.ingress_path&#125;&#125; $&#123;GIT_REPO&#125; ./helm/"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jenkinsfile定义了整个自动化构建部署的流程：</p><ol><li>Code Analyze，可以使用SonarQube之类的静态代码分析工具完成代码检查，这里先忽略</li><li>Maven Build，启动一个Maven的Docker容器来完成项目的maven构建打包，挂载maven本地仓库目录到宿主机，避免每次都需要重新下载依赖包</li><li>Docker Build，构建Docker镜像，并推送到镜像仓库，不同环境的镜像通过tag区分，开发环境使用dev.commitId的形式，如dev.88f5822，测试环境使用test.commitId，生产环境可以将webhook事件设置为tag push event，直接使用tag名称</li><li>Helm Deploy，使用helm完成新项目的部署，或已有项目的升级，不同环境使用不同的参数配置，如访问域名，K8s集群的访问凭证kube_config等</li></ol><h2 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h2><h3 id="Jenkins任务配置"><a href="#Jenkins任务配置" class="headerlink" title="Jenkins任务配置"></a>Jenkins任务配置</h3><p>在Jenkins中创建一个pipeline的任务，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-pipeline-pro.png" alt="jenkins-pipeline-pro"></p><p>配置构建触发器，将目标分支设置为develop分支，生成一个token，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-pipeline-config1.png" alt="jenkins-pipeline-config1"></p><p>记下这里的“GitLab webhook URL”及token值，在Gitlab配置中使用。</p><p>配置流水线，选择“Pipeline script from SCM”从项目源码中获取pipeline脚本文件，配置项目Git地址，拉取源码凭证等，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-pipeline-config2.png" alt="jenkins-pipeline-config2.png"></p><p>保存即完成了项目开发环境的Jenkins配置。测试环境只需将对应的分支修改为pre-release即可</p><h3 id="Jenkins凭据配置"><a href="#Jenkins凭据配置" class="headerlink" title="Jenkins凭据配置"></a>Jenkins凭据配置</h3><p>在Jenkinsfile文件中，我们使用到了两个访问凭证——Docker Registry凭证与本地K8s的kube凭证，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_REGISTER_CREDS = credentials('aliyun-docker-repo-creds') //docker registry凭证</span><br><span class="line">KUBE_CONFIG_LOCAL = credentials('local-k8s-kube-config')  //开发测试环境的kube凭证</span><br></pre></td></tr></table></figure><p>这两个凭证需要在Jenkins中创建。</p><p>添加Docker Registry登录凭证,在Jenkins 凭据页面，添加一个用户名密码类型的凭据，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-cred.png" alt="jenkins-cred"></p><p><img src="http://blog.jboost.cn/assets/jenkins-cred2.png" alt="jenkins-cred2"></p><p>添加K8s集群的访问凭证，在master节点上将/root/.kube/config文件内容进行base64编码，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base64 /root/.kube/config &gt; kube-config-base64.txt</span><br><span class="line">cat kube-config-base64.txt</span><br></pre></td></tr></table></figure><p>使用编码后的内容在Jenkins中创建一个Secret text类型的凭据，如图</p><p><img src="http://blog.jboost.cn/assets/jenkins-cred3.png" alt="jenkins-cred3"></p><p>在Secret文本框中输入base64编码后的内容。</p><h2 id="Gitlab配置"><a href="#Gitlab配置" class="headerlink" title="Gitlab配置"></a>Gitlab配置</h2><p>在Gitlab项目的 Settings - Integrations 页面配置一个webhook，在URL与Secret Token中填入前面Jenkins触发器部分的“GitLab webhook URL”及token值，选中“Push events”作为触发事件，如图</p><p><img src="http://blog.jboost.cn/assets/gitlab-webhook-config.png" alt="gitlab-webhook-config"></p><p>开发、测试环境选择“Push events”则在开发人员push代码，或merge代码到develop，pre-release分支时，就会触发开发或测试环境的Jenkins pipeline任务完成自动化构建；生产环境选择“Tag push events”，在往master分支push tag时触发自动化构建。如图为pipeline构建视图</p><p><img src="http://blog.jboost.cn/assets/jenkins-build.png" alt="jenkins-build"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍使用Gitlab+Jenkins Pipeline+Docker+Kubernetes+Helm来实现Spring Boot项目的自动化部署，只要稍加修改即可应用于其它基于Spring Boot的项目（具体修改的地方在源码的Readme文件中说明）。</p><p>本文涉及的所有配置文件（包括基于Spring Boot的服务端项目与基于Vue.js的Web项目）可在源码项目中获取（源码地址获取办法：关注公众号“半路雨歌”，首页输入“k8sops”即可）。</p><p>原文地址：<a href="http://blog.jboost.cn/k8s3-cd.html">http://blog.jboost.cn/k8s3-cd.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前面两篇文章，我们已经有了一个“嗷嗷待哺”的K8s集群环境，也对相关的概念与组件有了一个基本了解（前期对概念有个印象即可，因为只有实践了才能对其有深入理解，所谓“纸上得来终觉浅，绝知此事要躬行”），本文从实践角度介绍如何结合我们常用的Gitlab与Jenkins，通过K8s来实现项目的自动化部署，示例将包括基于SpringBoot的服务端项目与基于Vue.js的Web项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
      <category term="helm" scheme="http://blog.jboost.cn/tags/helm/"/>
    
      <category term="jenkins" scheme="http://blog.jboost.cn/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（二）：了解k8s的基本组件与概念</title>
    <link href="http://blog.jboost.cn/k8s2-concept.html"/>
    <id>http://blog.jboost.cn/k8s2-concept.html</id>
    <published>2020-05-06T13:13:53.000Z</published>
    <updated>2020-05-08T03:05:23.443Z</updated>
    
    <content type="html"><![CDATA[<p>前文 <a href="/k8s1-installation.html">Kubernetes笔记（一）：十分钟部署一套K8s环境</a> 介绍了如何快速搭建一个k8s系统。为了继续使用k8s来部署我们的应用，需要先对k8s中的一些基本组件与概念有个了解。</p><a id="more"></a><h2 id="Kubernetes是什么"><a href="#Kubernetes是什么" class="headerlink" title="Kubernetes是什么"></a>Kubernetes是什么</h2><p>Kubernetes是Google于2014年基于其内部Brog系统开源的一个容器编排管理系统，可使用声明式的配置（以yaml文件的形式）自动地执行容器化应用程序的管理，包括部署、伸缩、负载均衡、回滚等。</p><p>kubernetes提供的功能：</p><ul><li>自动发布与伸缩：可以通过声明式的配置文件定义想要部署的容器，Kubernetes将自动进行容器的部署，达到期望的结果；通过指定容器副本数，或者设置根据资源负载情况（如CPU、内存使用率），自动对容器组进行快速的伸缩——增大或缩小容器数量</li><li>滚动升级与灰度发布：采用逐步替换的策略实现滚动升级，使用Kubernetes也可以很轻易地管理系统的灰度发布</li><li>服务发现与负载均衡：Kubernetes通过DNS名称或IP地址暴露容器的访问方式，并且可在同一容器组内实现负载分发与均衡</li><li>存储编排：Kubernetes可以自动挂载指定的存储系统，如local storage/nfs/云存储等</li><li>故障恢复：Kubernetes自动重启已经停机的容器，替换不满足健康检查的容器</li><li>密钥与配置管理：Kubernetes可以存储与管理敏感信息，如Docker Registry的登录凭证，密码，ssh密钥等</li></ul><h2 id="Kubernetes架构"><a href="#Kubernetes架构" class="headerlink" title="Kubernetes架构"></a>Kubernetes架构</h2><p>我们先来看一张Kubernetes的架构图</p><p><img src="/assets/k8s-arch.png" alt="k8s-arch"></p><p>Kubernetes是一套分布式系统， 与大多数分布式系统类似，包含控制节点（master node）与工作节点（worker node）。</p><h3 id="master-node"><a href="#master-node" class="headerlink" title="master node"></a>master node</h3><p>控制节点就是指挥官，负责发号施令的，其上运行一些管理服务来对整个系统进行管理与控制，包括</p><ul><li>apiserver：作为整个系统的对外接口，提供一套Restful API供客户端调用，任何的资源请求/调用操作都是通过kube-apiserver提供的接口进行,如kubectl、kubernetes dashboard等管理工具就是通过apiserver来实现对集群的管理</li><li>kube-scheduler：资源调度器，负责将容器组分配到哪些节点上</li><li>kube-controller-manager：管理控制器，集群中处理常规任务的后台线程，包括节点控制器（负责监听节点停机的事件并作出对应响应）、endpoint-controller（刷新服务与容器组的关联信息）、replication-controller（维护容器组的副本数为指定的数值）、Service Account &amp; Token控制器（负责为新的命名空间创建默认的 Service Account 以及 API Access Token）</li><li>etcd：数据存储，存储集群所有的配置信息</li><li>coredns：实现集群内部通过服务名称进行容器组访问的功能</li></ul><h3 id="worker-node"><a href="#worker-node" class="headerlink" title="worker node"></a>worker node</h3><p>工作节点就是具体干活的小兵，其上也运行一些服务来执行指挥官分派的任务，包括</p><ul><li>kubelet：是工作节点上执行操作的代理程序，负责容器的生命周期管理，定期执行容器健康检查，并上报容器的运行状态</li><li>kube-proxy：是一个具有负载均衡能力的简单的网络访问代理，负责将访问某个服务的请求分配到工作节点的具体某个容器上（kube-proxy也运行于master node上）</li><li>Docker Daemon：这个不难理解，所有服务或容器组都要以Docker容器的形式来运行（但Kubernetes其实不局限于Docker，它支持任何实现了Kubernetes容器引擎接口的容器引擎，如containerd、rktlet）</li></ul><p>另外还有既在master node上也在worker node上运行的网络通信组件 kube-flannel。这些服务组件一般运行在kube-system的命名空间中，如图</p><p><img src="/assets/kube-system.png" alt="kube-system"></p><h2 id="Kubernetes基本概念"><a href="#Kubernetes基本概念" class="headerlink" title="Kubernetes基本概念"></a>Kubernetes基本概念</h2><p>我们再来看第二张图</p><p><img src="/assets/k8s.png" alt="k8s"></p><p>功能组件在上面已经做了介绍。Kubernetes的操作对象主要包括容器组（Pod），服务（Service），副本控制器（replication-controller），及围绕这些的其它辅助对象</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是Kubernetes创建或部署的最小基本单元。一个Pod封装一个或多个应用容器、存储资源、一个独立的网络IP以及管理控制容器运行方式的策略选项。Pod中的每个容器共享网络命名空间（包括IP与端口），Pod内的容器可以使用localhost相互通信。Pod可以指定一组共享存储卷Volumes，Pod中所有容器都可以访问共享的Volumes，Volumes用于数据持久化，防止容器重启丢失数据。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Kubernetes使用Volume来解决Pod中容器重启数据丢失的问题，以及Pod中多个容器间数据共享的问题。Kubernetes支持的Volume类型包括：</p><ul><li>emptyDir：当Pod分配到Node上时，将会创建emptyDir，只要Node上的Pod一直运行，Volume就会一直存在。当Pod（不管任何原因）从Node上被删除时，emptyDir也同时会删除，存储的数据也将永久删除，但删除容器不影响emptyDir</li><li>hostPath：hostPath允许挂载Node上的文件系统到Pod里面去。如果Pod需要使用Node上的文件，可以使用hostPath</li><li>nfs: 使用nfs网络文件系统提供的共享目录</li></ul><h3 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h3><p>ReplicationController确保在任何时候都有按配置的Pod副本数在运行。现在推荐使用配置ReplicaSet（下一代ReplicationController）的Deployment来建立副本管理机制。</p><h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><p>ReplicaSet是下一代ReplicationController，两者的唯一区别是ReplicaSet支持新的基于集合的选择器，而ReplicationController仅支持基于相等选择器的需求。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment为Pod与ReplicaSet提供了声明式的定义，描述你想要的目标状态是什么，Deployment controller就会帮你将Pod与ReplicaSet的实际状态改变到你想要的目标状态。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>一个Service可以看做一组提供相同服务的Pod的对外访问接口。Kubernetes提供两种类型的Service：</p><ul><li>NodePort： 集群外部可以通过Node IP与Node Port来访问具体某个Pod</li><li>ClusterIP：指通过集群的内部IP暴露服务，服务只能够在集群内部可以访问，这也是默认的 ServiceType</li></ul><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Label就是一对key/value，可以附加到各种资源对象上，如Node、Pod、Service等，一个资源对象可以定义任意数量的Label。可以通过Label选择器来选择具备某个（些）Label的资源。</p><h3 id="PV-amp-PVC"><a href="#PV-amp-PVC" class="headerlink" title="PV &amp; PVC"></a>PV &amp; PVC</h3><p>PersistentVolume（PV） 为用户提供了一个存储抽象，由管理员设置，它是集群的一部分。就像节点是集群中的资源一样，PV也是集群中的资源。 PV是Volume之类的卷插件，但具有独立于Pod的生命周期。</p><p>PersistentVolumeClaim（PVC）是用户存储的请求。它与Pod相似。Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源（CPU和内存）。PVC可以请求特定大小和访问模式的存储资源（例如，可以以读/写或只读模式挂载）。</p><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><p>Secret解决了密码、token、密钥等敏感数据的存储问题，Secret的三种类型：</p><ul><li>Service Account ：用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中</li><li>Opaque ：Base64编码格式的Secret，用来存储密码、密钥等</li><li>kubernetes.io/dockerconfigjson ：用来存储docker registry的认证信息</li></ul><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>ConfigMap用来保存key/value对的配置数据，这个数据可以在Pods里使用，或者被用来为像controller一样的系统组件存储配置数据。ConfigMap可以方便的处理不含敏感信息的字符串（敏感信息可使用Secret）。</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace类似于Kubernetes中的虚拟集群，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。比如我们如果开发测试共用一个Kubernetes集群，则可以将开发环境的服务部署到dev的namespace，测试环境的部署到test的namespace。</p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>为集群服务提供外部访问，包括基于Nginx与Traefik两个版本，为服务提供域名绑定访问与路径路由功能。也可以基于Ingress实现服务的灰度发布。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对Kubernetes中涉及的基本组件与概念进行了整理，对其基本构成有了一个大致的理解与印象。下一篇将从一个实践出发，实现一个基于Gitlab+Jenkins+K8s的CI/CD流程，以对涉及的各个组件进行深入了解与学习。</p><hr><p>相关阅读：</p><ul><li><a href="/k8s1-installation.html">Kubernetes笔记（一）：十分钟部署一套K8s环境</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文 &lt;a href=&quot;/k8s1-installation.html&quot;&gt;Kubernetes笔记（一）：十分钟部署一套K8s环境&lt;/a&gt; 介绍了如何快速搭建一个k8s系统。为了继续使用k8s来部署我们的应用，需要先对k8s中的一些基本组件与概念有个了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（一）：十分钟部署一套K8s环境</title>
    <link href="http://blog.jboost.cn/k8s1-installation.html"/>
    <id>http://blog.jboost.cn/k8s1-installation.html</id>
    <published>2020-04-28T00:21:03.000Z</published>
    <updated>2020-05-07T06:38:48.101Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes是Goole开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理 —— 百度百科。</p><p>接触K8s也有半年多了，也基于阿里云平台搭建了包含多级服务、目前运行较为稳定的K8s集群（感兴趣的可参考 <a href="https://mp.weixin.qq.com/s/8s-OUUsZI0UyyyTgruEO1A" target="_blank" rel="noopener">k8s云集群混搭模式，可能帮你节省50%以上的服务成本</a>， <a href="https://mp.weixin.qq.com/s/VuSWn7cWacW6i_MtpvQ5Sw" target="_blank" rel="noopener">k8s云集群混搭模式落地分享</a>），但一直没来得及对其进行系统的学习，本系列文章还像以前Docker系列一样，以笔记的形式进行记录与分享，会包括理论与实践，感兴趣的同学可以关注，一起探索下目前较为流行的容器化及服务编排解决方案。</p><a id="more"></a><p>工欲善其事，必先利其器，本文先介绍如何在本地自行搭建一套k8s集群，并且采用我们前面介绍过的Ansible来提高效率（参考 <a href="https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw" target="_blank" rel="noopener">Ansible简明教程</a>）</p><p>本文所涉及的所有配置文件可在这里找到 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation" target="_blank" rel="noopener">github</a></p><h2 id="一-准备服务器节点"><a href="#一-准备服务器节点" class="headerlink" title="一. 准备服务器节点"></a>一. 准备服务器节点</h2><p>如果还没有服务器，可以参考 <a href="https://mp.weixin.qq.com/s/FVyzPVwwQ85AC4jlVZvF4g" target="_blank" rel="noopener">ubuntu18.04上搭建KVM虚拟机环境超完整过程</a> 创建虚拟服务器。</p><p>服务器节点IP（hostname）：</p><ul><li>192.168.40.111 (kmaster)</li><li>192.168.40.112 (knode1)</li><li>192.168.40.113 (knode2)</li><li>192.168.40.114 (knode3)</li></ul><p>操作系统版本：</p><ul><li><code>cat /etc/redhat-release</code> : CentOS Linux release 7.6.1810 (Core)</li><li><code>uname -a</code> : 3.10.0-957.el7.x86_64</li></ul><h2 id="二-配置Ansible"><a href="#二-配置Ansible" class="headerlink" title="二. 配置Ansible"></a>二. 配置Ansible</h2><p>如果还没有Ansible环境，可以参考 [Ansible简明教程]<a href="https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw</a>) 搭建。</p><p>1.在Ansible服务器上的/etc/hosts文件中添加k8s服务器节点信息(参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/hosts" target="_blank" rel="noopener">hosts</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.40.111 kmaster</span><br><span class="line">192.168.40.112 knode1</span><br><span class="line">192.168.40.113 knode2</span><br><span class="line">192.168.40.114 knode3</span><br></pre></td></tr></table></figure><p>2.在Ansible服务器上的/etc/ansible/hosts文件中添加k8s服务器节点（参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/ansible_hosts" target="_blank" rel="noopener">ansible_hosts</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[k8s-all]</span><br><span class="line">kmaster</span><br><span class="line">knode1</span><br><span class="line">knode2</span><br><span class="line">knode3</span><br><span class="line"></span><br><span class="line">[k8s-master]</span><br><span class="line">kmaster</span><br><span class="line"></span><br><span class="line">[k8s-nodes]</span><br><span class="line">knode1</span><br><span class="line">knode2</span><br><span class="line">knode3</span><br></pre></td></tr></table></figure><h2 id="三-修改k8s集群各节点-etc-hosts（非必须）"><a href="#三-修改k8s集群各节点-etc-hosts（非必须）" class="headerlink" title="三. 修改k8s集群各节点/etc/hosts（非必须）"></a>三. 修改k8s集群各节点/etc/hosts（非必须）</h2><p>修改所有主机/etc/hosts文件，添加IP/主机名映射，方便通过主机名ssh访问</p><p>1.创建playbook文件（参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/set_hosts_playbook.yml" target="_blank" rel="noopener">set_hosts_playbook.yml</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim set_hosts_playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: k8s-all</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: backup /etc/hosts</span><br><span class="line">      shell: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">    - name: copy local hosts file to remote</span><br><span class="line">      copy: src=/etc/hosts dest=/etc/ owner=root group=root mode=0644</span><br></pre></td></tr></table></figure><p>2.执行ansible-playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook set_hosts_playbook.yml</span><br></pre></td></tr></table></figure><h2 id="四-安装Docker"><a href="#四-安装Docker" class="headerlink" title="四. 安装Docker"></a>四. 安装Docker</h2><p>在所有主机上安装Docker</p><p>1.创建playbook文件（参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/install_docker_playbook.yml" target="_blank" rel="noopener">install_docker_playbook.yml</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vim install_docker_playbook.yml</span><br><span class="line">- hosts: k8s-all</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars: </span><br><span class="line">     docker_version: 18.09.2</span><br><span class="line"></span><br><span class="line">  tasks: </span><br><span class="line">     - name: install dependencies</span><br><span class="line">       #shell: yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br><span class="line">       yum: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">       with_items:</span><br><span class="line">          - yum-utils</span><br><span class="line">          - device-mapper-persistent-data</span><br><span class="line">          - lvm2</span><br><span class="line"></span><br><span class="line">     - name: config yum repo</span><br><span class="line">       shell: yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">     - name: install docker</span><br><span class="line">       yum: name=docker-ce-&#123;&#123;docker_version&#125;&#125; state=present</span><br><span class="line"></span><br><span class="line">     - name: start docker</span><br><span class="line">       shell: systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure><p>2.执行ansible-playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook install_docker_playbook.yml</span><br></pre></td></tr></table></figure><h2 id="五-部署k8s-master"><a href="#五-部署k8s-master" class="headerlink" title="五. 部署k8s master"></a>五. 部署k8s master</h2><p>1.开始部署之前，需要做一些初始化处理：关闭防火墙、关闭selinux、禁用swap、配置k8s阿里云yum源等，所有操作放在脚本 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/pre-setup.sh" target="_blank" rel="noopener">pre-setup.sh</a> 中，并在2中playbook中通过script模块执行</p><p>2.创建playbook文件 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/deploy_master_playbook.yml" target="_blank" rel="noopener">deploy_master_playbook.yml</a>，只针对master节点，安装kubectl，kubeadm，kubelet，以及flannel（将kube-flannel.yml文件里镜像地址的quay.io改为quay-mirror.qiniu.com避免超时，参考 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/kube-flannel.yml" target="_blank" rel="noopener">kube-flannel.yml</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vim deploy_master_playbook.yml</span><br><span class="line">- hosts: k8s-master</span><br><span class="line">  remote_user: root：q</span><br><span class="line">  vars:</span><br><span class="line">    kube_version: 1.16.0-0</span><br><span class="line">    k8s_version: v1.16.0</span><br><span class="line">    k8s_master: 192.168.40.111 </span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: prepare env</span><br><span class="line">      script: ./pre-setup.sh      </span><br><span class="line"></span><br><span class="line">    - name: install kubectl,kubeadm,kubelet</span><br><span class="line">      yum: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - kubectl-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">        - kubeadm-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">        - kubelet-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    - name: init k8s</span><br><span class="line">      shell: kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version &#123;&#123;k8s_version&#125;&#125; --apiserver-advertise-address &#123;&#123;k8s_master&#125;&#125;  --pod-network-cidr=10.244.0.0/16 --token-ttl 0</span><br><span class="line">    </span><br><span class="line">    - name: config kube</span><br><span class="line">      shell: mkdir -p $HOME/.kube &amp;&amp; cp -i /etc/kubernetes/admin.conf $HOME/.kube/config &amp;&amp; chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">    </span><br><span class="line">    - name: copy flannel yaml file</span><br><span class="line">      copy: src=./kube-flannel.yml dest=/tmp/ owner=root group=root mode=0644 </span><br><span class="line">    </span><br><span class="line">    - name: install flannel</span><br><span class="line">      shell: kubectl apply -f /tmp/kube-flannel.yml</span><br><span class="line"></span><br><span class="line">    - name: get join command</span><br><span class="line">      shell: kubeadm token create --print-join-command </span><br><span class="line">      register: join_command</span><br><span class="line">    - name: show join command</span><br><span class="line">      debug: var=join_command verbosity=0</span><br></pre></td></tr></table></figure><p>3.执行ansible-playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook deploy_master_playbook.yml</span><br></pre></td></tr></table></figure><p>4.上述命令执行完成会输出节点加入k8s集群的命令，如下图。记下该命令，后面部署node时会用到</p><p><img src="http://blog.jboost.cn/assets/join-command.png" alt="图片"></p><h2 id="六-部署k8s-node"><a href="#六-部署k8s-node" class="headerlink" title="六. 部署k8s node"></a>六. 部署k8s node</h2><p>1.同master一样，开始部署之前，需要做一些初始化处理：关闭防火墙、关闭selinux、禁用swap、配置k8s阿里云yum源等，所有操作放在脚本  <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/pre-setup.sh" target="_blank" rel="noopener">pre-setup.sh</a> 中，并在2中playbook中通过script模块执行</p><p>2.创建playbook文件 <a href="https://github.com/ronwxy/ops/blob/master/k8s/installation/basic/deploy_nodes_playbook.yml" target="_blank" rel="noopener">deploy_nodes_playbook.yml</a>，针对除master外的其它集群节点，安装kubeadm，kubelet，并将节点加入到k8s集群中，使用的是前面部署master时输出的加入集群命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vim deploy_nodes_playbook.yml</span><br><span class="line">- hosts: k8s-nodes</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">     kube_version: 1.16.0-0</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: prepare env</span><br><span class="line">      script: ./pre-setup.sh</span><br><span class="line"></span><br><span class="line">    - name: install kubeadm,kubelet</span><br><span class="line">      yum: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - kubeadm-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">        - kubelet-&#123;&#123;kube_version&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    - name: start kubelt</span><br><span class="line">      shell: systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line">   </span><br><span class="line">    - name: join cluster</span><br><span class="line">      shell: kubeadm join 192.168.40.111:6443 --token zgx3ov.zlq3jh12atw1zh8r --discovery-token-ca-cert-hash sha256:60b7c62687974ec5803e0b69cfc7ccc2c4a8236e59c8e8b8a67f726358863fa7</span><br></pre></td></tr></table></figure><p>3.执行ansible-playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook deploy_nodes_playbook.yml</span><br></pre></td></tr></table></figure><p>4.稍等片刻，即可在master节点上通过<code>kubectl get nodes</code>看到加入到集群中的节点，并且status为Ready状态，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES    AGE     VERSION</span><br><span class="line">kmaster   Ready    master   37m     v1.16.0</span><br><span class="line">knode1    Ready    &lt;none&gt;   7m1s    v1.16.0</span><br><span class="line">knode2    Ready    &lt;none&gt;   7m1s    v1.16.0</span><br><span class="line">knode3    Ready    &lt;none&gt;   4m12s   v1.16.0</span><br></pre></td></tr></table></figure><p>至此，k8s集群基本部署完成。接下来可安装Ingress与Dashboard。</p><h2 id="七-安装Ingress"><a href="#七-安装Ingress" class="headerlink" title="七. 安装Ingress"></a>七. 安装Ingress</h2><p>Ingress为集群内服务提供外网访问，包括基于Nginx与Traefik两个版本，这里使用比较熟悉的Nginx版本。安装Ingress的操作在master节点进行（因为前面在master节点安装并配置了kubectl，也可在其它安装并配置好了kubectl的节点进行）</p><p>1.下载yaml文件（此目录已包含 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/ingress/nginx-ingress.yaml" target="_blank" rel="noopener">nginx-ingress.yaml</a>，并修改了镜像地址，可直接进入第3步） </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O nginx-ingress.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/deploy.yaml</span><br></pre></td></tr></table></figure><p>2.将里面的quay.io修改为quay-mirror.qiniu.com，避免镜像拉取超时。同时在nginx-ingress-controller的Deployment上添加hostNetwork为true及nginx-ingress的标签，以使用宿主机网络与控制Ingress部署的节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim nginx-ingress.yaml</span><br><span class="line">:s/quay.io/quay-mirror.qiniu.com/g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim nginx-ingress.yaml</span><br><span class="line"></span><br><span class="line">    spec:</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      nodeSelector:</span><br><span class="line">        nginx-ingress: "true"</span><br></pre></td></tr></table></figure><p>3.部署Ingress</p><p>首先在knode1节点上打标签nginx-ingress=true，控制Ingress部署到knode1上，保持IP固定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl label node knode1 nginx-ingress=true</span><br><span class="line">node/knode1 labeled</span><br></pre></td></tr></table></figure><p>然后完成nginx-ingress的部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-ingress.yaml</span><br></pre></td></tr></table></figure><p>4.部署完成，稍等片刻等Pod创建完成，可通过如下命令查看ingress相关Pod情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl get pods -n ingress-nginx -o wide</span><br><span class="line">NAME                                        READY   STATUS      RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">ingress-nginx-admission-create-drpg5        0/1     Completed   0          79m   10.244.2.2       knode1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-admission-patch-db2rt         0/1     Completed   1          79m   10.244.3.2       knode3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-controller-575cffb49c-4xm55   1/1     Running     0          79m   192.168.40.112   knode1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><h2 id="八-安装Kubernetes-Dashboard"><a href="#八-安装Kubernetes-Dashboard" class="headerlink" title="八. 安装Kubernetes Dashboard"></a>八. 安装Kubernetes Dashboard</h2><p>1.下载yaml文件（此目录已包含 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/dashboard/kubernetes-dashboard.yaml" target="_blank" rel="noopener">kubernetes-dashboard.yaml</a> 文件，可直接进入第3步）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O kubernetes-dashboard.yaml  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta5/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure><p>2.修改kubernetes-dashboard.yaml</p><p>将Service type改为NodePort，使得可通过IP访问Dashboard。注释掉默认的Secret（默认的secret权限很有限，看不到多少数据）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30443</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure><p>3.部署Dashboard，并创建绑定cluster-admin角色的ServiceAccount —— admin-user (参考 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/dashboard/kubernetes-dashboard-auth.yaml" target="_blank" rel="noopener">auth.yaml</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f kubernetes-dashboard.yaml</span><br><span class="line">kubectl apply -f kubernetes-dashboard-auth.yaml</span><br></pre></td></tr></table></figure><p>4.访问Dashboard</p><p>访问 https://集群任意节点IP:30443，打开Dashboard登录页面，执行如下命令获取登录token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '&#123;print $1&#125;')</span><br></pre></td></tr></table></figure><p>使用token完成登录，如图</p><p><img src="http://blog.jboost.cn/assets/dashboard-login.png" alt="图片"></p><h2 id="九-解决证书无效问题"><a href="#九-解决证书无效问题" class="headerlink" title="九. 解决证书无效问题"></a>九. 解决证书无效问题</h2><p>安装完后，默认的证书可能无效，在Chrome浏览中无法打开Dashboard，可通过重新生成证书解决。</p><p>1.创建自定义证书 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# cd /etc/kubernetes/pki/</span><br><span class="line"><span class="meta">#</span><span class="bash">生成私钥</span></span><br><span class="line">[root@kmaster pki]# openssl genrsa -out dashboard.key 2048</span><br><span class="line"><span class="meta">#</span><span class="bash">生成证书</span></span><br><span class="line">[root@kmaster pki]# openssl req -new -key dashboard.key -out dashboard.csr -subj "/O=JBST/CN=kubernetes-dashboard"</span><br><span class="line"><span class="meta">#</span><span class="bash">使用集群的CA来签署证书</span></span><br><span class="line">[root@kmaster pki]# openssl x509 -req -in dashboard.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out dashboard.crt -days 3650</span><br><span class="line"><span class="meta">#</span><span class="bash">查看自创证书</span></span><br><span class="line">[root@kmaster pki]# openssl x509 -in dashboard.crt -noout -text</span><br></pre></td></tr></table></figure><p>2.注释 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation/dashboard/kubernetes-dashboard.yaml" target="_blank" rel="noopener">kubernetes-dashboard.yaml</a> 中默认的Secret，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#apiVersion: v1</span></span><br><span class="line"><span class="comment">#kind: Secret</span></span><br><span class="line"><span class="comment">#metadata:</span></span><br><span class="line"><span class="comment">#  labels:</span></span><br><span class="line"><span class="comment">#    k8s-app: kubernetes-dashboard</span></span><br><span class="line"><span class="comment">#  name: kubernetes-dashboard-certs</span></span><br><span class="line"><span class="comment">#  namespace: kubernetes-dashboard</span></span><br><span class="line"><span class="comment">#type: Opaque</span></span><br></pre></td></tr></table></figure><p>3.重新部署Dashboard，并通过自定义证书创建新的Secret</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl delete -f kubernetes-dashboard.yaml</span><br><span class="line">[root@kmaster k8s-deploy]# kubectl apply -f kubernetes-dashboard.yaml </span><br><span class="line">[root@kmaster k8s-deploy]# kubectl create secret generic kubernetes-dashboard-certs --from-file=dashboard.crt=/etc/kubernetes/pki/dashboard.crt --from-file=dashboard.key=/etc/kubernetes/pki/dashboard.key  -n kubernetes-dashboard</span><br></pre></td></tr></table></figure><h2 id="十-在本地（win10）管理k8s集群"><a href="#十-在本地（win10）管理k8s集群" class="headerlink" title="十. 在本地（win10）管理k8s集群"></a>十. 在本地（win10）管理k8s集群</h2><p>1.下载kubectl windows版本： <a href="https://storage.googleapis.com/kubernetes-release/release/v1.16.0/bin/windows/amd64/kubectl.exe" target="_blank" rel="noopener">https://storage.googleapis.com/kubernetes-release/release/v1.16.0/bin/windows/amd64/kubectl.exe</a></p><p>2.将kubectl.exe文件所在目录加入系统环境变量的Path中</p><p>3.将master节点上 /etc/kubernetes/admin.conf 的内容拷贝到本地用户目录的 .kube/config 文件中，如 <code>C:\Users\Administrator\.kube\config</code></p><p>4.验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES    AGE     VERSION</span><br><span class="line">kmaster   Ready    master   4d19h   v1.16.0</span><br><span class="line">knode1    Ready    &lt;none&gt;   4d19h   v1.16.0</span><br><span class="line">knode2    Ready    &lt;none&gt;   4d19h   v1.16.0</span><br><span class="line">knode3    Ready    &lt;none&gt;   4d19h   v1.16.0</span><br></pre></td></tr></table></figure><p>本文所涉及的所有配置文件可在这里找到 <a href="https://github.com/ronwxy/ops/tree/master/k8s/installation" target="_blank" rel="noopener">github</a></p><hr><p>相关阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s/8s-OUUsZI0UyyyTgruEO1A" target="_blank" rel="noopener">k8s云集群混搭模式，可能帮你节省50%以上的服务成本</a></li><li><a href="https://mp.weixin.qq.com/s/VuSWn7cWacW6i_MtpvQ5Sw" target="_blank" rel="noopener">k8s云集群混搭模式落地分享</a></li><li><a href="https://mp.weixin.qq.com/s/JIZE1RvN7Yop5dsOHJvStw" target="_blank" rel="noopener">Ansible简明教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes是Goole开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理 —— 百度百科。&lt;/p&gt;
&lt;p&gt;接触K8s也有半年多了，也基于阿里云平台搭建了包含多级服务、目前运行较为稳定的K8s集群（感兴趣的可参考 &lt;a href=&quot;https://mp.weixin.qq.com/s/8s-OUUsZI0UyyyTgruEO1A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;k8s云集群混搭模式，可能帮你节省50%以上的服务成本&lt;/a&gt;， &lt;a href=&quot;https://mp.weixin.qq.com/s/VuSWn7cWacW6i_MtpvQ5Sw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;k8s云集群混搭模式落地分享&lt;/a&gt;），但一直没来得及对其进行系统的学习，本系列文章还像以前Docker系列一样，以笔记的形式进行记录与分享，会包括理论与实践，感兴趣的同学可以关注，一起探索下目前较为流行的容器化及服务编排解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
      <category term="ansible" scheme="http://blog.jboost.cn/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Ansible简明教程</title>
    <link href="http://blog.jboost.cn/ansible.html"/>
    <id>http://blog.jboost.cn/ansible.html</id>
    <published>2020-04-17T00:39:52.000Z</published>
    <updated>2020-04-18T06:28:32.952Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible是当下比较流行的自动化运维工具，可通过SSH协议对远程服务器进行集中化的配置管理、应用部署等，常结合Jenkins来实现自动化部署。</p><a id="more"></a><p>除了Ansible，还有像SaltStack、Fabric（曾经管理100多台服务器上的应用时也曾受益于它）、Puppet等自动化工具。相比之下，Ansible最大的优势就是无需在被管理主机端部署任何客户端代理程序，通过SSH通道就可以进行远程命令的执行或配置的下发，足够轻量级，但同时功能非常强大，且各项功能通过模块来实现，具备良好的扩展性。不足之处是Ansible只支持在Linux系统上安装，不支持Windows。</p><p>如果你需要在多于一台服务器上做相同的操作，那么建议你使用Ansible之类的自动化工具，这将极大提高你的操作效率。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>1.找一台主机用于做管理服务器，在其上安装Ansible</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ansible</span><br></pre></td></tr></table></figure><p>Ansible基于Python实现，一般Linux系统都自带Python，所以可以直接使用yum安装或pip安装。</p><p>安装完后，在/etc/ansible/目录下生成三个主要的文件或目录，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# ll /etc/ansible/</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r--. 1 root root 19179 Jan 30  2018 ansible.cfg</span><br><span class="line">-rw-r--r--. 1 root root  1136 Apr 17 15:17 hosts</span><br><span class="line">drwxr-xr-x. 2 root root     6 Jan 30  2018 roles</span><br></pre></td></tr></table></figure><ul><li>ansible.cfg： Ansible的配置文件</li><li>hosts：登记被管理的主机</li><li>roles：角色项目定义目录，主要用于代码复用</li></ul><p>2.在/etc/ansible/hosts文件中添加需要被管理的服务器节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# vim /etc/ansible/hosts</span><br><span class="line">[k8s]</span><br><span class="line">192.168.40.201</span><br><span class="line">192.168.40.202</span><br><span class="line">192.168.40.205</span><br><span class="line">192.168.40.206</span><br></pre></td></tr></table></figure><p><code>[k8s]</code>表示将下面的服务器节点分到k8s的组中，后面执行命令时可指定针对某个组执行。</p><p>3.生成SSH KEY，并copy到被管理节点上，实现免密SSH访问</p><p>在管理节点执行 <code>ssh-keygen</code> 生成SSH KEY，然后copy到各被管理节点上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.40.201</span><br></pre></td></tr></table></figure><p>上面命令将<code>~/.ssh/id_rsa.pub</code>文件内容添加到被管理节点的/root/.ssh/authorized_keys文件中，实现管理节点到被管理节点的免密SSH访问。</p><p>4.调试Ansible</p><p>针对k8s服务器组执行ping，验证Ansible到各被管理节点的连通性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# ansible k8s -m ping</span><br><span class="line">192.168.40.201 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.40.205 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.40.202 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.40.206 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ansible只需要在管理主机上安装，然后打通管理主机到各被管理主机的SSH免密访问即可进行集中化的管理控制，不需在被管理主机安装任何代理程序。</p><h2 id="Ansible命令"><a href="#Ansible命令" class="headerlink" title="Ansible命令"></a>Ansible命令</h2><p>Ansible的命令格式为， <code>ansible 主机群组名 -m 命令模块名 -a &quot;批量执行的操作&quot;</code></p><p>其中-m不是必须的，默认为command模块，-a也不是必须的，表示命令模块的参数，比如前面的ping模块就没有参数。</p><p>可以使用 <code>ansible-doc -l</code> 列出所有可用的命令模块， <code>ansible-doc -s 模块名</code> 查看指定模块的参数信息</p><p>常用命令模块</p><p>1.command<br>command是Ansible的默认模块，不指定-m参数时默认使用command。command可以运行远程主机权限范围内的所有shell命令，但不支持管道操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看k8s分组主机内存使用情况</span></span><br><span class="line">ansible k8s -m command -a "free -g"</span><br></pre></td></tr></table></figure><p>2.shell<br>shell基本与command相同，但shell支持管道操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">shell支持管道操作 |grep Mem</span></span><br><span class="line">ansible k8s -m shell -a "free -g|grep Mem"</span><br></pre></td></tr></table></figure><p>3.script<br>script就是在远程主机上执行管理端存储的shell脚本文件，相当于scp+shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /root/echo.sh为管理端本地shell脚本</span></span><br><span class="line">ansible k8s -m script -a "/root/echo.sh"</span><br></pre></td></tr></table></figure><p>4.copy<br>copy实现管理端到远程主机的文件拷贝，相当于scp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拷贝本地echo.sh文件到k8s组中远程主机的/tmp目录下，所属用户、组为 root ，权限为 0755</span></span><br><span class="line">ansible k8s -m copy -a "src=/root/echo.sh dest=/tmp/ owner=root group=root mode=0755"</span><br></pre></td></tr></table></figure><p>5.yum<br>软件包安装或删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m yum -a "name=wget state=latest"</span><br></pre></td></tr></table></figure><p>其中state有如下取值：</p><ul><li>针对安装，可取值“present，installed，latest”，present，installed即普通安装，两者无区别，latest是使用yum mirror上最新的版本进行安装</li><li>针对删除，可取值“absent，removed”，两者无差别</li></ul><p>6.service<br>对远程主机的服务进行管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m service -a "name=nginx state=stoped"</span><br></pre></td></tr></table></figure><p>state可取值“started/stopped/restarted/reloaded”。</p><p>7.get_url<br>在远程主机上下载指定URL到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m get_url -a "url=http://www.baidu.com dest=/tmp/index.html mode=0440 force=yes"</span><br></pre></td></tr></table></figure><p>8.setup<br>获取远程主机的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m setup</span><br></pre></td></tr></table></figure><p>9.file<br>管理远程主机的文件或目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m file -a "dest=/opt/test state=touch"</span><br></pre></td></tr></table></figure><p>state可取值</p><ul><li>directory：创建目录</li><li>file：如果文件不存在，则创建</li><li>link：创建symbolic link</li><li>absent：删除文件或目录</li><li>touch： 创建一个不存在的空文件</li></ul><p>10.cron<br>管理远程主机的crontab定时任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m cron -a "name='backup servcie' minute=*/5 job='/usr/sbin/ntpdate  time.nist.gov &gt;/dev/null 2&gt;&amp;1'"</span><br></pre></td></tr></table></figure><p>支持的参数</p><ul><li>state： 取值present表示创建定时任务，absent表示删除定时任务</li><li>disabled： yes表示注释掉定时任务，no表示接触注释</li></ul><h2 id="Ansible-playbook"><a href="#Ansible-playbook" class="headerlink" title="Ansible playbook"></a>Ansible playbook</h2><p>Ansible的playbook由一个或多个play组成，play的功能就是为归为一组的主机编排要执行的一系列task，其中每一个task就是调用Ansible的一个命令模块。</p><p>playbook的核心元素包括：</p><ul><li>hosts：执行任务的远程主机组或列表</li><li>tasks：要执行的任务列表</li><li>variables：内置变量或自定义的变量</li><li>templates：使用模板语法的文件，通常为配置文件</li><li>handlers：和notify结合使用，由特定条件触发，一般用于配置文件变更触发服务重启</li><li>tags：标签，可在运行时通过标签指定运行playbook中的部分任务</li><li>roles：</li></ul><p>playbook文件遵循yaml的语法格式，运行命令的格式为 <code>ansible-playbook &lt;filename.yml&gt; ... [options]</code>， 常用options包括</p><ul><li>–syntax        检查playbook文件语法是否正确</li><li>–check 或 -C   只检测可能会发生的改变，但不真正执行操作</li><li>–list-hosts    列出运行任务的主机</li><li>–list-tags     列出playbook文件中定义所有的tags</li><li>–list-tasks    列出playbook文件中定义的所有任务集</li><li>–limit         只针对主机列表中的某个主机或者某个组执行</li><li>-f              指定并发数，默认为5个</li><li>-t              指定某个或多个tags运行（前提playbook中有定义tags）</li><li>-v              显示过程 -vv -vvv更详细</li></ul><p>下面以批量安装Nginx为例，尽可能介绍playbook各核心元素的用法。</p><p>定义palybook yaml文件nginx_playbook.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">,192.168.40.205</span> <span class="comment"># 主机列表，也可以是/etc/ansible/hosts中定义的主机分组名</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> <span class="comment"># 远程用户</span></span><br><span class="line">  <span class="attr">vars:</span>             <span class="comment"># 自定义变量</span></span><br><span class="line">     <span class="attr">version:</span> <span class="number">1.16</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">vars_files:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./templates/nginx_locations_vars.yml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">dependencies</span>          <span class="comment"># 定义任务的名称</span></span><br><span class="line">       <span class="attr">yum:</span> <span class="string">name=&#123;&#123;item&#125;&#125;</span> <span class="string">state=installed</span>  <span class="comment"># 调用模块，具体要做的事情，这里使用with_items迭代多个yum任务安装必要的依赖</span></span><br><span class="line">       <span class="attr">with_items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">gcc</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">gcc-c++</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pcre</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pcre-devel</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">zlib</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">zlib-devel</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">openssl</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">openssl-devel</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">download</span> <span class="string">nginx</span>                <span class="comment"># 通过get_url模块下载nginx</span></span><br><span class="line">       <span class="attr">get_url:</span> <span class="string">url=http://nginx.org/download/nginx-&#123;&#123;version&#125;&#125;.tar.gz</span> <span class="string">dest=/tmp/</span> <span class="string">mode=0755</span> <span class="string">force=no</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">unarchive</span>                     <span class="comment"># 通过unarchive模块解压nginx</span></span><br><span class="line">       <span class="attr">unarchive:</span> <span class="string">src=/tmp/nginx-&#123;&#123;version&#125;&#125;.tar.gz</span> <span class="string">dest=/tmp/</span> <span class="string">mode=0755</span> <span class="string">copy=no</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">configure,make</span> <span class="string">and</span> <span class="string">install</span>    <span class="comment"># 通过shell模块执行shell命令编译安装</span></span><br><span class="line">       <span class="attr">shell:</span> <span class="string">cd</span> <span class="string">/tmp/nginx-&#123;&#123;version&#125;&#125;</span> <span class="string">&amp;&amp;</span> <span class="string">./configure</span> <span class="string">--prefix=/usr/local/nginx</span> <span class="string">&amp;&amp;</span> <span class="string">make</span> <span class="string">&amp;&amp;</span> <span class="string">make</span> <span class="string">install</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span> <span class="string">nginx</span>                   <span class="comment"># 通过shell模块执行shell命令启动nginx</span></span><br><span class="line">       <span class="attr">shell:</span> <span class="string">/usr/local/nginx/sbin/nginx</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">update</span> <span class="string">config</span>                 <span class="comment"># 通过template模块动态生成配置文件下发到远程主机目录</span></span><br><span class="line">       <span class="attr">template:</span> <span class="string">src=nginx.conf.j2</span> <span class="string">dest=/usr/local/nginx/conf/nginx.conf</span></span><br><span class="line">       <span class="attr">notify:</span> <span class="string">reload</span> <span class="string">nginx</span>                <span class="comment"># 在结束时触发一个操作，具体操作通过handlers来定义</span></span><br><span class="line">       <span class="attr">tags:</span> <span class="string">reload</span>                        <span class="comment"># 对任务定义一个标签，运行时通过-t执行带指定标签的任务</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">reload</span> <span class="string">nginx</span>                  <span class="comment"># 与notify定义的内容对应</span></span><br><span class="line">       <span class="attr">shell:</span> <span class="string">/usr/local/nginx/sbin/nginx</span> <span class="string">-s</span> <span class="string">reload</span></span><br></pre></td></tr></table></figure><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><p>在上面的示例中使用vars定义了变量version，在tasks中通过进行引用。Ansible支持如下几种定义变量的方式</p><p>1.在playbook文件中定义<br>前面示例已经说明</p><p>2.命令行指定<br>在执行playbook时通过-e指定，如<code>ansible-playbook -e &quot;version=1.17.9&quot; nginx_playbook.yml</code>， 这里指定的变量将覆盖playbook中定义的同名变量的值</p><p>3.hosts文件中定义变量<br>在/etc/ansible/hosts文件中也可以定义针对单个主机或主机组的变量，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">192.168.40.201 version=1.17.9 # 定义单个主机的变量</span><br><span class="line">192.168.40.205 </span><br><span class="line">[nginx:vars]  # 定义整个组的统一变量</span><br><span class="line">version=1.16.1</span><br></pre></td></tr></table></figure><p>4.在独立的yaml文件中定义变量<br>专门定义一个yaml变量文件，然后在playbook文件中通过var_files引用，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义存放变量的文件</span></span><br><span class="line">[root@ansible ]# cat var.yml</span><br><span class="line">version: 1.16.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写playbook</span></span><br><span class="line">[root@ansible ]# cat nginx_playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: nginx</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars_files:     # 引用变量文件</span><br><span class="line">    - ./var.yml   # 指定变量文件的path（这里可以是绝对路径，也可以是相对路径）</span><br></pre></td></tr></table></figure><p>5.使用setup模块获取到的变量<br>前面介绍setup模块可获取远程主机的信息，可在playbook中直接引用setup模块获取到的属性，比如系统版本： ansible_distribution_major_version</p><h3 id="2-模板"><a href="#2-模板" class="headerlink" title="2. 模板"></a>2. 模板</h3><p>playbook模板为我们提供了动态的配置服务，使用jinja2语言，支持多种条件判断、循环、逻辑运算、比较操作等。应用场景就是定义一个模板配置文件，然后在执行的时候动态生成最终的配置文件下发到远程主机。一般将模板文件放在playbook文件同级的templates目录下，这样在playbook文件中可以直接引用，否则需要通过绝对路径指定，模板文件后缀名一般为 .j2。</p><p>本例中，我们将nginx.conf配置文件作为模板文件，添加需要动态配置的内容，并定义一个变量文件，通过vars_files引入：<code>vars_files: ./templates/nginx_locations_vars.yml</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 模板文件</span></span><br><span class="line">[root@tool-server nginx-deploy]# vim templates/nginx.conf.j2</span><br><span class="line"> ...</span><br><span class="line"> server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        # 这里的内容动态生成</span><br><span class="line">        &#123;% for location in nginx_locations %&#125;</span><br><span class="line">        location &#123;&#123;location.path&#125;&#125; &#123;</span><br><span class="line">           proxy_pass &#123;&#123;location.proxy&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"> ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 独立的自定义变量文件，用于填充模板文件中的变量</span></span><br><span class="line">[root@tool-server nginx-deploy]# vim templates/nginx_locations_vars.yml</span><br><span class="line"></span><br><span class="line">nginx_locations:</span><br><span class="line">  - &#123;"path": "/cns", "proxy": "http://192.168.40.202/cns"&#125;</span><br><span class="line">  - &#123;"path": "/admin", "proxy": "http://192.168.40.202/admin"&#125;</span><br></pre></td></tr></table></figure><h3 id="3-handlers"><a href="#3-handlers" class="headerlink" title="3. handlers"></a>3. handlers</h3><p>handlers和notify结合使用，由特定条件触发，一般用于配置文件变更触发服务重启。在本例中我们在配置文件变更时，通过notify定义了一个“reload nginx”的操作，然后在handlers部分定义“reload nginx”操作——通过shell模块调用nginx的reload来重新加载配置。</p><h3 id="4-标签"><a href="#4-标签" class="headerlink" title="4. 标签"></a>4. 标签</h3><p>playbook文件中，如果只想执行某一个或几个任务，则可以给任务打标签，在运行的时候通过 -t 选择带指定标签的任务执行，也可以通过 –skip-tags 选择不带指定标签的任务执行。比如在本例中，我们在“update config”的task上加了“reload”的标签，如果后面再修改配置，我们只需要执行“update config”的task并触发reload nginx就行了，可以这么执行playbook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server nginx-deploy]# ansible-playbook -t reload nginx_playbook.yml</span><br></pre></td></tr></table></figure><h3 id="5-when"><a href="#5-when" class="headerlink" title="5. when"></a>5. when</h3><p>可以在task上添加when表示当某个条件达到了该任务才执行，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">nginx</span></span><br><span class="line">     <span class="attr">yum:</span> <span class="string">name=nginx</span> <span class="string">state=installed</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">update</span> <span class="string">config</span> <span class="string">for</span> <span class="string">system6</span></span><br><span class="line">     <span class="attr">template:</span> <span class="string">src=nginx.conf.j2</span> <span class="string">dest=/usr/local/nginx/conf/nginx.conf</span></span><br><span class="line">     <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">"6"</span>   <span class="comment"># 判断系统版本，为6才执行上面的template配置的文件</span></span><br></pre></td></tr></table></figure><h3 id="6-roles"><a href="#6-roles" class="headerlink" title="6. roles"></a>6. roles</h3><p>roles就是将变量、文件、任务、模板及处理器放置在单独的目录中，并可以在playbook中include的一种机制，一般用于主机构建服务的场景中，但也可以是用于构建守护进程等场景。</p><p>roles的目录结构，默认的roles目录为/etc/ansible/roles</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">roles:</span>          <span class="comment"># 所有的角色项目必须放在roles目录下</span></span><br><span class="line">  <span class="attr">project:</span>      <span class="comment"># 具体的角色项目名称，比如nginx、tomcat</span></span><br><span class="line">    <span class="string">files：</span>     <span class="comment"># 用来存放由copy或script模块调用的文件</span></span><br><span class="line">    <span class="string">templates：</span> <span class="comment"># 用来存放jinjia2模板，template模块会自动在此目录中寻找jinjia2模板文件</span></span><br><span class="line">    <span class="string">tasks：</span>     <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色的任务列表，此文件可以使用include包含其它的位于此目录的task文件。</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">handlers：</span>  <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色中触发条件时执行的动作</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">vars：</span>      <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色用到的变量</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">defaults：</span>  <span class="comment"># 此目录应当包含一个main.yml文件，用于为当前角色设定默认变量</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">meta：</span>      <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系</span></span><br><span class="line">      <span class="string">main.yml</span></span><br></pre></td></tr></table></figure><p>我们将上面的例子通过roles改造一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# cd /etc/ansible/roles/</span><br><span class="line">[root@tool-server roles]# mkdir -p nginx/&#123;tasks,vars,templates,handlers&#125;</span><br><span class="line">...#创建各目录的mian.yml文件，并将对应的内容加入文件中</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">最终目录结构</span></span><br><span class="line">[root@tool-server roles]# tree  .</span><br><span class="line">.</span><br><span class="line">└── nginx</span><br><span class="line">    ├── handlers</span><br><span class="line">    │   └── main.yml # 上例handlers部分的内容，直接 -name开头，不需要再加 `handlers：`</span><br><span class="line">    ├── tasks</span><br><span class="line">    │   └── main.yml # tasks部分内容，直接-name开头，不需要加tasks，可以将各个task拆分为多个文件，然后在main.yml中通过 `- include: install.yml` 形式的列表引入</span><br><span class="line">    ├── templates</span><br><span class="line">    │   └── main.yml # templates/nginx.conf.j2的内容</span><br><span class="line">    └── vars</span><br><span class="line">        └── main.yml # templates/nginx_locations_vars.yml的内容</span><br><span class="line"></span><br><span class="line">5 directories, 4 files</span><br></pre></td></tr></table></figure><p>最后，在playbook中通过roles引入，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible roles]# vim nginx_playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: nginx</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - role: nginx # 指定角色名称</span><br></pre></td></tr></table></figure><p>roles将playbook的各个部分进行拆分组织，主要用于代码复用度较高的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ansible是功能强大但又很轻量级的自动化运维工具，基于SSH协议批量对远程主机进行管理，不仅可用于日常的服务维护，也可与Jenkins等CI/CD工具结合实现自动化部署。如果你需要在多于一台服务器上做重复又稍显复杂的操作，那么建议你使用Ansible，这将极大提高你的操作效率，并且所有操作文档化，更易维护与迁移。</p><hr><p>如果你对Java、Spring Boot、Spring Cloud、Docker，技术管理心得等感兴趣<br>欢迎关注作者微信公众号：空山新雨的技术空间，一起学习成长  </p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ansible是当下比较流行的自动化运维工具，可通过SSH协议对远程服务器进行集中化的配置管理、应用部署等，常结合Jenkins来实现自动化部署。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="ansible" scheme="http://blog.jboost.cn/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（十三）：容器日志采集实践</title>
    <link href="http://blog.jboost.cn/docker-13.html"/>
    <id>http://blog.jboost.cn/docker-13.html</id>
    <published>2020-04-01T06:08:12.000Z</published>
    <updated>2020-05-06T11:05:40.448Z</updated>
    
    <content type="html"><![CDATA[<p>日志是服务运行过程中的一个关键环节，借助日志，我们可以排查定位问题，也可以借助集中化的日志管理平台（如ELK）来做一些必要的数据统计分析。在Docker环境中，日志的采集比传统环境更为复杂，因此了解Docker日志的管理机制，及基于此熟悉日志采集的最佳实践对于开发运维人员来说也是避不开的一个知识点。那就开始吧。</p><a id="more"></a><h2 id="Docker容器的日志管理机制"><a href="#Docker容器的日志管理机制" class="headerlink" title="Docker容器的日志管理机制"></a>Docker容器的日志管理机制</h2><h3 id="1-Docker-Daemon日志"><a href="#1-Docker-Daemon日志" class="headerlink" title="1. Docker Daemon日志"></a>1. Docker Daemon日志</h3><p>Docker Daemon在Linux中本身作为systemd service启动，因此可以通过 <code>sudo journalctl -u docker</code> 命令来查看Daemon本身的日志。</p><h3 id="2-Docker容器日志"><a href="#2-Docker容器日志" class="headerlink" title="2. Docker容器日志"></a>2. Docker容器日志</h3><p>通过 <code>docker logs container_id|container_name</code> 可以查看Docker容器的输出日志，但这里的日志只包含容器的标准输出（STDOUT）与标准错误输出（STDERR），适用于一些将日志输出到STDOUT的容器,比如Nginx，查看nginx的dockerfile可发现其是将日志文件链接到了STDOUT与STDERR来实现的，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN ln -sf /dev/stdout /var/log/nginx/access.log</span><br><span class="line">&amp;&amp; ln -sf /dev/stderr /var/log/nginx/error.log</span><br></pre></td></tr></table></figure><p>但如果容器内部应用日志是输出到日志文件（比如Spring Boot项目或Tomcat容器，一般将日志输出到日志文件中），则无法通过 <code>docker logs</code> 命令查看。</p><blockquote><p><code>docker logs</code> 会显示历史日志，日志太多的话要等半天才能看到最新日志，同时也对Docker Daemon造成一定的压力，可使用 <code>docker logs --tail 200 container_id</code>来查看最新的N条或使用<code>docker logs -f container_id</code>（类似于tail -f）</p></blockquote><h3 id="3-Docker日志处理机制"><a href="#3-Docker日志处理机制" class="headerlink" title="3. Docker日志处理机制"></a>3. Docker日志处理机制</h3><p>当我们启动一个容器时，其实是作为Docker Daemon的一个子进程运行，Docker Daemon可以拿到容器里进程的标准输出与标准错误输出，然后通过Docker的Log Driver模块来处理。如下图所示</p><p><img src="/assets/docker-log-driver.png" alt="docker-log-driver.png"></p><p>目前支持的Log Drvier包括：</p><ul><li>none：容器没有日志，<code>docker logs</code>不输出任何内容</li><li>local：日志以自定义格式存储</li><li>json-file：日志以json格式存储，默认的Log Driver</li><li>syslog：将日志写入syslog。syslog守护程序必须在主机上运行</li><li>journald：将日志写入journald。journald守护程序必须在主机上运行</li><li>gelf：将日志写入Graylog Extended Log Format端点，如Graylog或Logstash</li><li>fluentd：将日志写入fluentd。fluentd守护程序必须在主机上运行</li><li>awslogs：将日志写入Amazon CloudWatch Logs</li><li>splunk：通过HTTP Event Collector将日志写入splunk</li><li>etwlogs：将日志作为ETW（Event Tracing for Windows）事件写入。只在Windows平台可用</li><li>gcplogs：将日志写入Google Cloud Platform Logging</li><li>logentries：将日志写入Rapid7 Logentries</li></ul><p>使用Docker-CE版本时，<strong><code>docker logs</code>命令仅适用于 local， json-file， journald 三种Log Driver</strong>。</p><p>可通过<code>docker info</code>来查看Docker Daemon（针对所有容器）或<code>docker inspect</code>来查看单个容器所使用的Log Driver</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Docker Daemon</span></span><br><span class="line">[devuser@test-server-1 ~]$ docker  info |grep  "Logging Driver"</span><br><span class="line">Logging Driver: json-file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 单个Docker 容器</span></span><br><span class="line">[devuser@test-server-1 ~]$ docker inspect  -f '&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;'  76f82aa32468</span><br><span class="line">json-file</span><br></pre></td></tr></table></figure><p>修改Docker Daemon使用的Log Driver可通过修改配置文件 /etc/docker/daemon.json 进行，重启Docker后该配置对该Docker Daemon管理的所有容器生效， 如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"log-driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">    <span class="attr">"log-opts"</span>: &#123;</span><br><span class="line">        <span class="attr">"max-size"</span>: <span class="string">"10m"</span>,</span><br><span class="line">        <span class="attr">"max-file"</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置单个容器的Log Driver则可以在容器运行时通过参数指定，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# docker run -d --name nginx -p 80:80 --log-driver local  --log-opt max-size=10m  --log-opt max-file=3  --restart=always nginx</span><br><span class="line">63155291e724276d6154a26958b0e523a003958b1cdf7df9f1f0903bfc989b99</span><br><span class="line"></span><br><span class="line">[root@tool-server ~]# tail -f /var/lib/docker/containers/63155291e724276d6154a26958b0e523a003958b1cdf7df9f1f0903bfc989b99/local-logs/container.log</span><br><span class="line">stdoutҭʡ󹾖ā192.168.40.160 - - [02/Apr/2020:06:05:56 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" "-"ܻ </span><br><span class="line">stdout򪸶¡󹾖㿱92.168.40.160 - - [02/Apr/2020:06:05:56 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://192.168.40.110/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" "-"</span><br></pre></td></tr></table></figure><p>以下对常用的几种Log Driver进行详细介绍</p><ol><li>local</li></ol><p>local Log Driver会将容器的STDOUT/STDERR输出写到宿主机的磁盘。前面示例了将Docker Daemon或单个容器的Log Driver设置为local，可以看到local的日志保存路径为 <code>/var/lib/docker/containers/{container_id}/local-logs/container.log</code></p><p>local Log Driver支持的配置属性如下</p><table><thead><tr><th align="left">配置属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">max-size</td><td align="left">单个日志文件的最大大小，默认为20m（单位可为k,m,g）</td></tr><tr><td align="left">max-file</td><td align="left">最多存在多少个日志文件，文件数超过该值则会删除最旧的文件，默认为5</td></tr><tr><td align="left">compress</td><td align="left">是否对切割文件进行压缩，默认为true</td></tr></tbody></table><ol start="2"><li>json-file</li></ol><p>json-file Log Driver是Docker默认启用的Driver，将容器的STDOUT/STDERR输出以json的格式写到宿主机的磁盘，日志文件路径为 <code>/var/lib/docker/containers/{container_id}/{container_id}-json.log</code></p><p>格式如下，包含三个字段： log, stream, time。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# tail -f /var/lib/docker/containers/2cef9daeac7b009c636ed2b1a7ad8fe3342bc0d5dcd55e69d7a45a586d7abc47/2cef9daeac7b009c636ed2b1a7ad8fe3342bc0d5dcd55e69d7a45a586d7abc47-json.log</span><br><span class="line">&#123;"log":"2020-03-31T10:27:30.639+0000 I  SHARDING [conn4] Marking collection yapi.project as collection version: \u003cunsharded\u003e\n","stream":"stdout","time":"2020-03-31T10:27:30.639749587Z"&#125;</span><br><span class="line">&#123;"log":"2020-03-31T10:27:30.756+0000 I  SHARDING [conn2] Marking collection yapi.log as collection version: \u003cunsharded\u003e\n","stream":"stdout","time":"2020-03-31T10:27:30.756744876Z"&#125;</span><br></pre></td></tr></table></figure><p>json-file将日志的每一行封装到一个json串中，因此像Java的异常栈日志将会被拆分为多条json，在导入到ELK日志管理系统中时需要做合并处理。</p><p>json-file Log Driver支持的配置属性如下</p><table><thead><tr><th align="left">配置属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">max-size</td><td align="left">单个日志文件的最大大小，单位可为k,m,g。默认-1，表示无限制</td></tr><tr><td align="left">max-file</td><td align="left">最多存在多少个日志文件，文件数超过该值则会删除最旧的文件，默认为1</td></tr><tr><td align="left">labels</td><td align="left">在启动Docker容器时以逗号分隔的与日志相关的标签列表</td></tr><tr><td align="left">env</td><td align="left">在启动Docker容器时以逗号分隔的与日志相关的环境变量列表</td></tr><tr><td align="left">env-regex</td><td align="left">类似于env，用于匹配与日志相关的环境变量的正则表达式</td></tr><tr><td align="left">compress</td><td align="left">是否对切割文件进行压缩，默认为disabled</td></tr></tbody></table><ol start="3"><li>journald</li></ol><p>journald Log Driver将容器的STDOUT/STDERR发送到systemd journal，与local，json-file一样可以使用 <code>docker logs</code> 来查看。也可以使用 journalctl命令来查看，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# docker run -d --name nginx -p 80:80 --log-driver journald  --log-opt labels=profile  --log-opt env=ONLINE --label profile=dev --env "ONLINE=false"  --restart=always nginx</span><br><span class="line">2011dc967d7e068b14d974bdc083d072fd09498a7de74984d482897d1b5c4200</span><br><span class="line"></span><br><span class="line">[root@tool-server ~]# journalctl -f CONTAINER_NAME=nginx</span><br><span class="line">-- Logs begin at Tue 2020-03-31 18:24:36 CST. --</span><br><span class="line"></span><br><span class="line">Apr 02 18:20:05 tool-server 2011dc967d7e[3655]: 192.168.40.160 - - [02/Apr/2020:10:20:05 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" "-"</span><br></pre></td></tr></table></figure><p>journalctl的命令形式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">journalctl CONTAINER_NAME=nginx # 输出指定容器的日志</span><br><span class="line">journalctl -b CONTAINER_NAME=nginx # 输出从上次启动以来的所有日志</span><br><span class="line">journalctl -o json CONTAINER_NAME=nginx # 以json格式显示日志，包含了label，env中指定的属性值</span><br><span class="line">journalctl -f CONTAINER_NAME=nginx  # 类似于tail -f</span><br></pre></td></tr></table></figure><p>journald Log Driver支持的配置属性如下</p><table><thead><tr><th align="left">配置属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">tag</td><td align="left">指定要在日志中设置CONTAINER_TAG与SYSLOG_IDENTIFIER值的模板</td></tr><tr><td align="left">labels</td><td align="left">定义一个标签列表，可在后面通过 –label 设置标签的值，该标签值会包含在日志体中</td></tr><tr><td align="left">env</td><td align="left">定义一个环境变量列表，可在后面通过 –env 指定环境变量的值，并且值会包含在日志体重</td></tr><tr><td align="left">env-regex</td><td align="left">与env类似，用于匹配与日志相关的环境变量的正则表达式</td></tr></tbody></table><p>下图是使用 <code>journalctl -o json CONTAINER_NAME=nginx</code> 命令输出的完整json格式日志，其中包含了前面设置的profile标签与ONLINE环境变量。<br><img src="/assets/docker-journald-log.png" alt="docker-journald-log"></p><p>除此之外，journald日志体中还会加上下面的数据</p><ul><li>CONTAINER_ID： 容器ID，12位</li><li>CONTAINER_ID_FULL：完整的容器ID，64位</li><li>CONTAINER_NAME：容器名称</li><li>CONTAINER_TAG，SYSLOG_IDENTIFIER：容器的tag</li></ul><p>具体从上图也可以看出。</p><ol start="4"><li>syslog</li></ol><p>syslog Log Driver将日志发送到syslog的服务器，在Linux中，一般使用rsyslog服务。</p><p>修改rsyslog配置，打开udp或tcp监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# vim /etc/rsyslog.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides UDP syslog reception</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ModLoad imudp</span></span><br><span class="line"><span class="meta">$</span><span class="bash">UDPServerRun 514</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides TCP syslog reception</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ModLoad</span> imtcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$InputTCPServerRun</span> 514</span></span><br></pre></td></tr></table></figure><p>重启rsyslog</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# systemctl restart  rsyslog</span><br><span class="line"></span><br><span class="line">[root@tool-server ~]# netstat -ano|grep 514</span><br><span class="line">udp        0      0 0.0.0.0:514             0.0.0.0:*                           off (0.00/0/0)</span><br><span class="line">udp6       0      0 :::514                  :::*                                off (0.00/0/0)</span><br></pre></td></tr></table></figure><p>以syslog Log Driver启动nginx容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# docker run -d --name nginx -p 80:80 --log-driver syslog --log-opt syslog-address=udp://127.0.0.1:514  --restart=always nginx</span><br><span class="line">989db94a01c36b7ea767bcb8db8ccc64bd558291ef7bcb364efa1352c78b8878</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看syslog日志</span></span><br><span class="line">[root@tool-server ~]# tail -f /var/log/messages</span><br><span class="line">Apr  2 18:58:06 localhost 989db94a01c3[3655]: 192.168.40.160 - - [02/Apr/2020:10:58:06 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36" "-"</span><br></pre></td></tr></table></figure><h2 id="容器日志采集实践"><a href="#容器日志采集实践" class="headerlink" title="容器日志采集实践"></a>容器日志采集实践</h2><ol><li><p>对于使用STDOUT/STDERR输出日志的容器，比如nginx，可通过默认的json-file，从前文提到的目录下通过filebeat或logstash进行监听采集</p></li><li><p>对于使用日志文件记录的容器，比如tomcat，可通过目录挂载的方式将容器日志目录挂载到宿主机目录，然后监听宿主机目录进行日志采集，比如启动时指定参数 <code>-v /data/tomcat/logs:/usr/local/tomcat/logs</code>。但这种方式如果同一应用的容器在一个服务器节点上启动多个时，会造成日志文件名相同产生冲突，对于这种情况，如果使用的是logback日志框架，之前的文章<a href="https://mp.weixin.qq.com/s/ql22PC_PJQ-0SuJyXpf4TQ" target="_blank" rel="noopener">自定义logback日志文件的名称</a> 提供了一种方案</p></li><li><p>如果既有标准输出又有日志文件输出，可考虑第三方日志采集框架，比如阿里巴巴开源的log-pilot</p></li><li><p>如果是Serverless环境，即没有具体的物理机或虚拟机，通过云容器服务部署的情况，则可以通过挂载云盘的方式，将容器日志目录挂载到云盘目录下，通过监听云盘目录进行日志采集</p></li></ol><p>出于篇幅与时间关系，这里只列出几种不同场景的日志采集方案，1,2场景比较好理解，对于4一般云平台都有相关的文档可查阅，场景3后续可再整理一篇实操文来补充说明。</p><hr><p>作者：空山新雨<br>近期作者写了几十篇技术博客，内容包括Java、Spring Boot、Spring Cloud、Docker，技术管理心得等<br>欢迎关注作者微信公众号：空山新雨的技术空间，一起学习成长  </p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志是服务运行过程中的一个关键环节，借助日志，我们可以排查定位问题，也可以借助集中化的日志管理平台（如ELK）来做一些必要的数据统计分析。在Docker环境中，日志的采集比传统环境更为复杂，因此了解Docker日志的管理机制，及基于此熟悉日志采集的最佳实践对于开发运维人员来说也是避不开的一个知识点。那就开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
      <category term="log-pilot" scheme="http://blog.jboost.cn/tags/log-pilot/"/>
    
  </entry>
  
  <entry>
    <title>Linux开机自启动配置</title>
    <link href="http://blog.jboost.cn/linux-autoboot.html"/>
    <id>http://blog.jboost.cn/linux-autoboot.html</id>
    <published>2020-03-24T06:39:09.000Z</published>
    <updated>2020-03-25T07:00:01.980Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候，我们需要将一些服务在Linux系统启动时即自动运行，省得每次都要去手动启动一遍，如Redis， MySQL， Nginx等。本文对CentOS与Ubuntu下开机自启动的配置方法进行整理，供参考查阅。</p><a id="more"></a><h2 id="CentOS7的开机自启动配置"><a href="#CentOS7的开机自启动配置" class="headerlink" title="CentOS7的开机自启动配置"></a>CentOS7的开机自启动配置</h2><h3 id="一-rc-local方式"><a href="#一-rc-local方式" class="headerlink" title="一. rc.local方式"></a>一. rc.local方式</h3><p>rc.local是CentOS以前版本的方式，在CentOS7中仍然以兼容的形式存在，虽仍可用，但不推荐（推荐使用systemd service）。</p><ol><li>编写需要开机自启动的脚本，并添加执行权限</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 ~]# vim test_rclocal.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">time=`date +%F_%T`</span><br><span class="line">echo $time' from rc.local' &gt;&gt; /tmp/test.log</span><br><span class="line"></span><br><span class="line">[root@dev-server-1 ~]# chmod +x test_rclocal.sh</span><br></pre></td></tr></table></figure><p>作为测试，上述脚本打印一个时间到/tmp/test.log文件中</p><ol start="2"><li>在/etc/rc.d/rc.local配置文件中添加脚本运行命令（使用绝对路径）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 ~]# vim /etc/rc.d/rc.local </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...注释部分</span></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line"></span><br><span class="line">/root/test_rclocal.sh &gt;/dev/null 2&gt;/dev/null</span><br></pre></td></tr></table></figure><ol start="3"><li>添加/etc/rc.d/rc.local文件的执行权限</li></ol><p>在centos7中，/etc/rc.d/rc.local没有执行权限，需要手动授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 ~]# chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><p>以上三步，即可使<code>/root/test_rclocal.sh &gt;/dev/null 2&gt;/dev/null</code> 命令在服务器系统启动时自动运行。</p><h3 id="二-chkconfig方式"><a href="#二-chkconfig方式" class="headerlink" title="二. chkconfig方式"></a>二. chkconfig方式</h3><ol><li>编写需要开机自启动的测试脚本，并添加执行权限</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 ~]# vim test_chkconfig.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">time=`date +%F_%T`</span><br><span class="line">echo $time' from chkconfig' &gt;&gt; /tmp/test.log</span><br><span class="line"></span><br><span class="line">[root@dev-server-1 ~]# chmod +x test_chkconfig.sh</span><br></pre></td></tr></table></figure><ol start="2"><li>在/etc/rc.d/init.d/目录下添加一个可执行脚本testchkconfig</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 ~]# vim /etc/rc.d/init.d/testchkconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: 2345 90 10</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: <span class="built_in">test</span> chkconfig</span></span><br><span class="line"></span><br><span class="line">/root/test_chkconfig.sh &gt;/dev/null 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line">[root@dev-server-1 ~]# chmod 755 /etc/rc.d/init.d/testchkconfig</span><br></pre></td></tr></table></figure><p>上述testchkconfig脚本的头部必须遵循一定的格式 <code># chkconfig: 2345 90 10</code>， 其中2345指定服务在哪些执行等级中开启或关闭，90表示启动的优先级（0-100，越大优先级越低），10表示关闭的优先级。执行等级包括</p><ul><li>0：表示关机</li><li>1：单用户模式</li><li>2：无网络连接的多用户命令行模式</li><li>3：有网络连接的多用户命令行模式</li><li>4：保留未使用</li><li>5：带图形界面的多用户模式</li><li>6：重新启动</li></ul><ol start="3"><li>加入开机启动服务列表</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 ~]# chkconfig --add testchkconfig</span><br><span class="line">[root@dev-server-1 ~]# chkconfig --list</span><br><span class="line"></span><br><span class="line">Note: This output shows SysV services only and does not include native</span><br><span class="line">      systemd services. SysV configuration data might be overridden by native</span><br><span class="line">      systemd configuration.</span><br><span class="line"></span><br><span class="line">      If you want to list systemd services use 'systemctl list-unit-files'.</span><br><span class="line">      To see services enabled on particular target use</span><br><span class="line">      'systemctl list-dependencies [target]'.</span><br><span class="line"></span><br><span class="line">netconsole     0:off1:off2:off3:off4:off5:off6:off</span><br><span class="line">network        0:off1:off2:on3:on4:on5:on6:off</span><br><span class="line">testchkconfig  0:off1:off2:on3:on4:on5:on6:off</span><br></pre></td></tr></table></figure><p>使用 <code>chkconfig --list</code> 可查看当前加入开机自启动的服务列表，但如Note部分所述，该命令只显示SysV服务，不包含原生的systemd服务，查看systemd服务可使用<code>systemctl list-unit-files</code>命令。</p><p>以上三步，即可使<code>/root/test_chkconfig.sh &gt;/dev/null 2&gt;/dev/null</code> 命令在服务器系统启动时自动运行。</p><p>chkconfig的其它命令参考</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">chkconfig --list <span class="comment"># 表示查看所有服务在各个运行级别下的状态。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">chkconfig testchkconfig on <span class="comment"># 表示指定服务在所有的运行级别下都是开启状态。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">chkconfig testchkconfig off <span class="comment"># 表示指定服务在所有的运行级别下都是关闭状态。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">chkconfig --level 5 testchkconfig on <span class="comment"># 表示指定服务在运行级别5图形模式的状态下开机启动服务。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">chkconfig --level 5 testchkconfig off <span class="comment"># 表示指定服务在运行级别5图形模式的状态下开机不启动服务。</span></span></span><br></pre></td></tr></table></figure><h3 id="三-自定义systemd-service方式"><a href="#三-自定义systemd-service方式" class="headerlink" title="三. 自定义systemd service方式"></a>三. 自定义systemd service方式</h3><p>CentOS7的systemd服务脚本存放在：/usr/lib/systemd/system（系统级）/usr/lib/systemd/user（用户级）下，以.service结尾。这里以nginx为例</p><ol><li>在/usr/lib/systemd/system目录下创建nginx.service文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[devuser@test-server-1 ~]$ sudo vim /usr/lib/systemd/system/nginx.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 依赖服务，仅当依赖的服务启动之后再启动自定义的服务</span></span><br><span class="line">After=network.target remote-fs.target nss-lookup.target  </span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动类型，包括simple、forking、oneshot、notify、dbus</span></span><br><span class="line">Type=forking</span><br><span class="line"><span class="meta">#</span><span class="bash"> pid文件路径</span></span><br><span class="line">PIDFile=/var/run/nginx.pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动前执行的操作</span></span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动命令</span></span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载命令</span></span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止命令</span></span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否给服务分配独立的临时空间</span></span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务安装的用户模式，一般使用multi-user即可</span></span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>其中Service部分的Type包括如下几种类型：</p><ul><li>simple：表示ExecStart启动的进程是该服务的主进程。如果它需要为其他进程提供服务，那么必须在该服务启动之前先建立好通信渠道，比如套接字，以加快后续单元的启动速度。</li><li>forking：表示ExecStart进程将会在启动时使用fork()函数，这是传统Unix系统的做法，也就是说这个进程将由systemd进程fork出来，然后当该进程都准备就绪时，systemd进程退出，而fork出来的进程作为服务的主进程继续运行，对于此类型的进程，建议设置PIDFile选项，以帮助systemd准确定位该服务的主进程。</li><li>oneshot：该进程会在systemd启动后续单元之前退出，适用于仅需要执行一次的程序。比如清理磁盘，你只需要执行一次，不需要一直在后台运行这个程序。</li><li>notify：与simple类似，不同之处在于该进程会在启动完成之后通过sd_notify之类的接口发送一个通知消息。systemd在启动后续单元之前，必须确保该进程已经成功地发送了一个消息。</li><li>dbus：该进程需要在D-Bus上获得一个由BusName指定的名称，systemd将会在启动后续单元之前，首先确保该进程已经成功获取了指定D-Bus名称。</li></ul><ol start="2"><li>开启开机自启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[devuser@test-server-1 ~]$ sudo systemctl enable nginx.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.</span><br></pre></td></tr></table></figure><p>以上两步，就将nginx服务配置成了在操作系统启动时自动启动。</p><p>其它命令参考</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl start nginx.service <span class="comment"># 启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl restart nginx.service <span class="comment"># 重启</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl reload nginx.service <span class="comment"># 重载</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl stop nginx.service <span class="comment"># 停止</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl status nginx.service <span class="comment"># 查看服务状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl cat nginx.service <span class="comment"># 查看服务配置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">systemctl list-unit-files |grep nginx <span class="comment"># 查看服务enabled状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl <span class="built_in">disable</span> nginx.service <span class="comment"># 关闭开机自启动</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo journalctl -f -u nginx.service <span class="comment"># 查看日志</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl daemon-reload <span class="comment"># 配置修改后，重新加载</span></span></span><br></pre></td></tr></table></figure><blockquote><p>根据以上配置，通过start启动nginx服务时，报<code>PID file /var/run/nginx.pid not readable (yet?) after start.</code>的错误，启动失败，日志如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[devuser@test-server-1 ~]$ sudo journalctl -f -u nginx.service</span><br><span class="line">-- Logs begin at Wed 2020-03-25 09:14:55 CST. --</span><br><span class="line">Mar 25 11:02:27 test-server-1 nginx[14144]: nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br><span class="line">Mar 25 11:02:27 test-server-1 systemd[1]: PID file /run/nginx.pid not readable (yet?) after start.</span><br><span class="line">Mar 25 11:04:29 test-server-1 systemd[1]: nginx.service start operation timed out. Terminating.</span><br><span class="line">Mar 25 11:04:29 test-server-1 systemd[1]: Failed to start nginx.</span><br><span class="line">Mar 25 11:04:29 test-server-1 systemd[1]: Unit nginx.service entered failed state.</span><br><span class="line">Mar 25 11:04:29 test-server-1 systemd[1]: nginx.service failed.</span><br></pre></td></tr></table></figure><p>从字面看是PID文件不可读，查看/var/run/nginx.pid，该文件也确实不存在，查看nginx.conf配置文件，发现是<code>pid /var/run/nginx.pid;</code>这行配置被注释掉了， 如果不指定pid文件位置，nginx默认会把pid文件保存在logs目录中。所以出现systemd启动服务时找不到pid文件而报错，将nginx.conf中的pid配置注释去掉，重启nginx.service即可。</p><h2 id="Ubuntu18-04的开机自启动配置"><a href="#Ubuntu18-04的开机自启动配置" class="headerlink" title="Ubuntu18.04的开机自启动配置"></a>Ubuntu18.04的开机自启动配置</h2><p>在Ubuntu18.04中，主要也是以systemd服务来实现开机自启动，systemd默认读取/etc/systemd/system/下的配置文件，该目录下的一些文件会链接到/lib/systemd/system/下的文件。</p><p>因此可以在/etc/systemd/system/目录下面创建一个自启动服务配置，以内网穿透服务frp客户端为例，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frpc</span><br><span class="line">After=network.target</span><br><span class="line">Wants=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=30</span><br><span class="line">ExecStart=/home/devuser/apps/frp/frpc -c /home/devuser/apps/frp/frpc.ini</span><br><span class="line">ExecStop=/bin/kill $MAINPID</span><br><span class="line">Restart=1</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>各配置项与CentOS类似。然后将服务器加到自启动列表中并启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl <span class="built_in">enable</span> frpc</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo systemctl start frpc</span></span><br></pre></td></tr></table></figure><p>其它更多systemctl命令与CentOS类似。 </p><p>也可以使用/lib/systemd/system/rc-local.service来执行一些开机需要执行的脚本，该文件内容为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  SPDX-License-Identifier: LGPL-2.1+</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  This file is part of systemd.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  systemd is free software; you can redistribute it and/or modify it</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  under the terms of the GNU Lesser General Public License as published by</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  the Free Software Foundation; either version 2.1 of the License, or</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  (at your option) any later version.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This unit gets pulled automatically into multi-user.target by</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemd-rc-local-generator <span class="keyword">if</span> /etc/rc.local is executable.</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.local Compatibility</span><br><span class="line">Documentation=man:systemd-rc-local-generator(8)</span><br><span class="line">ConditionFileIsExecutable=/etc/rc.local</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">GuessMainPID=no</span><br></pre></td></tr></table></figure><p>从Description看它是为了兼容之前版本的/etc/rc.local的，该服务启动命名就是<code>/etc/rc.local start</code>，将该文件链接到/etc/systemd/system下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.service</span></span><br></pre></td></tr></table></figure><p>创建/etc/rc.local文件，并赋予可执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/rc.local</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash  </span></span><br><span class="line">echo "test rc " &gt; /var/test.log  </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod +x /etc/rc.local</span></span><br></pre></td></tr></table></figure><p>&lt;<em>完</em>&gt;</p><p>欢迎关注作者微信公众号：空山新雨的技术空间，查看更多关于Java、Spring Boot、Spring Cloud、Docker等技术实践文章</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多时候，我们需要将一些服务在Linux系统启动时即自动运行，省得每次都要去手动启动一遍，如Redis， MySQL， Nginx等。本文对CentOS与Ubuntu下开机自启动的配置方法进行整理，供参考查阅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="linux" scheme="http://blog.jboost.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot（十三）：整合Redis集群</title>
    <link href="http://blog.jboost.cn/springboot-redis.html"/>
    <id>http://blog.jboost.cn/springboot-redis.html</id>
    <published>2020-03-18T10:05:01.000Z</published>
    <updated>2020-03-21T02:40:17.242Z</updated>
    
    <content type="html"><![CDATA[<p>前面的两篇文章（<a href="http://blog.jboost.cn/redis-persistence.html">Redis的持久化方案</a>， <a href="http://blog.jboost.cn/redis-cluster.html">一文掌握Redis的三种集群方案</a>）分别介绍了Redis的持久化与集群方案 —— 包括主从复制模式、哨兵模式、Cluster模式，其中主从复制模式由于不能自动做故障转移，当节点出现故障时需要人为干预，不满足生产环境的高可用需求，所以在生产环境一般使用哨兵模式或Cluster模式。那么在Spring Boot项目中，如何访问这两种模式的Redis集群，可能遇到哪些问题，是本文即将介绍的内容。</p><a id="more"></a><h2 id="Spring-Boot-2-整合Redis"><a href="#Spring-Boot-2-整合Redis" class="headerlink" title="Spring Boot 2 整合Redis"></a>Spring Boot 2 整合Redis</h2><p>spring boot中整合Redis非常简单，在pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring boot 2的<code>spring-boot-starter-data-redis</code>中，默认使用的是lettuce作为redis客户端，它与jedis的主要区别如下：</p><ol><li>Jedis是同步的，不支持异步，Jedis客户端实例不是线程安全的，需要每个线程一个Jedis实例，所以一般通过连接池来使用Jedis</li><li>Lettuce是基于Netty框架的事件驱动的Redis客户端，其方法调用是异步的，Lettuce的API也是线程安全的，所以多个线程可以操作单个Lettuce连接来完成各种操作，同时Lettuce也支持连接池</li></ol><p>如果不使用默认的lettuce，使用jedis的话，可以排除lettuce的依赖，手动加入jedis依赖，配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在配置文件application.yml中添加配置（针对单实例）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">passw0rd</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># 数据库索引，默认0</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span>  <span class="comment"># 连接超时，单位ms</span></span><br><span class="line">    <span class="attr">jedis:</span>  <span class="comment"># 或lettuce, 连接池配置，springboot2.0中使用jedis或者lettuce配置连接池，默认为lettuce连接池</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span> <span class="comment"># 连接池分配连接最大阻塞等待时间（阻塞时间到，抛出异常。使用负值表示无限期阻塞）</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 连接池中的最大空闲连接数</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 连接池中的最小空闲连接数</span></span><br></pre></td></tr></table></figure><p>然后添加配置类。其中@EnableCaching注解是为了使@Cacheable、@CacheEvict、@CachePut、@Caching注解生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerialize 替换默认的jdkSerializeable序列化</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置类注入了自定义的RedisTemplate&lt;String, Object&gt;， 替换RedisAutoConfiguration中自动配置的RedisTemplate&lt;Object, Object&gt;类（RedisAutoConfiguration另外还自动配置了StringRedisTemplate）。</p><p>此时，我们可以通过定义一个基于RedisTemplate的工具类，或通过在Service层添加@Cacheable、@CacheEvict、@CachePut、@Caching注解来使用缓存。比如定义一个RedisService类，封装常用的Redis操作方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception when expire key &#123;&#125;. "</span>, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception when check key &#123;&#125;. "</span>, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于篇幅，完整代码请查阅本文示例源码： <a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-redis-sentinel" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-redis-sentinel</a></p><p>或在Service层使用注解，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, User&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut</span>(key = <span class="string">"#user.username"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        user.setUid(UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(<span class="string">"add user: "</span> + user);</span><br><span class="line">        userMap.put(user.getUsername(), user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Caching</span>(put = &#123;</span><br><span class="line">            <span class="meta">@CachePut</span>( key = <span class="string">"#user.username"</span>),</span><br><span class="line">            <span class="meta">@CachePut</span>( key = <span class="string">"#user.uid"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">addUser2</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user.setUid(UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(<span class="string">"add user2: "</span> + user);</span><br><span class="line">        userMap.put(user.getUsername(), user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-2-整合Redis哨兵模式"><a href="#Spring-Boot-2-整合Redis哨兵模式" class="headerlink" title="Spring Boot 2 整合Redis哨兵模式"></a>Spring Boot 2 整合Redis哨兵模式</h2><p>Spring Boot 2 整合Redis哨兵模式除了配置稍有差异，其它与整合单实例模式类似，配置示例为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">passw0rd</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">:26379,192.168.40.201:36379,192.168.40.201:46379</span> <span class="comment"># 哨兵的IP:Port列表</span></span><br><span class="line">    <span class="attr">jedis:</span> <span class="comment"># 或lettuce</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>完整示例可查阅源码： <a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-redis-sentinel" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-redis-sentinel</a> </p><p>上述配置只指定了哨兵节点的地址与master的名称，但Redis客户端最终访问操作的是master节点，那么Redis客户端是如何获取master节点的地址，并在发生故障转移时，如何自动切换master地址的呢？我们以Jedis连接池为例，通过源码来揭开其内部实现的神秘面纱。</p><p>在 JedisSentinelPool 类的构造函数中，对连接池做了初始化，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">JedisSentinelPool</span><span class="params">(String masterName, Set&lt;String&gt; sentinels,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> GenericObjectPoolConfig poolConfig, <span class="keyword">final</span> <span class="keyword">int</span> connectionTimeout, <span class="keyword">final</span> <span class="keyword">int</span> soTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String password, <span class="keyword">final</span> <span class="keyword">int</span> database, <span class="keyword">final</span> String clientName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.poolConfig = poolConfig;</span><br><span class="line">    <span class="keyword">this</span>.connectionTimeout = connectionTimeout;</span><br><span class="line">    <span class="keyword">this</span>.soTimeout = soTimeout;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">    <span class="keyword">this</span>.database = database;</span><br><span class="line">    <span class="keyword">this</span>.clientName = clientName;</span><br><span class="line"></span><br><span class="line">    HostAndPort master = initSentinels(sentinels, masterName);</span><br><span class="line">    initPool(master);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> HostAndPort <span class="title">initSentinels</span><span class="params">(Set&lt;String&gt; sentinels, <span class="keyword">final</span> String masterName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String sentinel : sentinels) &#123;</span><br><span class="line">      <span class="keyword">final</span> HostAndPort hap = HostAndPort.parseString(sentinel);</span><br><span class="line"></span><br><span class="line">      log.fine(<span class="string">"Connecting to Sentinel "</span> + hap);</span><br><span class="line"></span><br><span class="line">      Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = <span class="keyword">new</span> Jedis(hap.getHost(), hap.getPort());</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; masterAddr = jedis.sentinelGetMasterAddrByName(masterName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// connected to sentinel...</span></span><br><span class="line">        sentinelAvailable = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (masterAddr == <span class="keyword">null</span> || masterAddr.size() != <span class="number">2</span>) &#123;</span><br><span class="line">          log.warning(<span class="string">"Can not get master addr, master name: "</span> + masterName + <span class="string">". Sentinel: "</span> + hap</span><br><span class="line">              + <span class="string">"."</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        master = toHostAndPort(masterAddr);</span><br><span class="line">        log.fine(<span class="string">"Found Redis master at "</span> + master);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">        <span class="comment">// resolves #1036, it should handle JedisException there's another chance</span></span><br><span class="line">        <span class="comment">// of raising JedisDataException</span></span><br><span class="line">        log.warning(<span class="string">"Cannot get master address from sentinel running @ "</span> + hap + <span class="string">". Reason: "</span> + e</span><br><span class="line">            + <span class="string">". Trying next one."</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">          jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略了非关键代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String sentinel : sentinels) &#123;</span><br><span class="line">      <span class="keyword">final</span> HostAndPort hap = HostAndPort.parseString(sentinel);</span><br><span class="line">      MasterListener masterListener = <span class="keyword">new</span> MasterListener(masterName, hap.getHost(), hap.getPort());</span><br><span class="line">      <span class="comment">// whether MasterListener threads are alive or not, process can be stopped</span></span><br><span class="line">      masterListener.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">      masterListeners.add(masterListener);</span><br><span class="line">      masterListener.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> master;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>initSentinels</code> 方法中主要干了两件事：</p><ol><li>遍历哨兵节点，通过<code>get-master-addr-by-name</code>命令获取master节点的地址信息，找到了就退出循环。<code>get-master-addr-by-name</code>命令执行结果如下所示</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 master-slave]# redis-cli -p 26379</span><br><span class="line">127.0.0.1:26379&gt; sentinel get-master-addr-by-name mymaster</span><br><span class="line">1) "192.168.40.201"</span><br><span class="line">2) "7001"</span><br><span class="line">127.0.0.1:26379&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>对每一个哨兵节点通过一个 MasterListener 进行监听（Redis的发布订阅功能），订阅哨兵节点<code>+switch-master</code>频道，当发生故障转移时，客户端能收到哨兵的通知，通过重新初始化连接池，完成主节点的切换。<br>MasterListener.run方法中监听哨兵部分代码如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">j.subscribe(<span class="keyword">new</span> JedisPubSub() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span><br><span class="line">             log.fine(<span class="string">"Sentinel "</span> + host + <span class="string">":"</span> + port + <span class="string">" published: "</span> + message + <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">             String[] switchMasterMsg = message.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (switchMasterMsg.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (masterName.equals(switchMasterMsg[<span class="number">0</span>])) &#123;</span><br><span class="line">                 initPool(toHostAndPort(Arrays.asList(switchMasterMsg[<span class="number">3</span>], switchMasterMsg[<span class="number">4</span>])));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 log.fine(<span class="string">"Ignoring message on +switch-master for master name "</span></span><br><span class="line">                     + switchMasterMsg[<span class="number">0</span>] + <span class="string">", our master name is "</span> + masterName);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               log.severe(<span class="string">"Invalid message received on Sentinel "</span> + host + <span class="string">":"</span> + port</span><br><span class="line">                   + <span class="string">" on channel +switch-master: "</span> + message);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;, <span class="string">"+switch-master"</span>);</span><br></pre></td></tr></table></figure><p>initPool 方法如下：如果发现新的master节点与当前的master不同，则重新初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">(HostAndPort master)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!master.equals(currentHostMaster)) &#123;</span><br><span class="line">      currentHostMaster = master;</span><br><span class="line">      <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> JedisFactory(master.getHost(), master.getPort(), connectionTimeout,</span><br><span class="line">            soTimeout, password, database, clientName, <span class="keyword">false</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        initPool(poolConfig, factory);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        factory.setHostAndPort(currentHostMaster);</span><br><span class="line">        <span class="comment">// although we clear the pool, we still have to check the</span></span><br><span class="line">        <span class="comment">// returned object</span></span><br><span class="line">        <span class="comment">// in getResource, this call only clears idle instances, not</span></span><br><span class="line">        <span class="comment">// borrowed instances</span></span><br><span class="line">        internalPool.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      log.info(<span class="string">"Created JedisPool to master at "</span> + master);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过以上两步，Jedis客户端在只知道哨兵地址的情况下便能获得master节点的地址信息，并且当发生故障转移时能自动切换到新的master节点地址。</p><h2 id="Spring-Boot-2-整合Redis-Cluster模式"><a href="#Spring-Boot-2-整合Redis-Cluster模式" class="headerlink" title="Spring Boot 2 整合Redis Cluster模式"></a>Spring Boot 2 整合Redis Cluster模式</h2><p>Spring Boot 2 整合Redis Cluster模式除了配置稍有差异，其它与整合单实例模式也类似，配置示例为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">passw0rd</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">:7100,192.168.40.201:7200,192.168.40.201:7300,192.168.40.201:7400,192.168.40.201:7500,192.168.40.201:7600</span></span><br><span class="line">      <span class="attr">max-redirects:</span> <span class="number">3</span>  <span class="comment"># 重定向的最大次数</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>完整示例可查阅源码： <a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-redis-cluster" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-redis-cluster</a> </p><p>在 <a href="http://blog.jboost.cn/redis-cluster.html">一文掌握Redis的三种集群方案</a> 中已经介绍了Cluster模式访问的基本原理，可以通过任意节点跳转到目标节点执行命令，上面配置中 max-redirects 控制在集群中跳转的最大次数。</p><p>查看JedisClusterConnection的execute方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(String command, <span class="keyword">byte</span>[]... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(command, <span class="string">"Command must not be null!"</span>);</span><br><span class="line">    Assert.notNull(args, <span class="string">"Args must not be null!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clusterCommandExecutor</span><br><span class="line">            .executeCommandOnArbitraryNode((JedisClusterCommandCallback&lt;Object&gt;) client -&gt; JedisClientUtils.execute(command,</span><br><span class="line">                    EMPTY_2D_BYTE_ARRAY, args, () -&gt; client))</span><br><span class="line">            .getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群命令的执行是通过<code>ClusterCommandExecutor.executeCommandOnArbitraryNode</code>来实现的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">NodeResult&lt;T&gt; <span class="title">executeCommandOnArbitraryNode</span><span class="params">(ClusterCommandCallback&lt;?, T&gt; cmd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(cmd, <span class="string">"ClusterCommandCallback must not be null!"</span>);</span><br><span class="line">    List&lt;RedisClusterNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;(getClusterTopology().getActiveNodes());</span><br><span class="line">    <span class="keyword">return</span> executeCommandOnSingleNode(cmd, nodes.get(<span class="keyword">new</span> Random().nextInt(nodes.size())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;S, T&gt; <span class="function">NodeResult&lt;T&gt; <span class="title">executeCommandOnSingleNode</span><span class="params">(ClusterCommandCallback&lt;S, T&gt; cmd, RedisClusterNode node,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> redirectCount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(cmd, <span class="string">"ClusterCommandCallback must not be null!"</span>);</span><br><span class="line">    Assert.notNull(node, <span class="string">"RedisClusterNode must not be null!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (redirectCount &gt; maxRedirects) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooManyClusterRedirectionsException(String.format(</span><br><span class="line">                <span class="string">"Cannot follow Cluster Redirects over more than %s legs. Please consider increasing the number of redirects to follow. Current value is: %s."</span>,</span><br><span class="line">                redirectCount, maxRedirects));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RedisClusterNode nodeToUse = lookupNode(node);</span><br><span class="line"></span><br><span class="line">    S client = <span class="keyword">this</span>.resourceProvider.getResourceForSpecificNode(nodeToUse);</span><br><span class="line">    Assert.notNull(client, <span class="string">"Could not acquire resource for node. Is your cluster info up to date?"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NodeResult&lt;&gt;(node, cmd.doInCluster(client));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line"></span><br><span class="line">        RuntimeException translatedException = convertToDataAccessException(ex);</span><br><span class="line">        <span class="keyword">if</span> (translatedException <span class="keyword">instanceof</span> ClusterRedirectException) &#123;</span><br><span class="line">            ClusterRedirectException cre = (ClusterRedirectException) translatedException;</span><br><span class="line">            <span class="keyword">return</span> executeCommandOnSingleNode(cmd,</span><br><span class="line">                    topologyProvider.getTopology().lookup(cre.getTargetHost(), cre.getTargetPort()), redirectCount + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> translatedException != <span class="keyword">null</span> ? translatedException : ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceProvider.returnResourceForSpecificNode(nodeToUse, client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码逻辑如下</p><ol><li>从集群节点列表中随机选择一个节点</li><li>从该节点获取一个客户端连接（如果配置了连接池，从连接池中获取），执行命令</li><li>如果抛出ClusterRedirectException异常，则跳转到返回的目标节点上执行</li><li>如果跳转次数大于配置的值 max-redirects， 则抛出TooManyClusterRedirectionsException异常</li></ol><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><ol><li><p>Redis连接超时<br>检查服务是否正常启动（比如 <code>ps -ef|grep redis</code>查看进程，<code>netstat -ano|grep 6379</code>查看端口是否起来，以及日志文件），如果正常启动，则查看Redis服务器是否开启防火墙，关闭防火墙或配置通行端口。</p></li><li><p>Cluster模式下，报连接到127.0.0.1被拒绝错误，如 <code>Connection refused: no further information: /127.0.0.1:7600</code><br>这是因为在redis.conf中配置 <code>bind 0.0.0.0</code> 或 <code>bind 127.0.0.1</code>导致，需要改为具体在外部可访问的IP，如 <code>bind 192.168.40.201</code>。如果之前已经起了集群，并产生了数据，则修改redis.conf文件后，还需要修改cluster-config-file文件，将127.0.0.1替换为bind 的具体IP，然后重启。</p></li><li><p>master挂了，slave升级成为master，重启master，不能正常同步新的master数据<br>如果设置了密码，需要在master, slave的配置文件中都配置<code>masterauth password</code></p></li></ol><p>相关阅读：</p><ol><li><a href="http://blog.jboost.cn/redis-persistence.html">Redis的持久化方案</a></li><li><a href="http://blog.jboost.cn/redis-cluster.html">一文掌握Redis的三种集群方案</a></li></ol><hr><p>作者：空山新雨<br>近期作者写了几十篇技术博客，内容包括Java、Spring Boot、Spring Cloud、Docker，技术管理心得等<br>欢迎关注作者微信公众号：空山新雨的技术空间，一起学习成长  </p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的两篇文章（&lt;a href=&quot;http://blog.jboost.cn/redis-persistence.html&quot;&gt;Redis的持久化方案&lt;/a&gt;， &lt;a href=&quot;http://blog.jboost.cn/redis-cluster.html&quot;&gt;一文掌握Redis的三种集群方案&lt;/a&gt;）分别介绍了Redis的持久化与集群方案 —— 包括主从复制模式、哨兵模式、Cluster模式，其中主从复制模式由于不能自动做故障转移，当节点出现故障时需要人为干预，不满足生产环境的高可用需求，所以在生产环境一般使用哨兵模式或Cluster模式。那么在Spring Boot项目中，如何访问这两种模式的Redis集群，可能遇到哪些问题，是本文即将介绍的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="redis" scheme="http://blog.jboost.cn/tags/redis/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>一文了解Redis的三种集群方案</title>
    <link href="http://blog.jboost.cn/redis-cluster.html"/>
    <id>http://blog.jboost.cn/redis-cluster.html</id>
    <published>2020-03-12T06:08:10.000Z</published>
    <updated>2020-03-16T01:26:43.589Z</updated>
    
    <content type="html"><![CDATA[<p>在开发测试环境中，我们一般搭建Redis的单实例来应对开发测试需求，但是在生产环境，如果对可用性、可靠性要求较高，则需要引入Redis的集群方案。虽然现在各大云平台有提供缓存服务可以直接使用，但了解一下其背后的实现与原理总还是有些必要（比如面试）， 本文就一起来学习一下Redis的几种集群方案。</p><a id="more"></a><p>Redis支持三种集群方案</p><ul><li>主从复制模式</li><li>Sentinel（哨兵）模式</li><li>Cluster模式</li></ul><h2 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h3><p>主从复制模式中包含一个主数据库实例（master）与一个或多个从数据库实例（slave），如下图</p><p><img src="/assets/redis-master-slave.png" alt="redis-master-slave"></p><p>客户端可对主数据库进行读写操作，对从数据库进行读操作，主数据库写入的数据会实时自动同步给从数据库。</p><p>具体工作机制为：</p><ol><li>slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照（即上文所介绍的RDB持久化），并使用缓冲区记录保存快照这段时间内执行的写命令</li><li>master将保存的快照文件发送给slave，并继续记录执行的写命令</li><li>slave接收到快照文件后，加载快照文件，载入数据</li><li>master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化</li><li>此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性</li></ol><h3 id="2-部署示例"><a href="#2-部署示例" class="headerlink" title="2. 部署示例"></a>2. 部署示例</h3><p>本示例基于Redis 5.0.3版。  </p><p>redis.conf的主要配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">###网络相关###</span><br><span class="line"># bind 127.0.0.1 # 绑定监听的网卡IP，注释掉或配置成0.0.0.0可使任意IP均可访问</span><br><span class="line">protected-mode no # 关闭保护模式，使用密码访问</span><br><span class="line">port 6379  # 设置监听端口，建议生产环境均使用自定义端口</span><br><span class="line">timeout 30 # 客户端连接空闲多久后断开连接，单位秒，0表示禁用</span><br><span class="line"></span><br><span class="line">###通用配置###</span><br><span class="line">daemonize yes # 在后台运行</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid  # pid进程文件名</span><br><span class="line">logfile &#x2F;usr&#x2F;local&#x2F;redis&#x2F;logs&#x2F;redis.log # 日志文件的位置</span><br><span class="line"></span><br><span class="line">###RDB持久化配置###</span><br><span class="line">save 900 1 # 900s内至少一次写操作则执行bgsave进行RDB持久化</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000 </span><br><span class="line"># 如果禁用RDB持久化，可在这里添加 save &quot;&quot;</span><br><span class="line">rdbcompression yes #是否对RDB文件进行压缩，建议设置为no，以（磁盘）空间换（CPU）时间</span><br><span class="line">dbfilename dump.rdb # RDB文件名称</span><br><span class="line">dir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;datas # RDB文件保存路径，AOF文件也保存在这里</span><br><span class="line"></span><br><span class="line">###AOF配置###</span><br><span class="line">appendonly yes # 默认值是no，表示不使用AOF增量持久化的方式，使用RDB全量持久化的方式</span><br><span class="line">appendfsync everysec # 可选值 always， everysec，no，建议设置为everysec</span><br><span class="line"></span><br><span class="line">###设置密码###</span><br><span class="line">requirepass 123456 # 设置复杂一点的密码</span><br></pre></td></tr></table></figure><p>部署主从复制模式只需稍微调整slave的配置，在redis.conf中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replicaof 127.0.0.1 6379 # master的ip，port</span><br><span class="line">masterauth 123456 # master的密码</span><br><span class="line">replica-serve-stale-data no # 如果slave无法与master同步，设置成slave不可读，方便监控脚本发现问题</span><br></pre></td></tr></table></figure><p>本示例在单台服务器上配置master端口6379，两个slave端口分别为7001,7002，启动master，再启动两个slave</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 master-slave]# redis-server master.conf</span><br><span class="line">[root@dev-server-1 master-slave]# redis-server slave1.conf</span><br><span class="line">[root@dev-server-1 master-slave]# redis-server slave2.conf</span><br></pre></td></tr></table></figure><p>进入master数据库，写入一个数据，再进入一个slave数据库，立即便可访问刚才写入master数据库的数据。如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 master-slave]# redis-cli </span><br><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set site blog.jboost.cn</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get site</span><br><span class="line">"blog.jboost.cn"</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=7001,state=online,offset=13364738,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=7002,state=online,offset=13364738,lag=0</span><br><span class="line">...</span><br><span class="line">127.0.0.1:6379&gt; exit</span><br><span class="line"></span><br><span class="line">[root@dev-server-1 master-slave]# redis-cli -p 7001</span><br><span class="line">127.0.0.1:7001&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; get site</span><br><span class="line">"blog.jboost.cn"</span><br></pre></td></tr></table></figure><p>执行<code>info replication</code>命令可以查看连接该数据库的其它库的信息，如上可看到有两个slave连接到master</p><h3 id="3-主从复制的优缺点"><a href="#3-主从复制的优缺点" class="headerlink" title="3. 主从复制的优缺点"></a>3. 主从复制的优缺点</h3><p>优点：</p><ol><li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</li><li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</li></ol><p>缺点：</p><ol><li>不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复</li><li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</li><li>难以支持在线扩容，Redis的容量受限于单机配置</li></ol><h2 id="Sentinel（哨兵）模式"><a href="#Sentinel（哨兵）模式" class="headerlink" title="Sentinel（哨兵）模式"></a>Sentinel（哨兵）模式</h2><h3 id="1-基本原理-1"><a href="#1-基本原理-1" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h3><p>哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。如图</p><p><img src="/assets/redis-sentinel.png" alt="redis-sentinel"></p><p>哨兵顾名思义，就是来为Redis集群站哨的，一旦发现问题能做出相应的应对处理。其功能包括</p><ol><li>监控master、slave是否正常运行</li><li>当master出现故障时，能自动将一个slave转换为master（大哥挂了，选一个小弟上位）</li><li>多个哨兵可以监控同一个Redis，哨兵之间也会自动监控</li></ol><p>哨兵模式的具体工作机制：</p><p>在配置文件中通过 <code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code> 来定位master的IP、端口，一个哨兵可以监控多个master数据库，只需要提供多个该配置项即可。哨兵启动后，会与要监控的master建立两条连接：</p><ol><li>一条连接用来订阅master的<code>_sentinel_:hello</code>频道与获取其他监控该master的哨兵节点信息</li><li>另一条连接定期向master发送INFO等命令获取master本身的信息</li></ol><p>与master建立连接后，哨兵会执行三个操作：</p><ol><li>定期（一般10s一次，当master被标记为主观下线时，改为1s一次）向master和slave发送INFO命令</li><li>定期向master和slave的<code>_sentinel_:hello</code>频道发送自己的信息</li><li>定期（1s一次）向master、slave和其他哨兵发送PING命令</li></ol><p>发送INFO命令可以获取当前数据库的相关信息从而实现新节点的自动发现。所以说哨兵只需要配置master数据库信息就可以自动发现其slave信息。获取到slave信息后，哨兵也会与slave建立两条连接执行监控。通过INFO命令，哨兵可以获取主从数据库的最新信息，并进行相应的操作，比如角色变更等。</p><p>接下来哨兵向主从数据库的<em>sentinel</em>:hello频道发送信息与同样监控这些数据库的哨兵共享自己的信息，发送内容为哨兵的ip端口、运行id、配置版本、master名字、master的ip端口还有master的配置版本。这些信息有以下用处：</p><ol><li>其他哨兵可以通过该信息判断发送者是否是新发现的哨兵，如果是的话会创建一个到该哨兵的连接用于发送PING命令。</li><li>其他哨兵通过该信息可以判断master的版本，如果该版本高于直接记录的版本，将会更新</li><li>当实现了自动发现slave和其他哨兵节点后，哨兵就可以通过定期发送PING命令定时监控这些数据库和节点有没有停止服务。</li></ol><p>如果被PING的数据库或者节点超时（通过 <code>sentinel down-after-milliseconds master-name milliseconds</code> 配置）未回复，哨兵认为其主观下线（sdown，s就是Subjectively —— 主观地）。如果下线的是master，哨兵会向其它哨兵发送命令询问它们是否也认为该master主观下线，如果达到一定数目（即配置文件中的quorum）投票，哨兵会认为该master已经客观下线（odown，o就是Objectively —— 客观地），并选举领头的哨兵节点对主从系统发起故障恢复。若没有足够的sentinel进程同意master下线，master的客观下线状态会被移除，若master重新向sentinel进程发送的PING命令返回有效回复，master的主观下线状态就会被移除</p><p>哨兵认为master客观下线后，故障恢复的操作需要由选举的领头哨兵来执行，选举采用Raft算法：</p><ol><li>发现master下线的哨兵节点（我们称他为A）向每个哨兵发送命令，要求对方选自己为领头哨兵</li><li>如果目标哨兵节点没有选过其他人，则会同意选举A为领头哨兵</li><li>如果有超过一半的哨兵同意选举A为领头，则A当选</li><li>如果有多个哨兵节点同时参选领头，此时有可能存在一轮投票无竞选者胜出，此时每个参选的节点等待一个随机时间后再次发起参选请求，进行下一轮投票竞选，直至选举出领头哨兵</li></ol><p>选出领头哨兵后，领头者开始对系统进行故障恢复，从出现故障的master的从数据库中挑选一个来当选新的master,选择规则如下：</p><ol><li>所有在线的slave中选择优先级最高的，优先级可以通过slave-priority配置</li><li>如果有多个最高优先级的slave，则选取复制偏移量最大（即复制越完整）的当选</li><li>如果以上条件都一样，选取id最小的slave</li></ol><p>挑选出需要继任的slave后，领头哨兵向该数据库发送命令使其升格为master，然后再向其他slave发送命令接受新的master，最后更新数据。将已经停止的旧的master更新为新的master的从数据库，使其恢复服务后以slave的身份继续运行。</p><h3 id="2-部署演示"><a href="#2-部署演示" class="headerlink" title="2. 部署演示"></a>2. 部署演示</h3><p>本示例基于Redis 5.0.3版。  </p><p>哨兵模式基于前文的主从复制模式。哨兵的配置文件为sentinel.conf，在文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1 # mymaster定义一个master数据库的名称，后面是master的ip， port，1表示至少需要一个Sentinel进程同意才能将master判断为失效，如果不满足这个条件，则自动故障转移（failover）不会执行</span><br><span class="line">sentinel auth-pass mymaster 123456 # master的密码</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds mymaster 5000 # 5s未回复PING，则认为master主观下线，默认为30s</span><br><span class="line">sentinel parallel-syncs mymaster 2  # 指定在执行故障转移时，最多可以有多少个slave实例在同步新的master实例，在slave实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span><br><span class="line">sentinel failover-timeout mymaster 300000 # 如果在该时间（ms）内未能完成故障转移操作，则认为故障转移失败，生产环境需要根据数据量设置该值</span><br></pre></td></tr></table></figure><blockquote><p>一个哨兵可以监控多个master数据库，只需按上述配置添加多套</p></blockquote><p>分别以26379,36379,46379端口启动三个sentinel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 sentinel]# redis-server sentinel1.conf --sentinel</span><br><span class="line">[root@dev-server-1 sentinel]# redis-server sentinel2.conf --sentinel</span><br><span class="line">[root@dev-server-1 sentinel]# redis-server sentinel3.conf --sentinel</span><br></pre></td></tr></table></figure><p>也可以使用<code>redis-sentinel sentinel1.conf</code> 命令启动。此时集群包含一个master、两个slave、三个sentinel，如图，</p><p><img src="/assets/redis-cluster-instance.png" alt="redis-cluster-instance"></p><p>我们来模拟master挂掉的场景，执行 <code>kill -9 3017</code> 将master进程干掉，进入slave中执行 <code>info replication</code>查看，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 sentinel]# redis-cli -p 7001</span><br><span class="line">127.0.0.1:7001&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:7002</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 省略</span></span><br><span class="line">127.0.0.1:7001&gt; exit</span><br><span class="line">[root@dev-server-1 sentinel]# redis-cli -p 7002</span><br><span class="line">127.0.0.1:7002&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7002&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=7001,state=online,offset=13642721,lag=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 省略</span></span><br></pre></td></tr></table></figure><p>可以看到slave 7002已经成功上位晋升为master（role：master），接收一个slave 7001的连接。此时查看slave2.conf配置文件，发现<code>replicaof</code>的配置已经被移除了，slave1.conf的配置文件里<code>replicaof 127.0.0.1 6379</code> 被改为 <code>replicaof 127.0.0.1 7002</code>。重新启动master，也可以看到master.conf配置文件中添加了<code>replicaof 127.0.0.1 7002</code>的配置项，可见大哥（master）下位后，再出来混就只能当当小弟（slave）了，三十年河东三十年河西。</p><h3 id="3-哨兵模式的优缺点"><a href="#3-哨兵模式的优缺点" class="headerlink" title="3. 哨兵模式的优缺点"></a>3. 哨兵模式的优缺点</h3><p>优点：</p><ol><li>哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有</li><li>哨兵模式下，master挂掉可以自动进行切换，系统可用性更高</li></ol><p>缺点：</p><ol><li>同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置</li><li>需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务</li></ol><h2 id="Cluster模式"><a href="#Cluster模式" class="headerlink" title="Cluster模式"></a>Cluster模式</h2><h3 id="1-基本原理-2"><a href="#1-基本原理-2" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h3><p>哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，Redis容量受限于单机配置的问题。Cluster模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。如图</p><p><img src="/assets/redis-cluster.png" alt="redis-cluster"></p><p>Cluster采用无中心结构,它的特点如下：</p><ol><li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽</li><li>节点的fail是通过集群中超过半数的节点检测失效时才生效</li><li>客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</li></ol><p>Cluster模式的具体工作机制：</p><ol><li>在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383</li><li>当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作</li><li>为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点</li><li>当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了</li></ol><p>Cluster模式集群节点最小配置6个节点(3主3从，因为需要半数以上)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><h3 id="2-部署演示-1"><a href="#2-部署演示-1" class="headerlink" title="2. 部署演示"></a>2. 部署演示</h3><p>本示例基于Redis 5.0.3版。 </p><p>Cluster模式的部署比较简单，首先在redis.conf中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 7100 # 本示例6个节点端口分别为7100,7200,7300,7400,7500,7600 </span><br><span class="line">daemonize yes # r后台运行 </span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_7100.pid # pidfile文件对应7100,7200,7300,7400,7500,7600 </span><br><span class="line">cluster-enabled yes # 开启集群模式 </span><br><span class="line">masterauth passw0rd # 如果设置了密码，需要指定master密码</span><br><span class="line">cluster-config-file nodes_7100.conf # 集群的配置文件，同样对应7100,7200等六个节点</span><br><span class="line">cluster-node-timeout 15000 # 请求超时 默认15秒，可自行设置</span><br></pre></td></tr></table></figure><p>分别以端口7100,7200,7300,7400,7500,7600 启动六个实例(如果是每个服务器一个实例则配置可一样)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 cluster]# redis-server redis_7100.conf</span><br><span class="line">[root@dev-server-1 cluster]# redis-server redis_7200.conf</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后通过命令将这个6个实例组成一个3主节点3从节点的集群，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7100 127.0.0.1:7200 127.0.0.1:7300 127.0.0.1:7400 127.0.0.1:7500 127.0.0.1:7600 -a passw0rd</span><br></pre></td></tr></table></figure><p>执行结果如图</p><p><img src="/assets/redis-cluster-deploy.png" alt="redis-cluster-deploy"></p><p>可以看到 7100， 7200， 7300 作为3个主节点，分配的slot分别为 0-5460， 5461-10922， 10923-16383， 7600作为7100的slave， 7500作为7300的slave，7400作为7200的slave。</p><p>我们连接7100设置一个值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-1 cluster]# redis-cli -p 7100 -c -a passw0rd</span><br><span class="line">Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:7100&gt; set site blog.jboost.cn</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [9421] located at 127.0.0.1:7200</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7200&gt; get site</span><br><span class="line">"blog.jboost.cn"</span><br><span class="line">127.0.0.1:7200&gt;</span><br></pre></td></tr></table></figure><p>注意添加 -c 参数表示以集群模式，否则报 <code>(error) MOVED 9421 127.0.0.1:7200</code> 错误， 以 -a 参数指定密码，否则报<code>(error) NOAUTH Authentication required</code>错误。</p><p>从上面命令看到key为site算出的slot为9421，落在7200节点上，所以有<code>Redirected to slot [9421] located at 127.0.0.1:7200</code>，集群会自动进行跳转。因此客户端可以连接任何一个节点来进行数据的存取。</p><p>通过<code>cluster nodes</code>可查看集群的节点信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7200&gt; cluster nodes</span><br><span class="line">eb28aaf090ed1b6b05033335e3d90a202b422d6c 127.0.0.1:7500@17500 slave c1047de2a1b5d5fa4666d554376ca8960895a955 0 1584165266071 5 connected</span><br><span class="line">4cc0463878ae00e5dcf0b36c4345182e021932bc 127.0.0.1:7400@17400 slave 5544aa5ff20f14c4c3665476de6e537d76316b4a 0 1584165267074 4 connected</span><br><span class="line">dbbb6420d64db22f35a9b6fa460b0878c172a2fb 127.0.0.1:7100@17100 master - 0 1584165266000 1 connected 0-5460</span><br><span class="line">d4b434f5829e73e7e779147e905eea6247ffa5a2 127.0.0.1:7600@17600 slave dbbb6420d64db22f35a9b6fa460b0878c172a2fb 0 1584165265000 6 connected</span><br><span class="line">5544aa5ff20f14c4c3665476de6e537d76316b4a 127.0.0.1:7200@17200 myself,master - 0 1584165267000 2 connected 5461-10922</span><br><span class="line">c1047de2a1b5d5fa4666d554376ca8960895a955 127.0.0.1:7300@17300 master - 0 1584165268076 3 connected 10923-16383</span><br></pre></td></tr></table></figure><p>我们将7200通过 <code>kill -9 pid</code>杀死进程来验证集群的高可用，重新进入集群执行<code>cluster nodes</code>可以看到7200 fail了，但是7400成了master，重新启动7200，可以看到此时7200已经变成了slave。</p><h3 id="3-Cluster模式的优缺点"><a href="#3-Cluster模式的优缺点" class="headerlink" title="3. Cluster模式的优缺点"></a>3. Cluster模式的优缺点</h3><p>优点：</p><ol><li>无中心架构，数据按照slot分布在多个节点。</li><li>集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li><li>可线性扩展到1000多个节点，节点可动态添加或删除</li><li>能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换</li></ol><p>缺点：</p><ol><li>客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”</li><li>节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的</li><li>数据通过异步复制，不保证数据的强一致性</li><li>slave充当“冷备”，不能缓解读压力</li><li>批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好</li><li>key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能</li><li>不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0</li></ol><p>Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了Redis集群方案的三种模式，其中主从复制模式能实现读写分离，但是不能自动故障转移；哨兵模式基于主从复制模式，能实现自动故障转移，达到高可用，但与主从复制模式一样，不能在线扩容，容量受限于单机的配置；Cluster模式通过无中心化架构，实现分布式存储，可进行线性扩展，也能高可用，但对于像批量操作、事务操作等的支持性不够好。三种模式各有优缺点，可根据实际场景进行选择。</p><p>参考：</p><ol><li><a href="https://blog.csdn.net/q649381130/article/details/79931791" target="_blank" rel="noopener">https://blog.csdn.net/q649381130/article/details/79931791</a></li><li><a href="https://www.cnblogs.com/51life/p/10233340.html" target="_blank" rel="noopener">https://www.cnblogs.com/51life/p/10233340.html</a></li><li><a href="https://www.cnblogs.com/chensuqian/p/10538365.html" target="_blank" rel="noopener">https://www.cnblogs.com/chensuqian/p/10538365.html</a></li><li><a href="https://stor.51cto.com/art/201910/604653.htm" target="_blank" rel="noopener">https://stor.51cto.com/art/201910/604653.htm</a>  </li></ol><hr><p>作者：空山新雨，一枚仍在学习路上的大龄码农<br>近期作者写了几十篇技术博客，内容包括Java、Spring Boot、Spring Cloud、Docker，技术管理心得等<br>欢迎关注作者微信公众号：空山新雨的技术空间，一起学习成长  </p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发测试环境中，我们一般搭建Redis的单实例来应对开发测试需求，但是在生产环境，如果对可用性、可靠性要求较高，则需要引入Redis的集群方案。虽然现在各大云平台有提供缓存服务可以直接使用，但了解一下其背后的实现与原理总还是有些必要（比如面试）， 本文就一起来学习一下Redis的几种集群方案。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis的持久化方案</title>
    <link href="http://blog.jboost.cn/redis-persistence.html"/>
    <id>http://blog.jboost.cn/redis-persistence.html</id>
    <published>2020-03-10T00:45:17.000Z</published>
    <updated>2020-03-10T10:20:08.256Z</updated>
    
    <content type="html"><![CDATA[<p>Redis支持RDB与AOF两种持久化机制，持久化可以避免因进程异常退出或down机导致的数据丢失问题，在下次重启时能利用之前的持久化文件实现数据恢复。</p><a id="more"></a><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB持久化即通过创建快照（压缩的二进制文件）的方式进行持久化，保存某个时间点的全量数据。RDB持久化是Redis默认的持久化方式。RDB持久化的触发包括手动触发与自动触发两种方式。</p><p><strong>手动触发</strong></p><ol><li>save， 在命令行执行save命令，将以同步的方式创建rdb文件保存快照，会阻塞服务器的主进程，生产环境中不要用</li><li>bgsave, 在命令行执行bgsave命令，将通过fork一个子进程以异步的方式创建rdb文件保存快照，除了fork时有阻塞，子进程在创建rdb文件时，主进程可继续处理请求</li></ol><p><strong>自动触发</strong></p><ol><li>在redis.conf中配置 <code>save m n</code> 定时触发，如 <code>save 900 1</code>表示在900s内至少存在一次更新就触发</li><li>主从复制时，如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li><li>执行debug reload命令重新加载Redis时</li><li>执行shutdown且没有开启AOF持久化</li></ol><p>redis.conf中RDB持久化配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 只要满足下列条件之一，则会执行bgsave命令</span><br><span class="line">save 900 1 # 在900s内存在至少一次写操作</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"># 禁用RBD持久化，可在最后加 save &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 当备份进程出错时主进程是否停止写入操作</span><br><span class="line">stop-writes-on-bgsave-error yes  </span><br><span class="line"># 是否压缩rdb文件 推荐no 相对于硬盘成本cpu资源更贵</span><br><span class="line">rdbcompression no</span><br></pre></td></tr></table></figure><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF（Append-Only-File）持久化即记录所有变更数据库状态的指令，以append的形式追加保存到AOF文件中。在服务器下次启动时，就可以通过载入和执行AOF文件中保存的命令，来还原服务器关闭前的数据库状态。</p><p>redis.conf中AOF持久化配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 默认关闭AOF，若要开启将no改为yes</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># append文件的名字</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 每隔一秒将缓存区内容写入文件 默认开启的写入方式</span><br><span class="line">appendfsync everysec </span><br><span class="line"></span><br><span class="line"># 当AOF文件大小的增长率大于该配置项时自动开启重写（这里指超过原大小的100%）。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"># 当AOF文件大小大于该配置项时自动开启重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><p>AOF持久化的实现包括3个步骤:</p><ol><li>命令追加：将命令追加到AOF缓冲区</li><li>文件写入：缓冲区内容写到AOF文件</li><li>文件保存：AOF文件保存到磁盘</li></ol><p>其中后两步的频率通过appendfsync来配置，appendfsync的选项包括</p><ul><li>always， 每执行一个命令就保存一次，安全性最高，最多只丢失一个命令的数据，但是性能也最低（频繁的磁盘IO）</li><li>everysec，每一秒保存一次，推荐使用，在安全性与性能之间折中，最多丢失一秒的数据</li><li>no， 依赖操作系统来执行（一般大概30s一次的样子），安全性最低，性能最高，丢失操作系统最后一次对AOF文件触发SAVE操作之后的数据</li></ul><p>AOF通过保存命令来持久化，随着时间的推移，AOF文件会越来越大，Redis通过AOF文件重写来解决AOF文件不断增大的问题（可以减少文件的磁盘占有量，加快数据恢复的速度），原理如下：</p><ol><li><p>调用fork，创建一个子进程</p></li><li><p>子进程读取当前数据库的状态来“重写”一个新的AOF文件（这里虽然叫“重写”，但实际并没有对旧文件进行任何读取，而是根据数据库的当前状态来形成指令）</p></li><li><p>主进程持续将新的变动同时写到AOF重写缓冲区与原来的AOF缓冲区中</p></li><li><p>主进程获取到子进程重写AOF完成的信号，调用信号处理函数将AOF重写缓冲区内容写入新的AOF文件中，并对新文件进行重命名，原子地覆盖原有AOF文件，完成新旧文件的替换</p></li></ol><p>AOF的重写也分为手动触发与自动触发</p><ul><li>手动触发： 直接调用bgrewriteaof命令</li><li>自动触发： 根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。其中auto-aof-rewrite-min-size表示运行AOF重写时文件最小体积，默认为64MB。auto-aof-rewrite-percentage表示当前AOF文件大小（aof_current_size）和上一次重写后AOF文件大小（aof_base_size）的比值。自动触发时机为 aof_current_size &gt; auto-aof-rewrite-min-size &amp;&amp;（aof_current_size - aof_base_size）/aof_base_size&gt; = auto-aof-rewrite-percentage</li></ul><h2 id="RDB-vs-AOF"><a href="#RDB-vs-AOF" class="headerlink" title="RDB vs AOF"></a>RDB vs AOF</h2><p>RDB与AOF两种方式各有优缺点。</p><p>RDB的优点：与AOF相比，RDB文件相对较小，恢复数据比较快（原因见数据恢复部分）<br>RDB的缺点：服务器宕机，RBD方式会丢失掉上一次RDB持久化后的数据；使用bgsave fork子进程时会耗费内存。</p><p>AOF的优点： AOF只是追加文件，对服务器性能影响较小，速度比RDB快，消耗内存也少，同时可读性高。<br>AOF的缺点：生成的文件相对较大，即使通过AOF重写，仍然会比较大；恢复数据的速度比RDB慢。</p><h2 id="数据库的恢复"><a href="#数据库的恢复" class="headerlink" title="数据库的恢复"></a>数据库的恢复</h2><p>服务器启动时，如果没有开启AOF持久化功能，则会自动载入RDB文件，期间会阻塞主进程。如果开启了AOF持久化功能，服务器则会优先使用AOF文件来还原数据库状态，因为AOF文件的更新频率通常比RDB文件的更新频率高，保存的数据更完整。</p><p>redis数据库恢复的处理流程如下，</p><p><img src="/assets/redis-restore.png" alt="redis-restore"></p><p>在数据恢复方面，RDB的启动时间会更短，原因有两个：</p><ol><li>RDB 文件中每一条数据只有一条记录，不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了，文件相对较小。</li><li>RDB 文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作，所以在CPU消耗上要远小于AOF日志的加载。</li></ol><p>但是在进行RDB持久化时，fork出来进行dump操作的子进程会占用与父进程一样的内存，采用的copy-on-write机制，对性能的影响和内存的消耗都是比较大的。比如16G内存，Redis已经使用了10G，这时save的话会再生成10G，变成20G，大于系统的16G。这时候会发生交换，要是虚拟内存不够则会崩溃，导致数据丢失。所以在用redis的时候一定对系统内存做好容量规划。</p><h2 id="RDB、AOF混合持久化"><a href="#RDB、AOF混合持久化" class="headerlink" title="RDB、AOF混合持久化"></a>RDB、AOF混合持久化</h2><p>Redis从4.0版开始支持RDB与AOF的混合持久化方案。首先由RDB定期完成内存快照的备份，然后再由AOF完成两次RDB之间的数据备份，由这两部分共同构成持久化文件。该方案的优点是充分利用了RDB加载快、备份文件小及AOF尽可能不丢数据的特性。缺点是兼容性差，一旦开启了混合持久化，在4.0之前的版本都不识别该持久化文件，同时由于前部分是RDB格式，阅读性较低。</p><p>开启混合持久化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><p>数据恢复加载过程就是先按照RDB进行加载，然后把AOF命令追加写入。</p><h2 id="持久化方案的建议"><a href="#持久化方案的建议" class="headerlink" title="持久化方案的建议"></a>持久化方案的建议</h2><ol><li>如果Redis只是用来做缓存服务器，比如数据库查询数据后缓存，那可以不用考虑持久化，因为缓存服务失效还能再从数据库获取恢复。</li><li>如果你要想提供很高的数据保障性，那么建议你同时使用两种持久化方式。如果你可以接受灾难带来的几分钟的数据丢失，那么可以仅使用RDB。</li><li>通常的设计思路是利用主从复制机制来弥补持久化时性能上的影响。即Master上RDB、AOF都不做，保证Master的读写性能，而Slave上则同时开启RDB和AOF（或4.0以上版本的混合持久化方式）来进行持久化，保证数据的安全性。</li></ol><br>认真生活，快乐分享欢迎关注微信公众号：空山新雨的技术空间![微信公众号](/assets/qrcode-05.jpg) ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis支持RDB与AOF两种持久化机制，持久化可以避免因进程异常退出或down机导致的数据丢失问题，在下次重启时能利用之前的持久化文件实现数据恢复。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="redis" scheme="http://blog.jboost.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（八）：使用Spring Cloud Bus来实现配置动态更新</title>
    <link href="http://blog.jboost.cn/springcloud-8.html"/>
    <id>http://blog.jboost.cn/springcloud-8.html</id>
    <published>2020-02-26T02:04:16.000Z</published>
    <updated>2020-02-27T05:11:37.349Z</updated>
    
    <content type="html"><![CDATA[<p>使用Spring Cloud Config我们能实现服务配置的集中化管理，在服务启动时从Config Server获取需要的配置属性。但如果在服务运行过程中，我们需要将某个配置属性进行修改，比如将验证码的失效时间从五分钟调整为十分钟，如何将这个更新在服务端不重启服务就能动态生效，是本文讨论的内容。</p><a id="more"></a><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><p>Spring Cloud Bus可以理解为Spring Cloud体系架构中的消息总线，通过一个轻量级的Message Broker来将分布式系统中的节点连接起来。可用来实现广播状态更新（如配置更新），或其它管理指令。<br>Spring Cloud Bus 就像是一个分布式的Spring Boot Actuator， 目前提供了两种类型的消息队列中间件支持：RabbitMQ与Kafka（对应的pom依赖分别为spring-cloud-starter-bus-amqp， spring-cloud-starter-bus-kafka）。</p><p>Spring Cloud 在spring-cloud-context中添加了两个actuator管理接口（POST请求）： <code>/actuator/env</code> 与 <code>/actuator/refresh</code>， 前者可用于更新当前服务实例Environment对象中的配置属性，后者可用于刷新当前服务实例的配置信息。</p><p>Spring Cloud Bus也提供了两个对应的接口</p><ol><li><code>/actuator/bus-env</code>，相对于<code>/actuator/env</code> ， 使用键值对更新每个实例的Environment，默认不暴露，需配置management.endpoints.web.exposure.include=bus-env 来开放接口访问</li><li><code>/actuator/bus-refresh</code>，相对于<code>/actuator/refresh</code>，对每个实例，清空<code>RefreshScope</code>缓存，重新绑定@ConfigurationProperties， 默认不暴露，可通过配置<br>management.endpoints.web.exposure.include=bus-refresh 来开放接口访问</li></ol><p>综上，<code>/actuator/env</code> 与 <code>/actuator/refresh</code> 是针对单个服务实例修改或刷新其配置信息，而 <code>/actuator/bus-env</code> 与 <code>/actuator/bus-refresh</code> 则是借助于Spring Cloud Bus的消息机制作用于分布式系统中的所有服务实例，因此前面有Spring Cloud Bus 就像是一个分布式的Spring Boot Actuator的说法。</p><p>使用Spring Cloud Bus来实现服务配置动态更新的结构图如下</p><p><img src="/assets/spring-cloud-bus.png" alt="spring-cloud-bus"></p><ol><li>更新配置仓库中的配置文件，push到远程Git仓库</li><li>远程Git仓库通过Webhook调用配置服务器的通知更新接口</li><li>配置服务器发送配置更新消息到消息总线</li><li>其它服务节点监听到配置服务器发送的配置更新消息</li><li>其它服务节点向配置服务器发送拉取最新配置的请求</li><li>配置服务器向配置仓库拉取最新的配置返回给其它服务节点</li></ol><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>我们还是以前面的springcloud-config， springcloud-eureka， springcloud-eureka-client三个项目来完成本文的案例演示。<a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">源码地址</a></p><h3 id="使用Actuator"><a href="#使用Actuator" class="headerlink" title="使用Actuator"></a>使用Actuator</h3><p>在不引入Spring Cloud Bus的情况下，我们可以通过Spring Cloud提供的actuator接口来实现单个实例的配置动态更新。</p><p>依次启动springcloud-eureka， springcloud-config， springcloud-eureka-client项目，然后修改springcloud-eureka-client的启动端口，将8080改为8081，再启动一个springcloud-eureka-client的服务实例。</p><p>springcloud-eureka-client 的测试接口代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;app&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String app;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, welcome to spring cloud 2. env: "</span> + env.getProperty(<span class="string">"app"</span>) + <span class="string">", value: "</span> + app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时依次请求两个实例的hello接口，得到结果如下</p><p><img src="/assets/springcloudbus-test1.png" alt="springcloudbus-test1"></p><p><img src="/assets/springcloudbus-test2.png" alt="springcloudbus-test2"></p><p>我们通过<code>/actuator/env</code>接口来修改端口8080实例的属性app的值，使用postman操作如图</p><p><img src="/assets/springcloudbus-test3.png" alt="springcloudbus-test3"></p><p>此时再请求接口返回结果如下</p><p><img src="/assets/springcloudbus-test4.png" alt="springcloudbus-test4"></p><p>可以看到Environment对象中app属性的值已更新，但是 @Value注解的属性值未变，可见 <code>/actuator/env</code> 接口只是更新了Environment对象，并不负责刷新其它方式引用的属性值。此时请求另一个端口为8081的实例接口，其属性值都未更新，也可见 <code>/actuator/env</code> 只作用于当前实例本身。</p><p>如果要让8080实例的@Value属性也动态更新，则可再调用<code>/actuator/refresh</code>接口，如图</p><p><img src="/assets/springcloudbus-test5.png" alt="springcloudbus-test5"></p><p>此时再请求测试接口，得到结果如下（@Value注解的属性也已经更新了）</p><p><img src="/assets/springcloudbus-test6.png" alt="springcloudbus-test6"></p><h3 id="使用Spring-Cloud-Bus"><a href="#使用Spring-Cloud-Bus" class="headerlink" title="使用Spring Cloud Bus"></a>使用Spring Cloud Bus</h3><p>前面我们使用 <code>/actuator/env</code> 与 <code>/actuator/refresh</code> 两个接口可以实现单个服务实例配置的动态更新，但在微服务架构中，服务实例可能达几十甚至几百个，一个个调用来做动态更新就有点太不方便了。这时就该Spring Cloud Bus登场了。</p><p>1.添加依赖与配置</p><p>在springcloud-config， 与springcloud-eureka-client两个项目中，添加spring cloud bus的依赖与配置。<br>在pom.xml文件中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在application.yml配置文件中添加RabbitMQ的相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">rabbitmq</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">passw0rd</span></span><br></pre></td></tr></table></figure><p>2.依次启动springcloud-eureka， springcloud-config， springcloud-eureka-client项目，并以8081端口再启动一个springcloud-eureka-client的服务实例。</p><p>3.我们使用postman对配置服务器调用<code>/actuator/bus-env</code>接口，</p><p><img src="/assets/springcloudbus-test7.png" alt="springcloudbus-test7"></p><p>请求两个服务实例的测试接口，得到结果</p><p><img src="/assets/springcloudbus-test9.png" alt="springcloudbus-test9"></p><p><img src="/assets/springcloudbus-test8.png" alt="springcloudbus-test8"></p><p>两个实例的Environment对象都已经更新，如果要将@Value注解的属性也更新，则可再调用配置服务器的<code>/actuator/bus-refresh</code>接口。</p><p><code>/actuator/bus-env</code>接口是直接更新的内存Environment实例属性，如果服务重启，则又还原到之前的配置了， 所以还是需要借助配置仓库来永久更新。配置更新后还需要手动调用接口使其生效？DevOps时代了，能自动化的就自动化吧，我们可以借助Git的webhook机制来实现自动化。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>本文开头的“使用Spring Cloud Bus来实现服务配置动态更新的结构图”已经示例了使用Git仓库的webhook来触发自动更新配置的流程。但是在Git（如Github）中，我们不能直接使用<code>/actuator/bus-refresh</code>接口来作为webhook（因为接口协议不一致，会出现解析异常），也有人通过提供自己的接口来作为webhook，在自己接口中再转发请求到<code>/actuator/bus-refresh</code>来实现。但实际上，spring-cloud-config-monitor已经提供了对Git webhook的支持。</p><p>如下图，spring-cloud-config-monitor提供了对Github，Gitlab，Gitee，BitBucket等的支持</p><p><img src="/assets/spring-cloud-config-monitor.png" alt="springcloud-config-monitor"></p><p>1.在配置服务器springcloud-config的pom.xml文件中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-monitor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在配置仓库的设置页面配置webhook，比如Github的配置如图</p><p><img src="/assets/config-github-webhook.png" alt="config-github-webhook"></p><p>Payload URL 配置为配置服务器的monitor接口地址，path参数必须。如果你的配置服务器在内网，比如做本地测试时，还需要实现一下内网穿透（如frp）。<br>在配置仓库项目中修改配置属性，提交代码，Github webhook就会触发自动更新，上图下方红色框为触发自动更新的记录。</p><h3 id="自动更新配置未生效排查"><a href="#自动更新配置未生效排查" class="headerlink" title="自动更新配置未生效排查"></a>自动更新配置未生效排查</h3><p>如果出现Github触发了自动更新，但服务的配置更新未生效的情况，则需要查看webhook的匹配规则与服务实例的ServiceID是否匹配，webhook的匹配规则为 <code>spring.application.name:spring.cloud.config.profile:**</code>，服务实例的ServiceID可通过<code>spring.cloud.bus.id</code>配置，如果没有配置，则默认为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;vcap.application.name:<span class="variable">$&#123;spring.application.name:application&#125;</span>&#125;:<span class="variable">$&#123;vcap.application.instance_index:$&#123;spring.application.index:$&#123;local.server.port:$&#123;server.port:0&#125;</span>&#125;&#125;&#125;:<span class="variable">$&#123;vcap.application.instance_id:$&#123;random.value&#125;</span>&#125;</span></span><br></pre></td></tr></table></figure><p>遵循app:index:id的格式，</p><ul><li>app：如果vcap.application.name存在，使用vcap.application.name，否则使用spring.application.name，默认值为application</li><li>index：优先使用vcap.application.instance_index，如果不存在则依次使用spring.application.index、local.server.port、server.port， 默认值为0</li><li>id：如果vcap.application.instance_id存在，使用vcap.application.instance_id，否则给一个随机值</li></ul><p>我们可以在服务项目中打开spring cloud bus的debug日志</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.springframework.cloud.bus:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>通过DefaultBusPathMatcher的debug日志来查看是否匹配，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG 286196 --- [7O8XC9KNWbyDA-1] o.s.cloud.bus.DefaultBusPathMatcher      : In match: hello-service:8081:c96f04c81dfce6dffaa9d116811d127c, hello-service:8081:c96f04c81dfce6dffaa9d116811d127c</span><br></pre></td></tr></table></figure><p>如果没有匹配则可以按照webhook的匹配规则设置<code>spring.cloud.bus.id</code>值或<code>vcap.application.instance_index</code>值，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hello-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">config-server</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">$&#123;spring.profiles.active:default&#125;</span></span><br><span class="line">    <span class="attr">bus:</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;spring.cloud.config.profile&#125;:$&#123;random.value&#125;</span></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="attr">vcap:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">instance_index:</span> <span class="string">$&#123;spring.cloud.config.profile&#125;</span></span><br></pre></td></tr></table></figure><p>配置更新未生效的另一个情况是查看是否用了@RefreshScope注解。</p><h2 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h2><p>细心的人会发现本文开头的测试接口类上加了@RefreshScope注解。 @RefreshScope是Spring Cloud提供的用来实现配置、实例热加载的注解。被@RefreshScope修饰的@Bean都是延迟加载的，即在第一次访问（调用方法）时才会被初始化，并且这些bean存于缓存中。当收到配置更新的消息时，缓存中的@RefreshScope bean会被清除，这样下次访问时将会重新创建bean，此时使用的就是最新的配置信息，从而实现配置的热加载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分别示例了使用spring boot actuator与spring cloud bus来实现服务配置的更新及两者之间的区别， spring cloud bus一定程度上像是一个分布式的spring boot actuator。同时演示了使用webhook与spring cloud bus，monitor结合来实现配置自动更新的具体流程及可能遇到的问题。</p><br>认真生活，快乐分享欢迎关注微信公众号：空山新雨的技术空间![微信公众号](/assets/qrcode-05.jpg) ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Spring Cloud Config我们能实现服务配置的集中化管理，在服务启动时从Config Server获取需要的配置属性。但如果在服务运行过程中，我们需要将某个配置属性进行修改，比如将验证码的失效时间从五分钟调整为十分钟，如何将这个更新在服务端不重启服务就能动态生效，是本文讨论的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（七）：服务网关zuul过滤器</title>
    <link href="http://blog.jboost.cn/springcloud-7.html"/>
    <id>http://blog.jboost.cn/springcloud-7.html</id>
    <published>2020-02-20T05:47:57.000Z</published>
    <updated>2020-02-21T04:05:09.935Z</updated>
    
    <content type="html"><![CDATA[<p>上文介绍了Zuul的基本使用与路由功能，本文接着介绍Zuul的核心概念 —— Zuul过滤器（filter）。</p><p>Zuul的功能基本通过Zuul过滤器来实现（类比于Struts的拦截器，只是Struts拦截器用到责任链模式，Zuul则是通过FilterProcessor来控制执行），在不同的阶段，通过不同类型的过滤器来实现相应的功能。</p><a id="more"></a><h2 id="Zuul过滤器"><a href="#Zuul过滤器" class="headerlink" title="Zuul过滤器"></a>Zuul过滤器</h2><h3 id="过滤器类型"><a href="#过滤器类型" class="headerlink" title="过滤器类型"></a>过滤器类型</h3><p>zuul的过滤器根据对HTTP请求的不同处理阶段包括如下四种类型</p><ul><li>pre ：在请求转发到后端目标服务之前执行，一般用于请求认证、确定路由地址、日志记录等</li><li>route ：转发请求，使用Apache HttpClient 或 Ribbon来构造对目标服务的请求</li><li>post ：在目标服务返回结果后对结果进行处理，比如添加响应头、收集统计性能数据等</li><li>error ：在请求处理的整个流程中如果出现错误，则会触发error过滤器执行，对错误进行处理</li></ul><p>客户端请求经过zuul过滤器处理的流程如下图</p><p><img src="/assets/zuul-filter.png" alt="zuul-filter"></p><p>zuul使用<code>RequestContext</code>来在过滤器之间传递数据，数据存于每个request的ThreadLocal，包含请求路由到哪里，错误，HttpServletRequest，HttpServletResponse 等这些数据都存储于RequestContext中。RequestContext 扩展了ConcurrentHashMap，所以我们可以根据需要将信息存于context中进行传递。</p><h3 id="EnableZuulProxy-vs-EnableZuulServer"><a href="#EnableZuulProxy-vs-EnableZuulServer" class="headerlink" title="@EnableZuulProxy vs @EnableZuulServer"></a>@EnableZuulProxy vs @EnableZuulServer</h3><p>zuul提供了两个注解 @EnableZuulProxy， @EnableZuulServer，来启用不同的过滤器集合。@EnableZuulProxy 启用的过滤器 是@EnableZuulServer 的超集， 它包含了@EnableZuulServer 的所有过滤器，proxy主要多了一些提供路由功能的过滤器（可见@EnableZuulServer 不提供路由功能，作为server模式而不是代理模式运行）</p><p>@EnableZuulServer 注解启用的过滤器包括</p><table><thead><tr><th align="center">filter类型</th><th align="center">实现类</th><th align="center">filter顺序值</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">pre</td><td align="center">ServletDetectionFilter</td><td align="center">-3</td><td align="center">检测请求是否通过Spring Dispatcher，并在RequestContext 中添加一个key为isDispatcherServletRequest， 值为true（不通过则为false）的属性</td></tr><tr><td align="center">pre</td><td align="center">FormBodyWrapperFilter</td><td align="center">-1</td><td align="center">解析Form data，为请求的下游进行重新编码</td></tr><tr><td align="center">pre</td><td align="center">DebugFilter</td><td align="center">1</td><td align="center">如果请求参数设置了debug，则会将RequestContext.setDebugRouting() ，RequestContext.setDebugRequest() 设置为ture</td></tr><tr><td align="center">route</td><td align="center">SendForwardFilter</td><td align="center">500</td><td align="center">使用RequestDispatch servlet来转发请求，转发地址存于RequestContext中key为FilterConstants.FORWARD_TO_KEY的属性中，对于转发到当前应用的接口比较有用</td></tr><tr><td align="center">post</td><td align="center">SendResponseFilter</td><td align="center">1000</td><td align="center">将代理请求的响应内容写到当前的响应中</td></tr><tr><td align="center">error</td><td align="center">SendErrorFilter</td><td align="center">0</td><td align="center">如果RequestContext.getThrowable() 不为空，则会转发到/error，可以通过error.path来改变默认的转发路径/error</td></tr></tbody></table><p>@EnableZuulProxy 除了上面的过滤器，还包含如下过滤器</p><table><thead><tr><th align="center">filter类型</th><th align="center">实现类</th><th align="center">filter顺序值</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">pre</td><td align="center">PreDecorationFilter</td><td align="center">5</td><td align="center">确定路由到哪里，如何路由，依赖提供的RouteLocator，同时也为下游请求设置多个与proxy相关的header</td></tr><tr><td align="center">route</td><td align="center">RibbonRoutingFilter</td><td align="center">10</td><td align="center">使用ribbon，hystrix，以及内嵌的http client来发送请求，可在RequestContext中通过FilterConstants.SERVICE_ID_KEY 来找到路由Service的ID</td></tr><tr><td align="center">route</td><td align="center">SimpleHostRoutingFilter</td><td align="center">100</td><td align="center">使用Apache httpClient来发送请求到一个预先确定的url，可通过RequestContext.getRouteHost()来获取urls</td></tr></tbody></table><p>由上可见@EnableZuulServer 注解并不包含往后端服务负载均衡地路由请求的代理功能，@EnableZuulProxy的PreDecorationFilter，RibbonRoutingFilter过滤器才能担当此任。PreDecorationFilter通过提供的DiscoveryClientRouteLocator 从 DiscoveryClient（如Eureka）与属性文件中加载路由定义， 为每个serviceId创建一个route，新服务添加进来，路由也会动态刷新。路由确定了，在RibbonRoutingFilter 中通过ribbon与hystrix结合来向后端目标服务发起请求，并进行负载均衡。过滤器的顺序值表示在同类型过滤器中的执行顺序，值越小越先执行。</p><h2 id="自定义Zuul过滤器"><a href="#自定义Zuul过滤器" class="headerlink" title="自定义Zuul过滤器"></a>自定义Zuul过滤器</h2><p>自定义的zuul过滤器与框架自带过滤器类似，包括四部分</p><ol><li>过滤器类型，包括pre， route， post</li><li>过滤器顺序，定义在同类型过滤器中的执行顺序，数值越小越先执行</li><li>是否执行过滤，通过一些条件判断来确定是否执行该过滤器</li><li>过滤器执行体，定义具体执行的操作</li></ol><p>比如我们需要在Http请求头中设置一个值，供请求链路的下游环节访问，则可以自定义一个过滤器如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReqIdPreFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_DECORATION_FILTER_ORDER - <span class="number">1</span>; <span class="comment">//在PreDecorationFilter过滤器之前执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        ctx.addZuulRequestHeader(<span class="string">"reqId"</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在请求的后续环节，比如后端服务的filter或接口中，则可直接从HttpServletRequest 获取该header值，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"hello/reqId"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getReqId</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello-service返回："</span> + request.getHeader(<span class="string">"reqId"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Zuul的错误处理"><a href="#Zuul的错误处理" class="headerlink" title="Zuul的错误处理"></a>Zuul的错误处理</h2><p>在zuul过滤器的生命周期中，如果任何一个环节抛出异常，则error过滤器会被执行，SendErrorFilter只有当RequestContext.getThrowable()不为null时才会运行，会设置javax.servlet.error.* 属性到request中，然后将请求转发到spring boot的error page， 默认为BasicErrorController实现的/error接口。 有时候我们需要将返回响应格式进行统一，而默认的/error接口实现可能不满足要求，则可以自定义/error接口。需要实现ErrorController 接口以使默认的BasicErrorController 失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulErrorController</span> <span class="keyword">implements</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/error"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">error</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; result = Maps.newHashMap();</span><br><span class="line">        result.put(<span class="string">"code"</span>, request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>).toString());</span><br><span class="line">        result.put(<span class="string">"message"</span>, request.getAttribute(<span class="string">"javax.servlet.error.message"</span>).toString());</span><br><span class="line">        result.put(<span class="string">"exception"</span>, request.getAttribute(<span class="string">"javax.servlet.error.exception"</span>).toString());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Zuul的服务降级"><a href="#Zuul的服务降级" class="headerlink" title="Zuul的服务降级"></a>Zuul的服务降级</h2><p>当调用服务出现超时或异常时，在zuul侧可提供回调进行服务降级，返回默认响应结果，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFallbackProvider</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//指定这个回调针对的route Id，如果对所有route，则返回* 或null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</span><br><span class="line">            <span class="keyword">return</span> response(HttpStatus.GATEWAY_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> response(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ClientHttpResponse <span class="title">response</span><span class="params">(<span class="keyword">final</span> HttpStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> status.value();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> status.getReasonPhrase();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Map&lt;String, String&gt; result = Maps.newLinkedHashMap();</span><br><span class="line">                result.put(<span class="string">"code"</span>, <span class="string">""</span> + status.value());</span><br><span class="line">                String msg = HttpStatus.GATEWAY_TIMEOUT == getStatusCode() ? <span class="string">"请求服务超时"</span> : <span class="string">"服务器内部错误"</span>;</span><br><span class="line">                result.put(<span class="string">"message"</span>, msg);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(<span class="keyword">new</span> ObjectMapper().writeValueAsString(result).getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则当服务请求失败时，统一返回如下格式的响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"500"</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"服务器内部错误"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对Zuul过滤器相关内容及自定义使用进行了介绍，同时对过滤器运行过程中异常的处理及服务调用失败的降级回调进行了简单说明。出于篇幅，开发过程中更具体的细节我们后续再继续探讨。</p><br>认真生活，快乐分享欢迎关注微信公众号：空山新雨的技术空间![微信公众号](/assets/qrcode-05.jpg) ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文介绍了Zuul的基本使用与路由功能，本文接着介绍Zuul的核心概念 —— Zuul过滤器（filter）。&lt;/p&gt;
&lt;p&gt;Zuul的功能基本通过Zuul过滤器来实现（类比于Struts的拦截器，只是Struts拦截器用到责任链模式，Zuul则是通过FilterProcessor来控制执行），在不同的阶段，通过不同类型的过滤器来实现相应的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（六）：服务网关zuul</title>
    <link href="http://blog.jboost.cn/springcloud-6.html"/>
    <id>http://blog.jboost.cn/springcloud-6.html</id>
    <published>2020-02-14T02:45:40.000Z</published>
    <updated>2020-02-14T09:17:54.862Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面几篇文章的介绍，Spring Cloud微服务架构可通过Eureka实现服务注册与发现，通过Ribbon或Feign来实现服务间的负载均衡调用，通过Hystrix来为服务调用提供服务降级、熔断机制避免雪崩效应，通过Spring Cloud Config实现服务配置的集中化管理。微服务架构内部管理的基本组件差不多都已涵盖了，但是我们的服务最终是需要提供给客户端访问的，客户端如何来访问这些微服务，就需要引入一个叫服务网关的组件了。</p><a id="more"></a><h2 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h2><p>zuul是netflix提供的一个基于JVM的路由与服务端负载均衡器。它在客户端与后端服务之间建立了一道关卡，客户端所有请求必须经过zuul转发到后端对应的微服务，返回结果再经由zuul返回给客户端。zuul与Eureka，Config组合的基本结构如图</p><p><img src="/assets/zuul.png" alt="zuul"></p><p>zuul作为Eureka Client从Eureka Server获取其它微服务的配置信息，从而可以将客户端请求通过Service ID来负载均衡地转发到后端的服务实例，同时也作为Config Client从Config Server获取自身所需的配置信息。</p><p>在netflix内部，zuul被用来实现安全认证、动态路由、反向代理、服务迁移、服务削峰、压力测试、金丝雀测试（灰度发布测试）等功能。本文介绍zuul的基本使用与路由规则。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>创建maven项目 springcloud-zuul</p><ol><li>pom.xml中引入依赖 <code>spring-cloud-starter-netflix-zuul</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>application.yml配置文件中添加必要的配置，主要是eureka客户端配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">zuul-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8765</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动类添加注解 <code>@EnableZuulProxy</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一如既往的简单，Spring Cloud之所以流行就是因为它基于Spring Boot将一些通用的功能进行了开箱即用的封装，使得开发者简单几步就能快速集成一个微服务框架。</p><p>依次启动前文所创建的springcloud-eureka, springcloud-config, springcloud-eureka-client, springcloud-zuul，<a href="http://localhost:8765/hello-service/hello" target="_blank" rel="noopener">http://localhost:8765/hello-service/hello</a> 返回 <code>Hello, welcome to spring cloud. env: hello-service-dev, value: hello-service-dev</code> 可见通过zuul的请求转发到了hello-service。</p><p>为了验证zuul转发请求具备负载均衡的能力，可以将springcloud-eureka-client 中的hello接口返回值做一些调整，并改变端口重启一个实例，再次请求<a href="http://localhost:8765/hello-service/hello" target="_blank" rel="noopener">http://localhost:8765/hello-service/hello</a> 将能看到返回结果在两者之间切换。</p><p>以上配置文件中并没有加任何路由配置，zuul是怎么将请求正确转发到对应的微服务的呢？ 请看下面的路由规则。</p><h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><ol><li>默认路由规则</li></ol><p>zuul提供了默认的路由规则，不需要任何配置就会默认将注册的服务进行路径映射。我们可以通过actuator提供的接口来查看，在application.yml中添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><p>放开actuator的其它接口访问（默认只放开了/info 与/health接口）， 浏览器中访问 <a href="http://localhost:8765/actuator/routes，" target="_blank" rel="noopener">http://localhost:8765/actuator/routes，</a> 可以看到返回的zuul默认的路由映射关系</p><p><img src="/assets/zuul-routes.png" alt="zuul-route"></p><p>zuul默认将 /service-id/** 的请求路由到Service ID（即spring.application.name的值）为 service-id的服务，如 /hello-service/hello，将转发到hello-service服务的/hello接口。</p><ol start="2"><li>自定义路由规则</li></ol><p>我们看到zuul的默认路由规则将config-server也映射出来了，对于这类内部服务我们不希望暴露，则可以通过 <code>zuul.ignoredServices</code> 来进行屏蔽，在application.yml配置文件中添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">ignored-services:</span> <span class="string">"config-server"</span></span><br></pre></td></tr></table></figure><p>重启，再次查看<a href="http://localhost:8765/actuator/routes" target="_blank" rel="noopener">http://localhost:8765/actuator/routes</a> ， config-server已经被屏蔽了。</p><p>通过zuul.routes可添加自定义路由，可以有 <code>zuul.routes.{route-name}.path</code> + <code>zuul.routes.{route-name}.serviceId或url</code> 或 <code>zuul.routes.{service-id}: path</code> 两个格式， 如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">ignored-services:</span> <span class="string">"config-server"</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">hello:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/hi/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">hello-service</span></span><br><span class="line">    <span class="attr">hello-service:</span> <span class="string">/hi2/**</span></span><br><span class="line">    <span class="attr">jboost:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/jboost/**</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://blog.jboost.cn</span></span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8765/hi/hello" target="_blank" rel="noopener">http://localhost:8765/hi/hello</a>  或 <a href="http://localhost:8765/hi2/hello" target="_blank" rel="noopener">http://localhost:8765/hi2/hello</a> 都将路由到 hello-service的hello接口，访问 <a href="http://localhost:8765/jboost/" target="_blank" rel="noopener">http://localhost:8765/jboost/</a> 将访问到jboost博客首页。添加自定义路由后，默认路由仍然存在， 你仍然可以通过 <a href="http://localhost:8765/hello-service/hello" target="_blank" rel="noopener">http://localhost:8765/hello-service/hello</a> 来访问 hello-service的hello接口。</p><p>默认的路由规则将Service ID作为匹配路径，看起来有点长，我们想将匹配路径缩短一点，比如hello-service的匹配路径想改为 <code>/hello/**</code>， 而不是<code>/hello-service/**</code>， 如果像上面配置，一个微服务系统可能涉及几十甚至上百个服务，那配置起来将是一场噩梦。别急， zuul提供了 ServiceRouteMapper 接口来解决这一问题，其中 PatternServiceRouteMapper 可以基于正则表达式来进行路由抽取。</p><p>创建一个配置类，注入一个 PatternServiceRouteMapper 的bean，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PatternServiceRouteMapper <span class="title">serviceRouteMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PatternServiceRouteMapper(</span><br><span class="line">                <span class="string">"(?&lt;name&gt;^.+)-(?&lt;postfix&gt;.+$)"</span>,</span><br><span class="line">                <span class="string">"$&#123;name&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现将会对所有服务的路由进行调整，service id 形如 name-postfix的匹配路径为 <code>/name/**</code>， 如hello-service 匹配 <code>/hello/**</code>。 如果正则表达式匹配失败，则还是以默认规则进行路由，如果匹配成功，则默认规则失效，但在配置文件中定义的路由仍然有效。上述验证中，你都可以通过 <a href="http://localhost:8765/actuator/routes" target="_blank" rel="noopener">http://localhost:8765/actuator/routes</a> 来查看当前生效的路由。</p><h2 id="其它配置"><a href="#其它配置" class="headerlink" title="其它配置"></a>其它配置</h2><p>zuul使用Ribbon来定位服务实例，所有请求都在hystrix command里执行，所以在zuul中可以添加Ribbon， Hystrix相关配置（具体参考前面Ribbon、Hystrix相关文章）</p><ul><li>zuul.ignoredPatterns 对某些路径进行屏蔽，如 <code>/**/admin/**</code> 将会屏蔽所有路径中包含admin的接口访问</li><li>zuul.sensitiveHeaders 对一些header进行过滤，不传递给后端服务，默认包括Cookie,Set-Cookie,Authorization， 如果要让zuul发送所有header，则需要显式地将sensitiveHeaders置空值</li><li>zuul.prefix 为所有映射添加前缀，如/api， 这样route里配的 <code>/myusers/**</code> 就能匹配客户端请求的<code>/api/myusers/**</code>。默认zuul代理在转发时，前缀会被移除，通过设置<code>zuul.stripPrefix=false</code>可不移除</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了zuul的基本使用与路由规则，更高阶的应用我们后面继续。</p><br>认真生活，快乐分享欢迎关注微信公众号：空山新雨的技术空间![微信公众号](/assets/qrcode-05.jpg) ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前面几篇文章的介绍，Spring Cloud微服务架构可通过Eureka实现服务注册与发现，通过Ribbon或Feign来实现服务间的负载均衡调用，通过Hystrix来为服务调用提供服务降级、熔断机制避免雪崩效应，通过Spring Cloud Config实现服务配置的集中化管理。微服务架构内部管理的基本组件差不多都已涵盖了，但是我们的服务最终是需要提供给客户端访问的，客户端如何来访问这些微服务，就需要引入一个叫服务网关的组件了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（五）：服务配置管理中心</title>
    <link href="http://blog.jboost.cn/springcloud-5.html"/>
    <id>http://blog.jboost.cn/springcloud-5.html</id>
    <published>2020-02-11T02:59:41.000Z</published>
    <updated>2020-02-11T07:39:11.424Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud Config为微服务提供了集中化的配置管理，可以通过git仓库的形式来对各个服务的配置属性进行管理维护，在配置更新时，可通过消息总线的方式实现动态更新，而不需要重启服务。</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Spring Cloud Config属于CS架构，包括Config Server与Config Client， Config Server从配置存储库（可以是git，svn，jdbc数据库，或本地文件系统）获取配置属性，Config Client通过http请求对应的配置属性。如图</p><p><img src="/assets/configserver.png" alt="config-server"></p><p>Config Server在客户端请求配置信息时，从git获取配置信息（可以配置为启动时即从git获取）返回给客户端，当配置发生更新时，可通过webhook的方式通知到Config Server，Config Server发出RefreshRemoteApplicationEvent 事件，通知客户端更新配置信息。</p><h1 id="Config-Server"><a href="#Config-Server" class="headerlink" title="Config Server"></a>Config Server</h1><p>搭建一个Config Server很简单。</p><ol><li>首先pom.xml中引入依赖，</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加入Eureka Client是使配置服务作为一个微服务注册到Eureka被其它微服务（作为Config Client）发现。</p><ol start="2"><li>然后application.yml中添加配置，<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/ronwxy/jboost-config</span></span><br><span class="line">          <span class="attr">searchPaths:</span> <span class="string">'&#123;application&#125;'</span>  <span class="comment"># 按应用名称分文件夹目录存储配置文件，只在应用名所在目录及顶层目录下寻找配置文件</span></span><br><span class="line">          <span class="attr">cloneOnStart:</span> <span class="literal">true</span> <span class="comment"># 启动时就获取配置，否则只有当客户端请求时才去获取配置</span></span><br><span class="line">          <span class="attr">basedir:</span> <span class="string">D:\config</span> <span class="comment">#本地缓存路径</span></span><br><span class="line">          <span class="attr">forcePull:</span> <span class="literal">true</span>  <span class="comment"># 在本地配置被污染（篡改）时， 强制拉取远程配置覆盖</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">$&#123;spring.profiles.active:default&#125;</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure></li></ol><p>上述配置使Config Server从github仓库获取配置信息，searchPaths: ‘{application}’ 可以将每个服务的配置属性文件放入仓库的同名文件夹下。 注意这里的引号是必须的，否则因为不符合yaml文件语法导致不生效。</p><p>定期刷新： spring.cloud.config.server.git.refreshRate 单位秒， 默认为0， 表示每次请求时，config server都会从git 仓库获取更新的配置。<br>本地缓存： 默认本地副本存在临时目录中，有些操作系统可能会定时清理临时目录，导致问题，设置配置的本地目录：spring.cloud.config.server.git.basedir</p><ol start="3"><li>最后启动类上添加注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成以上三步一个简单的Config Server就搭建完成了，启动项目，访问 <a href="http://localhost:8888/hello-service/dev" target="_blank" rel="noopener">http://localhost:8888/hello-service/dev</a> 可获取到仓库 hello-service 目录下对应profile为dev的配置属性文件hello-service-dev.yml与默认配置文件（包括同目录下application.yml与仓库根目录下的application.yml, application-dev.yml配置文件）</p><p>通过url获取配置的访问方式：</p><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><p>其中 application是spring.config.name的值，profile可以是以逗号分隔的列表，label是git的分支，默认是master。</p><p>Config Server的高可用：</p><ol><li>起多个实例，客户端配置spring.cloud.config.uri 以逗号隔开配多个uri</li><li>或将实例注册到服务注册中心</li></ol><p>对于500,401等异常，客户端不会重试其它实例， 只在实例挂掉或连接超时时，才会重试其它实例</p><h1 id="Config-Client"><a href="#Config-Client" class="headerlink" title="Config Client"></a>Config Client</h1><p>客户端以springcloud-eureka-client项目为基础进行改造</p><ol><li>在pom.xml中添加config相关依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加actuator可以暴露相关接口，如/env 来查看配置属性加载情况，springboot2中actuator默认只开放/info /health 两个接口，可通过如下配置放开（生产环境根据需要调整）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加bootstrap.yml配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hello-service</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">serviceId:</span> <span class="string">config-server</span></span><br><span class="line">      <span class="attr">failfast:</span> <span class="literal">true</span> <span class="comment"># 在启动时如果连不上config server，则启动失败</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">$&#123;spring.profiles.active:default&#125;</span></span><br></pre></td></tr></table></figure><p>依次启动服务注册中心 springcloud-eureka， 配置管理服务 springcloud-config， 配置客户端 springcloud-eureka-client， 访问 <a href="http://localhost:8080/actuator/env" target="_blank" rel="noopener">http://localhost:8080/actuator/env</a> 可看到配置客户端加载的配置信息。在配置客户端启动时，控制台也会打印从配置服务获取配置的相关信息，如 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Located property source: OriginTrackedCompositePropertySource &#123;name='configService', propertySources=[MapPropertySource &#123;name='configClient'&#125;, OriginTrackedMapPropertySource &#123;name='https://github.com/ronwxy/jboost-config/hello-service/hello-service-dev.yml'&#125;, OriginTrackedMapPropertySource &#123;name='https://github.com/ronwxy/jboost-config/application-dev.yml'&#125;, OriginTrackedMapPropertySource &#123;name='https://github.com/ronwxy/jboost-config/hello-service/application.yml'&#125;, OriginTrackedMapPropertySource &#123;name='https://github.com/ronwxy/jboost-config/application.yml'&#125;]&#125;</span><br></pre></td></tr></table></figure><p>这样，在客户端就可以通过 @ConfigurationProperties注解的属性类， @Value 注解，或Environment对象来访问相关属性，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">env.getProperty(<span class="string">"app"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;app&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String app;</span><br></pre></td></tr></table></figure><p>客户端重试机制：</p><ol><li>首先设置 spring.cloud.config.failfast=true</li><li>然后添加 spring-retry， spring-boot-starter-aop 依赖</li></ol><p>默认进行6次重试，每次间隔一开始1s，然后每次1.1倍递增。如果要自定义，则通过spring.cloud.config.retry.* 配置参数， 或通过定义一个ID为configServerRetryInterceptor 的RetryOperationsInterceptor 类型的@Bean，可通过RetryInterceptorBuilder 来创建。</p><p>本文示例源码地址： <a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">https://github.com/ronwxy/springcloud-demos</a></p><br>认真生活，快乐分享欢迎关注微信公众号：空山新雨的技术空间![微信公众号](/assets/qrcode-05.jpg) ]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring Cloud Config为微服务提供了集中化的配置管理，可以通过git仓库的形式来对各个服务的配置属性进行管理维护，在配置更新时，可通过消息总线的方式实现动态更新，而不需要重启服务。&lt;/p&gt;
&lt;h1 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>mybatis缓存，从一个“灵异”事件说起</title>
    <link href="http://blog.jboost.cn/mybatis-cache.html"/>
    <id>http://blog.jboost.cn/mybatis-cache.html</id>
    <published>2020-01-20T03:19:30.000Z</published>
    <updated>2020-01-20T10:06:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>刚准备下班走人，被一开发同事叫住，让帮看一个比较奇怪的问题：Mybatis同一个Mapper接口的查询方法，第一次返回与第二次返回结果不一样，百思不得其解！</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Talk is cheap. Show me the code.  该问题涉及的主要代码实现包括</p><ol><li><p>mapper接口定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodsTrackMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">GoodsTrack</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;GoodsTrackDTO&gt; <span class="title">listGoodsTrack</span><span class="params">(@Param(<span class="string">"criteria"</span>)</span> GoodsTrackQueryCriteria criteria)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listGoodsTrack"</span> <span class="attr">resultType</span>=<span class="string">"xxx.GoodsTrackDTO"</span>&gt;</span></span><br><span class="line">    SELECT ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>service定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.SUPPORTS, readOnly = <span class="keyword">true</span>, rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">GoodsTrackService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">GoodsTrack</span>, <span class="title">GoodsTrackDTO</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsTrackMapper goodsTrackMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;GoodsTrackDTO&gt; <span class="title">listGoodsTrack</span><span class="params">(GoodsTrackQueryCriteria criteria)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> goodsTrackMapper.listGoodsTrack(criteria);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;GoodsTrackDTO&gt; <span class="title">goodsTrackList</span><span class="params">(GoodsTrackQueryCriteria criteria)</span></span>&#123;</span><br><span class="line">        List&lt;GoodsTrackDTO&gt; listGoodsTrack = goodsTrackMapper.listGoodsTrack(criteria);</span><br><span class="line">        Map&lt;String, GoodsTrackDTO&gt; goodsTrackDTOMap = <span class="keyword">new</span> HashMap&lt;String, GoodsTrackDTO&gt;();</span><br><span class="line">        <span class="keyword">for</span> (GoodsTrackDTO goodsTrackDTO : listGoodsTrack)&#123;</span><br><span class="line">            String goodsId = String.valueOf(goodsTrackDTO.getGoodsId());</span><br><span class="line">            <span class="keyword">if</span> (!goodsTrackDTOMap.containsKey(goodsId))&#123;</span><br><span class="line">                goodsTrackDTOMap.put(goodsId, goodsTrackDTO);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                GoodsTrackDTO goodsTrack = goodsTrackDTOMap.get(goodsId);</span><br><span class="line">                <span class="keyword">int</span> num = goodsTrack.getGoodsNum() + goodsTrackDTO.getGoodsNum();</span><br><span class="line">                goodsTrack.setGoodsNum(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GoodsTrackDTO&gt;  list = <span class="keyword">new</span> ArrayList(goodsTrackDTOMap.values());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.SUPPORTS, readOnly = <span class="keyword">true</span>, rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">GoodsOrderService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">GoodsOrder</span>, <span class="title">GoodsOrderDTO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsTrackService goodsTrackService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GoodsOrderDTO <span class="title">create</span><span class="params">(GoodsOrderDTO goodsOrderDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        List&lt;GoodsTrackDTO&gt; rs1 = goodsTrackList(criteria);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        List&lt;GoodsTrackDTO&gt; rs2 = listGoodsTrack(criteria);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致逻辑就是在 <code>GoodsTrackService</code> 定义了两个查询方法，一个是直接从数据库中获取数据，第二个是从数据库中获取数据后进行了一些加工（通过某个字段进行合并累加，类似sum group by），然后在<code>GoodsOrderService</code> 的同一个方法（该方法是一个事务方法 ）中调用这两个查询，发现rs2中的数据存在问题， 期望是都应该与数据库表的数据一致，但其中部分数据却与查出后进行了修改的rs1中的一致。</p></li></ol><p>即本来期望查出的结果如图</p><p><img src="/assets/mybatis-cache1.png" alt="mybatis-cache1"></p><p>rs2与数据库表数据一致。</p><p>但是经上面代码运行的结果却如图</p><p><img src="/assets/mybatis-cache2.png" alt="mybatis-cache2"></p><p>rs2中的数据包含了rs1中的数据。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>初步看，<code>listGoodsTrack</code> 方法直接调用的mapper方法 <code>goodsTrackMapper.listGoodsTrack(criteria)</code> 没做任何应用层的处理，第一反应是缓存的原因。 我问前面的查询有没有改变查询返回的结果（一开始没细看具体实现），答曰没有。折腾一阵后，返过去细看 <code>goodsTrackList</code> 的实现，果然还是眼见为实、耳听为虚。在该方法中，通过goodsId对返回的列表进行分组，对goodsNum进行累加，最后返回累加后的几个对象。但是在累加的时候，是直接作用于返回结果对象的，明明就是改变了查询结果（居然说没有？！！）。 这就是问题所在了，mybatis在同一个事务中，对同一个查询（同样的sql，同样的参数）的返回结果进行了缓存（称为一级缓存），下一次做同样的查询时，如果中间没有任何更新操作，则直接返回缓存的数据，而在本例中因为对缓存数据做了人为的修改，所以最后导致查出的数据与数据库不一致。</p><h2 id="mybatis缓存机制"><a href="#mybatis缓存机制" class="headerlink" title="mybatis缓存机制"></a>mybatis缓存机制</h2><p>简单介绍下mybatis的两级缓存机制</p><ul><li><p>一级缓存：一级缓存包括SqlSession与STATEMENT两种级别，默认在 SqlSession 中实现。在一次会话中，如果两次查询sql相同，参数相同，且中间没有任何更新操作，则第二次查询会直接返回第一次查询缓存的结果，不再请求数据库。如果中间存在更新操作，则更新操作会清除掉缓存，后面的查询就会访问数据库了。STATEMENT级别则每次查询都会清掉一级缓存，每次查询都会进行数据库访问。</p></li><li><p>二级缓存：二级缓存则是在同一个namesapce的多个 SqlSession 间共享的缓存，默认未开启。当开启二级缓存后，数据查询的流程就是 二级缓存 ——&gt; 一级缓存 ——&gt; 数据库， 同一个namespace下的更新操作，会影响同一个Cache。</p></li></ul><p>如何开启二级缓存</p><ol><li>需要在mybatis-config.xml中设置：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>然后在mapper的xml文件的&lt;mapper&gt;下设置cache相关配置：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> </span></span><br><span class="line"><span class="tag"><span class="attr">eviction</span>=<span class="string">"LRU"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">flushInterval</span>=<span class="string">"60000"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">size</span>=<span class="string">"512"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>支持的属性：</p><ul><li>type：cache使用的类型，默认是PerpetualCache</li><li>eviction： 回收的策略，常见的有LRU，FIFO</li><li>flushInterval： 配置一定时间自动刷新缓存，单位毫秒</li><li>size： 最多缓存的对象个数</li><li>readOnly： 是否只读，若配置为可读写，则需要对应的实体类实现Serializable接口</li><li>blocking： 如果缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存</li></ul><p>也可以使用 <code>&lt;cache-ref namespace=&quot;mapper.UserMapper&quot;/&gt;</code> 来与另一个mapper共享二级缓存</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>已经定位到是由于mybatis的一级缓存导致，那如何解决本文提到的问题呢？ 基本上有三个解决方向。</p><ol><li>使用缓存的方案</li></ol><p>既然要使用缓存，那就不能更改缓存的数据，此时我们可以在需要更改数据的地方把数据做一次副本拷贝，使其不改变缓存数据本身， 如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (GoodsTrackDTO goodsTrackDTO : listGoodsTrack)&#123;</span><br><span class="line">    String goodsId = String.valueOf(goodsTrackDTO.getGoodsId());</span><br><span class="line">    <span class="keyword">if</span> (!goodsTrackDTOMap.containsKey(goodsId))&#123;</span><br><span class="line">        goodsTrackDTOMap.put(goodsId, ObjectUtil.clone(goodsTrackDTO));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        GoodsTrackDTO goodsTrack = goodsTrackDTOMap.get(goodsId);</span><br><span class="line">        <span class="keyword">int</span> num = goodsTrack.getGoodsNum() + goodsTrackDTO.getGoodsNum();</span><br><span class="line">        goodsTrack.setGoodsNum(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ObjectUtil.clone()方法（hutool工具包中提供）对需要更改的数据做副本拷贝。</p><ol start="2"><li>禁用缓存的方案</li></ol><p>在xml的sql定义中添加 flushCache=”true” 的配置，使该查询不使用缓存，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listGoodsTrack"</span> <span class="attr">resultType</span>=<span class="string">"xxx.GoodsTrackDTO"</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>&gt;</span> </span><br><span class="line">    SELECT ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>禁用缓存的另一种方案是将一级缓存直接设置为STATEMENT来进行全局禁用，在mybatis-config.xml中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"STATEMENT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>避开缓存的方案</li></ol><p>再定义一个实现相同查询的mapper方法，id不一样来避开使用相同的缓存，这种做法就不怎么优雅了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listGoodsTrack2"</span> <span class="attr">resultType</span>=<span class="string">"xxx.GoodsTrackDTO"</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>&gt;</span> </span><br><span class="line">    SELECT ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>避开缓存的另一种做法是不使用事务，使两个查询不在一个SqlSession中，但有时候事务是必须的，所以得分场景来。</p><blockquote><p>另外由于mybatis的缓存都是基于本地的，在分布式环境下可能导致读取的数据与数据库不一致，比如一个服务实例两次读取中间，另一个服务实例对数据进行了更新，则后一次读取由于缓存还是读取的旧数据，而不是更新后的数据，可能导致问题。这时可以通过将缓存设置为STATEMENT级别来禁用mybatis缓存，通过Redis，MemCached等来提供分布式的全局缓存。</p></blockquote><br>认真生活，快乐分享欢迎关注微信公众号：空山新雨的技术空间![微信公众号](/assets/qrcode-05.jpg) ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚准备下班走人，被一开发同事叫住，让帮看一个比较奇怪的问题：Mybatis同一个Mapper接口的查询方法，第一次返回与第二次返回结果不一样，百思不得其解！&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud（四）：啥是服务降级与熔断之Hystrix</title>
    <link href="http://blog.jboost.cn/springcloud-4.html"/>
    <id>http://blog.jboost.cn/springcloud-4.html</id>
    <published>2020-01-19T01:31:02.000Z</published>
    <updated>2020-01-20T02:50:05.938Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务的架构中，一个业务的实现通常包括多层服务的调用，底层基础服务的故障可能会导致上层服务级联发生故障，进而故障不断蔓延导致系统整体不可用，这种现象称为服务的雪崩效应。</p><a id="more"></a><h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><p>断路器（CircuitBreaker， 或叫熔断器）是用来避免服务雪崩效应，提升系统整体可用性的一种技术手段。通过在一个时间窗口内监测服务的调用失败情况，在失败时通过回调返回默认实现（这叫服务降级），当失败达到一定程度时，后续的调用直接导致快速失败，不再访问远程服务（这叫熔断机制），防止不断尝试调用可能会失败的服务，以使服务有机会恢复，一定时间后，当断路器监测到服务恢复后，会继续尝试调用。</p><p>断路器原理有点类似于电路中的保险丝或电闸，当发现电路中出现短路异常情况时，通过保险丝熔断或电闸跳闸来断开电路，避免事故发生。</p><h2 id="Hystrix服务降级"><a href="#Hystrix服务降级" class="headerlink" title="Hystrix服务降级"></a>Hystrix服务降级</h2><p>当使用Hystrix时，每一个远程服务的调用都被封装到一个HystrixCommand中，HystrixCommand有两个主要方法：run(), getFallback()。<br>其中run方法封装了远程服务的调用逻辑，如果run方法超时或者抛出异常，并且启用了服务降级，则会调用getFallback方法来进行降级处理。</p><p>降级处理由 HystrixCommandProperties.Setter 中定义的配置属性来控制，主要包括：</p><ul><li>fallbackEnabled， 是否启用降级处理，如果启用则在超时或异常时调用getFallback来进行降级处理，默认启用</li><li>fallbackIsolationSemaphoreMaxConcurrentRequests，控制getFallback方法并发请求的信号量，默认为10，如果请求超过了信号量限制，则不再尝试调用getFallback方法，而是快速失败</li><li>executionIsolationThreadInterruptOnFutureCancel，隔离策略为THREAD，当Future#cancel(true)时，是否进行中断处理，默认为false</li><li>executionIsolationThreadInterruptOnTimeout，隔离策略为THREAD，当执行线程超时时，是否进行中断，默认为true</li><li>executionTimeoutInMilliseconds，执行超时时间，默认为1000ms，如果隔离策略为THREAD（线程池隔离），且配置了executionIsolationThreadInterruptOnTimeout=true，则执行线程将被中断，如果隔离策略为SEMAPHORE（信号量隔离），则终止操作，信号量隔离下执行线程与主线程是同一个线程，所以不会中断线程处理</li></ul><p>在进行降级处理调用getFallback方法时，需注意：</p><ol><li><p>该方法最大并发数受fallbackIsolationSemaphoreMaxConcurrentRequests控制，默认为10，如果失败率很高，则需配置该参数，如果并发数超过了配置，则不会执行getFallback，而是快速失败，抛出异常“HystrixRuntimeException: xxx fallback executionrejected”</p></li><li><p>尽量避免在getFallback中进行网络请求，而是能快速返回的缓存数据或静态数据（如默认值）；如果需要做网络请求，则应该是调用另一个被Hystrix保护的请求，即对fallback进行串联，第一个fallback中请求网络做业务调用，第二个fallback中回调缓存或静态数据</p></li></ol><p>上文提到Hystrix的线程池隔离策略与信号量隔离策略，两者如何理解？</p><ol><li>线程池隔离：执行在一个单独的线程中，通过线程池中线程数量来控制并发请求量。每一个服务使用一个单独的线程池进行隔离，避免互相影响。这种策略下的服务调用是异步的，可通过hystrix来配置超时。</li><li>信号量隔离：执行在调用线程中，通过信号量来控制控制并发请求量（executionIsolationSemaphoreMaxConcurrentRequests， 默认为10），如果并发量超过该值，则调用getFallback方法对服务进行降级。这种策略下的服务调用是同步的，无法对调用进行超时配置，只能通过调用协议（如http）的超时。信号量隔离策略一般只有在高并发量的情况下使用（如一秒几百次），这种情况下使用单独的线程池开销比较大；或者如果需要在调用服务的线程中，如RequestInterceptor中使用ThreadLocal中的变量，也可以通过将隔离策略设置为信号量来实现(hystrix.command.default.execution.isolation.strategy=SEMAPHORE)</li></ol><blockquote><p>注： 如果只是需要在服务调用中使用安全上下文 SecurityContext， 则也可以通过配置 hystrix.shareSecurityContext=true 来实现，这样Hystrix的并发策略插件会将SecurityContext从主线程传递到Hystrix command使用的线程。</p></blockquote><p>线程池隔离策略与信号量隔离策略两者之间的区别</p><table><thead><tr><th align="center">隔离策略</th><th align="center">实现原理</th><th align="center">调用模式</th><th align="center">是否支持超时配置</th><th align="center">降级实现</th><th align="center">资源消耗</th></tr></thead><tbody><tr><td align="center">线程池隔离</td><td align="center">每个服务使用单独的线程池</td><td align="center">异步调用</td><td align="center">支持</td><td align="center">线程池满则请求拒绝，降级处理</td><td align="center">较大，容易造成服务器负载高</td></tr><tr><td align="center">信号量隔离</td><td align="center">使用信号量的计数器</td><td align="center">同步调用</td><td align="center">不支持</td><td align="center">信号量达到最大值则请求拒绝，降级处理</td><td align="center">较小</td></tr></tbody></table><h2 id="Hystrix熔断机制"><a href="#Hystrix熔断机制" class="headerlink" title="Hystrix熔断机制"></a>Hystrix熔断机制</h2><p>Hystrix客户端会对调用失败情况进行采样统计。当在一个时间窗口（由metrics.rollingStats.timeInMilliseconds配置， 默认10s）内，调用某个服务超过一定次数（由circuitBreaker.requestVolumeThreshold配置，默认20），失败率超过一定比例（由circuitBreaker.errorThresholdPercentage配置，默认50%），则熔断开关打开，调用会被快速失败（不再进行远程调用），如果开发者提供了fallback，则会调用fallback进行降级处理，如果没有，则抛出 异常。</p><p>调用失败包括如下几种情况：</p><ol><li>调用中抛出异常</li><li>调用超时</li><li>线程池拒绝</li><li>信号量拒绝</li></ol><p>熔断开关的状态：</p><ul><li>闭合（closed）：如果配置了熔断开关强制闭合，或者当前的请求失败率没有超过设置的阈值，则熔断开关处于闭合状态，不启动熔断机制。但这时如果调用超时或失败，仍会进行降级处理（除非fallbackEnabled为false）</li><li>打开（open）：如果配置了熔断开关强制打开，或者当前的请求失败率超过了设置的阈值，则熔断开关打开，启动熔断机制，直接进行降级处理，不再进行远程调用</li><li>半打开（half-open）：当熔断开关处理打开状态，需要在一定的时间窗口后进行重试，检测服务是否恢复，这种状态就是半打开状态。如果测试成功则关闭熔断开关，否则还是处于打开状态</li></ul><p>Hystrix熔断开关的状态关系如图所示</p><p><img src="/assets/hystrix-status.png" alt="hystrix熔断开关状态"></p><p>熔断相关的参数配置（HystrixCommandProperties.Setter）：</p><ul><li>circuitBreakerEnabled， 是否开启熔断机制，默认true</li><li>circuitBreakerForceOpen，是否强制打开熔断开关，如果为true，则对请求进行强制降级，默认为false</li><li>circuitBreakerForceClosed， 是否强制关闭熔断开关，默认为false</li><li>circuitBreakerRequestVolumeThreshold， 在熔断开关闭合的情况下，一个采样时间窗口内需要进行至少多少个请求才进行采用统计计算失败率，默认为20</li><li>circuitBreakerErrorThresholdPercentage， 在一个采样时间窗口内，失败率超过该值，则打开熔断开关，进行快速失败，默认采样时间窗口为10s，失败率为50%</li><li>circuitBreakerSleepWindowInMilliseconds， 熔断后的重试时间窗口，在该时间窗口允许一次重试，如果重试成功，则关闭熔断开关，否则还是打开状态，默认5s</li></ul><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>熔断是服务调用端的一种保护机制，因此通常与Feign结合使用，Feign的Hystrix支持在Dalston版本之前，hystrix只要在类路径中，feign默认就会自动将所有方法封装到断路器中，Dalston版及以后的版本改变了这一做法，需要进行显示配置 feign.hystrix.enabled=true。</p><p>本文案例还是基于前面创建的springcloud-eureka（注册中心）， springcloud-eureka-client（一个简单的hello service）两个项目。</p><ol><li><p>新建springcloud-hystrix项目，pom.xml中引入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>applicaiton.yml配置文件中添加必要配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>启动类添加必要注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplication</span></span></span><br></pre></td></tr></table></figure></li></ol><p>其它Feign Client类与Controller类详见源码：<a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">https://github.com/ronwxy/springcloud-demos</a>  springcloud-hystrix项目</p><ol start="4"><li>测试</li></ol><p>这里分四种情形分别进行演示。依次启动springcloud-eureka， springcloud-eureka-client（debug模式启动，并在hello接口里设置断点，模拟超时），springcloud-hystrix</p><ul><li>启用断路器，未指定fallback</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span></span></span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8084/hystrix0" target="_blank" rel="noopener">http://localhost:8084/hystrix0</a>  得到结果如下</p><p><img src="/assets/hystrix-nofallback.png" alt="无fallback"></p><p>抛出异常： HystrixRuntimeException: HelloClient#hello() timed-out and no fallback available.] with root cause java.util.concurrent.TimeoutException: null</p><ul><li>启用断路器，指定fallback</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>, contextId = <span class="string">"hello-with-fallback"</span>, fallback = HelloClientFallback<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">HelloClient1</span></span></span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8084/hystrix1" target="_blank" rel="noopener">http://localhost:8084/hystrix1</a>  得到结果返回 “调用hello-service返回：this is returned by fallback”， 不会抛出异常。</p><ul><li>启用断路器，指定fallbackFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>, contextId = <span class="string">"hello-with-fallbackFactory"</span>, fallbackFactory = HelloClientFallbackFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">HelloClient2</span></span></span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8084/hystrix2" target="_blank" rel="noopener">http://localhost:8084/hystrix2</a>  得到结果返回 “调用hello-service返回：this is returned from fallbackFactory, cause: com.netflix.hystrix.exception.HystrixTimeoutException”，不会抛出异常。</p><ul><li>不启用断路器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>, contextId = <span class="string">"hello-without-circuitBreaker"</span>, configuration = DisableCircuitBreakerConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">HelloClient3</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DisableCircuitBreakerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Feign.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对单个feign client禁用断路器可以配置一个注入了 prototype scope的 Feign.Builder实例的配置类来实现。</p><p>访问 <a href="http://localhost:8084/hystrix3" target="_blank" rel="noopener">http://localhost:8084/hystrix3</a>  得到结果如下</p><p><img src="/assets/nohystrix.png" alt="无Hystrix"></p><p>抛出异常： feign.RetryableException: Read timed out executing GET <a href="http://hello-service/hello]" target="_blank" rel="noopener">http://hello-service/hello]</a> with root cause java.net.SocketTimeoutException: Read timed out</p><p>可见，在启用断路器，不指定fallback时，抛出HystrixRuntimeException异常，指定fallback时，调用fallback方法降级处理，但获取不到失败原因，如果需要获取失败原因，可使用fallbackFactory，不启用断路器时，抛出feign.RetryableException异常。</p><p>注意上面的contextId， 当使用同一个名称或url来创建多个指向同一服务的feign client时， 需要使用contextId来避免配置bean的名称冲突。该属性可以改变feign 客户端的ApplicationContext的名称，覆盖feign客户端别名，作为客户端配置bean名称的一部分。</p><p><a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">本文示例代码</a></p><br>认真生活，快乐分享欢迎关注微信公众号：空山新雨的技术空间![微信公众号](/assets/qrcode-05.jpg) ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务的架构中，一个业务的实现通常包括多层服务的调用，底层基础服务的故障可能会导致上层服务级联发生故障，进而故障不断蔓延导致系统整体不可用，这种现象称为服务的雪崩效应。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（三）：Web服务客户端之Feign</title>
    <link href="http://blog.jboost.cn/springcloud-3.html"/>
    <id>http://blog.jboost.cn/springcloud-3.html</id>
    <published>2020-01-15T08:59:09.000Z</published>
    <updated>2020-01-19T11:29:53.145Z</updated>
    
    <content type="html"><![CDATA[<p>前文介绍了实现客户端负载均衡的Ribbon，但直接使用Ribbon的API来实现服务间的调用相对较为繁琐，服务间的调用能否像本地接口调用一样便捷、透明，更符合编程习惯呢？ Feign就是用来干这事的。</p><a id="more"></a><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是一个声明式的Web服务客户端，让服务之间的调用变得非常简单——定义带@FeignClient注解的接口，本地直接@Autowired 接口，通过调用接口的方法来实现远程服务的调用。</p><p>支持的注解包括Feign注解与JAX-RS（Java API for RESTful Web Services）注解。</p><p>每一个Feign的客户端都包含一系列对应的组件，Spring Cloud通过FeignClientsConfiguration 为每一个命名的Feign客户端创建一个组件集合，包括feign.Decoder，feign.Encoder，feign.Contract等。</p><p>Feign提供的默认bean实现及说明</p><table><thead><tr><th align="center">Bean类型</th><th align="center">默认实现类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Decoder</td><td align="center">ResponseEntityDecoder</td><td align="center">ResponseEntityDecoder封装了SpringDecoder，解码器，将服务的响应消息进行解码</td></tr><tr><td align="center">Encoder</td><td align="center">SpringEncoder</td><td align="center">编码器</td></tr><tr><td align="center">Logger</td><td align="center">Slf4jLogger</td><td align="center">日志框架</td></tr><tr><td align="center">Contract</td><td align="center">SpringMvcContract</td><td align="center">支持注解契约，使用SpringMvcContract可以对Spring MVC注解提供支持</td></tr><tr><td align="center">Feign.Builder</td><td align="center">HystrixFeign.Builder</td><td align="center">使用断路器来装饰Feign接口</td></tr><tr><td align="center">Client</td><td align="center">LoadBalancerFeignClient</td><td align="center">如果是ribbon则  LoadBalancerFeignClient， 如果是spring cloud LoadBalancer 则  FeignBlockingLoadBalancerClient，默认ribbon</td></tr></tbody></table><p>跟Ribbon类似，可以通过配置类来自定义Feign客户端，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>, configuration = CustomConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">StoreClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>, <span class="string">"password"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样Feign客户端就包含了FeignClientsConfiguration 与CustomConfiguration 中定义的组件，并且后者会覆盖前者（即自定义配置的优先级高于默认配置）。</p><blockquote><p>自定义配置类不需要加注解@Configuration，如果加了且被@ComponentScan扫描到，则将成为所有Feign客户端的默认配置</p></blockquote><p>同样Feign客户端也支持通过配置文件来配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">            <span class="attr">feignName:</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line">                <span class="attr">errorDecoder:</span> <span class="string">com.example.SimpleErrorDecoder</span></span><br><span class="line">                <span class="attr">retryer:</span> <span class="string">com.example.SimpleRetryer</span></span><br><span class="line">                <span class="attr">requestInterceptors:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">com.example.FooRequestInterceptor</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">com.example.BarRequestInterceptor</span></span><br><span class="line">                <span class="attr">decode404:</span> <span class="literal">false</span></span><br><span class="line">                <span class="attr">encoder:</span> <span class="string">com.example.SimpleEncoder</span></span><br><span class="line">                <span class="attr">decoder:</span> <span class="string">com.example.SimpleDecoder</span></span><br><span class="line">                <span class="attr">contract:</span> <span class="string">com.example.SimpleContract</span></span><br></pre></td></tr></table></figure><p>对于应用于所有Feign客户端的全局默认配置，也可以通过两种方式</p><ol><li>通过@EnableFeignClients 的defaultConfiguration 属性指定默认配置类</li><li>在配置文件中通过名称为default的配置实现<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">            <span class="attr">default:</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">loggerLevel:</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure></li></ol><p>优先级同Ribbon， 配置文件&gt;自定义配置类&gt;默认的FeignClientsConfiguration</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>本文案例演示基于前面搭建的springcloud-eureka 与 springcloud-eureka-client 两个示例项目。</p><ol><li><p>新建springcloud-feign项目，pom.xml中加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-cloud-starter-openfeign 包含了spring-cloud-starter-netflix-ribbon 与 spring-cloud-starter-loadbalancer。</p></li><li><p>启动类加上@EnableFeignClients 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义Feign client（feign client支持继承）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"hello-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> <span class="keyword">extends</span> <span class="title">BaseHelloClient</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello/param"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@SpringQueryMap QueryParam param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用Feign client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloClient helloClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"feign"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">feignTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"调用Hello-service返回： "</span> + helloClient.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"feign/param"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">feignTestParam</span><span class="params">(QueryParam param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"调用Hello-service返回： "</span> + helloClient.hello(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>依次启动三个项目，调用<a href="http://localhost:8083/feign" target="_blank" rel="noopener">http://localhost:8083/feign</a> 能正常返回调用hello-service的结果。</p><p>本示例项目还通过@SrpingQueryMap 注解实现了Feign对 pojo用于GET请求参数的支持。如果不加@SrpingQueryMap， 则pojo参数是无法通过Feign client传递的，可去掉注解自行验证下。</p><h2 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h2><ol><li><p>如果需要定制化产生的查询参数map，可以实现并注入一个自定义的 QueryMapEncoder bean</p></li><li><p>Feign client的日志可通过feign client接口的全路径名进行配置，如logging.level.project.user.UserClient: DEBUG，默认为NONE（即不打印日志）。全局设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可设置的level值</p></li></ol><ul><li>NONE： 不记录日志 ，默认</li><li>BASIC：只记录请求方法，url，以及响应状态码与执行时间</li><li>HEADERS：包括BASIC与请求、响应头</li><li>FULL：包括请求与响应的headers，body，metadata</li></ul><ol start="3"><li><p>Feign默认使用Ribbon来做负载均衡，可通过配置spring.cloud.loadbalancer.ribbon.enabled=false 来使用spring cloud loadbalancer（目前Ribbon处于维护状态，近期内不做更新）</p></li><li><p>可通过配置feign.okhttp.enabled=true 或 feign.httpclient.enabled=true 来使用OkHttpClient 或ApacheHttpClient， 默认使用的是JDK 原生的URLConnection 发送HTTP请求，没有连接池</p></li><li><p>如果需要在RequestInterceptor 中使用ThreadLocal中的变量， 那么要么禁用Hystrix，要么设置hystrix的线程隔离策略为SEMAPHORE</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">    <span class="attr">hystrix:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">            <span class="attr">execution:</span></span><br><span class="line">                <span class="attr">isolation:</span></span><br><span class="line">                    <span class="attr">strategy:</span> <span class="string">SEMAPHORE</span></span><br></pre></td></tr></table></figure></li><li><p>使用有Hystrix fallback的Feign时，会在ApplicationContext中存在多个同类型bean， 导致@Autowired 失效。为了解决这个问题，Spring cloud netflix 将所有feign实例标为@Primary，如果要关闭该特性， 可将@FeignClient的 primary属性置为false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello"</span>, primary = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">本文示例代码</a></p><br>认真生活，快乐分享欢迎关注微信公众号：空山新雨的技术空间![微信公众号](/assets/qrcode-05.jpg) ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文介绍了实现客户端负载均衡的Ribbon，但直接使用Ribbon的API来实现服务间的调用相对较为繁琐，服务间的调用能否像本地接口调用一样便捷、透明，更符合编程习惯呢？ Feign就是用来干这事的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（二）：Web服务客户端之Ribbon</title>
    <link href="http://blog.jboost.cn/springcloud-2.html"/>
    <id>http://blog.jboost.cn/springcloud-2.html</id>
    <published>2020-01-14T05:04:40.000Z</published>
    <updated>2020-01-15T08:59:16.159Z</updated>
    
    <content type="html"><![CDATA[<p>上文介绍了服务如何通过Eureka实现注册，以及如何从Eureka获取已经注册的服务列表。那么拿到注册服务列表后， 如何进行服务调用？一个简单的实现是可以从被调用服务的实例列表中选择一个服务实例，通过其hostname（或IP），端口，及API的路径拼接成完整的url，通过http client来完成调用。但生产环境中，为了高性能、高可用等要素，服务的调用一般涉及负载均衡、故障转移、失败重试等实现，因此引入实现这些功能的客户端组件也成为了微服务架构中的必备要素。Spring Cloud中可通过Ribbon与Feign来实现服务间的调用。</p><p>本系列文章与示例均基于最新的Spring Cloud Hoxton版编写。</p><a id="more"></a><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>Ribbon是一个可实现负载均衡的Web客户端。我们一般理解的负载均衡是在服务端实现的，如Nginx（但这都是相对的，如果相对后端服务来说，也可以把Nginx当做一个实现了负载均衡的客户端）， 而Ribbon是客户端的负载均衡实现。</p><p>Ribbon的核心概念是命名的客户端（named client），Spring Cloud会为每个命名客户端创建一个子应用上下文（ApplicationContext），在该上下文中，通过RibbonClientConfiguration创建ILoadBalancer，RestClient，ServerListFilter等Bean。</p><p>Spring Cloud Netflix提供的默认的Ribbon bean及说明</p><table><thead><tr><th align="center">Bean类型</th><th align="center">默认实现类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">IClientConfig</td><td align="center">DefaultClientConfigImpl</td><td align="center">Ribbon客户端配置加载实现，加载各实现bean及客户端连接超时、通讯超时等配置</td></tr><tr><td align="center">IRule</td><td align="center">ZoneAvoidanceRule</td><td align="center">基于zone与可用性来过滤服务器的规则实现</td></tr><tr><td align="center">IPing</td><td align="center">DummyPing</td><td align="center">判断服务器是否存活的实现，默认总是返回true</td></tr><tr><td align="center">ServerList<Server></td><td align="center">ConfigurationBasedServerList</td><td align="center">获取服务器列表的实现，默认基于配置</td></tr><tr><td align="center">ServerListFilter<Server></td><td align="center">ZonePreferenceServerListFilter</td><td align="center">服务器过滤实现，默认过滤出与客户端在同一个zone中的服务器列表</td></tr><tr><td align="center">ILoadBalancer</td><td align="center">ZoneAwareLoadBalancer</td><td align="center">负载均衡实现，默认根据zone的请求负载量排除掉负载最高的zone，从剩下的zone中选择一个根据给定的Rule选择其中一个服务器</td></tr><tr><td align="center">ServerListUpdater</td><td align="center">PollingServerListUpdater</td><td align="center">动态的服务器列表更新器</td></tr></tbody></table><p>Spring Cloud允许我们通过声明一个configuration来对客户端进行自定义，来调整或覆盖上述默认实现，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"custom"</span>, configuration = CustomConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TestConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，客户端将由RibbonClientConfiguration 与 CustomConfiguration中定义的组件一起组成，且CustomConfiguration 中的组件会覆盖前者。</p><blockquote><p>注意CustomConfiguration 必须是@Configuration 修饰的类，且不能被main application context的 @ComponentScan 扫描，否则会被所有@RibbonClients 共享</p></blockquote><p>如果要为所有Ribbon Clients定制默认配置，则可使用@RibbonClients 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients</span>(defaultConfiguration = DefaultRibbonConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RibbonClientDefaultConfigurationTestsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过配置属性来定制Ribbon Client，支持的配置属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NFLoadBalancerClassName: ILoadBalancer接口实现类</span><br><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NFLoadBalancerRuleClassName: IRule接口实现类</span><br><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NFLoadBalancerPingClassName: IPing接口实现类</span><br><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NIWSServerListClassName: ServerList接口实现类</span><br><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NIWSServerListFilterClassName: ServerListFilter接口实现类</span><br></pre></td></tr></table></figure><p>比如对于一个服务名称为users的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">users:</span></span><br><span class="line">    <span class="attr">ribbon:</span></span><br><span class="line">        <span class="attr">NIWSServerListClassName:</span> <span class="string">com.netflix.loadbalancer.ConfigurationBasedServerList</span></span><br><span class="line">        <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.WeightedResponseTimeRule</span></span><br></pre></td></tr></table></figure><p>配置属性的优先级 &gt; configuration指定配置类的优先级 &gt; 默认RibbonClientConfiguration的优先级， 即同样的实现，前者覆盖后者。</p><p>当Eureka与Ribbon同时存在时，ribbonServerList会被 DiscoveryEnabledNIWSServerList覆盖，从Eureka来获取server list，同时 NIWSDiscoveryPing也会替换IPing接口，代理Eureka来确定服务器是否处于运行状态。</p><p>Ribbon的超时与重试配置</p><ul><li>&lt;clientName&gt;.ribbon.ConnectTimeout： 请求连接超时时间，默认2000</li><li>&lt;clientName&gt;.ribbon.ReadTimeout： 请求处理超时时间，默认5000</li><li>&lt;clientName&gt;.ribbon.MaxAutoRetries： 在同一台服务器上的重试次数，排除第一次调用，默认0</li><li>&lt;clientName&gt;.ribbon.MaxAutoRetriesNextServer： 切换服务器的重试次数，默认1</li><li>&lt;clientName&gt;.ribbon.OkToRetryOnAllOperations： 对所有请求都进行重试，默认false</li></ul><p>当项目中添加了Spring Retry的依赖，则会启用重试机制。当请求失败时，会再尝试访问当前服务器（次数由MaxAutoRetries配置），如果不行，就换一个服务器进行访问，如果还是不行，再换服务器访问（更换次数由MaxAutoRetriesNextServer配置），如果还是不行，则返回请求失败。</p><h2 id="Ribbon的负载均衡策略"><a href="#Ribbon的负载均衡策略" class="headerlink" title="Ribbon的负载均衡策略"></a>Ribbon的负载均衡策略</h2><p>前文提到Ribbon的负载均衡默认实现为ZoneAwareLoadBalancer，那么Ribbon提供的负载均衡策略还有哪些？ 罗列如下</p><ul><li>BestAvailableRule： 排除掉断路器打开的服务器，选取并发请求最小的服务器</li><li>AvailabilityFilteringRule： 过滤掉断路器打开或活跃连接数超过限制（通过&lt;clientName&gt;.&lt;nameSpace&gt;.ActiveConnectionsLimit配置，默认为Integer.MAX_VALUE）的服务器</li><li>WeightedResponseTimeRule: 根据平均响应时间来动态为服务器赋予权值，实现基于权重的轮询</li><li>RetryRule： 对选择负载均衡策略添加重试机制</li><li>RoundRobinRule： 简单轮询</li><li>RandomRule： 随机轮询</li><li>ZoneAvoidanceRule： 结合区域与可用性来选择服务器，也是默认实现</li></ul><p>可通过如下配置修改Ribbon的负载均衡策略</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-name:</span></span><br><span class="line">    <span class="attr">ribbon:</span></span><br><span class="line">        <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.WeightedResponseTimeRule</span></span><br></pre></td></tr></table></figure><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>本文案例演示基于上文搭建的springcloud-eureka 与 springcloud-eureka-client 两个示例项目 （<a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">源码</a>），依次启动两个项目，然后将springcloud-eureka-client项目的端口 server.port改为8081，新开一个springboot运行配置，如图</p><p><img src="/assets/eureka-client2.png" alt="Eureka客户端2"></p><p>以8081端口再起一个springcloud-eureka-client的服务实例。这是查看Eureka页面 <a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a>, 可以看到hello-service服务注册了两个实例</p><p><img src="/assets/hello-service.png" alt="hello服务注册"></p><p>新建springcloud-ribbon项目 （<a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">源码</a>）</p><p>pom.xml中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写测试接口， LoadBalanceClient 是Ribbon的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"ribbon"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRibbon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServiceInstance instance = loadBalancer.choose(<span class="string">"hello-service"</span>);</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"http://%s:%s"</span>, instance.getHost(),</span><br><span class="line">                instance.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动springcloud-ribbon， 调用测试接口 <a href="http://localhost:8082/ribbon，" target="_blank" rel="noopener">http://localhost:8082/ribbon，</a> 可以看到返回结果交替显示 <a href="http://CN-201911061714:8080，">http://CN-201911061714:8080，</a> <a href="http://CN-201911061714:8081" target="_blank" rel="noopener">http://CN-201911061714:8081</a>  （CN-201911061714是我电脑的hostname，你的可能不一样），可见Ribbon实现了客户端的负载均衡。</p><h2 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h2><ol><li><p>Ribbon如果对所有请求进行重试，则需要保证接口的幂等性（多次调用产生的结果是一致的）</p></li><li><p>每一个命名的Ribbon客户端都有一个相应的由Spring cloud维护的子应用上下文，默认是lazy load的（第一次请求客户端时才load），可以通过如下配置更改为启动立即加载</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">eager-load:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">clients:</span> <span class="string">client1,</span> <span class="string">client2,</span> <span class="string">client3</span></span><br></pre></td></tr></table></figure></li><li><p>client.ribbon.*  针对单个客户端进行配置，针对所有客户端默认配置，则使用ribbon.*</p></li><li><p>当结合断路器使用时， 断路器的超时时间要大于Ribbon的超时时间，不然不会触发重试（还没重试就触发断路器打开了）</p></li><li><p>除了Ribbon，能做负载均衡访问的Web客户端还有@LoadBalance 注解的RestTemplate， 与Feign</p></li></ol><p><a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">本文示例代码</a></p><br>认真生活，快乐分享欢迎关注微信公众号：空山新雨的技术空间![微信公众号](/assets/qrcode-05.jpg) ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文介绍了服务如何通过Eureka实现注册，以及如何从Eureka获取已经注册的服务列表。那么拿到注册服务列表后， 如何进行服务调用？一个简单的实现是可以从被调用服务的实例列表中选择一个服务实例，通过其hostname（或IP），端口，及API的路径拼接成完整的url，通过http client来完成调用。但生产环境中，为了高性能、高可用等要素，服务的调用一般涉及负载均衡、故障转移、失败重试等实现，因此引入实现这些功能的客户端组件也成为了微服务架构中的必备要素。Spring Cloud中可通过Ribbon与Feign来实现服务间的调用。&lt;/p&gt;
&lt;p&gt;本系列文章与示例均基于最新的Spring Cloud Hoxton版编写。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
</feed>
