<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空山新雨的技术空间</title>
  
  <subtitle>技术与管理兼修，空山新雨，勃勃生机</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jboost.cn/"/>
  <updated>2019-08-22T03:37:23.347Z</updated>
  <id>http://blog.jboost.cn/</id>
  
  <author>
    <name>空山新雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s云集群混搭模式，可能帮你节省50%的服务成本</title>
    <link href="http://blog.jboost.cn/mix-eci.html"/>
    <id>http://blog.jboost.cn/mix-eci.html</id>
    <published>2019-08-21T07:32:30.000Z</published>
    <updated>2019-08-22T03:37:23.347Z</updated>
    
    <content type="html"><![CDATA[<p>现在大部分中小企业或团队都是使用云平台来部署自己的服务，如阿里云，亚马逊云等。一般来说，业务的负载都具备一定的规律，比如每天集中在某几个小时，或呈现时间段周期性波峰、波谷交替的现象，如下图<br><img src="/assets/load-trend.png" alt="业务负载周期性"></p><p>如果使用ECS来部署服务，则可能大部分时间ECS的资源没有得到充分利用，造成成本浪费，尤其对于像GPU之类成本较高的资源就更加了。这个时候，我们可以考虑使用云集群的混搭模式来节约成本。</p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>假设有一个这样的业务场景，包括如下特点及要求：</p><ol><li>整个系统包括业务服务与两层视觉服务</li><li>各层服务之间调用需做负载均衡</li><li>每天的业务量主要集中在上午几个小时</li><li>平时业务量较低时仍要保证服务可用</li><li>尽可能降低成本，尤其是GPU服务器成本（GPU贵啊）</li></ol><p><img src="/assets/biz-top.png" alt="业务部署架构"></p><h2 id="k8s云集群混搭模式"><a href="#k8s云集群混搭模式" class="headerlink" title="k8s云集群混搭模式"></a>k8s云集群混搭模式</h2><p>现在各大云平台都已经提供容器云服务，如阿里云有基于ECI（弹性容器实例）的Serverless Kubernetes集群服务，基于ECS节点不需要提供master的Kubernetes托管版集群服务，及自己提供master的Kubernetes专有版集群服务等。为了迎合类似上述业务场景的需求，也提供了Kubernetes + virtual node（虚拟节点）的混合集群服务，如下图所示</p><p><img src="/assets/k8s-vn.png" alt="k8s-vn"></p><p>其中的虚拟节点基于ECI支持多种功能，如GPU容器实例、大规格容器实例等，增强了Kubernetes集群的弹性，使集群不局限于ECS节点的资源，做到弹性无限扩容。</p><h2 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h2><p>结合前面的业务场景，我们可以采用k8s的混合集群服务来部署我们的项目，如下图</p><p><img src="/assets/biz-deploy.png" alt="biz-deploy"></p><p>实现步骤：</p><ol><li>创建Kubernetes托管版集群</li><li>加入已有ECS节点</li><li>添加一个虚拟节点，通过添加应用 ack-virtual-node 来实现</li><li>分别创建无状态的业务Deployment、AI-1 Deployment、AI-2 Deployment（对应三层服务）</li><li>分别在业务Deployment上创建公网SLB，AI-1 Deployment、AI-2 Deployment上创建内网SLB</li><li>分别在各Deployment上根据CPU或内存使用阈值配置弹性水平伸缩HPA</li><li>根据需要可以在某个或某些Deployment上配置定时伸缩，通过添加应用 ack-kubernetes-cronhpa-controller 来实现</li></ol><blockquote><p>因为水平伸缩一般需要一定时间，延迟可能会对业务造成影响，所以在业务负载比较规律的时候，可以通过定时伸缩（就是定时扩展到多少个容器，再定时收缩到多少个容器）来改善；目前定时伸缩配置的查看与更新只能通过kubectl命令行进行。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按照官方文档的计费方式，一个普通的2核8G的ECS一年大概费用是2600左右，如果通过容器服务的方式（按秒计费），假设每天起8小时，则一年大概费用1550左右，如果业务负载再集中到几个小时，费用会更低，对于比较稀缺又昂贵的GPU服务就更加了。因此对于业务负载具有一定规律的服务来说，采用这种部署方式将极大地降低你的云服务成本。不过目前k8s云集群服务应该推出时间不久，产品的易用性还比较低，对不具备一定容器与编排基础的人使用门槛相对较高。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在大部分中小企业或团队都是使用云平台来部署自己的服务，如阿里云，亚马逊云等。一般来说，业务的负载都具备一定的规律，比如每天集中在某几个小时，或呈现时间段周期性波峰、波谷交替的现象，如下图&lt;br&gt;&lt;img src=&quot;/assets/load-trend.png&quot; alt=&quot;
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>小技巧：如何自定义logback日志文件的名称</title>
    <link href="http://blog.jboost.cn/trick-logback-prop.html"/>
    <id>http://blog.jboost.cn/trick-logback-prop.html</id>
    <published>2019-08-20T09:42:28.000Z</published>
    <updated>2019-08-20T11:04:34.498Z</updated>
    
    <content type="html"><![CDATA[<p>在logback.xml中获取自定义变量值。<br><a id="more"></a></p><p>我们可以通过在logback.xml中配置appender来指定日志输出格式及输出文件路径，这在一台主机或一个文件系统上部署单个实例没有问题，但是如果部署多个实例（比如通过容器的方式），多个实例同时往同一文件写日志可能就会引起问题。这时可以将每个实例的日志文件加以区分，如IP或UUID，或两者结合的形式。</p><p>可以有4种方式来实现logback.xml中获取自定义变量值：</p><ol><li>通过设置环境变量或传递系统属性（比如在程序启动时通过-D传递）的方式，两者是可以直接在logback.xml中通过 <code>${变量名}</code> 获取的。</li><li>自定义logback.xml的加载时机，在其加载前将需要设置的属性注入到logback的context中，这种方式相对复杂，本文不讨论。</li><li>通过实现PropertyDefiner接口来提供属性值设置</li><li>通过实现LoggerContextListener接口来设置属性值</li></ol><p>第一种方式简单，但不能通过程序生成属性值，第二种方式稍显复杂，本文主要介绍后两种方式。</p><h2 id="PropertyDefiner方式"><a href="#PropertyDefiner方式" class="headerlink" title="PropertyDefiner方式"></a>PropertyDefiner方式</h2><p>首先定义一个类，实现PropertyDefiner接口，可以通过继承PropertyDefinerBase会更方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.core.PropertyDefinerBase;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 将本地IP拼接到日志文件名中，以区分不同实例，避免存储到同一位置时的覆盖冲突问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20 16:17   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPLogDefiner</span> <span class="keyword">extends</span> <span class="title">PropertyDefinerBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(IPLogDefiner.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUniqName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String localIp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            localIp = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">"fail to get ip..."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        String uniqName = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (localIp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqName = localIp + <span class="string">"-"</span> + uniqName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPropertyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getUniqName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现方法 <code>getPropertyValue</code> 中返回你需要生成的值，本例中是返回 <code>本地IP-UUID</code> 的形式。</p><p>然后在logback.xml中，添加 <code>&lt;define&gt;</code> 配置，指定属性名（本例中为localIP）及获取属性值的实现类，这样就可以在配置中通过 <code>${localIP}</code>来引用该属性值了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">define</span> <span class="attr">name</span>=<span class="string">"localIP"</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.IPLogDefiner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLogFile"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>D:\\logs\\elk\\interface-$&#123;localIP&#125;.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"># 省略了其它配置</span><br></pre></td></tr></table></figure></p><h2 id="LoggerContextListener方式"><a href="#LoggerContextListener方式" class="headerlink" title="LoggerContextListener方式"></a>LoggerContextListener方式</h2><p>定义一个实现LoggerContextListener接口的类，在start方法中，将需要设置的属性设置到logback的Context中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Level;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.spi.LoggerContextListener;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.Context;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.spi.ContextAwareBase;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.spi.LifeCycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 第二种实现方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20 18:45   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerStartupListener</span> <span class="keyword">extends</span> <span class="title">ContextAwareBase</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LoggerContextListener</span>, <span class="title">LifeCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (started) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        context.putProperty(<span class="string">"localIP"</span>, getUniqName());</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUniqName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String localIp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            localIp = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">//LOG.error("fail to get ip...", e);</span></span><br><span class="line">        &#125;</span><br><span class="line">        String uniqName = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (localIp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqName = localIp + <span class="string">"-"</span> + uniqName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//省略了其它函数</span></span><br></pre></td></tr></table></figure><p>然后在logback.xml中，配置如上监听器类，这样就可以通过 <code>${localIP}</code> 获取到上面 <code>context.putProperty(&quot;localIP&quot;, getUniqName());</code> 设置的值了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;define name="localIP" class="com.cnbot.common.IPLogDefiner"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextListener</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.LoggerStartupListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">define</span> <span class="attr">name</span>=<span class="string">"localIP"</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.IPLogDefiner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLogFile"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>D:\\logs\\elk\\interface-$&#123;localIP&#125;.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"># 省略了其它配置</span><br></pre></td></tr></table></figure></p><p>这种方式能设置任意个数的属性值，比前一种方式灵活。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在logback.xml中获取自定义属性值，主要是需要在加载前将对应的属性值进行设置，这样加载时才能有效获取。本文虽是自定义日志文件名称，但不局限于此，所有需要动态获取的变量都可以按这种方式实现。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在logback.xml中获取自定义变量值。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（八）：数据管理</title>
    <link href="http://blog.jboost.cn/docker-8.html"/>
    <id>http://blog.jboost.cn/docker-8.html</id>
    <published>2019-08-12T08:50:37.000Z</published>
    <updated>2019-08-12T13:01:44.281Z</updated>
    
    <content type="html"><![CDATA[<p>前面（哪个前面我也忘了）有说过，如果我们需要对数据进行持久化保存，不应使其存储在容器中，因为容器中的数据会随着容器的删除而丢失，而因通过将数据存储于宿主机文件系统的形式来持久化。在Docker容器中管理数据主要有数据卷、宿主机目录挂载两种方式<br><a id="more"></a></p><h2 id="1-数据卷的方式"><a href="#1-数据卷的方式" class="headerlink" title="1. 数据卷的方式"></a>1. 数据卷的方式</h2><p>数据卷是一个特殊的文件目录（或文件），具备如下特性：</p><ol><li>可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>数据卷的更新，不会影响到镜像</li><li>数据卷默认会一直存在，不会随容器的删除而消亡</li></ol><h3 id="1-1-创建数据卷"><a href="#1-1-创建数据卷" class="headerlink" title="1.1 创建数据卷"></a>1.1 创建数据卷</h3><p>可以使用<code>docker volume create 数据卷名称</code>的命令来创建一个数据卷，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume create volume1</span><br><span class="line">volume1</span><br></pre></td></tr></table></figure></p><h3 id="1-2-查看数据卷"><a href="#1-2-查看数据卷" class="headerlink" title="1.2 查看数据卷"></a>1.2 查看数据卷</h3><p>创建完后，这个数据卷具体对应宿主机哪个文件目录在上面是没法得知的，可以通过<code>docker volume inspect 数据卷名称</code>来查看，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume inspect volume1</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "CreatedAt": "2019-08-12T19:43:47+08:00",</span><br><span class="line">        "Driver": "local",</span><br><span class="line">        "Labels": &#123;&#125;,</span><br><span class="line">        "Mountpoint": "/var/lib/docker/volumes/volume1/_data",</span><br><span class="line">        "Name": "volume1",</span><br><span class="line">        "Options": &#123;&#125;,</span><br><span class="line">        "Scope": "local"</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可以看到数据卷volume1对应的文件目录是“/var/lib/docker/volumes/volume1/_data”。</p><p><code>docker inspect xxx</code>这个命令挺有用的，不论是查看镜像相关信息（<code>docker image inspect 镜像名/镜像ID</code>），还是查看容器相关信息（<code>docker container inspect 容器名/容器ID</code>），都可以使用，其中的image,container,volume是可以省略的，只要xxx部分不冲突就行。</p><p>可以通过<code>docker volume ls</code> 命令来查看所有数据卷，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               volume1</span><br></pre></td></tr></table></figure></p><h3 id="1-3-使用数据卷"><a href="#1-3-使用数据卷" class="headerlink" title="1.3 使用数据卷"></a>1.3 使用数据卷</h3><p>可以在启动容器时通过 -v 或 –mount 的方式将一个数据卷挂载到容器的某个目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu1 -v volume1:/vol1 ubuntu:18.04</span><br><span class="line">b060e793d44de2ca871da257b47598334658952943a13d1c478df5c3ae91a01c</span><br></pre></td></tr></table></figure></p><p>按照 <code>-v 数据卷名:容器目录</code> 的格式，也可以使用 –mount 按照 <code>--mount source=数据卷名,target=容器目录</code> 的格式，如我们再启动一个挂载相同数据卷的容器 ubuntu2，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount source=volume1,target=/vol2 ubuntu:18.04</span><br><span class="line">b30971f8a4bbadee10774fce0b4568b5b7b1c9cde36f4bf84ac911a4cdaf6c8d</span><br></pre></td></tr></table></figure></p><p>可以在数据卷所在目录中创建一个文件来看看效果，先创建文件 hello.txt<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# cd /var/lib/docker/volumes/volume1/_data</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ _data]# touch hello.txt</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ _data]# ls</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>然后通过<code>docker exec</code>来查看容器ubuntu1目录/vol1，及容器ubuntu2目录/vol2的内容<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu1 ls /vol1</span><br><span class="line">hello.txt</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu2 ls /vol2</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>可以看到通过挂载目录 /vol1， /vol2 都可以访问到数据卷volume1对应目录下的内容。这就像linux的软链接一样，将容器目录链接到了数据卷目录。并且上述示例也说明，同一个数据卷是可以在被多个容器共享的。</p><p>数据卷的共享也可以通过 <code>volumes-from 容器名称/容器ID</code> 参数来实现，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu3 --volumes-from ubuntu2 ubuntu:18.04</span><br><span class="line">bb5c6d61a1e6eeb18ba8c889e471b2f3215f97efca79b311eeca5968b2700df8</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu3 ls /vol2</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>通过<code>--volumes-from ubuntu2</code>来直接使用ubuntu2挂载的容器配置。</p><h3 id="1-4-删除数据卷"><a href="#1-4-删除数据卷" class="headerlink" title="1.4 删除数据卷"></a>1.4 删除数据卷</h3><p>数据卷不会随着容器的删除而自动删除。<br>如果一个数据卷还被某个容器使用，则不能删除；<br>如果一个数据卷只被一个容器使用，则可在删除容器时通过指定 <code>-v</code> 参数同时删除其挂载的数据卷；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker rm -v ubuntu3</span><br><span class="line">ubuntu3</span><br></pre></td></tr></table></figure></p><p>可以通过 <code>docker volume rm 数据卷名称</code> 来删除某个数据卷；<br>可以通过 <code>docker volume prune</code> 清理掉所有未被任何容器使用的数据卷。</p><h2 id="2-宿主机目录挂载方式"><a href="#2-宿主机目录挂载方式" class="headerlink" title="2. 宿主机目录挂载方式"></a>2. 宿主机目录挂载方式</h2><p>在容器启动时，使用 <code>-v 宿主机目录:容器目录</code> 或 <code>--mount type=bind,source=宿主机目录,target=容器目录</code>的参数格式指定将宿主机目录挂载到容器目录上。宿主机目录必须是绝对路径。两者之间的区别是 <code>-v</code> 如果在宿主机目录不存在时会自动创建目录，而<code>--mount</code>不会。如，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu1 -v /root/v1:/vol1 ubuntu:18.04</span><br><span class="line">25c91911709eebc9290b47b483666f7b7be840df947117f7cad323583905b9f1</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount type=bind,source=/root/v2,target=/vol1 ubuntu:18.04</span><br><span class="line">docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /root/v2.</span><br><span class="line">See 'docker run --help'.</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# mkdir /root/v2</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount type=bind,source=/root/v2,target=/vol1 ubuntu:18.04</span><br><span class="line">5a57285e9261d048dc71cf0476055a290f80538afff2cefd2a24f8b4468b5171</span><br></pre></td></tr></table></figure></p><p>/root/v1,/root/v2都没有事先创建，用 <code>-v</code> 不会报错，会自动创建； <code>--mount</code>则会报错，目录必须先存在。</p><p>docker不仅支持目录的挂载，也支持文件的挂载，如，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run --rm -it -v $HOME/.bash_history:/root/.bash_history ubuntu:18.04 bash </span><br><span class="line">root@3ae4ed4e687d:/# history</span><br><span class="line">    1  ll webapps/</span><br><span class="line">    2  ll confluence/images/</span><br></pre></td></tr></table></figure></p><p>通过将宿主机当前用户的历史操作文件挂载到容器的root用户下的历史操作文件，可在容器中通过<code>history</code>命令查看到宿主机的操作历史。</p><p>可通过 <code>docker inspect</code>来查看容器的挂载情况<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker inspect ubuntu1</span><br><span class="line">--省略了其它信息--</span><br><span class="line">"Mounts": [</span><br><span class="line">            &#123;</span><br><span class="line">                "Type": "bind",</span><br><span class="line">                "Source": "/root/v1",</span><br><span class="line">                "Destination": "/vol1",</span><br><span class="line">                "Mode": "",</span><br><span class="line">                "RW": true,</span><br><span class="line">                "Propagation": "rprivate"</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">--省略了其它信息--</span><br></pre></td></tr></table></figure></p><p>可在“Mounts”部分看到挂载信息。</p><h2 id="3-只读控制"><a href="#3-只读控制" class="headerlink" title="3. 只读控制"></a>3. 只读控制</h2><p>有时候，为了数据安全，我们不允许容器对挂载目录的内容进行修改，即对容器来说，挂载目录是只读的，这可以通过在挂载参数后面加限制实现。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu3 -v /root/v1:/vol1:ro ubuntu:18.04</span><br><span class="line">25eca348ed307afcbef92bc03f0a1304b31b52e6db1fa07772b5dbd1040ff7b6</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu3 bash</span><br><span class="line">root@25eca348ed30:/# touch /vol1/hello.txt</span><br><span class="line">touch: cannot touch '/vol1/hello.txt': Read-only file system</span><br></pre></td></tr></table></figure></p><p><code>-v</code>是在后面加<code>ro</code>（read-only），<code>--mount</code>则是形如<code>--mount type=bind,source=宿主机目录,target=容器目录,read only</code>的格式，可自行试验。<br>加了read only的挂载我们再通过<code>docker inspect</code>命令查看，可看到两者之间的差异 —— Mode与RW的值。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">            &#123;</span><br><span class="line">                "Type": "bind",</span><br><span class="line">                "Source": "/root/v1",</span><br><span class="line">                "Destination": "/vol1",</span><br><span class="line">                "Mode": "ro",</span><br><span class="line">                "RW": false,</span><br><span class="line">                "Propagation": "rprivate"</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>如果要对数据进行持久化管理或在容器之间共享数据，则需要将数据通过数据卷或宿主机目录（或文件）挂载的方式来将数据存储于宿主机上，使得数据的生命周期独立于容器的生命周期。这类似于我们不要把重要文件放在系统盘，而应放在其它数据盘一样，因为系统盘会由于重装系统或系统故障导致文件丢失。本文对Docker的数据管理进行了整理，后续对Docker的网络配置管理部分进行整理，欢迎持续关注。</p><p><br><br>我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面（哪个前面我也忘了）有说过，如果我们需要对数据进行持久化保存，不应使其存储在容器中，因为容器中的数据会随着容器的删除而丢失，而因通过将数据存储于宿主机文件系统的形式来持久化。在Docker容器中管理数据主要有数据卷、宿主机目录挂载两种方式&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>就业，该去小公司还是大公司？</title>
    <link href="http://blog.jboost.cn/company-choice.html"/>
    <id>http://blog.jboost.cn/company-choice.html</id>
    <published>2019-08-09T05:29:58.000Z</published>
    <updated>2019-08-12T04:00:24.375Z</updated>
    
    <content type="html"><![CDATA[<p>前几天跟一朋友交流，他说一个表弟明年就要毕业了，马上面临找工作，是去一线城市找大公司的工作好，还是留在二线城市中小公司发展好。我说，去大公司好。为什么会有这个结论，这篇文章结合自己的经历说说我的一些感受。<br><a id="more"></a></p><p>我的第一份工作是在一家外企，当时抱着“逃离”上海的想法去了二线城市的分公司，但是管理文化氛围跟总部几乎都是一样的，这份工作经历对我后面的工作不论是做事风格、习惯上还是思考问题的方式方法上都有很大的影响。后面陆续进入国企，民企，再进入初创公司，从公司规模上可以说各种类型的都有过体验。下面从环境因素，平台效应因素等几个角度说说自己的感受。</p><h2 id="环境因素"><a href="#环境因素" class="headerlink" title="环境因素"></a>环境因素</h2><p>环境对一个人的影响还是很重要的，不论是大家熟知的“近朱者赤近墨者黑”的说法，还是令我们中国人挤破脑袋的“学区房”现象，都说明环境对一个人的成长起着至关重要的作用。</p><p>小公司与大公司的环境差异首先体现在人员的素养、水平上。大公司的准入门槛相对高一些，所以人员的素质、水平也相对要高一些，如果你周围牛人比较多的话，跟牛人待久了，你也可能慢慢就步入牛人之列了——“近朱者赤”。而小公司，尤其是初创公司，为了尽快招人干活，往往人员的素质、水平会良莠不齐，你可能很难找到一个各方面让你信服，想跟着他学的真正的“牛人”。</p><p>其次在制度、流程规范上。大公司在制度、流程、规范方面相对健全完善，不论是人事管理还是日常合作分工都比较明确，你知道什么时候应该干什么（因为都给你安排好了），处理什么事情应该找谁，都有章可循，有人可找。而在小公司，可能很多人感觉的就一个字——“乱”，人员职责、分工、权限没有明确定义，没有人引导，不知道在什么阶段应该干什么，或者怎么干，明明是个小兵，老板却恨不得你是个全才，啥事都希望你能搞定。有人把在大公司工作比喻是做一颗螺丝钉，而觉得在小公司才能锻炼综合能力，但我觉得在一定的阶段，螺丝钉似的工作才能让你在专业能力上面得到更大的提升，而小公司所谓的综合能力，往往演变的是“打杂”能力，老板为了节约成本，充分发挥（压榨）每个人的能力（价值），往往一人要分饰多角，比如做人事的既要管招聘，又要管行政，甚至还可能被拉去监督项目进度，很难让你在一个专业的领域深度成长。</p><p>再次在产品规模上，大公司产品的日活规模可能少则上百万，多则上亿，不论是在技术实现还是产品运营上，都需要较高的要求与水准，你在其中能学习的技能与套路是小公司日活几千或几万的产品规模无法比拟的。</p><p>最后在文化氛围上，一般大公司都有形成自己的企业文化，包括周围人的工作风格、习惯，都会对你产生潜移默化的影响。比如我现在的不论是写代码，还是写文字，都会反复检查好几遍的习惯就是在第一家公司工作时养成的。因为你的每一行代码你的leader可能都会仔细帮你review，找出有问题的地方让你反复修正直到合格，你的每一封邮件都会被别人（在外企很多时候还包括美国人、印度人）认真查看，所以促使你在发出前会仔细核查是否有遗漏的点，是否存在错别字或语法错误，久而久之，就养成了这种反复检查的比较严谨的做事风格。而在小公司，一般很难在短时间内形成自己的企业文化，很多事情的处理都比较粗放，缺乏对细节的把握，你很难从企业文化氛围上受益。</p><p>如果用游泳来比喻大公司与小公司的差异，我觉得大公司就像是一个掌握各项泳姿、动作标准的游泳运动员，有规范有节奏，从而游得更远；而小公司则更像一个会“狗爬式”的乡下野孩子，虽然路子野，但有效——尽管比较费力，但是能游起来，但能游多远，得看方向对不对，人能不能坚持。</p><h2 id="平台效应因素"><a href="#平台效应因素" class="headerlink" title="平台效应因素"></a>平台效应因素</h2><p>现在有些企业招聘，都明确要求毕业院校必须是985、211，甚至有些岗位直接面向BAT。前不久看到一个案例，上海交大硕博毕业因本科不是211，而被招聘企业直接拒绝。<br><img src="/assets/case-10.jpg" alt="case1">    <img src="/assets/case-11.jpg" alt="case2"></p><p>现实就是这样，看背景，看出身。名企工作与名校毕业一样，对后面的跳槽都会有较大的加分与优势。从小公司跳大公司难，但从大公司跳小公司就容易很多，见过许多阿里系的普通技术人员跳到中小企业做技术管理者的情况。</p><p>名企光环，除了对后面的就业与跳槽方面具备优势，在社会活动上也具备一定的优势，比如现在很多技术书籍，相当一部分出自阿里系，不是说非阿里系的人不具备这个能力，而是因为有着阿里这个名企光环，出的东西更容易被人接受与认可，尽管不一定水平有多好。</p><h2 id="什么人适合去小公司"><a href="#什么人适合去小公司" class="headerlink" title="什么人适合去小公司"></a>什么人适合去小公司</h2><p>毕竟不是每个人都能去大公司，那么什么人适合去小公司呢？我觉得可能主要包括两类，一类是自己在某个领域已经取得了较好的成长，具备了独当一面或者懂得如何带领他人来做事情的能力，这种情况一般是为了追求高薪或对某个领域或公司比较看好，有自己想法的人；另一类是目前还不具备进入大公司的资本与能力的人，人总得工作与生活，所以不得不先进入小公司成长，但这部分人除非自身公司发展特别好，否则还是应该尽力往大公司靠，努力进入大公司体验其管理模式与文化氛围，对你整个职业生涯是有很大帮助的。</p><h2 id="选择什么样的小公司"><a href="#选择什么样的小公司" class="headerlink" title="选择什么样的小公司"></a>选择什么样的小公司</h2><p>选择什么样的小公司比较好，虽然很多时候也没有太多的选择，毕竟好的小公司也是可遇不可求的事情，但如果有的话，我觉得还是尽力选择满足如下四个条件的小公司比较好。</p><ol><li>靠谱的老板。小公司的管理文化与前途基本由老板的品质与能力决定，所以一个有能力、靠谱的老板是第一要素。</li><li>高水平的管理团队，技术、管理、营销各方面。管理团队对于创业公司来说非常重要，只有一个稳定的各方面成熟的团队，成功的几率才会大一点，你在里面能获得的成长空间也更多一些。</li><li>产品项目具备长远发展的潜力。企业经营就是做一个别人愿意花钱购买的产品，并寻找一个将产品源源不断卖不出的方式，所以产品是不是刚需，有没有人买单，能不能长久很重要。</li><li>可靠的资源与渠道。有可靠的资源与渠道，才能将产品源源不断地卖出去，企业才能保持可持续发展。</li></ol><p>以上四点从上往下重要性依次递减，同时满足四个条件的小公司应该是极少的，是可遇不可求的事情，可以按从上往下的重要性进行选择。</p><p>另外进入小公司，可能常见的一个东西是期权，我认为期权是一个美丽的梦，如果以上四点都靠谱，没有期权也能获得很好的锻炼与成长，如果不靠谱，那么就算拿了期权大概率也是一个美丽的梦，看起来很美好，但不会成真的那种，所以面对期权（画饼），也要保持理性。</p><h2 id="职场没有伊甸园"><a href="#职场没有伊甸园" class="headerlink" title="职场没有伊甸园"></a>职场没有伊甸园</h2><p>最后，不论是大公司，还是小公司，都不存在职场的伊甸园，只有自己不断成长，进步，自己强大了，才有更多的选择空间。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天跟一朋友交流，他说一个表弟明年就要毕业了，马上面临找工作，是去一线城市找大公司的工作好，还是留在二线城市中小公司发展好。我说，去大公司好。为什么会有这个结论，这篇文章结合自己的经历说说我的一些感受。&lt;br&gt;
    
    </summary>
    
      <category term="Career" scheme="http://blog.jboost.cn/categories/Career/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker笔记（七）：常用服务安装——Nginx、MySql、Redis</title>
    <link href="http://blog.jboost.cn/docker-7.html"/>
    <id>http://blog.jboost.cn/docker-7.html</id>
    <published>2019-08-07T05:29:45.000Z</published>
    <updated>2019-08-07T10:18:30.564Z</updated>
    
    <content type="html"><![CDATA[<p>开发中经常需要安装一些常用的服务软件，如Nginx、MySql、Redis等，如果按照普通的安装方法，一般都相对比较繁琐 —— 要经过下载软件或源码包，编译安装，配置，启动等步骤，使用 Docker 来安装这些服务软件能极大地简化安装过程，且速度也很快。<br><a id="more"></a></p><p>本文以下操作假定你已经装好了docker，并做好了镜像配置。如果没有，请参考 <a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a></p><h2 id="1-MySql-安装"><a href="#1-MySql-安装" class="headerlink" title="1. MySql 安装"></a>1. MySql 安装</h2><h3 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1 下载镜像"></a>1.1 下载镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull mysql:5.7</span><br></pre></td></tr></table></figure><h3 id="1-2-创建挂载目录"><a href="#1-2-创建挂载目录" class="headerlink" title="1.2 创建挂载目录"></a>1.2 创建挂载目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir -p apps/mysql/conf apps/mysql/data apps/mysql/logs</span><br></pre></td></tr></table></figure><p>如上分别创建了配置文件目录，数据存放目录，以及日志文件目录</p><h3 id="1-3-启动容器实例"><a href="#1-3-启动容器实例" class="headerlink" title="1.3 启动容器实例"></a>1.3 启动容器实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 3306:3306 --name mysql -v /home/devuser/apps/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf -v /home/devuser/apps/mysql/logs:/var/log/mysql -v /home/devuser/apps/mysql/data:/var/lib/mysql --restart=always -e MYSQL_ROOT_PASSWORD=Passw0rd mysql:5.7</span><br></pre></td></tr></table></figure><p>其中<br>-d： 表示在后台运行<br>-p： 宿主机端口与容器端口映射<br>–name： 容器名称<br>-v： 宿主机目录与容器目录映射<br>–restart=always：除非被<code>docker stop</code>命令明确停止，否则一直尝试重启处于停止态的容器；如果Docker重启，也会自动启动容器<br>-e： 设置环境变量，这里设置了mysql root用户的密码为Passw0rd</p><p>如此，MySql服务就跑起来了，很快很简单有木有。</p><h2 id="2-Redis-安装"><a href="#2-Redis-安装" class="headerlink" title="2. Redis 安装"></a>2. Redis 安装</h2><h3 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull redis:5.0.5</span><br></pre></td></tr></table></figure><h3 id="2-2-启动容器"><a href="#2-2-启动容器" class="headerlink" title="2.2 启动容器"></a>2.2 启动容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d --name redis -p 6379:6379 -v /home/devuser/apps/redis/data:/data --restart=always redis:5.0.5 redis-server --appendonly yes --requirepass "Passw1rd"</span><br></pre></td></tr></table></figure><p>-p， -v 与上同，不赘述<br>redis-server –appendonly yes : 在容器启动时执行redis-server命令，并打开redis持久化配置<br>–requirepass： 设置密码</p><h3 id="2-3-连接"><a href="#2-3-连接" class="headerlink" title="2.3 连接"></a>2.3 连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ docker exec -it redis redis-cli -h 172.17.0.4 -p 6379 -a Passw1rd</span><br><span class="line">Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.</span><br><span class="line">172.17.0.4:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">172.17.0.4:6379&gt;</span><br></pre></td></tr></table></figure><p>这种方式把密码暴露了，其它登录用户通过history即可看到密码，不是太安全。可改用如下方式，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~$ docker exec -it redis redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 'Passw1rd'</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><h2 id="3-Nginx-安装"><a href="#3-Nginx-安装" class="headerlink" title="3. Nginx 安装"></a>3. Nginx 安装</h2><h3 id="3-1-拉取镜像"><a href="#3-1-拉取镜像" class="headerlink" title="3.1 拉取镜像"></a>3.1 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull nginx</span><br></pre></td></tr></table></figure><p>会拉取最新的（latest）镜像</p><h3 id="3-2-创建目录"><a href="#3-2-创建目录" class="headerlink" title="3.2 创建目录"></a>3.2 创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir -p apps/nginx/html apps/nginx/logs apps/nginx/conf</span><br></pre></td></tr></table></figure><h3 id="3-3-先不指定映射路径启动一个容器"><a href="#3-3-先不指定映射路径启动一个容器" class="headerlink" title="3.3 先不指定映射路径启动一个容器"></a>3.3 先不指定映射路径启动一个容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 80:80 --name nginx nginx</span><br><span class="line">1fdcd13457a6eaacb511878e10d84ffbe48fe63fd1fb3705f58b2d4195b151d8</span><br></pre></td></tr></table></figure><p>这里如果直接指定映射路径运行会报错，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 80:80 --name nginx -v ~/apps/nginx/html:/usr/share/nginx/html -v ~/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/apps/nginx/logs:/var/log/nginx nginx</span><br><span class="line">dab56c13f9e76aad37fcf73411c78d495a6466f1c0d214949650dbae44adddf4</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused "process_linux.go:424: container init caused \"rootfs_linux.go:58: mounting \\\"/home/devuser/apps/nginx/conf/nginx.conf\\\" to rootfs \\\"/home/docker_image/overlay2/e40ccaf4d845a9af92487b47cbc4d505c5c776800ef8887c5b43833b10661427/merged\\\" at \\\"/home/docker_image/overlay2/e40ccaf4d845a9af92487b47cbc4d505c5c776800ef8887c5b43833b10661427/merged/etc/nginx/nginx.conf\\\" caused \\\"not a directory\\\"\"": unknown: Are you trying to mount a directory onto a file (or vice-versa)? Check if the specified host path exists and is the expected type.</span><br></pre></td></tr></table></figure></p><h3 id="3-4-将运行容器的配置文件复制到宿主机目录下"><a href="#3-4-将运行容器的配置文件复制到宿主机目录下" class="headerlink" title="3.4 将运行容器的配置文件复制到宿主机目录下"></a>3.4 将运行容器的配置文件复制到宿主机目录下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker cp 1fdcd13457a6:/etc/nginx/nginx.conf ~/apps/nginx/conf/</span><br></pre></td></tr></table></figure><h3 id="3-5-删除容器并重新运行"><a href="#3-5-删除容器并重新运行" class="headerlink" title="3.5 删除容器并重新运行"></a>3.5 删除容器并重新运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker stop 1fdcd1345</span><br><span class="line">~$ docker rm 1fdcd1345</span><br><span class="line">~$ docker run -d -p 80:80 --name nginx -v ~/apps/nginx/html:/usr/share/nginx/html -v ~/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/apps/nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure><h3 id="3-6-更新配置后重新加载"><a href="#3-6-更新配置后重新加载" class="headerlink" title="3.6 更新配置后重新加载"></a>3.6 更新配置后重新加载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker kill -s HUP nginx</span><br></pre></td></tr></table></figure><p>类似于 <code>nginx -s reload</code></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文没有总结。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中经常需要安装一些常用的服务软件，如Nginx、MySql、Redis等，如果按照普通的安装方法，一般都相对比较繁琐 —— 要经过下载软件或源码包，编译安装，配置，启动等步骤，使用 Docker 来安装这些服务软件能极大地简化安装过程，且速度也很快。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot（十一）：注解结合JWT实现简单的接口鉴权</title>
    <link href="http://blog.jboost.cn/springboot-simpleauth.html"/>
    <id>http://blog.jboost.cn/springboot-simpleauth.html</id>
    <published>2019-08-01T12:45:59.000Z</published>
    <updated>2019-08-12T04:00:24.375Z</updated>
    
    <content type="html"><![CDATA[<p>一般服务的安全包括认证（Authentication）与授权（Authorization）两部分，认证即证明一个用户是合法的用户，比如通过用户名密码的形式，授权则是控制某个用户可以访问哪些资源。比较成熟的框架有Shiro、Spring Security，如果要实现第三方授权模式，则可采用OAuth2。但如果是一些简单的应用，比如一个只需要鉴别用户是否登录的APP，则可以简单地通过注解+拦截器的方式来实现。本文介绍了具体实现过程，虽基于Spring Boot实现，但稍作修改（主要是拦截器配置）就可以引入其它Spring MVC的项目。<br><a id="more"></a></p><h2 id="1-涉及的知识点"><a href="#1-涉及的知识点" class="headerlink" title="1. 涉及的知识点"></a>1. 涉及的知识点</h2><ol><li>注解：用来标记某个接口是否需要登录</li><li>拦截器：拦截所有请求，判断请求的接口是否需要登录验证（基于是否标记了注解），如果需要，验证相应的信息（token），通过则放行，否则返回错误信息</li><li>JWT： Json Web Token，一种流行的认证解决方案，它可以生成携带信息的token，但token一旦生成，其过期时间就不好更新，如果需要实现用户有操作就自动延长过期时间的场景，就相对比较麻烦。我们这里只用来生成token，过期通过redis实现</li><li>RedisTemplate： 将token存在redis中，通过redis的过期机制来控制token的有效期</li><li>ThreadLocal：可以将一次请求中多个环节需要访问的变量通过ThreadLocal来传递，比如userId</li></ol><h2 id="2-依赖配置"><a href="#2-依赖配置" class="headerlink" title="2. 依赖配置"></a>2. 依赖配置</h2><p>在pom.xml中添加JWT与redis依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jwt.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在application.yml配置文件中添加redis相关配置属性<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123654</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">    jedis:</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        min-idle:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        max-idle:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        max-active:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        max-wait:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure></p><h2 id="3-定义注解"><a href="#3-定义注解" class="headerlink" title="3. 定义注解"></a>3. 定义注解</h2><p>注解的定义你可以根据项目的具体场景，比如需要登录的接口比较多，就可以定义如 @SkipAuth 的注解来标记不需要登录的接口，反之，则可以定义如 @NeedAuth 的注解来标记需要登录的接口，总之就是让标记接口这个操作尽可能少。但也可以基于另一种考虑，万一需要登录的接口忘了加不就存在安全问题吗，所以用 @SkipAuth 相对要保险点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SkipAuth &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-定义token管理器"><a href="#4-定义token管理器" class="headerlink" title="4. 定义token管理器"></a>4. 定义token管理器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTokenManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成TOKEN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createToken</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用uuid作为源token</span></span><br><span class="line">        String token = Jwts.builder().setId(userId).setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">            .signWith(SignatureAlgorithm.HS256, JwtConstant.JWT_SECRET).compact();</span><br><span class="line">        <span class="comment">//存储到redis并设置过期时间</span></span><br><span class="line">        redisTemplate.boundValueOps(JwtConstant.AUTHORIZATION + <span class="string">":"</span> + userId)</span><br><span class="line">            .set(token, JwtConstant.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkToken</span><span class="params">(TokenModel model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = redisTemplate.boundValueOps(JwtConstant.AUTHORIZATION + <span class="string">":"</span> </span><br><span class="line">            + model.getUserId()).get();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> || !token.equals(model.getToken())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果验证成功，说明此用户进行了一次有效操作，延长token的过期时间</span></span><br><span class="line">        redisTemplate.boundValueOps(model.getUserId())</span><br><span class="line">            .expire(JwtConstant.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteToken</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        redisTemplate.delete(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在登录接口通过时，调用 <code>createToken</code> 创建token，并保存到redis中，设置过期时间， 在调用未被 @SkipAuth 注解标记的接口时，调用 <code>checkToken</code> 来验证，并更新token的过期时间， 退出登录时，删除token。</p><h2 id="5-定义拦截器"><a href="#5-定义拦截器" class="headerlink" title="5. 定义拦截器"></a>5. 定义拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTokenManager tokenManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                             HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String requestPath = request.getRequestURI().substring(request.getContextPath().length());</span><br><span class="line">        <span class="comment">// 如果不是映射到方法直接通过</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line">        <span class="comment">// 如果方法注明了 SkipAuth，则不需要登录token验证</span></span><br><span class="line">        <span class="keyword">if</span> (method.getAnnotation(SkipAuth.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从header中得到token</span></span><br><span class="line">        String authorization = request.getHeader(JwtConstant.AUTHORIZATION);</span><br><span class="line">        <span class="comment">// 验证token</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(authorization))&#123;</span><br><span class="line">            WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"未提供有效Token！"</span>), response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = Jwts.parser().setSigningKey(JwtConstant.JWT_SECRET)</span><br><span class="line">                .parseClaimsJws(authorization).getBody();</span><br><span class="line">            String userId = claims.getId();</span><br><span class="line">            TokenModel model = <span class="keyword">new</span> TokenModel(userId, authorization);</span><br><span class="line">            <span class="keyword">if</span> (tokenManager.checkToken(model)) &#123;</span><br><span class="line">                <span class="comment">// 通过ThreadLocal设置下游需要访问的值</span></span><br><span class="line">                AuthUtil.setUserId(model.getUserId());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"连接"</span> + requestPath + <span class="string">"拒绝"</span>);</span><br><span class="line">                WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"未提供有效Token！"</span>), response);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"连接"</span> + requestPath + <span class="string">"发生错误:"</span>, e);</span><br><span class="line">            WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"校验Token发生异常！"</span>), response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结束后清除，否则由于线程池复用，导致ThreadLocal的值被其他用户获取</span></span><br><span class="line">        AuthUtil.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器通过对请求方法是否标记注解 @SkipAuth 来判断是否需要进行token验证，如果验证通过，则从JWT token中解析出userId，通过AuthUtil工具方法保存到ThreadLocal中，供下游访问。在请求处理结束调用 <code>afterCompletion</code> 方法中，要清除掉ThreadLocal中的值，否则由于线程池的复用，导致被其他用户获取。</p><p>然后，注册拦截器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AuthInterceptor authInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthInterceptor</span><span class="params">(AuthInterceptor authInterceptor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authInterceptor = authInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注册鉴权拦截器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(authInterceptor)</span><br><span class="line">            .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">"/error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里将 /error 这个接口排除了，因为如果接口处理过程中出现异常，则spring boot会自动跳转到 /error 接口，又会进入拦截器校验（因为/error接口没有标注 @SkipAuth 注解）。</p><h2 id="6-验证"><a href="#6-验证" class="headerlink" title="6. 验证"></a>6. 验证</h2><p>通过以上几步，一个简单的接口认证功能就实现了，我们可以通过添加一个登录接口，两个测试接口（一个需要认证，一个不需要认证）来验证下。<br>登录接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SkipAuth</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">login</span><span class="params">(@RequestBody Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">    String username = MapUtils.getString(params, <span class="string">"username"</span>);</span><br><span class="line">    String password = MapUtils.getString(params, <span class="string">"password"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"ksxy"</span>.equals(username) &amp;&amp; <span class="string">"jboost"</span>.equals(password))&#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(tokenManager.createToken(username));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.failed(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>登录成功后，通过<code>createToken</code>方法创建了JWT token。<br>测试接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SkipAuth</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/skip-auth"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">skipAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ApiResponse.success(<span class="string">"不需要认证的接口调用"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/need-auth"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">needAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiResponse.success(<span class="string">"username: "</span> + AuthUtil.getUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>本文介绍了一个简单的接口认证方案，适用于不需要基于用户角色进行授权的场景。如果有较复杂的授权需求，则还是基于Shiro， Spring Security， OAuth2等框架来实现。这里也可以不用JWT，但是需要自己去做一些处理，比如将userId以某种形式包含在token中，解析时取出。<br>本文完整实例代码：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-simpleauth" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-simpleauth</a><br><br><br><img src="/assets/card-2.png" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般服务的安全包括认证（Authentication）与授权（Authorization）两部分，认证即证明一个用户是合法的用户，比如通过用户名密码的形式，授权则是控制某个用户可以访问哪些资源。比较成熟的框架有Shiro、Spring Security，如果要实现第三方授权模式，则可采用OAuth2。但如果是一些简单的应用，比如一个只需要鉴别用户是否登录的APP，则可以简单地通过注解+拦截器的方式来实现。本文介绍了具体实现过程，虽基于Spring Boot实现，但稍作修改（主要是拦截器配置）就可以引入其它Spring MVC的项目。&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>老被跨域问题烦？看看都有哪些处理方法</title>
    <link href="http://blog.jboost.cn/cors.html"/>
    <id>http://blog.jboost.cn/cors.html</id>
    <published>2019-07-30T04:56:24.000Z</published>
    <updated>2019-07-31T05:39:09.209Z</updated>
    
    <content type="html"><![CDATA[<p>前面写的《IT技术人员的自我修养》，没想到几天内收到了不少良好的反馈，在此也感谢大家的关注。往后会不定时分享一些技术、管理领域的工作经验总结与感悟，欢迎大家持续关注、交流。最近被问及一个跨域的问题，包括之前面试时发现很多面试者对跨域及其处理也是一知半解，故本文对该问题进行了梳理总结，以供参考。<br><a id="more"></a></p><h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1. 什么是跨域"></a>1. 什么是跨域</h2><p>理解什么是跨域，就要先了解一个叫“同源策略”的东西，什么是“同源策略”？这是浏览器为了网站访问安全，对来自不同源的请求做一些必要的访问限制的一种策略。那什么叫“同源”呢？我们知道，一个http请求地址一般包含四部分：<code>协议://域名:端口/路径</code>，所谓同源，就是前面三者，即协议、域名、端口都一样。举例说明，假如我们有一个地址 <code>http://blog.jboost.cn/docker-1.html</code>， 来看以下地址是否与它同源</p><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">是否同源</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://blog.jboost.cn/docker-1.html">https://blog.jboost.cn/docker-1.html</a></td><td style="text-align:center">不同源</td><td style="text-align:center">协议不同，一个http，一个https</td></tr><tr><td style="text-align:center"><a href="http://www.jboost.cn/docker-1.html" target="_blank" rel="noopener">http://www.jboost.cn/docker-1.html</a></td><td style="text-align:center">不同源</td><td style="text-align:center">域名不同</td></tr><tr><td style="text-align:center"><a href="http://blog.jboost.cn:8080/docker-1.html">http://blog.jboost.cn:8080/docker-1.html</a></td><td style="text-align:center">不同源</td><td style="text-align:center">端口不同，一个是默认端口80，一个是8080</td></tr><tr><td style="text-align:center"><a href="http://blog.jboost.cn/docker-2.html">http://blog.jboost.cn/docker-2.html</a></td><td style="text-align:center">同源</td><td style="text-align:center">虽然路径不同，但协议、域名、端口（默认80）都相同</td></tr></tbody></table><p>那么浏览器对不同源的请求做了哪些访问限制呢？共有三种限制</p><ol><li>对Cookie、LocalStorage，以及IndexDB（浏览器提供的类NoSQL的一个本地数据库）的访问</li><li>对DOM的访问</li><li>AJAX请求</li></ol><p>而跨域就是要打破这种访问限制，对不同源的资源请求也能顺利进行，最常见的就是AJAX请求，比如前后端分离架构中，两者服务域名不同，前端通过AJAX直接访问服务端接口，就会存在跨域问题。</p><h2 id="2-为什么会存在跨域"><a href="#2-为什么会存在跨域" class="headerlink" title="2. 为什么会存在跨域"></a>2. 为什么会存在跨域</h2><p>前面说“同源策略”时已经提到，浏览器是为了网站的访问安全，才设置了跨域这道屏障。那么前面所说的三种限制，分别都是如何来保障网站安全的。</p><ol><li>对本地存储Cookie、LocalStorage、IndexDB的访问限制<br>我们系统的登录凭证一般是通过在Cookie中设置 SESSIONID（如针对浏览器表单请求）或直接返回 token（如针对REST请求）的形式返回给客户端的，比如Tomcat是通过在Cookie中设置名为 JSESSIONID 的属性来保存的，而一般REST请求的token前端会存储于 LocalStorage 中，如果不存在访问限制，则你访问的其它网站可能就会获取到这些凭证，然后伪造你的身份来发起非法请求，这就太不安全了。</li><li>对DOM的访问限制<br>如果不对DOM进行访问限制，那么其它网站，尤其一些钓鱼网站，就可以通过 <code>&lt;iframe&gt;</code> 的形式拿到你访问网站的DOM，进而获取到你输入的一些敏感信息，比如用户名、密码…</li><li>对AJAX请求的限制<br>同源策略规定，AJAX请求只能发给同源的网址，否则就会报错。至于为什么要限制，一方面是避免1中所提到伪造非法请求，另一方面我理解是AJAX过于灵活，如果不做限制，可能网站的接口资源就会被其它网站随意使用，就像你的私有物品被别人招呼都不打任意拿去用一样。</li></ol><p>总之，同源策略是浏览器提供的最基本的一种安全保障机制或约定。</p><h2 id="3-怎么实现跨域访问"><a href="#3-怎么实现跨域访问" class="headerlink" title="3. 怎么实现跨域访问"></a>3. 怎么实现跨域访问</h2><p>我们平常遇到的跨域问题基本都出现在AJAX请求的场景，一般而言，可以通过代理、CORS、JSONP等方式来解决跨域问题。</p><h3 id="3-1-代理"><a href="#3-1-代理" class="headerlink" title="3.1 代理"></a>3.1 代理</h3><p>既然“同源策略”是浏览器端的机制，那我们就可以绕开浏览器，最常见的做法就是使用代理，如 Nginx，比如我们前端项目的域名是 <a href="http://blog.jboost.cn，服务端接口域名是" target="_blank" rel="noopener">http://blog.jboost.cn，服务端接口域名是</a> <a href="http://api.jboost.cn，我们在" target="_blank" rel="noopener">http://api.jboost.cn，我们在</a> Nginx 中提供如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    # 端口</span><br><span class="line">    listen 80;</span><br><span class="line">    # 域名</span><br><span class="line">    server_name blog.jboost.cn;</span><br><span class="line">    # 所有 http://blog.jboost.cn/api/xxx 请求都会被转发到 http://api.jboost.cn/api/xxx</span><br><span class="line">    location ^~ /api &#123;</span><br><span class="line">        proxy_pass http://api.jboost.cn;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则前端通过AJAX请求服务端接口 <a href="http://api.jboost.cn/api/xxx" target="_blank" rel="noopener">http://api.jboost.cn/api/xxx</a> 都可以改为通过 <a href="http://blog.jboost.cn/api/xxx">http://blog.jboost.cn/api/xxx</a> 来访问，从而避免不同源的跨域问题。</p><h3 id="3-2-CORS"><a href="#3-2-CORS" class="headerlink" title="3.2 CORS"></a>3.2 CORS</h3><p>CORS是Cross-Origin Resource Sharing的简写，即跨域资源共享，CORS需要服务端与浏览器同时支持，目前所有浏览器（除IE10以下）都支持CORS，因此，实现CORS，主要就是服务端的工作了。例如在Spring Boot中，我们可通过如下配置注册一个CorsFilter的过滤器来实现跨域支持。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;Servlet.class, CorsFilter.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CORSAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"corsFilterRegistrationBean"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line"></span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.applyPermitDefaultValues();</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(CorsConfiguration.ALL));</span><br><span class="line">        corsConfiguration.addExposedHeader(HttpHeaders.DATE);</span><br><span class="line"></span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line"></span><br><span class="line">        CorsFilter corsFilter = <span class="keyword">new</span> CorsFilter(corsConfigurationSource);</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(corsFilter);</span><br><span class="line">        filterRegistrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实质就是在响应消息的Header中添加几个属性，主要有</p><ul><li>Access-Control-Allow-Origin  必需，表示允许跨域的请求源，可以是具体的域名，也可以是 * ，表示任意域名</li><li>Access-Control-Allow-Methods 必需，表示允许跨域访问的HTTP方法，如GET、POST、PUT、DELETE等，可以是 * ，表示所有</li><li>Access-Control-Allow-Headers 如果请求包括 Access-Control-Request-Headers 头信息，则必需，表示服务器支持的所有头信息字段</li></ul><h3 id="3-3-JSONP"><a href="#3-3-JSONP" class="headerlink" title="3.3 JSONP"></a>3.3 JSONP</h3><p>JSONP是利用浏览器对JS一些标签（如 <code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>等）的 src 属性不具有同源策略限制的特性实现的，如前端添加<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://api.jboost.cn/hello?name=jboost&amp;callback=jsonpCallback"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>并且定义JS方法 <code>jsonpCallback</code>。服务端接口返回内容需要是JS方法<code>jsonpCallback</code>的调用格式，如<code>jsonpCallback({&quot;name&quot;:&quot;jboost&quot;})</code>，这样在<code>jsonpCallback</code>方法中就可以获取服务端实际返回的结果数据<code>{&quot;name&quot;:&quot;jboost&quot;}</code>了。<br>JSONP方式的局限性也很明显，一是只支持GET请求——你没见过哪些<code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>标签是POST请求吧，二是需要对服务端返回数据格式做处理。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>三种跨域支持的实现，代理方式最简单，对客户端、服务端都不具有侵入性，但如果需要支持的请求源比较多，或者是与第三方对接的话，代理方式就不太适用了。CORS相对来说是一种标准的处理方式，并且通过过滤器的方式对业务代码也没有任何侵入性。而JSONP方式局限性较大，只支持GET，并且需要服务端做返回数据格式的支持。可针对具体情况选择适用的方式。</p><p><br><br><img src="/assets/card-2.png" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面写的《IT技术人员的自我修养》，没想到几天内收到了不少良好的反馈，在此也感谢大家的关注。往后会不定时分享一些技术、管理领域的工作经验总结与感悟，欢迎大家持续关注、交流。最近被问及一个跨域的问题，包括之前面试时发现很多面试者对跨域及其处理也是一知半解，故本文对该问题进行了梳理总结，以供参考。&lt;br&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="web" scheme="http://blog.jboost.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战（十）：异步处理</title>
    <link href="http://blog.jboost.cn/springboot-async.html"/>
    <id>http://blog.jboost.cn/springboot-async.html</id>
    <published>2019-07-22T10:25:49.000Z</published>
    <updated>2019-07-24T01:52:03.885Z</updated>
    
    <content type="html"><![CDATA[<p>在业务开发中，有时候会遇到一些非核心的附加功能，比如短信或微信模板消息通知，或者一些耗时比较久，但主流程不需要立即获得其结果反馈的操作，比如保存图片、同步数据到其它合作方等等。如果将这些操作都置于主流程中同步处理，势必会对核心流程的性能造成影响，甚至由于第三方服务的问题导致自身服务不可用。这时候就应该将这些操作异步化，以提高主流程的性能，并与第三方解耦，提高主流程的可用性。<br><a id="more"></a></p><p>在Spring Boot中，或者说在Spring中，我们实现异步处理一般有以下几种方式：</p><p><strong>1. 通过 @EnableAsync 与 @Asyc 注解结合实现</strong><br><strong>2. 通过异步事件实现</strong><br><strong>3. 通过消息队列实现</strong></p><h2 id="1-基于注解实现"><a href="#1-基于注解实现" class="headerlink" title="1. 基于注解实现"></a>1. 基于注解实现</h2><p>我们以前在Spring中提供异步支持一般是在配置文件 applicationContext.xml 中添加类似如下配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"executor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"executor"</span> <span class="attr">pool-size</span>=<span class="string">"10-200"</span> <span class="attr">queue-capacity</span>=<span class="string">"2000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>Spring的 @EnableAsync 注解的功能与<code>&lt;task:annotation-driven/&gt;</code>类似，将其添加于一个 @Configuration 配置类上，可对Spring应用的上下文开启异步方法支持。 @Async 注解可以标注在方法或类上，表示某个方法或某个类里的所有方法需要通过异步方式来调用。</p><p>我们以一个demo来示例具体用法，demo地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-async" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-async</a></p><ol><li>添加 @EnableAsync 注解</li></ol><p>在一个 @Configuration 配置类上添加 @EnableAysnc 注解，我们一般可以添加到启动类上，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>配置相关的异步执行线程池</li></ol><p>可通过配置类的方式对异步线程池进行配置，并提供异步执行时出现异常的处理方法，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.corePoolSize:10&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.maxPoolSize:200&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.queueCapacity:2000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.keepAlive:5&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAlive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        executor.setKeepAliveSeconds(keepAlive);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"async-"</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.setDaemon(<span class="keyword">false</span>); <span class="comment">//以用户线程模式运行</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAsyncUncaughtExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">AsyncUncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable throwable, Method method, Object... objects)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch exception when invoke "</span> + method.getName());</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们通过实现 AsyncConfigurer 接口提供了一个异步执行线程池对象，各参数的说明可以参考【<a href="/threadpool.html">线程池的基本原理，看完就懂了</a>】，里面有很详细的介绍。且通过实现   AsyncUncaughtExceptionHandler 接口提供了一个异步执行过程中未捕获异常的处理类。</p><ol start="3"><li>定义异步方法</li></ol><p>异步方法的定义只需要在类（类上注解表示该类的所有方法都异步执行）或方法上添加 @Async 注解即可，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethodWithException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"exception in async method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>测试</li></ol><p>我们可以通过如下测试类来对异步方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBasedAsyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        asyncService.asyncMethod();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAysncWithException</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        asyncService.asyncMethodWithException();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为异步方法在一个新的线程中执行，可能在主线程执行完后还没来得及处理，所以通过sleep来等待它执行完成。具体执行结果读者可自行尝试运行，这里就不贴图了。</p><h2 id="2-基于事件实现"><a href="#2-基于事件实现" class="headerlink" title="2. 基于事件实现"></a>2. 基于事件实现</h2><p>第二种方式是通过Spring框架的事件监听机制实现，但Spring的事件监听默认是同步执行的，所以实际上还是需要借助 @EnableAsync 与 @Async 来实现异步。</p><ol><li>添加 @EnableAsync 注解</li></ol><p>与上同，可添加到启动类上。</p><ol start="2"><li><p>自定义事件类<br>通过继承 ApplicationEvent 来自定义一个事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String arg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source, String arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.arg = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义事件处理类<br>支持两种形式，一是通过实现 ApplicationListener 接口，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"2. arg value: "</span> + event.getArg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>二是通过 @EventListener 注解，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(MyEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"3. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"3. arg value: "</span> + event.getArg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意两者都需要添加 @Async 注解，否则默认是同步方式执行。</p><ol start="4"><li><p>定义事件发送类<br>可以通过实现 ApplicationEventPublisherAware 接口来使用 ApplicationEventPublisher 的 publishEvent()方法发送事件，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p>可以通过如下测试类来进行测试，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBasedAsyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyEventPublisher myEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        myEventPublisher.publishEvent(<span class="keyword">new</span> MyEvent(<span class="keyword">this</span>,<span class="string">"testing event based async"</span>));</span><br><span class="line">        Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后发现两个事件处理类都执行了，因为两者都监听了同一个事件 MyEvent 。</p><h2 id="3-基于消息队列实现"><a href="#3-基于消息队列实现" class="headerlink" title="3. 基于消息队列实现"></a>3. 基于消息队列实现</h2><p>以上两种方式都是基于服务器本机运行，如果服务进程出现异常退出，可能导致异步执行中断。如果需要保证任务执行的可靠性，可以借助消息队列的持久化与重试机制。阿里云上的消息队列服务提供了几种类型的消息支持，如顺序消息、定时/延时消息、事务消息等（详情可参考：<a href="https://help.aliyun.com/document_detail/29532.html?spm=5176.234368.1278132.btn4.6f43db25Rn8oey" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/29532.html?spm=5176.234368.1278132.btn4.6f43db25Rn8oey</a> ），如果项目是基于阿里云部署的，可以考虑使用其中一类消息服务来实现业务需求。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文对spring boot下异步处理的几种方法进行了介绍，如果对任务执行的可靠性要求不高，则推荐使用第一种方式，如果可靠性要求较高，则推荐使用自建消息队列或云消息队列服务的方式。<br>本文demo源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-async/src/main/java/cn/jboost/async" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-async/src/main/java/cn/jboost/async</a><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在业务开发中，有时候会遇到一些非核心的附加功能，比如短信或微信模板消息通知，或者一些耗时比较久，但主流程不需要立即获得其结果反馈的操作，比如保存图片、同步数据到其它合作方等等。如果将这些操作都置于主流程中同步处理，势必会对核心流程的性能造成影响，甚至由于第三方服务的问题导致自身服务不可用。这时候就应该将这些操作异步化，以提高主流程的性能，并与第三方解耦，提高主流程的可用性。&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（六）：容器管理</title>
    <link href="http://blog.jboost.cn/docker-6.html"/>
    <id>http://blog.jboost.cn/docker-6.html</id>
    <published>2019-07-21T03:04:16.000Z</published>
    <updated>2019-07-22T10:24:14.304Z</updated>
    
    <content type="html"><![CDATA[<p>容器是Docker中的另一核心概念，在Docker中，应用的运行都是在容器内进行的，容器则基于镜像创建。前面已对Docker镜像做了基本介绍，本文对Docker容器管理的相关内容做一个梳理。<br><a id="more"></a></p><h2 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1. 启动容器"></a>1. 启动容器</h2><p>启动容器的命令格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE-NAME [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure></p><p>其中OPTIONS部分可指定容器运行的一些可选项，常用选项包括：</p><ul><li>-d 将容器以后台进程（daemon）的形式运行</li><li>-p 指定容器内应用暴露端口与主机端口的映射，如 -p 8080:80 表示将容器内80端口映射到主机的8080端口（主机端口在前，容器端口在后）</li><li>-v 指定容器与主机的挂载目录映射，如 -v /var/log:/log 表示将容器的/log目录挂载到主机的/var/log目录（同样主机目录在前，容器目录在后），后续对容器的/log写操作实际作用于主机的/var/log目录</li><li>-e 为容器设置环境变量</li><li>-t 为容器启动一个伪终端（pseudo-tty）</li><li>-i 让容器的标准输入保持打开，一般与 -t 配合使用，让容器启动后就打开一个可交互的命令行界面</li><li>-w 指定容器的工作目录</li></ul><p>COMMAND [ARG..] 部分就是容器需要运行的应用进程启动命令与参数，如果镜像中有通过 CMD， 或 ENTRYPOINT 指定了容器启动程序，则可省略。另外可通过 –name 指定容器的名称，以及 –restart 来指定重启策略，–restart有三种取值，代表容器支持的三种不同的重启策略</p><table><thead><tr><th style="text-align:center">取值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:left">除非被<code>docker stop</code>命令明确停止，否则一直尝试重启处于停止态的容器；如果Docker重启，也会自动启动容器</td></tr><tr><td style="text-align:center">unless-stopped</td><td style="text-align:left">与always的区别是，停止态的容器不在Docker重启的时候被重启</td></tr><tr><td style="text-align:center">on-failed</td><td style="text-align:left">在容器退出时返回值不为0的时候，重启容器；如果Docker重启，容器也会被启动，不管之前是否处于停止状态</td></tr></tbody></table><p>以启动一个mysql数据库服务为例<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name mysql \</span><br><span class="line"> -v /home/devuser/apps/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf \</span><br><span class="line"> -v /home/devuser/apps/mysql/logs:/var/log/mysql \</span><br><span class="line"> -v /home/devuser/apps/mysql/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=Passw0rd --restart=always mysql:5.7</span><br></pre></td></tr></table></figure></p><p>上述命令启动了一个mysql容器服务，-d 表示以后台进程运行，执行命令后只返回一个容器ID，不会输出任何其它信息；-p 将容器暴露的端口3306映射到宿主机的3306端口，外部主机就可以通过宿主机IP与3306端口来访问mysql服务； –name 指定了容器名称为mysql； -v 将mysql的配置文件路径、日志路径、数据存储路径映射到了宿主机对应的路径目录；-e 设置了一个环节变量指定mysql root账号的密码；–restart 指定容器在异常退出时，包括Docker重启时，自动启动容器。</p><p>我们前面有提过，当我们执行CLI命令时，实际上是客户端（Docker Client）通过发送请求到Docker后台进程（Docker Daemon），由Docker后台进程来执行的，那么当我们执行上述<code>docker run</code>命令的时候，Docker后台进程具体都干了些啥呢？一般来说，包括如下几个操作步骤</p><ol><li>检测本地是否存在指定的镜像，如果不存在，就从公共仓库下载</li><li>利用镜像创建一个容器，并启动它</li><li>分配一个文件系统，并在只读的镜像层上面挂载一层可读写层（容器存储层）</li><li>从宿主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行应用程序完毕后容器被终止 </li></ol><h2 id="2-管理已有容器"><a href="#2-管理已有容器" class="headerlink" title="2. 管理已有容器"></a>2. 管理已有容器</h2><p>一般对已有容器的管理包括如下几个操作：</p><ol><li>查看运行中的容器 <code>docker ps</code> 或 <code>docker container ls</code></li><li>查看所有容器 <code>docker ps -a</code> 或 <code>docker container ls -a</code></li><li>停止运行 <code>docker stop xxx</code></li><li>开始停止状态的容器 <code>docker start xxx</code></li><li>重启运行状态的容器 <code>docker restart xxx</code></li><li>删除停止状态的容器 <code>docker rm xxx</code></li><li>强制删除容器（包括运行状态中） <code>docker rm -f xxx</code></li><li>删除所有停止状态的容器 <code>docker container prune</code></li></ol><p>其中xxx既可以是容器ID（短ID即可，只要与其它区分开来），也可以是容器名称。<br><code>docker rm</code>之前必须要先<code>docker stop</code>将容器置为停止状态，而<code>docker rm -f</code>可以强制删除运行状态的容器，其背后是通过Linux/POSIX信号来实现的，<code>docker rm -f</code>命令直接发出<code>SIGKILL</code>信号，不会给容器内运行进程任何缓冲的时间，立即终止，而<code>docker stop</code>命令却是先发送<code>SIGTERM</code>信号，通知容器进程结束，会为进程预留一个清理并优雅停止的机会，如果一段时间后进程还没有终止，那么就会发送<code>SIGKILL</code>信号，来终止进程的运行。</p><p>我们也可以像镜像操作中一样，组合使用命令来更方便地操作，如强制删除所有容器（慎用）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure></p><h2 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3. 进入容器"></a>3. 进入容器</h2><p>容器在运行时指定 -d 选项时， 是以后台进程的形式运行的，如果我们需要进入容器查看或操作，可以通过<code>docker exec</code>命令，<code>docker exec</code>命令的格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] container-id COMMAND</span><br></pre></td></tr></table></figure></p><p>OPTIONS常用的一般是 -t， -i，意义跟在<code>docker run</code>选项中一样 —— 为容器启动一个伪终端（pseudo-tty），并保持标准输入打开，从而可以像Linux命令行一样进行交互， COMMAND一般为 <code>bash</code>。</p><p>另外还有一个命令是<code>docker attach xxx</code>，其中xxx是容器ID，但推荐使用<code>docker exec</code>，因为<code>docker attach</code>中当执行<code>exit</code>退出容器时，容器也会随之终止，但<code>docker exec</code>则不会。</p><p>如果不进入容器，也可以通过<code>docker logs xxx</code>，xxx是容器ID，来查看容器的输出信息。</p><h2 id="4-导入导出容器"><a href="#4-导入导出容器" class="headerlink" title="4. 导入导出容器"></a>4. 导入导出容器</h2><p>可以使用<code>docker export</code>命令将一个容器的快照进行导出，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export xxx &gt; mycontainer.tar</span><br></pre></td></tr></table></figure></p><p>其中xxx是容器ID，可以通过<code>docker ps -a</code>查看，上述命令将容器的当前快照导出到了本地文件。</p><p><code>docker import</code>命令则可以将一个容器快照文件导入为镜像，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat mycontainer.tar | docker import - test/myimage:v1.0</span><br></pre></td></tr></table></figure></p><p>可以通过URL来导入，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import http://test.com/testimage.tgz test/myimage2:v1.0</span><br></pre></td></tr></table></figure></p><p>由此可见，我们获取镜像又多了一个来源——从已有容器快照文件导入。 </p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文对容器的一些基本操作进行了介绍，需要注意的是如之前所说，容器应以无状态的形式运行，所有产生的数据应该通过挂载数据卷的方式写入宿主机文件目录，避免容器销毁时造成数据丢失；尽量使用<code>docker stop</code> + <code>docker rm</code>的方式来替代<code>docker rm -f</code>，使容器内运行程序“优雅”地退出。有时候可能遇到这样的场景，容器创建运行后，我们需要对运行的一些参数进行更新或添加，这时候该怎么操作。后文会对该场景进行介绍，欢迎关注。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器是Docker中的另一核心概念，在Docker中，应用的运行都是在容器内进行的，容器则基于镜像创建。前面已对Docker镜像做了基本介绍，本文对Docker容器管理的相关内容做一个梳理。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（五）：整一个自己的镜像</title>
    <link href="http://blog.jboost.cn/docker-5.html"/>
    <id>http://blog.jboost.cn/docker-5.html</id>
    <published>2019-07-17T08:32:35.000Z</published>
    <updated>2019-07-24T01:51:09.675Z</updated>
    
    <content type="html"><![CDATA[<p>获取镜像的途径有两个，一是从镜像仓库获取，如官方的Docker Hub，二是自定义。上文已经介绍如何从镜像仓库获取镜像，本文基于一个Springboot项目，来介绍自定义一个镜像的基本流程。<br><a id="more"></a></p><h2 id="1-定制镜像的本质"><a href="#1-定制镜像的本质" class="headerlink" title="1. 定制镜像的本质"></a>1. 定制镜像的本质</h2><p>我们知道镜像是分层存储的，镜像的构建也是一层一层进行的，一层构建完后，就变为只读，在其上再构建下一层。因此定制镜像，实际上就是定义每一层要干的事，比如执行某个命令，设置一个环境变量，声明一个暴露端口等等。然后在构建时，按照各层的定义，一层一层地完成构建，最终形成一个包含这些层的镜像。</p><h2 id="2-Dockerfile文件"><a href="#2-Dockerfile文件" class="headerlink" title="2. Dockerfile文件"></a>2. Dockerfile文件</h2><p>Docker中定义各层要干的事的文件叫Dockerfile，它是一个文本文件，包含了一条条的指令，每一条指令对应一层镜像，指令的内容就描述了这一层该如何构建。如下示例了一个非常简单的Dockerfile，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello jboost!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>我们定制镜像，必须要以某一个镜像为基础，在其上构建自己需要的层，如上示例中，我们是以nginx镜像为基础，然后在第二层定制了我们自己的内容——修改index.html的内容为<code>&lt;h1&gt;Hello jboost!&lt;/h1&gt;</code>，这样运行容器打开nginx主页时就不会显示默认的页面内容了。</p><p>上面示例中接触了Dockerfile的两个指令</p><ul><li>FROM：FROM指令指定基础镜像，每一个定制镜像必须要有一个基础镜像，所以必须要有一条FROM指令，并且是Dockerfile的第一条指令</li><li>RUN：RUN指令指定需要执行的命令，后面接的命令就像是shell脚本一样可执行</li></ul><p>Dockerfile还提供了许多其它指令，后续我们再集中介绍，本文只对接触到的指令做简单说明。</p><h2 id="3-自定义一个镜像"><a href="#3-自定义一个镜像" class="headerlink" title="3. 自定义一个镜像"></a>3. 自定义一个镜像</h2><p>这部分以一个Springboot项目为基础，介绍自定义一个镜像涉及的基本环节。项目地址为：<a href="https://github.com/ronwxy/swagger-register" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-register</a> ，该项目是一个Swagger API文档注册服务，其它项目可将Swagger API信息注册到该服务，进行统一查看与管理。</p><h3 id="3-1-定义Dockerfile文件"><a href="#3-1-定义Dockerfile文件" class="headerlink" title="3.1 定义Dockerfile文件"></a>3.1 定义Dockerfile文件</h3><p>首先，我们在项目的根目录下创建一个Dockerfile文件（文件名就叫Dockerfile），其内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">ENV PROFILE=dev</span><br><span class="line">RUN mkdir /app /logs</span><br><span class="line">COPY ./target/swagger-register-1.0.0-SNAPSHOT.jar /app/app.jar</span><br><span class="line">WORKDIR /app</span><br><span class="line">VOLUME /register-data</span><br><span class="line">EXPOSE 11090</span><br><span class="line">CMD [&quot;java&quot;, &quot;-Dspring.profiles.active=$&#123;PROFILE&#125;&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]</span><br></pre></td></tr></table></figure></p><p>从上往下依次介绍如下</p><ul><li>第一行：FORM openjdk:8-jdk-alpine， 表示以<code>openjdk:8-jdk-alpine</code>这个镜像为基础镜像，因为这是一个Springboot项目所以必须要有jdk支持，我们在定制镜像时，可以找一个最适合的镜像作为基础镜像。</li><li>第二行：ENV PROFILE=dev， 定义了一个环境变量，这个环境变量可以在后面被引用</li><li>第三行：RUN mkdir /app /logs，通过mkdir命令创建了两个目录，用来保存jar执行文件及日志</li><li>第四行：COPY ./target/swagger-register-1.0.0-SNAPSHOT.jar /app/app.jar 将target目录下的jar包复制到/app目录下，并且进行重命名</li><li>第五行：WORKDIR /app， 指定工作目录为/app，后面各层的当前目录就是指定的工作目录</li><li>第六行：VOLUME /register-data， 定义一个匿名数据卷，前面说过写操作不要直接在容器内进行，而要改为写挂载的数据卷目录，这个定义可在运行容器时通过 -v 来覆盖。</li><li>第七行：EXPOSE 11090， 声明了运行容器时提供的服务端口，也仅仅是个声明而已，只是告诉使用的人要映射这个端口，通过 -p 可映射端口。</li><li>第八行：CMD [“java”, “-Dspring.profiles.active=${PROFILE}”, “-jar”, “app.jar”]， 指定了容器启动命令，因为是一个Springboot项目，所以就是一个java -jar的执行命令，容器启动的时候就会执行该命令来运行Springboot服务，这里引用了第二行定义的环境变量PROFILE</li></ul><h3 id="3-2-配置maven插件"><a href="#3-2-配置maven插件" class="headerlink" title="3.2 配置maven插件"></a>3.2 配置maven插件</h3><p>定义好Dockerfile后，为了方便构建镜像，我们可以借助maven的dockerfile插件<code>dockerfile-maven-plugin</code>，在pom.xml的build部分加入配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>repository指定了镜像的名称，<code>docker.image.prefix</code>需要properties部分进行定义，我这里是<code>springboot</code>。</p><h3 id="3-3-构建镜像"><a href="#3-3-构建镜像" class="headerlink" title="3.3 构建镜像"></a>3.3 构建镜像</h3><p>下载源码：<a href="https://github.com/ronwxy/swagger-register.git" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-register.git</a> ，然后在项目的根目录下执行如下命令(前提是本地已经装好了docker与maven及jdk)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true dockerfile:build</span><br></pre></td></tr></table></figure></p><p>该命令首先会执行<code>mvn clean package -Dmaven.test.skip=true</code>对项目进行打包，生成./target/swagger-register-1.0.0-SNAPSHOT.jar文件，然后基于当前目录下的Dockerfile文件进行构建，如下图所示<br><img src="/assets/docker-build.png" alt="docker-build"></p><p>由上图可看出，该镜像构建分八步(对应Dockerfile的八行指令)，每一步生成一个镜像层，每一层都有唯一的ID。由图中也可以看出，除了COPY之类的命令外，每一层的构建实际上是先基于上一层启动一个容器，然后执行该层定义的操作，再移除这个容器来实现的，如第八步中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Step 8/8 : CMD ["java", "-Dspring.profiles.active=$&#123;PROFILE&#125;", "-jar", "app.jar"]</span><br><span class="line">[INFO] </span><br><span class="line">[INFO]  ---&gt; Running in f4acd0b53bca</span><br><span class="line">[INFO] Removing intermediate container f4acd0b53bca</span><br><span class="line">[INFO]  ---&gt; a9ee579f2d62</span><br></pre></td></tr></table></figure></p><p>先启动一个ID为f4acd0b53bca的容器，在其中执行CMD所定义的命令，然后再移除容器f4acd0b53bca，最后生成ID为a9ee579f2d62的镜像。</p><p>构建完后，我们就可以在本地镜像中通过<code>docker iamges</code>看到我们定制的镜像了，如图<br><img src="/assets/docker-image.png" alt="docker-image"></p><p>图中springboot/swagger-register镜像即为我们刚刚构建好的定制镜像。</p><h3 id="3-4-启动容器"><a href="#3-4-启动容器" class="headerlink" title="3.4 启动容器"></a>3.4 启动容器</h3><p>我们可以通过以下命令来启动一个刚才定制镜像的容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name swagger-register -p 11090:11090 -v /home/jenkins/swagger-register/register-data:/register-data -v /home/jenkins/swagger-register/logs:/logs --restart=always springboot/swagger-register:latest</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>-d 表示以后台进程方式运行</li><li>–name 指定容器名称</li><li>-p 指定端口映射，左边为宿主机端口，右边为容器服务端口</li><li>-v 指定数据卷挂载，左边为宿主机目录，右边为容器目录</li><li>–restart=always 表示在docker启动时自动启动该容器</li></ul><p>关于容器相关的内容后面详细介绍，这里不展开说明了。启动容器后， 我们就可以浏览器打开地址 http://宿主机ip:11090/doc.html 来访问服务了（打开页面后内容是空的，因为没有任何服务注册Swagger API， 相关内容可参考 <a href="/swagger-register.html">swagger api文档集中化注册管理</a>）</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文介绍了一个基于Springboot项目的Docker镜像定制及使用过程，对镜像的构建过程，及Dockerfile的基本指令以及容器的运行做了基本介绍。后续会对Dockerfile的其它指令及Dockerfile的一些最佳实践进行更为详细的介绍，欢迎关注。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;获取镜像的途径有两个，一是从镜像仓库获取，如官方的Docker Hub，二是自定义。上文已经介绍如何从镜像仓库获取镜像，本文基于一个Springboot项目，来介绍自定义一个镜像的基本流程。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（四）：Docker镜像管理</title>
    <link href="http://blog.jboost.cn/docker-4.html"/>
    <id>http://blog.jboost.cn/docker-4.html</id>
    <published>2019-07-16T13:22:11.000Z</published>
    <updated>2019-07-24T01:51:02.477Z</updated>
    
    <content type="html"><![CDATA[<p>在Docker中，应用是通过容器来运行的，而容器的运行是基于镜像的，类似面向对象设计中类与对象的关系——没有类的定义就谈不上实例的创建与使用，没有镜像的定义就谈不上容器的创建与运行。<br><a id="more"></a></p><h2 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h2><p>镜像从哪里来，一般两个途径，一是公共镜像库，如官方镜像库Docker Hub，上面有大量的高质量的镜像直接可拿来用；二是自定义，我们可基于一个已有镜像，在其基础上增加一些层（还记得镜像的分层存储特性吧），然后构建形成自己的镜像。</p><p>如果我们知道某个镜像的名称，则可直接通过<code>docker pull</code>来下载镜像到本地，如ubuntu、redis、nginx等，<code>docker pull</code>命令的格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry的地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure></p><p>其中选项可设置：</p><ul><li>-a, –all-tags：下载仓库中所有标签（一般指版本）的镜像</li><li>–disable-content-trust：跳过镜像验证，默认为true</li></ul><p>Docker Registry的地址即镜像仓库地址，一般为域名或IP加端口号，如果不指定则默认为Docker Hub；仓库名包含两部分，&lt;用户名&gt;/&lt;软件名&gt;，对于Docker Hub，如果不给出用户名，则默认为library，表示官方提供；标签一般是对应软件的版本号，如果不指定则默认为latest。</p><p>比如我们要下一个nginx镜像，则可执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker pull nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">fc7181108d40: Already exists </span><br><span class="line">d2e987ca2267: Pull complete </span><br><span class="line">0b760b431b11: Pull complete </span><br><span class="line">Digest: sha256:48cbeee0cb0a3b5e885e36222f969e0a2f41819a68e07aeb6631ca7cb356fed1</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br></pre></td></tr></table></figure><p>这里我们没有指定选项，也没有指定镜像仓库地址，那么默认会从Docker Hub获取镜像（但Docker Hub由于在国外，速度比较慢，所以一般要设置国内加速器，参考<a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a>第二部分：配置国内镜像)，也没有给出用户名，所以默认是library（第三行），没有指定标签，所以默认是latest（第二行），由第四至第六行可见，这个镜像包含三个层，并且第一个层已经存在了（之前下载的镜像已经包含了这个层， 直接复用），镜像分层的概念及层的复用，应该已经理解了。</p><p>如果我们不知道镜像的完整名称怎么办，那就搜索一下，有两个途径，一是通过命令，假设我们记不起nginx全称了， 只记得<code>ngi</code>，则可通过如下命令搜索<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker search ngi</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                             Official build of Nginx.                        11693               [OK]                </span><br><span class="line">jwilder/nginx-proxy               Automated Nginx reverse proxy for docker con…   1628                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm           Container running Nginx + PHP-FPM capable of…   726                                     [OK]</span><br><span class="line">bitnami/nginx                     Bitnami nginx Docker Image                      69                                      [OK]</span><br><span class="line">linuxserver/nginx                 An Nginx container, brought to you by LinuxS…   69                                      </span><br><span class="line">tiangolo/nginx-rtmp               Docker image with Nginx using the nginx-rtmp…   48                                      [OK]</span><br><span class="line">nginx/nginx-ingress               NGINX Ingress Controller for Kubernetes         20                                      </span><br><span class="line">nginxdemos/hello                  NGINX webserver that serves a simple page co…   18                                      [OK]</span><br><span class="line">jlesage/nginx-proxy-manager       Docker container for Nginx Proxy Manager        17                                      [OK]</span><br><span class="line">schmunk42/nginx-redirect          A very simple container to redirect HTTP tra…   17                                      [OK]</span><br><span class="line">crunchgeek/nginx-pagespeed        Nginx with PageSpeed + GEO IP + VTS + more_s…   13                                      </span><br><span class="line">blacklabelops/nginx               Dockerized Nginx Reverse Proxy Server.          12                                      [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>该命令会从Docker Hub搜索镜像名包含<code>ngi</code>的镜像，其中STARS表示收藏用户数，OFFICIAL为[OK]表示官方提供的镜像，AUTOMATED [OK]表示由自动构建生成，一般选择STARS最多，官方提供的镜像。<br>这种方式获取到的信息有限，比如具体包含哪些版本不知道。还有一个途径是直接在Docker Hub网站上搜索，打开 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> ， 在搜索框输入<code>ngi</code>，如下图<br><img src="/assets/docker-hub.png" alt="docker-hub"></p><p>则会列出所有满足条件的镜像，点开<code>nginx</code>结果链接，可以看到提供的版本（通过版本链接可以查看定义对应镜像的Dockerfile），及相应的文档说明。这种方式获取的信息更加全面，所以推荐这种方式！</p><p>另外，当我们没有执行<code>docker pull</code>，直接通过<code>docker run xx</code>来运行一个容器时，如果没有对应的镜像，则会先自动下载镜像，再基于镜像启动一个容器，比如我们在<a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a>中检验docker是否安装成功时运行的<code>hello-world</code><br><img src="/assets/hello-docker.png" alt="hello-docker"></p><h2 id="2-管理本地镜像"><a href="#2-管理本地镜像" class="headerlink" title="2. 管理本地镜像"></a>2. 管理本地镜像</h2><p>将镜像下载到本地后，我们可以基于镜像来创建、运行容器，及对镜像进行管理。</p><p><strong>查看本地镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              f68d6e55e065        2 weeks ago         109MB</span><br><span class="line">mysql               latest              c7109f74d339        5 weeks ago         443MB</span><br><span class="line">hello-world         latest              fce289e99eb9        6 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>上面各列依次列出了镜像名称、标签（版本）、镜像ID、创建时间、镜像大小。镜像可以拥有多个标签（版本）。镜像的大小总和一般要大于实际的磁盘占有量，为什么？回忆一下镜像的分层存储概念，层是可以复用的，某个层其中一个镜像有了，另一个镜像就不会再下载了。口说无凭，我们来验证下，<code>docker system df</code>可列出镜像、容器、数据卷所占用的空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              3                   1                   497.1MB             497.1MB (99%)</span><br><span class="line">Containers          1                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><p>通过<code>docker image ls</code>列出的各镜像大小总共约552MB，但这里列出的镜像大小只有约497MB，这下有凭有据了吧。</p><p><strong>根据条件列出镜像</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image ls nginx # 根据名称列出镜像</span><br><span class="line">docker image ls nginx:latest # 根据名称与标签列出镜像</span><br><span class="line">docker image ls -f since=hello-world:latest # -f 是--filter的缩写，过滤器参数，列出在hello-world:latest之后建立的镜像，before=hello-world:latest则查看之前建立的镜像</span><br></pre></td></tr></table></figure></p><p><strong>指定显示格式</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -q # 只显示镜像ID</span><br><span class="line">docker image ls --digests # 列出镜像摘要</span><br><span class="line"></span><br><span class="line">docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"  # 使用Go的模板语法格式化显示，这里显示格式为 镜像ID：镜像名称</span><br><span class="line">docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;" # 自己定义表格格式</span><br></pre></td></tr></table></figure></p><p><strong>虚悬镜像</strong><br>有时候会看到某些镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。这些镜像原本是有镜像名和标签的，随着官方镜像维护，发布了新版本后(新版本会复用之前的镜像名称与标签，一般是bug修复版)，重新<code>docker pull xx</code> 时， 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了<code>&lt;none&gt;</code> 。除了<code>docker pull</code>可能导致这种情况， <code>docker build</code>也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像被称为虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -f dangling=true</span><br></pre></td></tr></table></figure></p><p>一般虚悬镜像没什么意义了，可以通过如下命令删除<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure></p><p><strong>中间层镜像</strong><br>为了加速镜像构建、重复利用资源，Docker会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的<code>docker image ls</code>列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，可以加 -a<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls -a</span></span><br></pre></td></tr></table></figure></p><p>这样会看到很多无标签的镜像，与虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><p><strong>删除镜像</strong><br>删除镜像命令格式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure></p><p>选项可以设置：</p><ul><li>-f, –force  强制删除镜像</li><li>–no-prune   不删除没有标签的父镜像</li></ul><p>&lt;镜像1&gt;、&lt;镜像2&gt; 等可以是镜像的名称，镜像的全ID，也可以是镜像ID的前面几个数字（只要与其它镜像区分开来就行），或者是镜像摘要。 如删除镜像名称为mysql的镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker image rm mysql</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:415ac63da0ae6725d5aefc9669a1c02f39a00c574fdbc478dfd08db1e97c8f1b</span><br><span class="line">Deleted: sha256:c7109f74d339896c8e1a7526224f10a3197e7baf674ff03acbab387aa027882a</span><br><span class="line">Deleted: sha256:35d60530f024aa75c91a123a69099f7f6eaf5ad7001bb983f427f674980d8482</span><br><span class="line">Deleted: sha256:49d8bb533eee600076e3a513a203ee24044673fcef0c1b79e088b2ba43db2c17</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>由上面命令的执行结果可见，删除镜像包括另个行为：Untagged、Deleted。</p><p>当我们使用上面命令来删除镜像的时候，实际上是在要求删除某个/某些标签的镜像。所以首先需要做的是将满足要求的所有镜像标签都取消，这就是Untagged的行为。一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么Delete行为就不会发生，仅仅是取消了这个镜像的符合要求的所有标签。所以并非所有的<code>docker image rm</code>都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能就失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。如果某个其它镜像正依赖于当前镜像的某一层，这种情况，依旧不会触发删除该层的行为。直到没有任何镜像依赖当前层时，才会真实的删除当前层。</p><p>另外还需要注意是容器对镜像的依赖。如果基于镜像启动的容器存在（即使容器没有运行处于停止状态） ，同样不可以删除这个镜像。我们之前说了容器是以镜像为基础，再加一层容器存储层组成的多层存储结构去运行的。所以如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。 </p><p><strong>通过组合命令来删除</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q nginx) # 删除镜像名称为nginx的所有镜像</span><br><span class="line">docker image rm $(docker image ls -q -f since=hello-world:latest) # 删除所有在hello-world:latest之后建立的镜像</span><br></pre></td></tr></table></figure></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本文对镜像的获取及本地镜像的基本管理做了介绍，本文镜像的获取途径都是从镜像仓库直接获取，镜像的另一个获取途径便是自定义，接下来会通过实例来进行介绍，欢迎关注。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Docker中，应用是通过容器来运行的，而容器的运行是基于镜像的，类似面向对象设计中类与对象的关系——没有类的定义就谈不上实例的创建与使用，没有镜像的定义就谈不上容器的创建与运行。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（三）：Docker安装与配置</title>
    <link href="http://blog.jboost.cn/docker-3.html"/>
    <id>http://blog.jboost.cn/docker-3.html</id>
    <published>2019-07-14T11:54:05.000Z</published>
    <updated>2019-07-15T00:47:02.022Z</updated>
    
    <content type="html"><![CDATA[<p>Docker分为Docker CE社区免费版与Docker EE企业收费版。Docker EE主要是在安全性及镜像、容器高级管理方面提供了一些额外的支持。对于中小型企业、团队或个人来说，用Docker CE即可。<br><a id="more"></a></p><h2 id="1-安装Docker-CE"><a href="#1-安装Docker-CE" class="headerlink" title="1. 安装Docker CE"></a>1. 安装Docker CE</h2><p>Docker CE有三个更新渠道：</p><ul><li>Stable：提供最新的GA（General Availability）稳定版，每六个月一版，如 18.09 表示18年9月版，下一版就是19.03——19年3月版</li><li>Test：提供GA之前的Pre-release版</li><li>Nightly：提供最新的build版本，每天一版</li></ul><p>我们一般使用stable版。Docker CE支持在多种操作系统下安装，本文只介绍比较常见的Ubuntu 18.04 LTS、CentOS7、及Windows 10上的安装与配置。</p><h3 id="1-1-Ubuntu-18-04-LTS-上安装"><a href="#1-1-Ubuntu-18-04-LTS-上安装" class="headerlink" title="1.1 Ubuntu 18.04 LTS 上安装"></a>1.1 Ubuntu 18.04 LTS 上安装</h3><p>Docker CE支持的64位Ubuntu系统版本为</p><ul><li>Cosmic 18.10</li><li>Bionic 18.04 (LTS)</li><li>Xenial 16.04 (LTS)</li></ul><p>Docker CE在Ubuntu上支持 overlay2， aufs， 以及 btrfs 几种存储驱动程序，对于Linux内核版本为4或以上系统的安装，Docker CE默认使用 overlay2，如果需要使用 aufs，则需要手动配置（参考： <a href="https://docs.docker.com/storage/storagedriver/aufs-driver/" target="_blank" rel="noopener">Use the AUFS storage driver</a>）</p><ol><li>卸载旧版本</li></ol><p>如果系统安装有旧版本，旧版本命名为 docker， docker.io，或docker.engine，可使用如下命令进行卸载<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove docker docker-engine docker.io containerd runc</span></span><br></pre></td></tr></table></figure></p><p>目录/var/lib/docker下的内容，包括镜像、容器、数据卷、网络等，会被保留。</p><ol start="2"><li>使用APT安装</li></ol><p>apt源使用HTTPS来确保软件下载过程中不被篡改，所以首先添加使用HTTPS传输需要的软件包以及CA证书<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install \</span></span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></p><p>为了确认下载软件包的合法性，添加Docker官方的GPG key：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/</span></span><br><span class="line">gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></p><p>由于国内网络原因，我们一般要使用国内源，否则安装将会灰常灰常慢。向source.list中添加Docker软件源（以下命令添加的是stable版本的APT镜像源，如果需要test或nightly版，将stable改为对应test或nightly即可）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository \</span></span><br><span class="line">"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line"><span class="meta">$</span><span class="bash">(lsb_release -cs) \</span></span><br><span class="line">stable"</span><br></pre></td></tr></table></figure></p><p>然后，便可更新apt软件包缓存，开始安装了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install docker-ce</span></span><br></pre></td></tr></table></figure></p><p>以上命令默认会安装软件源里的最新版本，如果需要安装指定版本，则可通过查看可用版本，然后指定版本安装，查看版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-cache madison docker-ce</span></span><br></pre></td></tr></table></figure></p><p>安装指定版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install docker-ce=&lt;VERSION_STRING&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>使用脚本自动安装</li></ol><p>Docker提供了一个方便的安装脚本来在开发测试环境安装Docker CE的edge或测试版，Ubuntu上可使用这套脚本来安装Docker CE的edge版<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL https://get.docker.com -o get-docker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh get-docker.sh --mirror Aliyun</span></span><br></pre></td></tr></table></figure></p><ol start="4"><li>启动Docker CE</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker <span class="comment">#开启开机自动启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker  <span class="comment">#启动docker</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>用户组配置</li></ol><p>docker命令默认是使用Unix socket与Docker引擎进行通信（回顾下除了Unix socket还有REST API及网络端口），只有root用户或docker用户组里的用户才有权限访问Docker引擎的Unix socket，因此，需要将使用docker的用户加入docker用户组（处于安全考虑，一般尽量不要直接使用root用户来操作）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd docker <span class="comment">#添加docker用户组</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker <span class="variable">$USER</span> <span class="comment">#将当前用户加到docker用户组</span></span></span><br></pre></td></tr></table></figure></p><p>退出账号重新登录即可。</p><ol start="6"><li>测试安装是否成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run hello-world</span></span><br></pre></td></tr></table></figure><p>如果显示如下图，则说明安装已成功<br><img src="/assets/hello-docker.png" alt="hello-docker"></p><ol start="7"><li>卸载</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><p>以上命令可以卸载docker-ce，但是之前的镜像、容器、数据卷等不会自动删除，可通过如下命令彻底删除<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo rm -rf /var/lib/docker</span></span><br></pre></td></tr></table></figure></p><h3 id="1-2-CentOS-7-上安装"><a href="#1-2-CentOS-7-上安装" class="headerlink" title="1.2 CentOS 7 上安装"></a>1.2 CentOS 7 上安装</h3><p>Docker CE支持64位的CentOS7，并且要求内核版本不低于3.10。CentOS 7满足最低内核的要求，但由于版本较低，一些功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。<br>可以通过<code>uname -r</code>命令来查看系统内核版本，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# uname -r</span><br><span class="line">3.10.0-957.1.3.el7.x86_64</span><br></pre></td></tr></table></figure></p><ol><li>卸载旧版本</li></ol><p>如果安装了旧版本，需要先卸载。旧版本的Docker称为docker或者docker-engine，卸载命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker \</span></span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-selinux \</span><br><span class="line">    docker-engine-selinux \</span><br><span class="line">    docker-engine</span><br></pre></td></tr></table></figure></p><ol start="2"><li>使用yum安装</li></ol><p>安装依赖包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils \</span></span><br><span class="line">    device-mapper-persistent-data \</span><br><span class="line">    lvm2</span><br></pre></td></tr></table></figure></p><p>由于国内网络原因，我们一般要使用国内源，否则安装可能会灰常灰常慢。添加yum软件源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce</span><br><span class="line">    .repo</span><br></pre></td></tr></table></figure></p><p>如果要安装nightly或test版，执行如下对应的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-nightly <span class="comment"># 启用nightly， 将--enbale改为disable又可以禁用</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-test <span class="comment"># 启用test</span></span></span><br></pre></td></tr></table></figure></p><p>安装最新版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum makecache fast <span class="comment"># 更新软件源缓存</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce <span class="comment"># 安装最新版本</span></span></span><br></pre></td></tr></table></figure></p><p>安装指定版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum list docker-ce --showduplicates | sort -r <span class="comment"># 列出可用版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce-&lt;VERSION_STRING&gt; <span class="comment"># 安装指定版本</span></span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>使用脚本自动安装</li></ol><p>执行如下命令，则会自动安装Docker CE的edge版，注意只在开发或测试环境这么用（建议最好还是用stable版）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL get.docker.com -o get-docker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh get-docker.sh --mirror Aliyun</span></span><br></pre></td></tr></table></figure><ol start="4"><li>启动Docker CE</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker <span class="comment">#开启开机自动启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker  <span class="comment">#启动docker</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>用户组配置</li></ol><p>docker命令默认是使用Unix socket与Docker引擎进行通信（回顾下除了Unix socket还有REST API及网络端口），只有root用户或docker用户组里的用户才有权限访问Docker引擎的Unix socket，因此，需要将使用docker的用户加入docker用户组（处于安全考虑，一般尽量不要直接使用root用户来操作）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd docker <span class="comment">#添加docker用户组</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker <span class="variable">$USER</span> <span class="comment">#将当前用户加到docker用户组</span></span></span><br></pre></td></tr></table></figure></p><p>退出账号重新登录即可。</p><ol start="6"><li>测试安装是否成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run hello-world</span></span><br></pre></td></tr></table></figure><p>如果显示如下图，则说明安装已成功<br><img src="/assets/hello-docker.png" alt="hello-docker"></p><p>如果在 CentOS 中使用 Docker CE 看到下面的这些警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: bridge-nf-call-iptables is disabled</span><br><span class="line">WARNING: bridge-nf-call-ip6tables is disabled</span><br></pre></td></tr></table></figure></p><p>可以添加内核配置参数以启用这些功能。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tee -a /etc/sysctl.conf &lt;&lt;-EOF</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>然后重新加载 sysctl.conf 即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl -p</span></span><br></pre></td></tr></table></figure></p><ol start="7"><li>卸载</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker-ce <span class="comment"># 卸载docker-ce</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm -rf /var/lib/docker <span class="comment"># 该目录下的镜像、容器、数据卷、网络等不会自动删除</span></span></span><br></pre></td></tr></table></figure><h3 id="1-3-Windows-10-上安装"><a href="#1-3-Windows-10-上安装" class="headerlink" title="1.3 Windows 10 上安装"></a>1.3 Windows 10 上安装</h3><p>windows 10上的安装非常简单，直接下载<a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="noopener">stable版本</a>安装。<br>安装完后，在 Windows 搜索栏输入 Docker 点击 Docker for Windows 开始运行</p><h2 id="2-配置国内镜像"><a href="#2-配置国内镜像" class="headerlink" title="2. 配置国内镜像"></a>2. 配置国内镜像</h2><p>Docker默认是从Docker Hub（官方的镜像仓库）拉取镜像的，国内访问一般会比较慢，因此可以配置一些镜像加速器，很多云服务商提供了自己的加速器服务，如Azure中国，阿里云（需要登录获取），七牛云等。</p><p>Ubuntu、CentOS上，配置国内镜像只需要在/etc/docker/daemon.json中写入如下内容（如果文件不存在则创建一个）<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">        <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后重新启动服务<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure></p><p>对于Windows 10，在系统右下角托盘Docker图标上右键菜单选择<br>Settings ，打开配置窗口后在左侧导航菜单选择 Daemon 。在 Registry<br>mirrors 一栏中填写加速器地址 <a href="https://dockerhub.azk8s.cn" target="_blank" rel="noopener">https://dockerhub.azk8s.cn</a> ，之后点击<br>Apply 保存， Docker 就会自动重启并应用配置的镜像地址了。 </p><p>可以通过<code>docker info</code>命令来检查加速器是否生效，如果执行命令能看到类似如下信息，则说明加速器配置生效了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line">    https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Docker分Docker CE与Docker EE两个版本，对大多数人来说，一般使用Docker CE就行了。我们在安装Docker CE时，最好安装stable版，比较稳定可靠。同时，Linux安装时，记得配置Docker软件源，不然有可能太慢。安装完后，需要配置镜像加速器，加快镜像的下载速度。工具有了，接下来就是探索实践了，加油吧少年！<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker分为Docker CE社区免费版与Docker EE企业收费版。Docker EE主要是在安全性及镜像、容器高级管理方面提供了一些额外的支持。对于中小型企业、团队或个人来说，用Docker CE即可。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（二）：Docker管理的对象</title>
    <link href="http://blog.jboost.cn/docker-2.html"/>
    <id>http://blog.jboost.cn/docker-2.html</id>
    <published>2019-07-14T00:36:56.000Z</published>
    <updated>2019-07-24T01:50:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/docker-1.html">Docker笔记（一）：什么是Docker</a>中，我们提到了Docker管理的对象包含镜像、容器、网络、数据卷等，本文就来介绍下这些对象及用途。<br><a id="more"></a></p><h2 id="1-镜像"><a href="#1-镜像" class="headerlink" title="1. 镜像"></a>1. 镜像</h2><p>所谓镜像，是一个静态的概念。它对我们期望干的事情做了一些定义，比如要运行什么程序，需要哪些依赖，需要什么样的配置，需要开放哪个网络端口等等。<br>Docker的镜像是一个特殊的文件系统，提供了运行时需要的程序、库、资源、配置等文件，还包含一些为运行时准备的配置参数（如环境变量、匿名数据卷、用户等），镜像不包含任何动态数据，其内容在构建之后也不会被改变。<br>镜像的文件系统有一个分层存储的概念，采用的是Union FS技术，因此，镜像并不是简单地由一组文件组成，而是由多层文件系统叠加联合组成。如下图所示<br><img src="/assets/container-layers.jpg" alt="container-layers"></p><p>镜像构建时，会一层一层地构建，前一层是后一层的基础，每层构建完后就变成只读的，不会再发生改变。镜像分层存储的一大好处是复用，镜像的每一层可以在不同镜像间复用，这就好比我们开发项目时将一些公共功能封装成jar包，在各个项目可以直接依赖使用一样。关于镜像的更多内容，在后续使用时再详述。</p><h2 id="2-容器"><a href="#2-容器" class="headerlink" title="2. 容器"></a>2. 容器</h2><p>相对镜像，容器是一个动态的运行时的概念，它与镜像的关系类似于面向对象中类与实例的关系。容器可以被创建、启动、停止、删除等。容器运行实质上就是运行一个进程，但与那些直接在宿主机上运行的进程不同，容器运行在自己的独立的隔离的命名空间中——拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间，因此虽然是以进程的形式运行，但好像是运行在一个独立的系统中一样，这样相比直接运行于宿主机的进程，容器的运行显得更为安全。<br>前面说到镜像的分层存储概念，对于容器来说，实际上也是以镜像作为基础层，在其上创建了一个当前容器的存储层，如下图<br><img src="/assets/sharing-layers.jpg" alt="sharing-layers.jpg"></p><p>以镜像ubuntu:15.04为基础层所创建的容器，都有一个自己的可读写的存储层（镜像的存储层是只读的）。容器存储层的生命周期与容器一样，容器销毁时，容器的存储层也会随之消亡，任何保存在容器存储层的数据也都会随容器的删除而丢失，因此一般我们要保持容器存储层的无状态化，所有文件的写操作，都应该使用数据卷或绑定宿主机目录。</p><h2 id="3-数据卷"><a href="#3-数据卷" class="headerlink" title="3. 数据卷"></a>3. 数据卷</h2><p>数据卷是一个独立于容器，可供一个或多个容器使用的特殊目录，它绕过了Union FS，不会随容器的销毁而消亡。这好比我们在阿里云上建虚机，再加载一个数据盘一样，一般产生的数据都要保存在数据盘，而不是虚机的系统盘。<br>数据卷具备如下特性：</p><ol><li>可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>数据卷的更新，不会影响到镜像</li><li>数据卷默认会一直存在，不会随容器的删除而消亡</li></ol><h2 id="4-网络"><a href="#4-网络" class="headerlink" title="4. 网络"></a>4. 网络</h2><p>Docker容器是如何与外部进行网络通信的？一般来说，我们在运行容器时，只需要指定容器服务端口与宿主机端口的映射，就可以通过宿主机IP与映射的端口访问容器服务了，因为Docker默认使用了Bridge的模式来实现容器与外部的通信。<br>Docker的网络子系统通过使用一些驱动程序，是可插拔式的，默认提供了如下几种驱动：</p><ol><li>bridge：默认的网络驱动。运行在容器中的应用程序一般是通过网桥与外部进行通信。</li><li>host：容器直接使用宿主机的网络通信。host只在基于Docker 17.06或以上版本的Swarm服务中可用</li><li>overlay：overlay可将多个Docker daemon进程连接起来使得Swarm服务之间能相互通信，也可以将overlay用于Swarm服务与容器之间，或运行在不同Docker daemon上的容器之间的通信，不需要操作系统层面的路由配置。</li><li>macvlan：macvlan允许你分配一个mac地址给容器，让它像一台物理设备一样加入你的网络中。Docker daemon通过mac地址将请求路由给容器，适用于那些希望直接连到物理网络的遗留应用。</li><li>none：禁用所有网络。一般与一个自定义的网络驱动一起使用。none不能用于Swarm服务。</li><li>其它第三方网络插件：可从Docker Hub或其它第三方供应商获取安装。</li></ol><p>总之，bridge适用于在同一台宿主机运行多个容器的场景；host适用于不应与宿主机进行网络隔离的场景；overlay适用于运行在不同宿主机上的容器间通信，或多个应用通过Swarm服务来共同协作的场景；macvlan适用于从虚拟机迁移配置或希望容器作为物理机一样使用网络的场景。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文对Docker所管理的几个基本对象——镜像、容器、数据卷、网络做了简单介绍，这是认识或学习Docker的基础，在后续实践操作过程中，将会对各部分进行更详细的使用说明，欢迎持续关注。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/docker-1.html&quot;&gt;Docker笔记（一）：什么是Docker&lt;/a&gt;中，我们提到了Docker管理的对象包含镜像、容器、网络、数据卷等，本文就来介绍下这些对象及用途。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（一）：什么是Docker</title>
    <link href="http://blog.jboost.cn/docker-1.html"/>
    <id>http://blog.jboost.cn/docker-1.html</id>
    <published>2019-07-13T02:13:25.000Z</published>
    <updated>2019-07-13T09:59:13.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>接触Docker也有两年多了，断断续续玩过一些应用场景，如安装一些常用工具服务，部署业务项目，基于gitlab+jenkins pipeline+docker的CI/CD实现等。了解其基本知识与操作，但不能说深度掌握，故借此系列进行梳理与学习，也希望对有意学习Docker的人提供参考。</p><a id="more"></a><h2 id="2-Docker简介"><a href="#2-Docker简介" class="headerlink" title="2. Docker简介"></a>2. Docker简介</h2><p>Docker最初是dotCloud公司（后来也改名为Docker）的一个内部项目，于2013年3月开源。Docker使用Google推出的Go语言实现，基于Linux内核的cgroup、namespace、Union FS等技术（先不用急着了解这些都是啥），对进程进行隔离，是操作系统层面的虚拟化技术。相对于传统的硬件层面的虚拟化技术（虚拟机），Docker显得更为轻量化。下图为传统虚拟机与Docker的结构对比<br><img src="/assets/vm-docker.png" alt="vm-docker"></p><p>由上图可看出传统虚拟机技术是在硬件层面虚拟出一套硬件（CPU、内存、磁盘、网卡等）后，在其上运行一个完整的操作系统，再在操作系统上运行应用进程；而Docker的应用进程是直接运行在宿主机的内核上，也不需要进行硬件虚拟，因此，Docker要比传统虚拟机更为轻便。</p><p>总结Docker相对传统虚拟化技术的优势如下：</p><ol><li><strong>更高的资源利用率：</strong>Docker不需要硬件虚拟与运行完整操作系统的开销，所以资源利用率更高，同样配置的主机，采用Docker往往可以运行更多数量的应用。</li><li><strong>更高效的使用体验：</strong>在操作系统上安装一些常用软件，如mysql，redis等，往往需要折腾好一阵，有些还要手动安装各种依赖，而采用Docker，可能几行命令就可以让一个服务快速运行起来。</li><li><strong>一致的运行环境：</strong>Docker镜像功能可以把程序运行需要的环境进行封装，确保程序在开发、测试、生产环境都能保持一致性，避免因环境不一致导致程序运行异常。</li><li><strong>CI/CD支持：</strong>使用Docker可以定制镜像来实现持续集成、持续部署，如基于gitlab + jenkins pipeline + docker的自动化部署。</li><li><strong>更轻松的维护：</strong>因为Docker保证了运行环境的一致性，因此应用的迁移或缩放将变得很容易；Docker的分层存储与镜像技术，也使得应用重复部分的复用变得更简单，基于基础镜像可以进一步扩展定义自己的镜像，也可以直接使用官方镜像来使用。</li></ol><h2 id="3-Docker的基本架构"><a href="#3-Docker的基本架构" class="headerlink" title="3. Docker的基本架构"></a>3. Docker的基本架构</h2><p>Docker的基本架构图如下<br><img src="/assets/docker-arch.png" alt="docker-arch"></p><p>主要包括几部分：</p><ol><li>Docker daemon（Docker守护进程 <code>dockerd</code>）：Docker的执行引擎，负责监听处理Docker客户端请求与管理Docker相关对象，如镜像、容器、网络、数据卷等。一个Docker守护进程可与其它Docker守护进程进行通信，作为Docker服务进行管理。</li><li>Docker client（Docker客户端 <code>docker</code>）：Docker客户端（<code>docker</code> CLI命令）是大多数用户用来与Docker守护进程交互的方式，比如你在命令行执行<code>docker run</code>，Docker客户端将发送该命令请求到Docker守护进程，由守护进程执行。Docker客户端可通过REST API, UNIX Socket或网络接口来与Docker守护进程进行通信，并且可与多个Docker守护进程进行通信。</li><li>Docker Registry（Docker注册中心）：用来存储Docker镜像的仓库，类似于Maven的Nexus。Docker官方提供了一个公共镜像仓库Docker Hub（ <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> ），<code>docker</code>相关命令默认会从Docker Hub上搜索与下载镜像，我们可以配置一些国内镜像仓库地址来进行加速，甚至搭建自己的私有镜像仓库。</li><li>Docker Objects：Docker管理的对象，主要包括镜像、容器、网络、数据卷等。</li></ol><h2 id="4-Docker的用途"><a href="#4-Docker的用途" class="headerlink" title="4. Docker的用途"></a>4. Docker的用途</h2><p>根据第二部分Docker的优势及笔者的经验来看，目前Docker主要用于</p><ol><li>常用软件服务的搭建运行，如Mysql、Redis、Nginx等</li><li>业务服务的发布部署，尤其是基于SpringBoot的微服务</li><li>CI/CD实现，结合Gitlab的webhook，Jenkins的pipeline，实现自动化集成与部署</li><li>快速的弹性伸缩，在容器集群化管理的场景中，如Swarm、K8s解决方案中，可基于容器对服务进行快速的弹性伸缩来应对业务量的突发情况</li><li>执行环境封装，如一些深度学习框架模型，打成Docker镜像的方式进行发布，可以快速在不同的环境中运行起来</li><li>…</li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>在微服务架构、DevOps这些概念盛行的时代，容器化技术变得越来越重要，几乎成为每一位开发人员需要掌握的技能。本系列文章是笔者基于自身实践及相关文献参考，对Docker相关技术进行整理，欢迎关注，共同学习。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;接触Docker也有两年多了，断断续续玩过一些应用场景，如安装一些常用工具服务，部署业务项目，基于gitlab+jenkins pipeline+docker的CI/CD实现等。了解其基本知识与操作，但不能说深度掌握，故借此系列进行梳理与学习，也希望对有意学习Docker的人提供参考。&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu18.04上搭建KVM虚拟机环境超完整过程</title>
    <link href="http://blog.jboost.cn/ubuntu-kvm.html"/>
    <id>http://blog.jboost.cn/ubuntu-kvm.html</id>
    <published>2019-07-11T06:13:23.000Z</published>
    <updated>2019-07-12T11:19:00.269Z</updated>
    
    <content type="html"><![CDATA[<p>看标题这是篇纯运维的文章。在中小型企业中，一般很少配置专业的运维人员，都是由开发人员兼着。同时，对有志于技术管理的开发人员来说，多了解一些运维及整个软件生命周期的知识，是很有帮助的，因为带团队不仅仅是个管人的活，更多的是在你的部下遇到难题或者无人能上的时候，你能协助他解决或亲自上阵，这比只会“吆五喝六”的管理者将能获得更高的敬重与威信。闲话不多说了，记录下整个KVM虚拟机的搭建过程吧。<br><a id="more"></a></p><h2 id="1-KVM安装"><a href="#1-KVM安装" class="headerlink" title="1. KVM安装"></a>1. KVM安装</h2><h3 id="1-1-配置确认"><a href="#1-1-配置确认" class="headerlink" title="1.1 配置确认"></a>1.1 配置确认</h3><p>首先需要确认服务器的硬件是否支持虚拟化，执行如下命令确认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ egrep -c '(vmx|svm)' /proc/cpuinfo</span><br><span class="line">48</span><br></pre></td></tr></table></figure><p>如果输出结果大于0，意味着服务器硬件是支持虚拟化的。否则，重启进入BIOS设置中启用VT技术。<br>执行如下命令安装kvm-ok程序，来确定服务器是否能够运行硬件加速的KVM虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ sudo apt install cpu-checker</span><br><span class="line"></span><br><span class="line">devuser@server_01:~$ sudo kvm-ok</span><br><span class="line">INFO: /dev/kvm exists</span><br><span class="line">KVM acceleration can be used</span><br></pre></td></tr></table></figure><h3 id="1-2-安装KVM"><a href="#1-2-安装KVM" class="headerlink" title="1.2 安装KVM"></a>1.2 安装KVM</h3><p>安装KVM及依赖项<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ sudo apt update</span><br><span class="line">devuser@server_01:~$ sudo apt install qemu qemu-kvm libvirt-bin  bridge-utils  virt-manager</span><br></pre></td></tr></table></figure></p><p>启动libvirtd服务，并设置开机自动启动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ sudo systemctl start libvirtd.service</span><br><span class="line">devuser@server_01:~$ sudo systemctl enable libvirtd.service</span><br></pre></td></tr></table></figure></p><p>执行<code>service libvirtd status</code>查看libvirtd服务状态，如图<br><img src="/assets/kvm1.png" alt="libvirtd-status"></p><h3 id="1-3-桥接网络配置"><a href="#1-3-桥接网络配置" class="headerlink" title="1.3 桥接网络配置"></a>1.3 桥接网络配置</h3><p>一般虚拟机网络配置有Bridge、NAT等几种模式。NAT模式下，虚拟机不需要配置自己的IP，通过宿主机来访问外部网络；Bridge模式下， 虚拟机需要配置自己的IP，然后虚拟出一个网卡， 与宿主机的网卡一起挂到一个虚拟网桥上（类似于交换机）来访问外部网络，这种模式下，虚拟机拥有独立的IP，局域网其它主机能直接通过IP与其通信。简单理解，就是NAT模式下，虚机隐藏在宿主机后面了，虚机能通过宿主机访问外网，但局域网其它主机访问不到它，Bridge模式下，虚机跟宿主机一样平等地存在，局域网其它主机可直接通过IP与其通信。一般我们创建虚机是用来部署服务供使用的， 所以都是用Bridge模式。</p><p>ubuntu 18中，网络配置通过netplan来实现了，如下，更改配置文件 /etc/netplan/50-cloud-init.yaml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">devuser@cserver_01:~$ sudo vim /etc/netplan/50-cloud-init.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> This file is generated from information provided by</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the datasource.  Changes to it will not persist across an instance.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">disable</span> cloud-init<span class="string">'s network configuration capabilities, write a file</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> network: &#123;config: disabled&#125;</span></span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        enp6s0:</span><br><span class="line">            dhcp4: true</span><br><span class="line">        enp7s0:</span><br><span class="line">            dhcp4: no</span><br><span class="line">            dhcp6: no</span><br><span class="line">    version: 2</span><br><span class="line"></span><br><span class="line">    bridges:</span><br><span class="line">         br0:</span><br><span class="line">             interfaces: [enp7s0]</span><br><span class="line">             dhcp4: no</span><br><span class="line">             addresses: [192.168.40.241/24]</span><br><span class="line">             gateway4: 192.168.40.1</span><br><span class="line">             nameservers:</span><br><span class="line">                 addresses: [114.114.114.114,8.8.8.8]</span><br></pre></td></tr></table></figure><p>将宿主机原有网卡enp7s0挂到网桥br0上，并指定IP地址为192.168.40.241，nameservers指定DNS服务器。修改完后，通过<code>sudo netplan apply</code>重启网络服务生效，然后通过<code>ifconfig</code>查看，<br><img src="/assets/kvm2.png" alt="kvm2"><br>原来挂在enp7s0网卡下的IP现在挂到了br0上，宿主机及所有其它虚拟机都通过该网桥来与外部通讯。我们也可以通过<code>brctl show</code>来直观地查看，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ brctl show</span><br><span class="line">bridge name    bridge idSTP enabled    interfaces</span><br><span class="line">br0    8000.2a5be3ec2698no        enp7s0</span><br><span class="line">docker08000.02424524dcceno        veth580af8e</span><br><span class="line">        veth74119f3</span><br><span class="line">        vethe7a2b0f</span><br><span class="line">        vethfe89039</span><br></pre></td></tr></table></figure></p><p>目前因为还没虚机，所以只有宿主机的网卡enp7s0挂在网桥br0上。同时也可以看到docker容器也是通过网桥docker0来通讯的。</p><h2 id="2-虚拟机安装"><a href="#2-虚拟机安装" class="headerlink" title="2. 虚拟机安装"></a>2. 虚拟机安装</h2><h3 id="2-1-安装虚拟机"><a href="#2-1-安装虚拟机" class="headerlink" title="2.1 安装虚拟机"></a>2.1 安装虚拟机</h3><p>安装命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-install --name=dev-server1 --memory=16384,maxmemory=16384 \</span><br><span class="line">--vcpus=4,maxvcpus=4 --os-type=linux --os-variant=rhel7 \</span><br><span class="line">--location=/home/devuser/tools/CentOS-7-x86_64-DVD-1810.iso \</span><br><span class="line">--disk path=/var/lib/libvirt/images/devserver1.img,size=300 \</span><br><span class="line">--bridge=br0 --graphics=none --console=pty,target_type=serial \</span><br><span class="line">--extra-args="console=tty0 console=ttyS0"</span><br></pre></td></tr></table></figure></p><p>其中–name指定虚机名称；–memory=16384,maxmemory=16384配置了16G内存；–vcpus=4,maxvcpus=4配置了4个CPU内核；centos7需要指定–os-variant=rhel7；–disk path=xx,size=300指定了磁盘路径与大小，这里是300G。</p><p>如果执行上述命令出现<code>qemu-kvm: could not open &#39;xx/CentOS-7-x86_64-DVD-1810.iso&#39;: Permission denied</code>异常退出时，可通过修改<code>/etc/libvirt/qemu.conf</code>文件将<code>user = &quot;root&quot;</code>，<code>group = &quot;root&quot;</code>前面的注释去掉解决（<a href="https://github.com/jedi4ever/veewee/issues/996）" target="_blank" rel="noopener">https://github.com/jedi4ever/veewee/issues/996）</a></p><p>如无问题，安装程序将出现如下配置界面<br><img src="/assets/kvm3.png" alt="kvm3"></p><p>可通过输入选项对应的数字来选择不同的配置，依次操作如下步骤完成时区设置：<br>输入2，回车，选择时区设置；输入1，回车，选择“Set timezone”；输入2，回车，选择“Asia”；回车，输入64，回车，选择“Shanghai”</p><p>然后进行安装设置，<br><img src="/assets/kvm4.png" alt="kvm4"><br>依次操作如下：<br>输入5，回车，进入安装设置；输入c，回车，选择默认的磁盘进行安装；输入c，回车，使用默认的“2) Use All<br> Space”；输入1，回车，选择“1) Standard Partition”进行标准分区；输入c，回车，完成分区设置</p><p>最后进入root密码设置，<br><img src="/assets/kvm5.png" alt="kvm5"><br>操作如下：<br>输入8，回车，进入root密码设置；输入密码，回车；输入确认密码，回车</p><p>完成上述设置后，输入b开始进行安装<br><img src="/assets/kvm6.png" alt="kvm6"></p><p>等待一段时间后，安装程序停在如下界面<br><img src="/assets/kvm7.png" alt="kvm7"></p><p>按回车继续，最后输入用户名root，及前面设置的密码登录系统<br><img src="/assets/kvm8.png" alt="kvm8"></p><h3 id="2-2-虚拟机网络配置"><a href="#2-2-虚拟机网络配置" class="headerlink" title="2.2 虚拟机网络配置"></a>2.2 虚拟机网络配置</h3><p>虚拟机安装完后，是没有分配IP的，我们通过<code>ip a</code>命令查看，<br><img src="/assets/kvm9.png" alt="kvm9"></p><p>这时候的eth0下面空空如也，什么都没有。在<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>文件中添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static #静态指定IP</span><br><span class="line">DEFROUTE=yes</span><br><span class="line"><span class="meta">#</span><span class="bash">IPV4_FAILURE_FATAL=no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6INIT=yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_AUTOCONF=yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_DEFROUTE=yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_FAILURE_FATAL=no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_ADDR_GEN_MODE=stable-privacy</span></span><br><span class="line">NAME=eth0</span><br><span class="line">UUID=449ed621-97a8-45b9-902f-0d347e27de98</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes  #开机自动启动</span><br><span class="line">IPADDR=192.168.40.96</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.40.1</span><br><span class="line">DNS1=192.168.40.1</span><br></pre></td></tr></table></figure><p>并通过<code>systemctl restart network</code>重启网络生效，这时候再运行<code>ip a</code>查看，eth0下面已经有配置的IP了。不出意外的话，局域网其它主机就可以通过该IP来远程SSH连接了。<br><img src="/assets/kvm10.png" alt="kvm10"></p><p>这时候我们再通过<code>brctl show</code>来查看网桥挂载情况，br0下面已经多了一个vnet0虚拟网卡了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ brctl show</span><br><span class="line">bridge name    bridge idSTP enabled    interfaces</span><br><span class="line">br0    8000.2a5be3ec2698no        enp7s0</span><br><span class="line">        vnet0</span><br><span class="line">docker08000.02424524dcceno        veth580af8e</span><br><span class="line">        veth74119f3</span><br><span class="line">        vethd270ee8</span><br><span class="line">        vethe7a2b0f</span><br><span class="line">        vethfe89039</span><br></pre></td></tr></table></figure></p><p>虚拟机装完后，默认的hostname是localhost，针对centos7，我们可以通过如下命令来修改hostname<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl set-hostname dev-server1</span><br></pre></td></tr></table></figure></p><p>然后在/etc/hosts文件中添加127.0.0.1的host映射 dev-server1<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 dev-server1</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure></p><h2 id="3-虚拟机管理"><a href="#3-虚拟机管理" class="headerlink" title="3. 虚拟机管理"></a>3. 虚拟机管理</h2><ol><li>列出当前运行的虚拟机<code>virsh list</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh list</span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 5     dev-server1                    running</span><br></pre></td></tr></table></figure></li></ol><p>如果列出所有的，则<code>virsh list --all</code></p><ol start="2"><li>从宿主机进入虚拟机<code>virsh console</code>，后面接虚拟机ID或名称<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh console 5</span><br><span class="line">Connected to domain dev-server1</span><br><span class="line">Escape character is ^]</span><br><span class="line"></span><br><span class="line">CentOS Linux 7 (Core)</span><br><span class="line">Kernel 3.10.0-957.el7.x86_64 on an x86_64</span><br><span class="line"></span><br><span class="line">dev-server1 login:</span><br></pre></td></tr></table></figure></li></ol><p>输入用户名，密码即可登录虚拟机，按<code>Ctrl+]</code>可退出。</p><ol start="3"><li><p>启动与关闭虚拟机<code>virsh start|shutdown</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devuser@cserver_01:~$ virsh start dev-server1</span><br><span class="line">Domain dev-server1 started</span><br><span class="line"></span><br><span class="line">devuser@server_01:~$ virsh shutdown 5</span><br><span class="line">Domain 5 is being shutdown</span><br></pre></td></tr></table></figure></li><li><p>libvirtd启动时，自动启动虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh autostart dev-server1</span><br><span class="line">Domain dev-server1 marked as autostarted</span><br></pre></td></tr></table></figure></li><li><p>挂起/恢复虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh suspend dev-server1    # 挂起虚拟机</span><br><span class="line">devuser@server_01:~$ virsh resume dev-server1    # 恢复挂起的虚拟机</span><br></pre></td></tr></table></figure></li><li><p>销毁虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh undefine dev-server1   # 彻底销毁虚拟机，会删除虚拟机配置文件，但不会删除虚拟磁盘</span><br></pre></td></tr></table></figure></li></ol><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看标题这是篇纯运维的文章。在中小型企业中，一般很少配置专业的运维人员，都是由开发人员兼着。同时，对有志于技术管理的开发人员来说，多了解一些运维及整个软件生命周期的知识，是很有帮助的，因为带团队不仅仅是个管人的活，更多的是在你的部下遇到难题或者无人能上的时候，你能协助他解决或亲自上阵，这比只会“吆五喝六”的管理者将能获得更高的敬重与威信。闲话不多说了，记录下整个KVM虚拟机的搭建过程吧。&lt;br&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="kvm" scheme="http://blog.jboost.cn/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>软件项目研发流程该怎么规范</title>
    <link href="http://blog.jboost.cn/project-process.html"/>
    <id>http://blog.jboost.cn/project-process.html</id>
    <published>2019-07-08T11:14:47.000Z</published>
    <updated>2019-07-09T11:13:37.300Z</updated>
    
    <content type="html"><![CDATA[<p>在软件项目研发管理过程中，是否经常出现这样的场景：开发人员不知道什么时候转测；项目经理拿个Excel文档群里一发，某任务前天就应该完成的，怎么现在还没开始搞；前端问这部分UI是谁在做，什么时候能做完；测试说线上这个bug又是谁改出来的，这次没转测这模块……等等。整个协作感觉一团乱麻，团队内部充满了甩锅与抱怨的氛围。软件项目的研发流程该怎么规范，让团队成员都能目标明确，步调一致，让产品迭代充满节奏感。本文基于笔者项目研发管理经验整理，希望起到抛砖引玉的作用，探讨高效团队的协作流程模式。<br><a id="more"></a></p><h2 id="1-协作流程图"><a href="#1-协作流程图" class="headerlink" title="1. 协作流程图"></a>1. 协作流程图</h2><p><img src="/assets/project.png" alt="协作流程图"></p><p>基本原则：</p><ol><li>所有问题可跟踪 （需求、Bug、优化）</li><li>所有工作透明化 （工作量、进展、Block因素）</li></ol><h2 id="2-各阶段内容详解"><a href="#2-各阶段内容详解" class="headerlink" title="2. 各阶段内容详解"></a>2. 各阶段内容详解</h2><h3 id="2-1-需求收集确认"><a href="#2-1-需求收集确认" class="headerlink" title="2.1. 需求收集确认"></a>2.1. 需求收集确认</h3><p>本阶段主要是与产品经理相关的活动内容：</p><ol><li>产品经理在每次版本开始之前定期收集各方需求，包括客户反馈、领导意见（对很多中小企业来说，老板就是最大的“用户”）、市场调研及技术团队需求等来源，输出需求列表</li><li>在版本开始之前召开<strong>版本计划会议</strong>，参与者包括项目经理、产品经理，及项目核心成员，按优先级梳理需求列表，输出下次版本的初步任务列表（之所以说初步，是因为该列表后面可能根据评审情况进行调整）</li><li>产品经理基于初步任务列表完成详细需求文档，组织团队成员——包括相关UI、开发、测试，召开 <strong>需求评审会议</strong>，输出评审意见及修正完成时间</li><li>产品经理针对需求评审会议中团队提出的意见建议，在修正完成时间内及时修正需求文档，并及时通知团队相关成员，输出确定的需求文档</li></ol><blockquote><p>注：可在需求评审会议后，进行任务的初步认领分配与时间估算，初步<strong>确定转测、上线时间节点</strong></p></blockquote><h3 id="2-2-设计开发"><a href="#2-2-设计开发" class="headerlink" title="2.2. 设计开发"></a>2.2. 设计开发</h3><ol><li>项目经理根据需求文档完成任务拆解，并在任务管理系统中创建对应任务单，指定经办人</li><li>各经办人认领任务后，根据自身任务的期限，及时与依赖方沟通，确定依赖任务的完成时间，以免影响自身任务进度，存在问题及时向项目经理反馈。</li><li>UI设计完成后，相关开发人员与产品经理需对UI设计进行确认，如果涉及内容较多，可组织<strong>UI评审会议</strong>（由产品经理或项目经理权衡组织）</li><li>涉及流程的开发任务需要有必要的设计，技术相关负责人负责对<strong>设计review</strong>，没有review的设计不能开发；任务开发完成需要进行<strong>代码review</strong></li><li>项目经理定期组织项目例会（紧急版本建议每天一次，较长期版本建议一周一次或两次），持续跟进任务进度与问题，并及时协调处理，以保障进度预期</li><li>在预定转测时间节点前一天，开发人员编写转测文档，描述本次版本调整内容（附上任务列表）及注意事项，并通知项目相关人员（钉钉群或邮件）</li></ol><h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3. 测试"></a>2.3. 测试</h3><ol><li>需求评审会议后，测试人员需对各功能模块编写测试用例文档，并在转测前组织<strong>测试评审会议</strong>，对各功能各环节进行复核与查漏补缺</li><li>一次版本任务可根据情况分批测试，并确定每轮转测的内容与时间节点；分批测试完成后，需在上线前进行集成测试，注意预留一定的时间用于问题修复</li><li>测试完成，需要将测试结论通报项目相关人员（钉钉群或邮件），包括遗留问题与是否达到上线要求结论</li></ol><blockquote><p>注：产品经理可在转测后对开发实现进行验收，以确定开发是否符合需求实际，以便及时进行调整</p></blockquote><h3 id="2-4-上线"><a href="#2-4-上线" class="headerlink" title="2.4. 上线"></a>2.4. 上线</h3><ol><li>上线人员需在上线前编写上线方案文档，记录此次上线内容，并对此次上线操作进行推演，对所涉及的所有操作按步骤进行记录，如数据库操作，代码merge，jenkins构建等；对可能存在的问题进行备注及对应的处理方案，并提交技术相关负责人review</li><li>项目经理结合测试结论及其它各方面情况，决策是否上线，并将意见通知到项目相关人员（钉钉群或邮件）</li><li>上线人员按照上线方案文档记录的步骤，依次完成上线操作（上线操作最好至少由两人完成，一人操作，一人检视，避免出错）</li><li>上线完成后，测试人员与产品经理对此次上线进行线上验证，确保线上功能流程无问题</li><li>验证无误后，由项目经理或其他指定负责人将上线通知发布至利益相关者，包括项目团队所有成员及相关合作方，说明上线时间、上线内容、影响因素、注意事项等（即时通讯群或邮件）</li></ol><h3 id="2-5-复盘"><a href="#2-5-复盘" class="headerlink" title="2.5. 复盘"></a>2.5. 复盘</h3><ol><li>版本结束后，项目经理根据情况对上个周期组织复盘总结会，总结存在的问题与原因，及后续规避的办法，总结积累的经验等</li></ol><blockquote><p>以上各阶段并不是完全串行推进的，相互之间存在一些穿插，比如下一版本需求的收集整理与当前版本的开发是并行推进的，开发与测试也可以以分阶段转测的形式并行推进，等等。</p></blockquote><h2 id="3-一些常用工具"><a href="#3-一些常用工具" class="headerlink" title="3. 一些常用工具"></a>3. 一些常用工具</h2><ol><li>jira 用于项目任务管理，其中Agile插件可方便查看整体任务面板，对任务状态一目了然，需要求团队成员养成及时更新状态的习惯</li><li>confluence 文档管理，用于各类文档的集中化维护，以上所述的如需求文档、开发设计文档、转测文档、上线文档等均可使用confluence以项目空间的形式集中化管理。</li><li>gitlab 代码管理</li><li>jenkins 项目部署构建工具</li><li>nexus 搭建maven私有库</li></ol><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>团队工作讲求步调与节奏，好的流程与规范可以让一个水平一般的人也能充分发挥其作用，从而让团队整体稳步前进，高效产出。而不好的流程，或根本不重视流程的团队，却往往一盘散沙，甩锅与抱怨充斥，战斗力低下。本文以相对较粗粒度对软件项目的基本流程管理做了介绍，更细节的内容可能需要团队根据内部具体情况进行相应处理与对待。链接： <a href="https://pan.baidu.com/s/1WBHsIWoquKTQHJ6IaSql3Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1WBHsIWoquKTQHJ6IaSql3Q</a>  是笔者基于以前团队敏捷项目管理及一些具体问题的思考分享PPT，供参考。提取码：awya </p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在软件项目研发管理过程中，是否经常出现这样的场景：开发人员不知道什么时候转测；项目经理拿个Excel文档群里一发，某任务前天就应该完成的，怎么现在还没开始搞；前端问这部分UI是谁在做，什么时候能做完；测试说线上这个bug又是谁改出来的，这次没转测这模块……等等。整个协作感觉一团乱麻，团队内部充满了甩锅与抱怨的氛围。软件项目的研发流程该怎么规范，让团队成员都能目标明确，步调一致，让产品迭代充满节奏感。本文基于笔者项目研发管理经验整理，希望起到抛砖引玉的作用，探讨高效团队的协作流程模式。&lt;br&gt;
    
    </summary>
    
      <category term="teamwork" scheme="http://blog.jboost.cn/categories/teamwork/"/>
    
    
      <category term="agile" scheme="http://blog.jboost.cn/tags/agile/"/>
    
  </entry>
  
  <entry>
    <title>线程池的基本原理，看完就懂了</title>
    <link href="http://blog.jboost.cn/threadpool.html"/>
    <id>http://blog.jboost.cn/threadpool.html</id>
    <published>2019-07-05T09:32:30.000Z</published>
    <updated>2019-07-09T11:19:28.733Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容是基于研发部门内部的分享整理，记录下来供学习或回顾。</p><a id="more"></a><h2 id="1-为什么要用线程池"><a href="#1-为什么要用线程池" class="headerlink" title="1. 为什么要用线程池"></a>1. 为什么要用线程池</h2><ol><li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建、销毁线程造成的消耗。 </p></li><li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控</p></li></ol><h2 id="2-ThreadPoolExecutor线程池类参数详解"><a href="#2-ThreadPoolExecutor线程池类参数详解" class="headerlink" title="2. ThreadPoolExecutor线程池类参数详解"></a>2. ThreadPoolExecutor线程池类参数详解</h2><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">corePoolSize</td><td style="text-align:center">核心线程数量，线程池维护线程的最少数量</td></tr><tr><td style="text-align:center">maximumPoolSize</td><td style="text-align:center">线程池维护线程的最大数量  </td></tr><tr><td style="text-align:center">keepAliveTime</td><td style="text-align:center">线程池除核心线程外的其他线程的最长空闲时间，超过该时间的空闲线程会被销毁</td></tr><tr><td style="text-align:center">unit</td><td style="text-align:center">keepAliveTime的单位，TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS</td></tr><tr><td style="text-align:center">workQueue</td><td style="text-align:center">线程池所使用的任务缓冲队列</td></tr><tr><td style="text-align:center">threadFactory</td><td style="text-align:center">线程工厂，用于创建线程，一般用默认的即可</td></tr><tr><td style="text-align:center">handler</td><td style="text-align:center">线程池对拒绝任务的处理策略</td></tr></tbody></table><p>当线程池任务处理不过来的时候（什么时候认为处理不过来后面描述），可以通过handler指定的策略进行处理，ThreadPoolExecutor提供了四种策略：</p><ol><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常；也是默认的处理方式。</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ol><p>可以通过实现RejectedExecutionHandler接口自定义处理方式。</p><h2 id="3-线程池任务执行"><a href="#3-线程池任务执行" class="headerlink" title="3. 线程池任务执行"></a>3. 线程池任务执行</h2><h3 id="3-1-添加执行任务"><a href="#3-1-添加执行任务" class="headerlink" title="3.1. 添加执行任务"></a>3.1. 添加执行任务</h3><ul><li>submit() 该方法返回一个Future对象，可执行带返回值的线程；或者执行想随时可以取消的线程。Future对象的get()方法获取返回值。Future对象的cancel(true/false)取消任务，未开始或已完成返回false，参数表示是否中断执行中的线程</li><li>execute() 没有返回值。</li></ul><h3 id="3-2-线程池任务提交过程"><a href="#3-2-线程池任务提交过程" class="headerlink" title="3.2. 线程池任务提交过程"></a>3.2. 线程池任务提交过程</h3><p>一个线程提交到线程池的处理流程如下图<br><img src="/assets/threadpool.png" alt="线程池任务提交"></p><ol><li>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 </li><li>如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。 </li><li>如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。 </li><li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。 </li><li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。</li></ol><p>总结即：处理任务判断的优先级为 核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 </p><p><strong> 注意：</strong></p><ol><li>当workQueue使用的是无界限队列时，maximumPoolSize参数就变的无意义了，比如new LinkedBlockingQueue(),或者new ArrayBlockingQueue(Integer.MAX_VALUE);</li><li>使用SynchronousQueue队列时由于该队列没有容量的特性，所以不会对任务进行排队，如果线程池中没有空闲线程，会立即创建一个新线程来接收这个任务。maximumPoolSize要设置大一点。</li><li>核心线程和最大线程数量相等时keepAliveTime无作用.</li></ol><h3 id="3-3-线程池关闭"><a href="#3-3-线程池关闭" class="headerlink" title="3.3. 线程池关闭"></a>3.3. 线程池关闭</h3><ol><li>shutdown() 不接收新任务,会处理已添加任务</li><li>shutdownNow() 不接受新任务,不处理已添加任务,中断正在处理的任务</li></ol><h2 id="4-常用队列介绍"><a href="#4-常用队列介绍" class="headerlink" title="4. 常用队列介绍"></a>4. 常用队列介绍</h2><ol><li>ArrayBlockingQueue： 这是一个由数组实现的容量固定的有界阻塞队列.</li><li>SynchronousQueue： 没有容量，不能缓存数据；每个put必须等待一个take; offer()的时候如果没有另一个线程在poll()或者take()的话返回false。</li><li>LinkedBlockingQueue： 这是一个由单链表实现的默认无界的阻塞队列。LinkedBlockingQueue提供了一个可选有界的构造函数，而在未指明容量时，容量默认为Integer.MAX_VALUE。</li></ol><p>队列操作:</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">增加一个元索; 如果队列已满，则抛出一个异常</td></tr><tr><td style="text-align:center">remove</td><td style="text-align:center">移除并返回队列头部的元素; 如果队列为空，则抛出一个异常</td></tr><tr><td style="text-align:center">offer</td><td style="text-align:center">添加一个元素并返回true; 如果队列已满，则返回false</td></tr><tr><td style="text-align:center">poll</td><td style="text-align:center">移除并返回队列头部的元素; 如果队列为空，则返回null</td></tr><tr><td style="text-align:center">put</td><td style="text-align:center">添加一个元素; 如果队列满，则阻塞</td></tr><tr><td style="text-align:center">take</td><td style="text-align:center">移除并返回队列头部的元素; 如果队列为空，则阻塞</td></tr><tr><td style="text-align:center">element</td><td style="text-align:center">返回队列头部的元素; 如果队列为空，则抛出一个异常</td></tr><tr><td style="text-align:center">peek</td><td style="text-align:center">返回队列头部的元素; 如果队列为空，则返回null</td></tr></tbody></table><h2 id="5-Executors线程工厂类"><a href="#5-Executors线程工厂类" class="headerlink" title="5. Executors线程工厂类"></a>5. Executors线程工厂类</h2><ol><li><p>Executors.newCachedThreadPool();<br>说明: 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.<br>内部实现：new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue<runnable>());</runnable></p></li><li><p>Executors.newFixedThreadPool(int);<br>说明: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>内部实现：new ThreadPoolExecutor(nThreads, nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<runnable>());</runnable></p></li><li><p>Executors.newSingleThreadExecutor();<br>说明:创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照顺序执行。<br>内部实现：new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<runnable>())</runnable></p></li><li><p>Executors.newScheduledThreadPool(int);<br>说明:创建一个定长线程池，支持定时及周期性任务执行。<br>内部实现：new ScheduledThreadPoolExecutor(corePoolSize)</p></li></ol><p><strong> 【附】阿里巴巴Java开发手册中对线程池的使用规范 </strong></p><ol start="2"><li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"TimerTaskThread"</span>); </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br>说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p></li><li>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样<br>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明： Executors 返回的线程池对象的弊端如下：<br>1） FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br>2） CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。</li></ol><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>ThreadPoolExecutor通过几个核心参数来定义不同类型的线程池，适用于不同的使用场景；其中在任务提交时，会依次判断corePoolSize， workQueque， 及maximumPoolSize，不同的状态不同的处理。技术领域水太深，如果不是日常使用，基本一段时间后某些知识点就忘的差不多了，因此阶段性地回顾与总结，对夯实自己的技术基础很有必要。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容是基于研发部门内部的分享整理，记录下来供学习或回顾。&lt;/p&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="concurrency" scheme="http://blog.jboost.cn/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战（九）：统一异常处理</title>
    <link href="http://blog.jboost.cn/springboot-error.html"/>
    <id>http://blog.jboost.cn/springboot-error.html</id>
    <published>2019-07-03T06:35:02.000Z</published>
    <updated>2019-07-22T10:30:36.823Z</updated>
    
    <content type="html"><![CDATA[<p>都说管理的精髓就是“制度管人，流程管事”。而所谓流程，就是对一些日常工作环节、方式方法、次序等进行标准化、规范化。且不论精不精髓，在技术团队中，对一些通用场景，统一规范是必要的，只有步调一致，才能高效向前。如前后端交互协议，如本文探讨的异常处理。</p><a id="more"></a><h3 id="1-Spring-Mvc中的异常处理"><a href="#1-Spring-Mvc中的异常处理" class="headerlink" title="1. Spring Mvc中的异常处理"></a>1. Spring Mvc中的异常处理</h3><p>在spring mvc中，跟异常处理的相关类大致如下</p><p><img src="/assets/springmvcexresolver.png" alt="springmvn异常处理类"></p><p>上图中，spring mvc中处理异常的类（包括在请求映射时与请求处理过程中抛出的异常），都是 HandlerExceptionResolver 接口的实现，并且都实现了 Ordered 接口。与拦截器链类似，如果容器中存在多个实现了 HandlerExceptionResolver 接口的异常处理类，则它们的 resolveException 方法会被依次调用，顺序由order决定，值越小的先执行，只要其中一个调用返回不是null，则后续的异常处理将不再执行。</p><p>各实现类简单介绍如下：</p><ul><li>DefaultHandlerExceptionResolver： 这个是默认实现，处理Spring定义的各种标准异常，将其转换为对应的Http Status Code，具体处理的异常参考 doResolveException 方法</li><li>ResponseStatusExceptionResolver：用来支持@ResponseStatus注解使用的实现，如果自定义的异常通过@ResponseStatus注解进行了修饰，并且容器中存在ResponseStatusExceptionResolver的bean，则自定义异常抛出时会被该bean进行处理，返回注解定义的Http Status Code及内容给客户端</li><li>ExceptionHandlerExceptionResolver：用来支持@ExceptionHandler注解使用的实现，使用该注解修饰的方法来处理对应的异常。不过该注解的作用范围只在controller类，如果需要全局处理，则需要配合@ControllerAdvice注解使用。</li><li>SimpleMappingExceptionResolver：将异常映射为视图</li><li>HandlerExceptionResolverComposite：就是各类实现的组合，依次执行，只要其中一个处理返回不为null，则不再处理。</li></ul><p>因为本文主要是对spring boot如何对异常统一处理进行探讨，所以以上只对各实现做了基本介绍，更加详细的内容可查阅相关文档或后续再补上。</p><h3 id="2-Spring-Boot中如何统一异常处理"><a href="#2-Spring-Boot中如何统一异常处理" class="headerlink" title="2. Spring Boot中如何统一异常处理"></a>2. Spring Boot中如何统一异常处理</h3><p>通过第一部分介绍，可以使用@ExceptionHandler + @ControllerAdvice 组合的方式来实现异常的全局统一处理。对于REST服务来说，spring mvc提供了一个抽象类 ResponseEntityExceptionHandler， 该类类似于上面介绍的 DefaultHandlerExceptionResolver，对一些标准的异常进行了处理，但不是返回 ModelAndView对象， 而是返回 ResponseEntity对象。故我们可以基于该类来实现REST服务异常的统一处理<br>定义异常处理类 BaseWebApplicationExceptionHandler 如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseWebApplicationExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> includeStackTrace;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseWebApplicationExceptionHandler</span><span class="params">(<span class="keyword">boolean</span> includeStackTrace)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.includeStackTrace = includeStackTrace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BizException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">handleBizException</span><span class="params">(BizException ex)</span> </span>&#123;</span><br><span class="line">        logger.warn(<span class="string">"catch biz exception: "</span> + ex.toString(), ex.getCause());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.asResponseEntity(HttpStatus.valueOf(ex.getHttpStatus()), ex.getErrorCode(), ex.getErrorMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;IllegalArgumentException.class, IllegalStateException.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">handleIllegalArgumentException</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.warn(<span class="string">"catch illegal exception."</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.asResponseEntity(HttpStatus.BAD_REQUEST, HttpStatus.BAD_REQUEST.name().toLowerCase(), ex.getMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">handleException</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"catch exception."</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.asResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR, HttpStatus.INTERNAL_SERVER_ERROR.name().toLowerCase(), ExceptionConstants.INNER_SERVER_ERROR_MSG, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResponseEntity&lt;Object&gt; <span class="title">handleExceptionInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatus status, WebRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) &#123;</span><br><span class="line">            request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.warn(<span class="string">"catch uncustom exception."</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.asResponseEntity(status, status.name().toLowerCase(), ex.getMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResponseEntity&lt;Object&gt; <span class="title">asResponseEntity</span><span class="params">(HttpStatus status, String errorCode, String errorMessage, Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        data.put(BizException.ERROR_CODE, errorCode);</span><br><span class="line">        data.put(BizException.ERROR_MESSAGE, errorMessage);</span><br><span class="line">        <span class="comment">//是否包含异常的stack trace</span></span><br><span class="line">        <span class="keyword">if</span>(includeStackTrace)&#123;</span><br><span class="line">            addStackTrace(data, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(data, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addStackTrace</span><span class="params">(Map&lt;String, Object&gt; errorAttributes, Throwable error)</span> </span>&#123;</span><br><span class="line">        StringWriter stackTrace = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        error.printStackTrace(<span class="keyword">new</span> PrintWriter(stackTrace));</span><br><span class="line">        stackTrace.flush();</span><br><span class="line">        errorAttributes.put(BizException.ERROR_TRACE, stackTrace.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有几点：</p><ol><li>定义了一个includeStackTrace变量，来控制是否输出异常栈信息</li><li>自定义了一个异常类BizException，表示可预知的业务异常，并对它提供了处理方法，见handleBizException方法</li><li>对其它未预知异常，用Exception类型进行最后处理，见handleException方法</li><li>重写了超类的handleExceptionInternal方法，统一响应内容的字段与格式</li><li>针对REST服务，使用的是@RestControllerAdvice注解，而不是@ControllerAdvice</li></ol><p>BaseWebApplicationExceptionHandler是通过增强的方式对controller抛出的异常做了统一处理，那如果请求都没有到达controller怎么办，比如在过滤器那边就抛异常了，Spring Boot其实对错误的处理做了一些自动化配置，参考ErrorMvcAutoConfiguration类，具体这里不详述，只提出方案——自定义ErrorAttributes实现，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseErrorAttributes</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> includeStackTrace;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(WebRequest webRequest, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">        addStatus(errorAttributes, webRequest);</span><br><span class="line">        addErrorDetails(errorAttributes, webRequest, <span class="keyword">this</span>.includeStackTrace);</span><br><span class="line">        <span class="keyword">return</span> errorAttributes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>以上只列出了主要部分，具体实现可参考源码。这里同样定义了includeStackTrace来控制是否包含异常栈信息。</p><p>最后，将以上两个实现通过配置文件注入容器，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(ResponseEntityExceptionHandler.class)</span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(ErrorMvcAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"test"</span>, <span class="string">"formal"</span>, <span class="string">"prod"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntityExceptionHandler <span class="title">defaultGlobalExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试、正式环境，不输出异常的stack trace</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseWebApplicationExceptionHandler(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"default"</span>,<span class="string">"local"</span>,<span class="string">"dev"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntityExceptionHandler <span class="title">devGlobalExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//本地、开发环境，输出异常的stack trace</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseWebApplicationExceptionHandler(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"test"</span>, <span class="string">"formal"</span>, <span class="string">"prod"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorAttributes <span class="title">basicErrorAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试、正式环境，不输出异常的stack trace</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseErrorAttributes(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"default"</span>,<span class="string">"local"</span>,<span class="string">"dev"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorAttributes <span class="title">devBasicErrorAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//本地、开发环境，输出异常的stack trace</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseErrorAttributes(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>上面的@Profile主要是控制针对不同环境，输出不同的响应内容。以上配置的意思是在profile为default、local、dev时，响应内容中包含异常栈信息；profile为test、formal、prod时，响应内容不包含异常栈信息。这么做的好处是，开发阶段，当前端联调时，如果出错，可直接从响应内容中看到异常栈，方便服务端开发人员快速定位问题，而测试、生产环境， 就不要返回异常栈信息了。</p></blockquote><h3 id="3-基于Spring-Boot的异常处理规范"><a href="#3-基于Spring-Boot的异常处理规范" class="headerlink" title="3. 基于Spring Boot的异常处理规范"></a>3. 基于Spring Boot的异常处理规范</h3><ol><li>异常的表示形式<br>异常一般可通过自定义异常类，或定义异常的信息，比如code，message之类，然后通过一个统一的异常类进行封装。如果每一种异常都定义一个异常类，则会造成异常类过多，所以实践开发中我一般倾向于后者。<br>可以定义一个接口，该接口主要是方便后面的异常处理工具类实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseErrors</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>然后定义一个枚举，实现该接口，在该枚举中定义异常信息，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ErrorCodeEnum implements BaseErrors &#123;</span><br><span class="line">    qrcode_existed(<span class="string">"该公众号下已存在同名二维码"</span>),</span><br><span class="line">    authorizer_notexist(<span class="string">"公众号不存在"</span>),</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorCodeEnum</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>封装异常处理<br>分场景定义了ClientSideException，ServerSideException，UnauthorizedException，ForbiddenException异常，分别表示客户端异常（400），服务端异常（500），未授权异常（401），禁止访问异常（403），如ClientSideException定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientSideException</span> <span class="keyword">extends</span> <span class="title">BizException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E extends Enum&lt;E&gt; &amp; BaseErrors&gt; ClientSideException(E exceptionCode, Throwable cause) &#123;</span><br><span class="line">        <span class="keyword">super</span>(HttpStatus.BAD_REQUEST, exceptionCode, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E extends Enum&lt;E&gt; &amp; BaseErrors&gt; ClientSideException(E exceptionCode) &#123;</span><br><span class="line">        <span class="keyword">super</span>(HttpStatus.BAD_REQUEST, exceptionCode, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>并且提供一个异常工具类ExceptionUtil，方便不同场景使用，</p><ul><li>rethrowClientSideException：抛出ClientSideException，将以status code 400返回客户端。由客户端引起的异常调用该方法，如参数校验失败。</li><li>rethrowUnauthorizedException： 抛出UnauthorizedException，将以status code 401返回客户端。访问未授权时调用，如token校验失败等。</li><li>rethrowForbiddenException： 抛出ForbidenException，将以status code 403返回客户端。访问被禁止时调用，如用户被禁用等。</li><li>rethrowServerSideException： 抛出ServerSideException，将以status code 500返回客户端。服务端引起的异常调用该方法，如调用第三方服务异常，数据库访问出错等。</li></ul><p>在实际使用时，分两种情况，</p><ol><li><p>不通过try/catch主动抛出异常，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(appId)) &#123;</span><br><span class="line">    LOG.warn(<span class="string">"the authorizer for site[&#123;&#125;] is not existed."</span>, templateMsgRequestDto.getSiteId());</span><br><span class="line">    ExceptionUtil.rethrowClientSideException(ErrorCodeEnum.authorizer_notexist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过try/catch异常重新抛出（注意：可预知的异常，需要给客户端返回某种提示信息的，必须通过该方式重新抛出。否则将返回统一的code 500,提示“抱歉，服务出错了，请稍后重试”的提示信息）如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String result = wxOpenService.getWxOpenComponentService().getWxMpServiceByAppid(appId).getTemplateMsgService().sendTemplateMsg(templateMessage);</span><br><span class="line">    LOG.info(<span class="string">"result: &#123;&#125;"</span>, result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (WxErrorException wxException) &#123;</span><br><span class="line">    <span class="comment">//这里不需要打日志，会统一在异常处理里记录日志</span></span><br><span class="line">    ExceptionUtil.rethrowServerSideException(ExceptionCodeEnum.templatemsg_fail, wxException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>具体实现参考源码： <a href="https://github.com/ronwxy/base-spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/cn/jboost/springboot/autoconfig/error" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/cn/jboost/springboot/autoconfig/error</a><br>另附demo源码：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-error" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-error</a></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>本文写完感觉信息量有点多，对于不具备一定基础的人来说理解可能有点难度。如果有任何疑问，欢迎交流。后续有需要的话也可以针对某个环节再进行细化补充。本文所提的规范不一定是最好的实践，但规范或流程的管理，都是遵循先僵化，后优化，再固化的步骤，先解决有没有的问题，再解决好不好的问题。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都说管理的精髓就是“制度管人，流程管事”。而所谓流程，就是对一些日常工作环节、方式方法、次序等进行标准化、规范化。且不论精不精髓，在技术团队中，对一些通用场景，统一规范是必要的，只有步调一致，才能高效向前。如前后端交互协议，如本文探讨的异常处理。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>使用nvm来管理Node多版本</title>
    <link href="http://blog.jboost.cn/use-nvm.html"/>
    <id>http://blog.jboost.cn/use-nvm.html</id>
    <published>2019-07-02T00:41:51.000Z</published>
    <updated>2019-07-09T11:19:28.689Z</updated>
    
    <content type="html"><![CDATA[<p>最近在为前端配置jenkins持续集成环境时，在运行<code>npm install</code>下载依赖包的时候，速度极慢，而本地很快。对比node版本，一个v10.15.3，速度很快，一个v8.10.0，速度极慢。两者都设置了国内镜像。升级node能否解决问题？有没有工具支持node多版本管理，像python的anaconda一样？答案是有，叫nvm —— node version manager。<br><a id="more"></a></p><p>项目地址： <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a></p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>linux下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载并执行安装</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装后执行<span class="built_in">source</span>使其生效</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></p><blockquote><p>为了加速node的下载，可在~/.bashrc中添加 <code>export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</code></p></blockquote><p>windows：参考 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ol><li>列出所有node版本<br><code>nvm ls-remote</code></li></ol><ol start="2"><li><p>只列出长期支持版本，一般生产环境使用long term support版<br><code>nvm ls-remote --lts</code></p></li><li><p>安装指定版本<br><code>nvm install v10.15.3</code></p></li><li><p>安装完后即可查看安装的node及npm的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v  </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li><li><p>查看已安装版本<br><code>nvm ls</code></p></li><li><p>使用指定的版本，重连bash即失效<br><code>nvm use 10.15.3</code></p></li><li><p>设置默认，重连也生效<br><code>nvm alias default 10.15.3</code></p></li></ol><blockquote><p>配置npm国内淘宝镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line"></span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>nvm可在一个系统中非常便捷地管理多个node版本，并能自由切换使用哪个版本，方便需要多版本并存的场景。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy<br>————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在为前端配置jenkins持续集成环境时，在运行&lt;code&gt;npm install&lt;/code&gt;下载依赖包的时候，速度极慢，而本地很快。对比node版本，一个v10.15.3，速度很快，一个v8.10.0，速度极慢。两者都设置了国内镜像。升级node能否解决问题？有没有工具支持node多版本管理，像python的anaconda一样？答案是有，叫nvm —— node version manager。&lt;br&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="node" scheme="http://blog.jboost.cn/tags/node/"/>
    
      <category term="npm" scheme="http://blog.jboost.cn/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>redission-tomcat 快速实现从单机部署到多机部署</title>
    <link href="http://blog.jboost.cn/session-redis.html"/>
    <id>http://blog.jboost.cn/session-redis.html</id>
    <published>2019-06-29T01:01:24.000Z</published>
    <updated>2019-07-09T11:19:28.777Z</updated>
    
    <content type="html"><![CDATA[<p>一些项目初期出于简单快速，都是做单机开发与部署，但是随着业务的扩展或对可用性要求的提高，单机环境已不满足需求。单机部署往多机部署切换，其中可能存在的一个重要环节就是session的共享（如果一开始就是基于token的认证则可忽略）。本文介绍一个基于redis的tomcat session管理开源项目：redission-tomcat，可无代码侵入式地快速实现session共享。<br><a id="more"></a></p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>redisson是与jedis类似的一个redis客户端，其功能比jedis要更丰富一些。redission-tomcat是一个基于redis的tomcat session管理器项目，项目地址：<a href="https://github.com/redisson/redisson/tree/master/redisson-tomcat" target="_blank" rel="noopener">https://github.com/redisson/redisson/tree/master/redisson-tomcat</a> 。相比于其它实现，该项目的存储更为高效，写操作也更为优化。每一个session参数是在调用<code>HttpSession.setAttribute</code>时写入redis的，其它方案却一般是每次都将整个session进行序列化后写入。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ol><li><p>将<a href="https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&amp;g=org.redisson&amp;a=redisson-all&amp;v=3.11.0&amp;e=jar" target="_blank" rel="noopener">redisson-all-3.11.0.jar</a>，<a href="https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&amp;g=org.redisson&amp;a=redisson-tomcat-8&amp;v=3.11.0&amp;e=jar" target="_blank" rel="noopener">redisson-tomcat-8-3.11.0.jar</a>（针对tomcat8，其它版本可在上述项目地址页面找到下载链接）两个jar包下载放到tomcat的lib目录下。</p></li><li><p>在tomcat conf目录下的context.xml文件中添加如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"org.redisson.tomcat.RedissonSessionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">configPath</span>=<span class="string">"$&#123;catalina.base&#125;/conf/redisson.conf"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">readMode</span>=<span class="string">"MEMORY"</span> <span class="attr">updateMode</span>=<span class="string">"AFTER_REQUEST"</span> <span class="attr">broadcastSessionEvents</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>其中</p><ul><li>configPath：指向Redisson的json或yaml格式的配置文件，第3步中给出。</li><li>readMode：session属性的读取模式。可取值 1. MEMORY, 该模式会将session属性同时保存到本地tomcat session与redis中，后续的session更新通过redis事件传播到本地tomcat session；2. REDIS，只将session属性保存到redis中。默认为REDIS。</li><li>updateMode：session属性的更新模式。可取值 1. DEFAULT，session属性只通过<code>setAttribute</code>方法保存到redis中；2. AFTER_REQUEST，在每次请求之后，将所有session属性保存至redis。默认为DEFAULT。</li><li>broadcastSessionEvents：如果设置为true，则sessionCreated与sessionDestroyed事件将会被广播到所有tomcat实例，并使所有注册的HttpSessionListeners监听器被触发。默认为false。</li></ul><ol start="3"><li>在tomcat conf目录下新增配置文件redisson.conf，内容如下<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"singleServerConfig"</span>:&#123;</span><br><span class="line">    <span class="attr">"idleConnectionTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"connectTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"retryAttempts"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">"retryInterval"</span>:<span class="number">1500</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"123456"</span>,</span><br><span class="line">    <span class="attr">"subscriptionsPerConnection"</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="attr">"clientName"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"address"</span>: <span class="string">"redis://127.0.0.1:6379"</span>,</span><br><span class="line">    <span class="attr">"subscriptionConnectionMinimumIdleSize"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"subscriptionConnectionPoolSize"</span>:<span class="number">50</span>,</span><br><span class="line">    <span class="attr">"connectionMinimumIdleSize"</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="attr">"connectionPoolSize"</span>:<span class="number">64</span>,</span><br><span class="line">    <span class="attr">"database"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"dnsMonitoringInterval"</span>:<span class="number">5000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"threads"</span>:<span class="number">16</span>,</span><br><span class="line">  <span class="attr">"nettyThreads"</span>:<span class="number">32</span>,</span><br><span class="line">  <span class="attr">"codec"</span>:&#123;</span><br><span class="line">    <span class="attr">"class"</span>:<span class="string">"org.redisson.codec.FstCodec"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"transportMode"</span>:<span class="string">"NIO"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上为单机模式redis环境配置，其中password，address修改为自己的值。如果是集群模式，则配置文件为<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sentinelServersConfig"</span>:&#123;</span><br><span class="line">    <span class="attr">"idleConnectionTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"connectTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"retryAttempts"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">"retryInterval"</span>:<span class="number">1500</span>,</span><br><span class="line">    <span class="attr">"failedSlaveReconnectionInterval"</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"failedSlaveCheckInterval"</span>:<span class="number">60000</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"subscriptionsPerConnection"</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="attr">"clientName"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"loadBalancer"</span>:&#123;</span><br><span class="line">      <span class="attr">"class"</span>:<span class="string">"org.redisson.connection.balancer.RoundRobinLoadBalancer"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"subscriptionConnectionMinimumIdleSize"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"subscriptionConnectionPoolSize"</span>:<span class="number">50</span>,</span><br><span class="line">    <span class="attr">"slaveConnectionMinimumIdleSize"</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="attr">"slaveConnectionPoolSize"</span>:<span class="number">64</span>,</span><br><span class="line">    <span class="attr">"masterConnectionMinimumIdleSize"</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="attr">"masterConnectionPoolSize"</span>:<span class="number">64</span>,</span><br><span class="line">    <span class="attr">"readMode"</span>:<span class="string">"SLAVE"</span>,</span><br><span class="line">    <span class="attr">"subscriptionMode"</span>:<span class="string">"SLAVE"</span>,</span><br><span class="line">    <span class="attr">"sentinelAddresses"</span>:[</span><br><span class="line">      <span class="string">"redis://127.0.0.1:26379"</span>,</span><br><span class="line">      <span class="string">"redis://127.0.0.1:26389"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"masterName"</span>:<span class="string">"mymaster"</span>,</span><br><span class="line">    <span class="attr">"database"</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"threads"</span>:<span class="number">16</span>,</span><br><span class="line">  <span class="attr">"nettyThreads"</span>:<span class="number">32</span>,</span><br><span class="line">  <span class="attr">"codec"</span>:&#123;</span><br><span class="line">    <span class="attr">"class"</span>:<span class="string">"org.redisson.codec.FstCodec"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"transportMode"</span>:<span class="string">"NIO"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>我们可以使用nginx来实现负载均衡，参考配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream cnserver&#123;</span><br><span class="line">  server 127.0.0.1:8080 weight=2 fail_timeout=10s max_fails=1;</span><br><span class="line">  server 127.0.0.1:8081 weight=2 fail_timeout=10s max_fails=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  index index.html index.htm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  location /rest/ &#123;</span><br><span class="line">    index index.html;</span><br><span class="line">    proxy_pass http://cnserver/rest/;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上即为使用redisson-tomcat来实现单机部署到多机部署的所有配置。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>技术架构都是随着业务的发展而不断演进。在业务发展初期，用户量、业务复杂度都相对较低，为了实现快速上线验证，往往采用简单单一的架构。许多项目可能还没来得及进行架构演进升级就GG了，而有幸继续成长的项目必然会随着业务的扩张不断优化与升级。本文介绍的redisson-tomcat可帮助单机项目快速切换到多机支持，当然只是在session管理环节。如果涉及到其它如文件上传，定时任务等分布式支持，则要另做相应调整了。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号， 欢迎关注）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些项目初期出于简单快速，都是做单机开发与部署，但是随着业务的扩展或对可用性要求的提高，单机环境已不满足需求。单机部署往多机部署切换，其中可能存在的一个重要环节就是session的共享（如果一开始就是基于token的认证则可忽略）。本文介绍一个基于redis的tomcat session管理开源项目：redission-tomcat，可无代码侵入式地快速实现session共享。&lt;br&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="session" scheme="http://blog.jboost.cn/tags/session/"/>
    
      <category term="tomcat" scheme="http://blog.jboost.cn/tags/tomcat/"/>
    
      <category term="redission" scheme="http://blog.jboost.cn/tags/redission/"/>
    
  </entry>
  
</feed>
