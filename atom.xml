<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空山新雨的技术空间</title>
  
  <subtitle>技术与管理兼修</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jboost.cn/"/>
  <updated>2020-01-20T02:50:05.938Z</updated>
  <id>http://blog.jboost.cn/</id>
  
  <author>
    <name>空山新雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Cloud（四）：啥是服务降级与熔断之Hystrix</title>
    <link href="http://blog.jboost.cn/springcloud-4.html"/>
    <id>http://blog.jboost.cn/springcloud-4.html</id>
    <published>2020-01-19T01:31:02.000Z</published>
    <updated>2020-01-20T02:50:05.938Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务的架构中，一个业务的实现通常包括多层服务的调用，底层基础服务的故障可能会导致上层服务级联发生故障，进而故障不断蔓延导致系统整体不可用，这种现象称为服务的雪崩效应。</p><a id="more"></a><h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><p>断路器（CircuitBreaker， 或叫熔断器）是用来避免服务雪崩效应，提升系统整体可用性的一种技术手段。通过在一个时间窗口内监测服务的调用失败情况，在失败时通过回调返回默认实现（这叫服务降级），当失败达到一定程度时，后续的调用直接导致快速失败，不再访问远程服务（这叫熔断机制），防止不断尝试调用可能会失败的服务，以使服务有机会恢复，一定时间后，当断路器监测到服务恢复后，会继续尝试调用。</p><p>断路器原理有点类似于电路中的保险丝或电闸，当发现电路中出现短路异常情况时，通过保险丝熔断或电闸跳闸来断开电路，避免事故发生。</p><h2 id="Hystrix服务降级"><a href="#Hystrix服务降级" class="headerlink" title="Hystrix服务降级"></a>Hystrix服务降级</h2><p>当使用Hystrix时，每一个远程服务的调用都被封装到一个HystrixCommand中，HystrixCommand有两个主要方法：run(), getFallback()。<br>其中run方法封装了远程服务的调用逻辑，如果run方法超时或者抛出异常，并且启用了服务降级，则会调用getFallback方法来进行降级处理。</p><p>降级处理由 HystrixCommandProperties.Setter 中定义的配置属性来控制，主要包括：</p><ul><li>fallbackEnabled， 是否启用降级处理，如果启用则在超时或异常时调用getFallback来进行降级处理，默认启用</li><li>fallbackIsolationSemaphoreMaxConcurrentRequests，控制getFallback方法并发请求的信号量，默认为10，如果请求超过了信号量限制，则不再尝试调用getFallback方法，而是快速失败</li><li>executionIsolationThreadInterruptOnFutureCancel，隔离策略为THREAD，当Future#cancel(true)时，是否进行中断处理，默认为false</li><li>executionIsolationThreadInterruptOnTimeout，隔离策略为THREAD，当执行线程超时时，是否进行中断，默认为true</li><li>executionTimeoutInMilliseconds，执行超时时间，默认为1000ms，如果隔离策略为THREAD（线程池隔离），且配置了executionIsolationThreadInterruptOnTimeout=true，则执行线程将被中断，如果隔离策略为SEMAPHORE（信号量隔离），则终止操作，信号量隔离下执行线程与主线程是同一个线程，所以不会中断线程处理</li></ul><p>在进行降级处理调用getFallback方法时，需注意：</p><ol><li><p>该方法最大并发数受fallbackIsolationSemaphoreMaxConcurrentRequests控制，默认为10，如果失败率很高，则需配置该参数，如果并发数超过了配置，则不会执行getFallback，而是快速失败，抛出异常“HystrixRuntimeException: xxx fallback executionrejected”</p></li><li><p>尽量避免在getFallback中进行网络请求，而是能快速返回的缓存数据或静态数据（如默认值）；如果需要做网络请求，则应该是调用另一个被Hystrix保护的请求，即对fallback进行串联，第一个fallback中请求网络做业务调用，第二个fallback中回调缓存或静态数据</p></li></ol><p>上文提到Hystrix的线程池隔离策略与信号量隔离策略，两者如何理解？</p><ol><li>线程池隔离：执行在一个单独的线程中，通过线程池中线程数量来控制并发请求量。每一个服务使用一个单独的线程池进行隔离，避免互相影响。这种策略下的服务调用是异步的，可通过hystrix来配置超时。</li><li>信号量隔离：执行在调用线程中，通过信号量来控制控制并发请求量（executionIsolationSemaphoreMaxConcurrentRequests， 默认为10），如果并发量超过该值，则调用getFallback方法对服务进行降级。这种策略下的服务调用是同步的，无法对调用进行超时配置，只能通过调用协议（如http）的超时。信号量隔离策略一般只有在高并发量的情况下使用（如一秒几百次），这种情况下使用单独的线程池开销比较大；或者如果需要在调用服务的线程中，如RequestInterceptor中使用ThreadLocal中的变量，也可以通过将隔离策略设置为信号量来实现(hystrix.command.default.execution.isolation.strategy=SEMAPHORE)</li></ol><blockquote><p>注： 如果只是需要在服务调用中使用安全上下文 SecurityContext， 则也可以通过配置 hystrix.shareSecurityContext=true 来实现，这样Hystrix的并发策略插件会将SecurityContext从主线程传递到Hystrix command使用的线程。</p></blockquote><p>线程池隔离策略与信号量隔离策略两者之间的区别</p><table><thead><tr><th style="text-align:center">隔离策略</th><th style="text-align:center">实现原理</th><th style="text-align:center">调用模式</th><th style="text-align:center">是否支持超时配置</th><th style="text-align:center">降级实现</th><th style="text-align:center">资源消耗</th></tr></thead><tbody><tr><td style="text-align:center">线程池隔离</td><td style="text-align:center">每个服务使用单独的线程池</td><td style="text-align:center">异步调用</td><td style="text-align:center">支持</td><td style="text-align:center">线程池满则请求拒绝，降级处理</td><td style="text-align:center">较大，容易造成服务器负载高</td></tr><tr><td style="text-align:center">信号量隔离</td><td style="text-align:center">使用信号量的计数器</td><td style="text-align:center">同步调用</td><td style="text-align:center">不支持</td><td style="text-align:center">信号量达到最大值则请求拒绝，降级处理</td><td style="text-align:center">较小</td></tr></tbody></table><h2 id="Hystrix熔断机制"><a href="#Hystrix熔断机制" class="headerlink" title="Hystrix熔断机制"></a>Hystrix熔断机制</h2><p>Hystrix客户端会对调用失败情况进行采样统计。当在一个时间窗口（由metrics.rollingStats.timeInMilliseconds配置， 默认10s）内，调用某个服务超过一定次数（由circuitBreaker.requestVolumeThreshold配置，默认20），失败率超过一定比例（由circuitBreaker.errorThresholdPercentage配置，默认50%），则熔断开关打开，调用会被快速失败（不再进行远程调用），如果开发者提供了fallback，则会调用fallback进行降级处理，如果没有，则抛出 异常。</p><p>调用失败包括如下几种情况：</p><ol><li>调用中抛出异常</li><li>调用超时</li><li>线程池拒绝</li><li>信号量拒绝</li></ol><p>熔断开关的状态：</p><ul><li>闭合（closed）：如果配置了熔断开关强制闭合，或者当前的请求失败率没有超过设置的阈值，则熔断开关处于闭合状态，不启动熔断机制。但这时如果调用超时或失败，仍会进行降级处理（除非fallbackEnabled为false）</li><li>打开（open）：如果配置了熔断开关强制打开，或者当前的请求失败率超过了设置的阈值，则熔断开关打开，启动熔断机制，直接进行降级处理，不再进行远程调用</li><li>半打开（half-open）：当熔断开关处理打开状态，需要在一定的时间窗口后进行重试，检测服务是否恢复，这种状态就是半打开状态。如果测试成功则关闭熔断开关，否则还是处于打开状态</li></ul><p>Hystrix熔断开关的状态关系如图所示</p><p><img src="/assets/hystrix-status.png" alt="hystrix熔断开关状态"></p><p>熔断相关的参数配置（HystrixCommandProperties.Setter）：</p><ul><li>circuitBreakerEnabled， 是否开启熔断机制，默认true</li><li>circuitBreakerForceOpen，是否强制打开熔断开关，如果为true，则对请求进行强制降级，默认为false</li><li>circuitBreakerForceClosed， 是否强制关闭熔断开关，默认为false</li><li>circuitBreakerRequestVolumeThreshold， 在熔断开关闭合的情况下，一个采样时间窗口内需要进行至少多少个请求才进行采用统计计算失败率，默认为20</li><li>circuitBreakerErrorThresholdPercentage， 在一个采样时间窗口内，失败率超过该值，则打开熔断开关，进行快速失败，默认采样时间窗口为10s，失败率为50%</li><li>circuitBreakerSleepWindowInMilliseconds， 熔断后的重试时间窗口，在该时间窗口允许一次重试，如果重试成功，则关闭熔断开关，否则还是打开状态，默认5s</li></ul><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>熔断是服务调用端的一种保护机制，因此通常与Feign结合使用，Feign的Hystrix支持在Dalston版本之前，hystrix只要在类路径中，feign默认就会自动将所有方法封装到断路器中，Dalston版及以后的版本改变了这一做法，需要进行显示配置 feign.hystrix.enabled=true。</p><p>本文案例还是基于前面创建的springcloud-eureka（注册中心）， springcloud-eureka-client（一个简单的hello service）两个项目。</p><ol><li><p>新建springcloud-hystrix项目，pom.xml中引入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>applicaiton.yml配置文件中添加必要配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>启动类添加必要注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplication</span></span></span><br></pre></td></tr></table></figure></li></ol><p>其它Feign Client类与Controller类详见源码：<a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">https://github.com/ronwxy/springcloud-demos</a>  springcloud-hystrix项目</p><ol start="4"><li>测试</li></ol><p>这里分四种情形分别进行演示。依次启动springcloud-eureka， springcloud-eureka-client（debug模式启动，并在hello接口里设置断点，模拟超时），springcloud-hystrix</p><ul><li>启用断路器，未指定fallback</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span></span></span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8084/hystrix0" target="_blank" rel="noopener">http://localhost:8084/hystrix0</a>  得到结果如下</p><p><img src="/assets/hystrix-nofallback.png" alt="无fallback"></p><p>抛出异常： HystrixRuntimeException: HelloClient#hello() timed-out and no fallback available.] with root cause java.util.concurrent.TimeoutException: null</p><ul><li>启用断路器，指定fallback</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>, contextId = <span class="string">"hello-with-fallback"</span>, fallback = HelloClientFallback.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient1</span></span></span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8084/hystrix1" target="_blank" rel="noopener">http://localhost:8084/hystrix1</a>  得到结果返回 “调用hello-service返回：this is returned by fallback”， 不会抛出异常。</p><ul><li>启用断路器，指定fallbackFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>, contextId = <span class="string">"hello-with-fallbackFactory"</span>, fallbackFactory = HelloClientFallbackFactory.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient2</span></span></span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8084/hystrix2" target="_blank" rel="noopener">http://localhost:8084/hystrix2</a>  得到结果返回 “调用hello-service返回：this is returned from fallbackFactory, cause: com.netflix.hystrix.exception.HystrixTimeoutException”，不会抛出异常。</p><ul><li>不启用断路器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>, contextId = <span class="string">"hello-without-circuitBreaker"</span>, configuration = DisableCircuitBreakerConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient3</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DisableCircuitBreakerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Feign.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对单个feign client禁用断路器可以配置一个注入了 prototype scope的 Feign.Builder实例的配置类来实现。</p><p>访问 <a href="http://localhost:8084/hystrix3" target="_blank" rel="noopener">http://localhost:8084/hystrix3</a>  得到结果如下</p><p><img src="/assets/nohystrix.png" alt="无Hystrix"></p><p>抛出异常： feign.RetryableException: Read timed out executing GET <a href="http://hello-service/hello]" target="_blank" rel="noopener">http://hello-service/hello]</a> with root cause java.net.SocketTimeoutException: Read timed out</p><p>可见，在启用断路器，不指定fallback时，抛出HystrixRuntimeException异常，指定fallback时，调用fallback方法降级处理，但获取不到失败原因，如果需要获取失败原因，可使用fallbackFactory，不启用断路器时，抛出feign.RetryableException异常。</p><p>注意上面的contextId， 当使用同一个名称或url来创建多个指向同一服务的feign client时， 需要使用contextId来避免配置bean的名称冲突。该属性可以改变feign 客户端的ApplicationContext的名称，覆盖feign客户端别名，作为客户端配置bean名称的一部分。</p><p><a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">本文示例代码</a></p><p><br><br>认真生活，快乐分享<br>欢迎关注微信公众号：空山新雨的技术空间<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务的架构中，一个业务的实现通常包括多层服务的调用，底层基础服务的故障可能会导致上层服务级联发生故障，进而故障不断蔓延导致系统整体不可用，这种现象称为服务的雪崩效应。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（三）：Web服务客户端之Feign</title>
    <link href="http://blog.jboost.cn/springcloud-3.html"/>
    <id>http://blog.jboost.cn/springcloud-3.html</id>
    <published>2020-01-15T08:59:09.000Z</published>
    <updated>2020-01-19T11:29:53.145Z</updated>
    
    <content type="html"><![CDATA[<p>前文介绍了实现客户端负载均衡的Ribbon，但直接使用Ribbon的API来实现服务间的调用相对较为繁琐，服务间的调用能否像本地接口调用一样便捷、透明，更符合编程习惯呢？ Feign就是用来干这事的。</p><a id="more"></a><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是一个声明式的Web服务客户端，让服务之间的调用变得非常简单——定义带@FeignClient注解的接口，本地直接@Autowired 接口，通过调用接口的方法来实现远程服务的调用。</p><p>支持的注解包括Feign注解与JAX-RS（Java API for RESTful Web Services）注解。</p><p>每一个Feign的客户端都包含一系列对应的组件，Spring Cloud通过FeignClientsConfiguration 为每一个命名的Feign客户端创建一个组件集合，包括feign.Decoder，feign.Encoder，feign.Contract等。</p><p>Feign提供的默认bean实现及说明</p><table><thead><tr><th style="text-align:center">Bean类型</th><th style="text-align:center">默认实现类</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Decoder</td><td style="text-align:center">ResponseEntityDecoder</td><td style="text-align:center">ResponseEntityDecoder封装了SpringDecoder，解码器，将服务的响应消息进行解码</td></tr><tr><td style="text-align:center">Encoder</td><td style="text-align:center">SpringEncoder</td><td style="text-align:center">编码器</td></tr><tr><td style="text-align:center">Logger</td><td style="text-align:center">Slf4jLogger</td><td style="text-align:center">日志框架</td></tr><tr><td style="text-align:center">Contract</td><td style="text-align:center">SpringMvcContract</td><td style="text-align:center">支持注解契约，使用SpringMvcContract可以对Spring MVC注解提供支持</td></tr><tr><td style="text-align:center">Feign.Builder</td><td style="text-align:center">HystrixFeign.Builder</td><td style="text-align:center">使用断路器来装饰Feign接口</td></tr><tr><td style="text-align:center">Client</td><td style="text-align:center">LoadBalancerFeignClient</td><td style="text-align:center">如果是ribbon则  LoadBalancerFeignClient， 如果是spring cloud LoadBalancer 则  FeignBlockingLoadBalancerClient，默认ribbon</td></tr></tbody></table><p>跟Ribbon类似，可以通过配置类来自定义Feign客户端，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>, configuration = CustomConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StoreClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>, <span class="string">"password"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样Feign客户端就包含了FeignClientsConfiguration 与CustomConfiguration 中定义的组件，并且后者会覆盖前者（即自定义配置的优先级高于默认配置）。</p><blockquote><p>自定义配置类不需要加注解@Configuration，如果加了且被@ComponentScan扫描到，则将成为所有Feign客户端的默认配置</p></blockquote><p>同样Feign客户端也支持通过配置文件来配置<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">    client:</span></span><br><span class="line"><span class="attr">        config:</span></span><br><span class="line"><span class="attr">            feignName:</span></span><br><span class="line"><span class="attr">                connectTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">                readTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">                loggerLevel:</span> <span class="string">full</span></span><br><span class="line"><span class="attr">                errorDecoder:</span> <span class="string">com.example.SimpleErrorDecoder</span></span><br><span class="line"><span class="attr">                retryer:</span> <span class="string">com.example.SimpleRetryer</span></span><br><span class="line"><span class="attr">                requestInterceptors:</span></span><br><span class="line"><span class="bullet">                    -</span> <span class="string">com.example.FooRequestInterceptor</span></span><br><span class="line"><span class="bullet">                    -</span> <span class="string">com.example.BarRequestInterceptor</span></span><br><span class="line"><span class="attr">                decode404:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">                encoder:</span> <span class="string">com.example.SimpleEncoder</span></span><br><span class="line"><span class="attr">                decoder:</span> <span class="string">com.example.SimpleDecoder</span></span><br><span class="line"><span class="attr">                contract:</span> <span class="string">com.example.SimpleContract</span></span><br></pre></td></tr></table></figure></p><p>对于应用于所有Feign客户端的全局默认配置，也可以通过两种方式</p><ol><li>通过@EnableFeignClients 的defaultConfiguration 属性指定默认配置类</li><li>在配置文件中通过名称为default的配置实现<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">    client:</span></span><br><span class="line"><span class="attr">        config:</span></span><br><span class="line"><span class="attr">            default:</span></span><br><span class="line"><span class="attr">                connectTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">                readTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">                loggerLevel:</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure></li></ol><p>优先级同Ribbon， 配置文件&gt;自定义配置类&gt;默认的FeignClientsConfiguration</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>本文案例演示基于前面搭建的springcloud-eureka 与 springcloud-eureka-client 两个示例项目。</p><ol><li>新建springcloud-feign项目，pom.xml中加入依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>spring-cloud-starter-openfeign 包含了spring-cloud-starter-netflix-ribbon 与 spring-cloud-starter-loadbalancer。</p><ol start="2"><li><p>启动类加上@EnableFeignClients 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义Feign client（feign client支持继承）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"hello-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> <span class="keyword">extends</span> <span class="title">BaseHelloClient</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello/param"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@SpringQueryMap QueryParam param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用Feign client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloClient helloClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"feign"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">feignTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"调用Hello-service返回： "</span> + helloClient.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"feign/param"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">feignTestParam</span><span class="params">(QueryParam param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"调用Hello-service返回： "</span> + helloClient.hello(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>依次启动三个项目，调用<a href="http://localhost:8083/feign" target="_blank" rel="noopener">http://localhost:8083/feign</a> 能正常返回调用hello-service的结果。</p><p>本示例项目还通过@SrpingQueryMap 注解实现了Feign对 pojo用于GET请求参数的支持。如果不加@SrpingQueryMap， 则pojo参数是无法通过Feign client传递的，可去掉注解自行验证下。</p><h2 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h2><ol><li><p>如果需要定制化产生的查询参数map，可以实现并注入一个自定义的 QueryMapEncoder bean</p></li><li><p>Feign client的日志可通过feign client接口的全路径名进行配置，如logging.level.project.user.UserClient: DEBUG，默认为NONE（即不打印日志）。全局设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可设置的level值</p><ul><li>NONE： 不记录日志 ，默认</li><li>BASIC：只记录请求方法，url，以及响应状态码与执行时间</li><li>HEADERS：包括BASIC与请求、响应头</li><li>FULL：包括请求与响应的headers，body，metadata</li></ul><ol start="3"><li><p>Feign默认使用Ribbon来做负载均衡，可通过配置spring.cloud.loadbalancer.ribbon.enabled=false 来使用spring cloud loadbalancer（目前Ribbon处于维护状态，近期内不做更新）</p></li><li><p>可通过配置feign.okhttp.enabled=true 或 feign.httpclient.enabled=true 来使用OkHttpClient 或ApacheHttpClient， 默认使用的是JDK 原生的URLConnection 发送HTTP请求，没有连接池</p></li><li><p>如果需要在RequestInterceptor 中使用ThreadLocal中的变量， 那么要么禁用Hystrix，要么设置hystrix的线程隔离策略为SEMAPHORE</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">    hystrix:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="attr">        default:</span></span><br><span class="line"><span class="attr">            execution:</span></span><br><span class="line"><span class="attr">                isolation:</span></span><br><span class="line"><span class="attr">                    strategy:</span> <span class="string">SEMAPHORE</span></span><br></pre></td></tr></table></figure></li><li><p>使用有Hystrix fallback的Feign时，会在ApplicationContext中存在多个同类型bean， 导致@Autowired 失效。为了解决这个问题，Spring cloud netflix 将所有feign实例标为@Primary，如果要关闭该特性， 可将@FeignClient的 primary属性置为false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello"</span>, primary = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">本文示例代码</a></p><p><br><br>认真生活，快乐分享<br>欢迎关注微信公众号：空山新雨的技术空间<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文介绍了实现客户端负载均衡的Ribbon，但直接使用Ribbon的API来实现服务间的调用相对较为繁琐，服务间的调用能否像本地接口调用一样便捷、透明，更符合编程习惯呢？ Feign就是用来干这事的。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（二）：Web服务客户端之Ribbon</title>
    <link href="http://blog.jboost.cn/springcloud-2.html"/>
    <id>http://blog.jboost.cn/springcloud-2.html</id>
    <published>2020-01-14T05:04:40.000Z</published>
    <updated>2020-01-15T08:59:16.159Z</updated>
    
    <content type="html"><![CDATA[<p>上文介绍了服务如何通过Eureka实现注册，以及如何从Eureka获取已经注册的服务列表。那么拿到注册服务列表后， 如何进行服务调用？一个简单的实现是可以从被调用服务的实例列表中选择一个服务实例，通过其hostname（或IP），端口，及API的路径拼接成完整的url，通过http client来完成调用。但生产环境中，为了高性能、高可用等要素，服务的调用一般涉及负载均衡、故障转移、失败重试等实现，因此引入实现这些功能的客户端组件也成为了微服务架构中的必备要素。Spring Cloud中可通过Ribbon与Feign来实现服务间的调用。</p><p>本系列文章与示例均基于最新的Spring Cloud Hoxton版编写。</p><a id="more"></a><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>Ribbon是一个可实现负载均衡的Web客户端。我们一般理解的负载均衡是在服务端实现的，如Nginx（但这都是相对的，如果相对后端服务来说，也可以把Nginx当做一个实现了负载均衡的客户端）， 而Ribbon是客户端的负载均衡实现。</p><p>Ribbon的核心概念是命名的客户端（named client），Spring Cloud会为每个命名客户端创建一个子应用上下文（ApplicationContext），在该上下文中，通过RibbonClientConfiguration创建ILoadBalancer，RestClient，ServerListFilter等Bean。</p><p>Spring Cloud Netflix提供的默认的Ribbon bean及说明</p><table><thead><tr><th style="text-align:center">Bean类型</th><th style="text-align:center">默认实现类</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">IClientConfig</td><td style="text-align:center">DefaultClientConfigImpl</td><td style="text-align:center">Ribbon客户端配置加载实现，加载各实现bean及客户端连接超时、通讯超时等配置</td></tr><tr><td style="text-align:center">IRule</td><td style="text-align:center">ZoneAvoidanceRule</td><td style="text-align:center">基于zone与可用性来过滤服务器的规则实现</td></tr><tr><td style="text-align:center">IPing</td><td style="text-align:center">DummyPing</td><td style="text-align:center">判断服务器是否存活的实现，默认总是返回true</td></tr><tr><td style="text-align:center">ServerList<server></server></td><td style="text-align:center">ConfigurationBasedServerList</td><td style="text-align:center">获取服务器列表的实现，默认基于配置</td></tr><tr><td style="text-align:center">ServerListFilter<server></server></td><td style="text-align:center">ZonePreferenceServerListFilter</td><td style="text-align:center">服务器过滤实现，默认过滤出与客户端在同一个zone中的服务器列表</td></tr><tr><td style="text-align:center">ILoadBalancer</td><td style="text-align:center">ZoneAwareLoadBalancer</td><td style="text-align:center">负载均衡实现，默认根据zone的请求负载量排除掉负载最高的zone，从剩下的zone中选择一个根据给定的Rule选择其中一个服务器</td></tr><tr><td style="text-align:center">ServerListUpdater</td><td style="text-align:center">PollingServerListUpdater</td><td style="text-align:center">动态的服务器列表更新器</td></tr></tbody></table><p>Spring Cloud允许我们通过声明一个configuration来对客户端进行自定义，来调整或覆盖上述默认实现，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"custom"</span>, configuration = CustomConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，客户端将由RibbonClientConfiguration 与 CustomConfiguration中定义的组件一起组成，且CustomConfiguration 中的组件会覆盖前者。</p><blockquote><p>注意CustomConfiguration 必须是@Configuration 修饰的类，且不能被main application context的 @ComponentScan 扫描，否则会被所有@RibbonClients 共享</p></blockquote><p>如果要为所有Ribbon Clients定制默认配置，则可使用@RibbonClients 注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients</span>(defaultConfiguration = DefaultRibbonConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientDefaultConfigurationTestsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以通过配置属性来定制Ribbon Client，支持的配置属性<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NFLoadBalancerClassName: ILoadBalancer接口实现类</span><br><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NFLoadBalancerRuleClassName: IRule接口实现类</span><br><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NFLoadBalancerPingClassName: IPing接口实现类</span><br><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NIWSServerListClassName: ServerList接口实现类</span><br><span class="line"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span>.ribbon.NIWSServerListFilterClassName: ServerListFilter接口实现类</span><br></pre></td></tr></table></figure></p><p>比如对于一个服务名称为users的配置<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="attr">    ribbon:</span></span><br><span class="line"><span class="attr">        NIWSServerListClassName:</span> <span class="string">com.netflix.loadbalancer.ConfigurationBasedServerList</span></span><br><span class="line"><span class="attr">        NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.WeightedResponseTimeRule</span></span><br></pre></td></tr></table></figure></p><p>配置属性的优先级 &gt; configuration指定配置类的优先级 &gt; 默认RibbonClientConfiguration的优先级， 即同样的实现，前者覆盖后者。</p><p>当Eureka与Ribbon同时存在时，ribbonServerList会被 DiscoveryEnabledNIWSServerList覆盖，从Eureka来获取server list，同时 NIWSDiscoveryPing也会替换IPing接口，代理Eureka来确定服务器是否处于运行状态。</p><p>Ribbon的超时与重试配置</p><ul><li>&lt;clientName>.ribbon.ConnectTimeout： 请求连接超时时间，默认2000</li><li>&lt;clientName>.ribbon.ReadTimeout： 请求处理超时时间，默认5000</li><li>&lt;clientName>.ribbon.MaxAutoRetries： 在同一台服务器上的重试次数，排除第一次调用，默认0</li><li>&lt;clientName>.ribbon.MaxAutoRetriesNextServer： 切换服务器的重试次数，默认1</li><li>&lt;clientName>.ribbon.OkToRetryOnAllOperations： 对所有请求都进行重试，默认false</li></ul><p>当项目中添加了Spring Retry的依赖，则会启用重试机制。当请求失败时，会再尝试访问当前服务器（次数由MaxAutoRetries配置），如果不行，就换一个服务器进行访问，如果还是不行，再换服务器访问（更换次数由MaxAutoRetriesNextServer配置），如果还是不行，则返回请求失败。</p><h2 id="Ribbon的负载均衡策略"><a href="#Ribbon的负载均衡策略" class="headerlink" title="Ribbon的负载均衡策略"></a>Ribbon的负载均衡策略</h2><p>前文提到Ribbon的负载均衡默认实现为ZoneAwareLoadBalancer，那么Ribbon提供的负载均衡策略还有哪些？ 罗列如下</p><ul><li>BestAvailableRule： 排除掉断路器打开的服务器，选取并发请求最小的服务器</li><li>AvailabilityFilteringRule： 过滤掉断路器打开或活跃连接数超过限制（通过&lt;clientName>.&lt;nameSpace>.ActiveConnectionsLimit配置，默认为Integer.MAX_VALUE）的服务器</li><li>WeightedResponseTimeRule: 根据平均响应时间来动态为服务器赋予权值，实现基于权重的轮询</li><li>RetryRule： 对选择负载均衡策略添加重试机制</li><li>RoundRobinRule： 简单轮询</li><li>RandomRule： 随机轮询</li><li>ZoneAvoidanceRule： 结合区域与可用性来选择服务器，也是默认实现</li></ul><p>可通过如下配置修改Ribbon的负载均衡策略<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-name:</span></span><br><span class="line"><span class="attr">    ribbon:</span></span><br><span class="line"><span class="attr">        NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.WeightedResponseTimeRule</span></span><br></pre></td></tr></table></figure></p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>本文案例演示基于上文搭建的springcloud-eureka 与 springcloud-eureka-client 两个示例项目 （<a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">源码</a>），依次启动两个项目，然后将springcloud-eureka-client项目的端口 server.port改为8081，新开一个springboot运行配置，如图</p><p><img src="/assets/eureka-client2.png" alt="Eureka客户端2"></p><p>以8081端口再起一个springcloud-eureka-client的服务实例。这是查看Eureka页面 <a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a>, 可以看到hello-service服务注册了两个实例</p><p><img src="/assets/hello-service.png" alt="hello服务注册"></p><p>新建springcloud-ribbon项目 （<a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">源码</a>）</p><p>pom.xml中引入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>编写测试接口， LoadBalanceClient 是Ribbon的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"ribbon"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRibbon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServiceInstance instance = loadBalancer.choose(<span class="string">"hello-service"</span>);</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"http://%s:%s"</span>, instance.getHost(),</span><br><span class="line">                instance.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动springcloud-ribbon， 调用测试接口 <a href="http://localhost:8082/ribbon，" target="_blank" rel="noopener">http://localhost:8082/ribbon，</a> 可以看到返回结果交替显示 <a href="http://CN-201911061714:8080，" target="_blank" rel="noopener">http://CN-201911061714:8080，</a> <a href="http://CN-201911061714:8081" target="_blank" rel="noopener">http://CN-201911061714:8081</a>  （CN-201911061714是我电脑的hostname，你的可能不一样），可见Ribbon实现了客户端的负载均衡。</p><h2 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h2><ol><li><p>Ribbon如果对所有请求进行重试，则需要保证接口的幂等性（多次调用产生的结果是一致的）</p></li><li><p>每一个命名的Ribbon客户端都有一个相应的由Spring cloud维护的子应用上下文，默认是lazy load的（第一次请求客户端时才load），可以通过如下配置更改为启动立即加载</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">    eager-load:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        clients:</span> <span class="string">client1,</span> <span class="string">client2,</span> <span class="string">client3</span></span><br></pre></td></tr></table></figure></li><li><p>client.ribbon.*  针对单个客户端进行配置，针对所有客户端默认配置，则使用ribbon.*</p></li><li><p>当结合断路器使用时， 断路器的超时时间要大于Ribbon的超时时间，不然不会触发重试（还没重试就触发断路器打开了）</p></li><li><p>除了Ribbon，能做负载均衡访问的Web客户端还有@LoadBalance 注解的RestTemplate， 与Feign</p></li></ol><p><a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">本文示例代码</a></p><p><br><br>认真生活，快乐分享<br>欢迎关注微信公众号：空山新雨的技术空间<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文介绍了服务如何通过Eureka实现注册，以及如何从Eureka获取已经注册的服务列表。那么拿到注册服务列表后， 如何进行服务调用？一个简单的实现是可以从被调用服务的实例列表中选择一个服务实例，通过其hostname（或IP），端口，及API的路径拼接成完整的url，通过http client来完成调用。但生产环境中，为了高性能、高可用等要素，服务的调用一般涉及负载均衡、故障转移、失败重试等实现，因此引入实现这些功能的客户端组件也成为了微服务架构中的必备要素。Spring Cloud中可通过Ribbon与Feign来实现服务间的调用。&lt;/p&gt;
&lt;p&gt;本系列文章与示例均基于最新的Spring Cloud Hoxton版编写。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>微服务漫谈</title>
    <link href="http://blog.jboost.cn/micro-service.html"/>
    <id>http://blog.jboost.cn/micro-service.html</id>
    <published>2019-12-24T06:52:04.000Z</published>
    <updated>2019-12-26T07:38:58.727Z</updated>
    
    <content type="html"><![CDATA[<p>微服务可以说是近几年技术圈异常火爆的概念，人人都在说微服务，人人都在致力于打造自己的“微服务”。甚至于某些压根不懂技术的项目招标方都在问你们公司用了微服务吗？“微服务”俨然成了衡量团队技术实力或技术逼格的代名词。</p><p>但是，微服务真是万能的吗？是不是来个项目就得微服务一下，不然就显得落伍，显得low了呢？ 本文一起聊聊“微服务”的那些事。</p><a id="more"></a><h2 id="一-什么是微服务？"><a href="#一-什么是微服务？" class="headerlink" title="一. 什么是微服务？"></a>一. 什么是微服务？</h2><p>微服务是一种架构风格，由Martin Fowler（牛人，ThoughtWorks公司的首席科学家，同时也是敏捷开发方法的创始人之一）提出，是指将复杂应用通过拆分为一系列高内聚、低耦合、自治的小（微）服务，每个服务独立开发（可以使用不同的编程语言），独立部署（运行在不同的进程中），并通过轻量级的通信机制（Restful API）进行交互。微服务本质上还是SOA（Service-Oriented-Architecture, 面向服务的架构），但微服务不限定于特定的技术，通过Restful架构风格来完成系统的统一，因此比传统的SOA（一般基于较重的SOAP、WSDL、UDDI等协议技术，通过企业服务总线ESB进行连接集成）更为灵活，更具扩展性。</p><p>微服务的特征：</p><ol><li>是一种应用于组件设计(服务如何拆分)和部署架构(服务如何部署和通信)的模式</li><li>适用于创建具有“一定功能复杂性”的分布式应用系统</li><li>各个服务必须小，只负责某个具体的业务功能，比如商品服务，订单服务，根据功能实现关注点分离</li><li>各个服务保持自治和相互解耦，进行独立开发、独立部署，及独立升级与伸缩</li><li>各个服务之间通过轻量级 API （Restful API）和异步通信（如消息队列）相结合的方式进行通信</li></ol><h2 id="二-微服务的优缺点"><a href="#二-微服务的优缺点" class="headerlink" title="二. 微服务的优缺点"></a>二. 微服务的优缺点</h2><p>微服务的优缺点一般相对单体应用（就是所有功能、代码都整在一个工程项目中）而言</p><h3 id="1-微服务的优点："><a href="#1-微服务的优点：" class="headerlink" title="1. 微服务的优点："></a>1. 微服务的优点：</h3><p>1.1 简化复杂的业务模型<br>微服务将复杂的业务通过一系列的高内聚、低耦合的小型服务来实现，体现了分治的思想。每个服务的开发与维护都非常高效，可管理性更高，能快速响应需求。</p><p>1.2 不局限于某项特定的技术<br>因为服务间是通过轻量级的Restful API交互，每一个服务可以独立开发，可选用不同的编程语言与技术框架（虽然实际中对于一般规模一般都是统一的）。</p><p>1.3 独立部署与升级，按需伸缩<br>每个服务都是独立部署，运行在不同的进程中，因为加载内容相对较少，所以一般启动也比较快。单个服务的升级对系统整体的影响也较小。同时可以针对各个服务的负载情况，进行独立的按需伸缩。</p><h3 id="2-微服务的缺点："><a href="#2-微服务的缺点：" class="headerlink" title="2. 微服务的缺点："></a>2. 微服务的缺点：</h3><p>2.1 对“微”的粒度与服务的边界难以把握。<br>微服务开发过程中，开发人员最常见的疑问就是这个接口应该放到哪个服务里。服务应该微到什么程度，服务边界与服务交互如何定义与规范，需要有对业务、技术充分了解的专业人员做上层设计（一般就是架构师），并且持续跟进实施落地，否则很有可能就会导致只是将一个单体应用拆成了多个单体应用，或编织了一张交互错综复杂的服务网络的尴尬局面。</p><p>2.2 引入了分布式的复杂性。<br>微服务中某一个请求可能就涉及好几个服务间的调用，如果出现问题，则定位相对困难复杂；同时基于CAP（Consistency，Availability， Partition Tolerance）理论，分布式系统中一致性、可用性、分区容忍性只能同时满足两个，一般在满足可用性与分区容忍性的基础上，对系统提供最终一致性保障。</p><p>2.3 对技术栈的要求更高。<br>团队需要对微服务基本理论与相关技术有一定了解，且需要搭建许多业务服务之外的基础设施服务，比如服务注册发现、配置管理、链路监控等。目前微服务技术最热的就是Spring Cloud，也有部分团队选择Dubbo。</p><p>2.4 对运维的要求更高。<br>微服务将一个复杂应用拆分为几十个甚至上百个小型服务，迭代升级部署的频率比单体应用更高，采用传统的运维手段很难满足需求，一般需引进DevOps的相关技术手段，如CI（持续集成）、CD（持续部署）、自动化测试、容器化与服务编排，及丰富的监控告警机制等。</p><h2 id="三-如何抉择？"><a href="#三-如何抉择？" class="headerlink" title="三. 如何抉择？"></a>三. 如何抉择？</h2><p>如之前文章说到的，技术人员的能力在于解决问题的能力（当然解决问题也分临时性的解决问题与前瞻性的解决问题——解决方案能在较长一段时间内适用）。技术管理者或技术决策者最基本的修为就是在过火过热的各种技术概念与技术框架面前保持冷静，选择最适合业务场景与自身团队的技术方案。</p><p>要不要用微服务，什么时候不该用微服务？结合自身理解，总结整理如下：</p><ol><li><p>业务简单，应用规模很小不该用微服务<br>杀鸡不能用牛刀，微服务旨在将复杂业务拆分，简化业务规模， 如果业务本身很简单，一个单体应用就能处理的场景不该用微服务。</p></li><li><p>业务领域不够清晰、明确不该用微服务<br>业务领域不清晰、不明确，意味着整个业务定义、业务框架都可能朝令夕改，如果采用微服务，则可能导致牵一发而动全身的痛苦局面。</p></li><li><p>团队技术储备不够不该硬上微服务<br>微服务的分布式特性对团队的技术要求比单体应用高， 如果团队大部分成员之前都没接触过微服务，对微服务缺乏基本的了解，不该硬上微服务。</p></li><li><p>小型创业公司不适合用微服务<br>该条其实是前面几条的汇总，因为小型创业公司一般就意味着业务相对简单，并且业务领域、设计不够清晰、明确，以及团队技术实力相对较弱，并且人员流动性大等特点，任何一点都不利于微服务的构建。</p></li></ol><p>对于业务较为明确且复杂的系统，如果你团队的技术储备达到一定水平（如对Spring Boot，Spring Cloud，CI/CD，Docker/K8s等有一定掌握），并且有一个对业务与技术都有充分了解且具备决策权的master，微服务无疑是一个很好的选择。否则，慎重！</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p>任何技术与框架都有其适用场景，微服务不是万能钥匙。应结合具体的业务场景，团队组成，技术储备等因素综合考虑，选择最适合自身的技术方案。</p><p>—————————————————————————————<br>作者：空山新雨<br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号）<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务可以说是近几年技术圈异常火爆的概念，人人都在说微服务，人人都在致力于打造自己的“微服务”。甚至于某些压根不懂技术的项目招标方都在问你们公司用了微服务吗？“微服务”俨然成了衡量团队技术实力或技术逼格的代名词。&lt;/p&gt;
&lt;p&gt;但是，微服务真是万能的吗？是不是来个项目就得微服务一下，不然就显得落伍，显得low了呢？ 本文一起聊聊“微服务”的那些事。&lt;/p&gt;
    
    </summary>
    
      <category term="Architecture" scheme="http://blog.jboost.cn/categories/Architecture/"/>
    
    
      <category term="arch" scheme="http://blog.jboost.cn/tags/arch/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（一）：服务注册中心Eureka</title>
    <link href="http://blog.jboost.cn/springcloud-1.html"/>
    <id>http://blog.jboost.cn/springcloud-1.html</id>
    <published>2019-12-24T05:56:55.000Z</published>
    <updated>2020-01-13T11:34:24.509Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud 基于 Netflix 的几个开源项目进行了封装，提供包括服务注册与发现（Eureka），智能路由（Zuul），熔断器（Hystrix），客户端负载均衡（Ribbon）等在内的核心组件。</p><p>在微服务系统中，服务少则十几、几十个，多则上百、几百个（据悉 Netflix 的云平台上运行了500多个微服务），这些微服务通过相互调用来为用户提供功能。那么一个服务调用另一个服务是如何进行的，如何定位到另一个服务的地址？代码中写死，还是配置文件中配置？显然对于服务数量较多的系统，这两种方式先不说后续维护，光写起来就很痛苦。于是，对于微服务架构来说，服务的自动注册与发现就成为非常核心的功能，Eureka就是来负责实现这个功能的。</p><p>本系列文章与示例均基于最新的Spring Cloud Hoxton版编写。</p><a id="more"></a><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><hr><p>Eureka是一个基于REST的服务，包括Eureka Server与Eureka Client两个端。Eureka Server作为服务注册中心接受Eureka Client的注册及获取其它服务的地址信息。基本架构如下图所示：</p><p><img src="/assets/eureka-architecture-overview.png" alt="Eureka基本架构"></p><p>其中</p><ul><li><p>Eureka Server： 作为服务注册中心，提供服务注册与发现功能接口</p></li><li><p>Service Provider： 服务提供者，将自身服务注册到服务注册中心，供其它服务消费者发现与调用</p></li><li><p>Service Consumer： 服务消费者，从服务注册中心发现服务，并通过一些负载均衡客户端来调用（比如Ribbon或Feign）</p></li></ul><p>很多时候同一个应用可能既是服务提供者，也是服务消费者——自己作为服务方，为其它服务提供接口，同时也调用其它服务的接口来完成自身的业务逻辑。</p><h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><hr><p>Eureka Server的搭建非常简单，其部署可分为单实例部署与多实例集群部署，一般开发测试环境可以使用单实例部署，但生产环境出于高可用要求，可进行多实例集群部署。</p><ol><li>在pom.xml中添加依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>为了方便版本引入，可以在pom中添加依赖管理，这样spring cloud相关的starter依赖就不需要指定版本了（如上省略了version）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>在启动类上添加注解 @EnableEurekaServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在application.yml 或 application.properties配置文件中添加配置（个人比较倾向于yml，两者区别可自行百度）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">spring-cloud-eureka</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">single</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">single</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer2:8762/eureka/,http://peer3:8763/eureka/</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8761/eureka/,http://peer3:8763/eureka/</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer3</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8763</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer3</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8761/eureka/,http://peer2:8762/eureka/</span></span><br></pre></td></tr></table></figure></li></ol><p>在该配置文件中，实际上是定义了两种模式，其中默认的profile single是单实例模式， peer1， peer2， peer3组成多实例模式。</p><ul><li><code>eureka.client.registerWithEureka</code>：表示是否将自身注册到Eureka Server，默认为true，单实例模式下一般设置为false，否则会在启动时报连接不到服务器的错误</li><li><code>eureka.client.fetchRegistry</code>：表示是否从Eureka Server获取注册服务列表，默认为true，同样在单实例模式下设置为false</li><li><code>eureka.client.serviceUrl.defaultZone</code>：Eureka Server的地址，多实例模式下多个地址以“,”隔开，多个实例之间只要有一条路线连通，则总会将注册信息进行同步</li></ul><ol start="4"><li>启动</li></ol><p>对于单实例模式，如果按如上配置，则直接启动程序即可。启动完成后，访问 <a href="http://localhost:8761，即可查看Eureka" target="_blank" rel="noopener">http://localhost:8761，即可查看Eureka</a> Server的相关信息，如</p><p><img src="/assets/single-eureka.png" alt="单实例模式"></p><p>上图所示，当前没有Eureka Server的副本也没有任何服务注册。</p><p>对于多实例集群模式，则需要根据不同的profile启动多个实例，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br><span class="line">cd target</span><br><span class="line">java -jar springcloud-eureka-1.0-SNAPSHOT.jar --spring.profiles.active=peer1</span><br><span class="line">java -jar springcloud-eureka-1.0-SNAPSHOT.jar --spring.profiles.active=peer2</span><br><span class="line">java -jar springcloud-eureka-1.0-SNAPSHOT.jar --spring.profiles.active=peer3</span><br></pre></td></tr></table></figure><p>启动完成后，打开 <a href="http://localhost:8761，" target="_blank" rel="noopener">http://localhost:8761，</a> 可以看到Eureka Server已经存在副本与注册的服务了（Eureka将自身作为一个服务完成了注册）</p><p><img src="/assets/multi-eureka.png" alt="多实例模式"></p><p>上述操作如果是在单机进行，则需要在hosts文件中添加映射，linux下是/etc/hosts，windows10 下是C:\Windows\System32\drivers\etc\hosts，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 peer1</span><br><span class="line">127.0.0.1 peer2</span><br><span class="line">127.0.0.1 peer3</span><br></pre></td></tr></table></figure><h2 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h2><hr><p>Eureka Client一般集成在各个微服务中，集成也非常简单。</p><ol><li><p>pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.yml配置文件中添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;random.uuid&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>如果是多实例集群模式，则 <code>eureka.client.serviceUrl.defaultZone</code> 可以配置多个地址，“，”号分隔。</p><ul><li><code>eureka.client.*</code>：  发现服务的配置参数</li><li><code>eureka.instance.*</code>： 注册服务的配置参数， 如上 <code>eureka.instance.prefer-ip-address</code> 设置为true表示服务注册时使用IP，而不是hostname； <code>eureka.instance.instance-id</code> 配置服务实例的ID，默认为 ${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}}</li></ul><blockquote><p>添加了依赖就能集成Eureka Client，主类上添加 @EnableDiscoveryClient 注解不是必须。</p></blockquote><p>启动程序后，进入Eureka Server页面即可看到注册的服务</p><p><img src="/assets/eureka-client.png" alt="Eureka客户端"></p><h2 id="一些知识点（建议掌握）"><a href="#一些知识点（建议掌握）" class="headerlink" title="一些知识点（建议掌握）"></a>一些知识点（建议掌握）</h2><hr><ol><li><p>Eureka Client在注册服务时，提供包括hostname，IP地址， port， health indicator url，status page， home page 等在内的meta-data，其它客户端可通过这些信息来直接与服务进行交互，我们也可以通过 <code>eureka.instance.metadataMap</code> 来添加自定义的meta-data，供客户端访问</p></li><li><p>Eureka Server通过接收Eureka Client的心跳消息来判断服务实例是否存活，如果某一个实例的心跳在特定时间（可配置）内没收到，则将其从注册表中移除。心跳默认间隔为30s，一个服务被其它客户端发现，可能需要经过3次心跳，这也是有时候服务注册比较慢的原因。可通过<code>eureka.instance.leaseRenewalIntervalInSeconds</code>配置，但生产环境建议最好保持默认</p></li><li><p>Eureka Client默认不会传播当前应用的健康检查状态，一旦注册成功，只要心跳存在，Eureka总是认为应用处于UP状态。可以启用Eureka的健康检查，将状态传播给Eureka，其它应用只会将请求发给UP状态的服务实例 <code>eureka.client.healthcheck.enabled=true</code>。注意这个配置只能配置在application.yml中，配置在bootstrap.yml中可能导致注册服务时，服务以状态为UNKOWN进行注册</p></li><li><p>Eureka Server是没有后端存储的，服务实例需要通过心跳来更新注册信息，注册信息存于内存中，Eureka Client也有一个基于内存的缓存，不需要每次请求服务都要访问注册中心获取服务地址信息</p></li><li><p>Eureka的自我保护机制：Eureka Server在短时间内丢失比较多的客户端时，会进入自我保护模式，在该模式下，Eureka Server即使发现服务实例已经不再发送心跳了，也不会从服务注册表中删除。这样，当发生网络故障时，服务注册信息仍然存于Eureka中，当网络故障恢复后，会自动退出自我保护模式。自我保护模式是一种应对网络异常的安全保护机制。相关配置： <code>eureka.server.renewal-percent-threshold</code>， 触发自我保护机制的阈值，默认为0.85； <code>eureka.server.enable-self-preservation</code>， 自我保护开启，默认为true，如果设置为false，则关闭客户端程序后，可直观地从Eureka Server的页面发现服务实例被注销删除了。</p></li></ol><p><a href="https://github.com/ronwxy/springcloud-demos" target="_blank" rel="noopener">本文示例代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Cloud 基于 Netflix 的几个开源项目进行了封装，提供包括服务注册与发现（Eureka），智能路由（Zuul），熔断器（Hystrix），客户端负载均衡（Ribbon）等在内的核心组件。&lt;/p&gt;
&lt;p&gt;在微服务系统中，服务少则十几、几十个，多则上百、几百个（据悉 Netflix 的云平台上运行了500多个微服务），这些微服务通过相互调用来为用户提供功能。那么一个服务调用另一个服务是如何进行的，如何定位到另一个服务的地址？代码中写死，还是配置文件中配置？显然对于服务数量较多的系统，这两种方式先不说后续维护，光写起来就很痛苦。于是，对于微服务架构来说，服务的自动注册与发现就成为非常核心的功能，Eureka就是来负责实现这个功能的。&lt;/p&gt;
&lt;p&gt;本系列文章与示例均基于最新的Spring Cloud Hoxton版编写。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（十二）：Docker Compose入门</title>
    <link href="http://blog.jboost.cn/docker-12.html"/>
    <id>http://blog.jboost.cn/docker-12.html</id>
    <published>2019-11-20T11:09:23.000Z</published>
    <updated>2019-11-20T04:11:18.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Compose简介"><a href="#1-Compose简介" class="headerlink" title="1. Compose简介"></a>1. Compose简介</h2><p>Docker Compose是Docker官方的用于对Docker容器集群实现编排，快速部署分布式应用的开源项目。Docker Compose通过docker-compose.yml文件来定义一组相关联的应用容器的编排，这组相关联的应用容器一般通过互相交互作为一个整体项目提供服务，比如一个Web项目，既包含业务服务容器，也包含数据库服务容器与缓存服务容器等。</p><p>Compose中两个重要的概念：</p><ul><li>服务（service）： 包含多个运行相同镜像的容器实例</li><li>项目（project）： 由一组关联的应用容器（服务）组成一个完整的业务服务单元，在docker-compose.yml（即Compose的模板文件）中定义</li></ul><p>Copmpose项目由Python编写，通过调用Docker服务提供的API来对容器进行管理。Compose默认的管理对象是项目，可以通过子命令对项目中的一组容器进行生命周期管理。</p><h2 id="2-Compose安装"><a href="#2-Compose安装" class="headerlink" title="2. Compose安装"></a>2. Compose安装</h2><p>在macOS与Win10下，Docker安装自带了docker-compose的二进制文件，可以直接使用。<br>Linux下，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz ~]# curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">[root@iZwz ~]# chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></p><p>验证<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz ~]# docker-compose version</span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br><span class="line">docker-py version: 3.7.3</span><br><span class="line">CPython version: 3.6.8</span><br><span class="line">OpenSSL version: OpenSSL 1.1.0j  20 Nov 2018</span><br></pre></td></tr></table></figure></p><h2 id="3-Compose模板文件"><a href="#3-Compose模板文件" class="headerlink" title="3. Compose模板文件"></a>3. Compose模板文件</h2><p>模板文件是使用Compose的核心，定义了一组相关联的应用容器，使之构成一个项目，里面大部分指令跟docker run相关参数的含义是类似的。默认的模板文件名称为docker-compose.yml，为YAML格式，如<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">        build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">        depends_on:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">db</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">redis</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">    redis:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">redis</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">    db:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure></p><p>Compose模板文件可以动态读取主机的系统环境变量与当前目录下.env文件中的变量，通过${xx}引用。</p><p>模板文件中的常用指令说明</p><ul><li><p>build<br>指定Dockerfile所在文件夹的路径，可以是绝对路径或相对模板文件的路径。Compose将会自动构建镜像，然后使用该镜像。也可以通过如下方式详细指定。cache_from指定构建镜像的缓存</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">    context:</span> <span class="string">./dir</span></span><br><span class="line"><span class="attr">    dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="attr">        buildno:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    cache_from:</span></span><br><span class="line"><span class="attr">        - alpine:</span><span class="string">latest</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure></li><li><p>command<br>覆盖容器启动后默认执行的命令。</p></li><li><p>container_name<br>Compose默认会使用 项目名称<em>服务名称</em>序号的格式作为容器名称。一般不需要特别指定，因为指定具体名称后，服务将无法进行扩展（scale），因为不允许多个容器具有相同的名称。</p></li><li><p>depends_on<br>解决容器的依赖、启动先后顺序的问题，但是服务不会等待依赖的服务“完全启动”之后才启动。</p></li><li><p>env_file<br>指定环境变量定义文件，可以为单独文件路径或列表，当与environment中有同名冲突时，以environment为准。</p></li><li><p>environment<br>设置环境变量，支持数组或字典两种格式。只有名称的变量会自动获取运行Compose主机上的对应变量的值，以防止信息泄露</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="attr">    RACK_ENV:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">    SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">RACK_ENV=development</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure></li><li><p>expose<br>暴露端口，不映射到宿主机，只被连接的服务访问</p></li><li><p>healthcheck<br>通过命令检查容器是否健康运行，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line"><span class="attr">    test:</span> <span class="string">["CMD",</span> <span class="string">"curl"</span><span class="string">,</span> <span class="string">"-f"</span><span class="string">,</span> <span class="string">"http://localhost"</span><span class="string">]</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">1</span><span class="string">m30s</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">    retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>image<br>指定镜像名称或镜像ID，所有服务都必要要么通过build，要么通过image来指定镜像。</p></li><li><p>labels<br>为容器添加Docker元数据信息</p></li><li><p>network_mode<br>设置网络模式，与docker run的–network一样，如bridge，host，none等，也可以是如下形式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">"service:[service name]"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure></li><li><p>networks<br>配置容器连接的网络，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    service1:</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">some-network</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">other-network</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">    some-network:</span></span><br><span class="line"><span class="attr">    other-network:</span></span><br></pre></td></tr></table></figure></li><li><p>ports<br>暴露端口信息，遵循端口映射规则。</p></li><li><p>secrets<br>存储敏感数据，如密码等信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">        MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line"><span class="attr">    secrets:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">db_root_password</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">my_other_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line"><span class="attr">    my_secret:</span></span><br><span class="line"><span class="attr">        file:</span> <span class="string">./my_secret.txt</span></span><br><span class="line"><span class="attr">    my_other_secret:</span></span><br><span class="line"><span class="attr">        external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>volumes<br>容器的数据卷挂在路径设置，可以设置多个，与docker -v类似，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Compose命令"><a href="#4-Compose命令" class="headerlink" title="4. Compose命令"></a>4. Compose命令</h2><p>Compose命令默认是针对项目本身，也可以指定为项目中的服务或容器。<br>docker-compose 命令的基本使用格式为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure></p><p>命令选项</p><ul><li>-f, –file 指定模板文件，默认为docker-compose.yml，可多次指定</li><li>-p, –project-name 指定项目名称，默认为所在目录名称</li><li>–x-networking 使用Docker的可插拔网络特性</li><li>–x-networking-driver 指定网络驱动，默认为bridge</li><li>–verbose 输出更多调试信息</li><li>-v, –version 打印版本信息</li></ul><p>命令使用说明</p><ul><li>build 格式为<code>docker-compose build [options] [SERVICE...]</code>，构建项目中的服务容器，选项包括 –force-rm（删除构建过程中的临时容器），–no-cache（构建镜像过程不使用cache），–pull（始终尝试通过pull来获取最新版本镜像）</li><li>config 验证模板文件格式是否正确</li><li>down 停止up命令启动的容器，并移除网络</li><li>exec 进入指定的容器</li><li>images 列出compose文件中包含的镜像</li><li>kill 格式为<code>docker-compose kill [options] [SERVICE...]</code>，强制停止服务容器</li><li>logs 格式为<code>docker-compose logs [options] [SERVICE...]</code>，查看服务容器的输出</li><li>pause 格式为<code>docker-compose pause [SERVICE...]</code>， 暂停一个服务容器</li><li>port 格式为<code>docker-compose port [options] SERVICE PRIVATE_PORT</code>，打印容器端口所映射的公共端口，–index=index（指定容器序号，默认为1）</li><li>ps 格式为<code>docker-compose ps [options] [SERVICE...]</code>，列出项目中目前的所有容器</li><li>pull 格式为<code>docker-compose pull [options] [SERVICE...]</code>，拉去服务依赖的镜像</li><li>push 推送服务依赖的镜像到Docker镜像仓库</li><li>restart 重启项目中服务，格式为<code>docker-compose restart [options] [SERVICE...]</code></li><li>rm 删除所有停止的服务容器，格式<code>docker-compose rm [options] [SERVICE...]</code>， -f（强制直接删除）</li><li>run 在指定服务上执行一个命令，不会自动创建端口，以避免冲突</li><li>scale 格式<code>docker-compose scale [options] [SERVICE=NUM...]</code>，设置指定服务运行的容器个数，少则新建，多则删除</li><li>start 格式<code>docker-compose start [SERVICE...]</code>，启动已经存在的服务容器</li><li>stop 停止运行中的容器</li><li>top 查看各个服务容器内运行的进程</li><li>unpause 格式<code>docker-compose unpause [SERVICE...]</code>，恢复处于暂停状态的服务</li><li>up 格式<code>docker-compose up [options] [SERVICE...]</code>，尝试自动完成包括构建镜像，创建服务，启动服务，关联服务相关容器的一系列操作，大部分时候都可以通过该命令来启动一个项目，-d（在后台启动所有容器）。<code>docker-compose up --no-recreate</code>只启动处于停止状态的容器，忽略已经运行的服务，<code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code>重新创建服务，但不影响到它所依赖的服务</li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Compose是Docker官方的服务容器编排工具，对一些简单的但包含多个组件的服务可以借助Compose来快速搭建环境，如开源的错误监控系统sentry，包括sentry服务本身，redis，postgres。对于业务生产环境，则一般使用功能更为丰富的第三方编排系统如Kubernetes来部署。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Compose简介&quot;&gt;&lt;a href=&quot;#1-Compose简介&quot; class=&quot;headerlink&quot; title=&quot;1. Compose简介&quot;&gt;&lt;/a&gt;1. Compose简介&lt;/h2&gt;&lt;p&gt;Docker Compose是Docker官方的用于对Docke
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>软件系统的非功能要素与设计思路</title>
    <link href="http://blog.jboost.cn/arch-1.html"/>
    <id>http://blog.jboost.cn/arch-1.html</id>
    <published>2019-11-15T10:56:54.000Z</published>
    <updated>2019-11-15T02:04:14.490Z</updated>
    
    <content type="html"><![CDATA[<p>对于具备一定复杂度的软件系统，我们一般都会进行架构设计。架构设计中涉及功能要素与非功能要素，功能要素对应业务需求，关注需要实现的业务模块与功能，非功能要素对应系统本身的运行需求，一般包括性能、可用性、可伸缩性、可扩展性、安全等几个方面，软件系统的非功能架构设计，就是通过一些技术手段来满足这几个方面的运行需求。<br><a id="more"></a></p><h2 id="一-性能"><a href="#一-性能" class="headerlink" title="一. 性能"></a>一. 性能</h2><p>性能直观表现就是用户使用系统时响应的快慢程度。一般有响应时间（如用户点击一个按钮经服务端处理后，收到反馈的时长）、吞吐量（系统单位时间内能处理事务的个数，TPS —— Transaction-Per-Second）、支持并发数（能支持同时处理多少个并发在线用户）等衡量指标。</p><p>系统性能可通过相应的测试进行评估，一般包括：</p><ul><li>性能测试：验证系统在资源可接受范围内，是否能达到性能预期。比如2核8G的服务器配置，在CPU负载不超过指定值的情况下，系统的吞吐量能否达到1k。</li><li>负载测试：不断给系统增加并发请求以增加对系统的压力，直到系统的某项或多项性能指标达到安全临界值。这时候，继续增加压力，系统的处理能力如吞吐量不增反降。</li><li>压力测试：在超过安全负载的情况下，继续对系统施加压力，直到系统崩溃或不能再处理任何请求，即系统在达到崩溃临界点时最大能承受多大的压力。</li><li>稳定测试：在模拟生产环境的场景下，包括软硬件配置、网络环境等条件，加载一定的业务压力（业务压力也尽量模拟生产环境下的情况），运行一段比较长的时间，看系统是否能稳定地运行。</li></ul><p>测试报告形如下表</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">并发数</th><th style="text-align:center">响应时间（ms）</th><th style="text-align:center">TPS</th><th style="text-align:center">错误率（%）</th><th style="text-align:center">CPU负载</th><th style="text-align:center">内存使用（GB）</th></tr></thead><tbody><tr><td style="text-align:center">性能测试</td><td style="text-align:center">10</td><td style="text-align:center">500</td><td style="text-align:center">20</td><td style="text-align:center">0</td><td style="text-align:center">5</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">性能测试</td><td style="text-align:center">30</td><td style="text-align:center">1000</td><td style="text-align:center">40</td><td style="text-align:center">2</td><td style="text-align:center">15</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">负载测试</td><td style="text-align:center">40</td><td style="text-align:center">1200</td><td style="text-align:center">45</td><td style="text-align:center">20</td><td style="text-align:center">30</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">压力测试</td><td style="text-align:center">60</td><td style="text-align:center">2000</td><td style="text-align:center">30</td><td style="text-align:center">40</td><td style="text-align:center">50</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">压力测试</td><td style="text-align:center">80</td><td style="text-align:center">超时</td><td style="text-align:center">0</td><td style="text-align:center">100</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><p>系统高性能的设计思路：</p><ol><li>客户端优化，包括浏览器缓存（App本地缓存）、静态资源压缩、减少Cookie传输，减少HTTP请求（合并接口）等。</li><li>缓存，包括CDN缓存与服务端缓存。CDN将静态内容分发至离用户最近的网络服务商机房，通过反向代理服务器，缓存热点资源，从而加快用户请求的响应速度，减轻后端服务的负载压力；服务端缓存通过本地缓存与分布式缓存，缓存热点数据，从而加快数据请求过程，减轻数据库的负载压力。</li><li>异步，对不需要立即获取结果的操作异步化，减少用户响应时间，改善系统的可扩展性与性能。异步一般通过消息队列实现。</li><li>集群，将同一个服务使用多个实例通过负载均衡来提高服务的整体处理能力。集群需要服务实现无状态化，即对每一个请求的处理在服务本地不保留任何数据与状态。</li><li>代码优化，多线程，资源服用（数据库连接池、线程池、HTTP连接池等），减少HTTP及数据库访问次数（如避免在循环中调用数据库访问，可优化成一次获取数据到本地再处理）。</li><li>数据库访问，索引的使用，读写分离，分库分表，NoSQL的引入，存储结构优化等。</li></ol><h2 id="二-可用性"><a href="#二-可用性" class="headerlink" title="二. 可用性"></a>二. 可用性</h2><p>系统的高可用就是当系统的某个服务器宕机时，系统服务或系统的核心服务依然可用。</p><p>对于互联网服务，一般要求7*24小时提供不间断的服务能力。系统的可用性一般就通过服务可用时间比来衡量，如三个9的可用性，就是在一段考核时间内，99.9%的时间服务可用。</p><p>系统高可用的设计主要通过冗余与失效转移的手段来实现：</p><ol><li>冗余，在系统的每一层，都通过部署多台服务器以负载均衡的形式提供访问（集群的形式），避免单点问题。关系型数据库无法通过集群部署，可提供多台互相备份，在主服务挂掉时，从服务能快速切换。</li><li>失效转移，在集群中其中一台服务器出现故障时，负载均衡能实时监测到并且不再往这台服务器分发请求，已失败的请求能重新调度到其它可用服务器。</li></ol><p>提高系统高可用也需要在开发测试阶段尽可能地进行质量保证，通过代码review，多维度测试，预发布验证，灰度发布等手段，来减少生产环境的bug引入率，提高系统的可用性。同时，在各环节添加必要的监控与告警，包括服务器资源、网络、应用等多个维度，当问题发生时能及时获得告警通知。即一方面通过多种途径规避问题的发生，另一方面当问题真正发生时，能快速响应尽可能减少影响。</p><h2 id="三-可伸缩性"><a href="#三-可伸缩性" class="headerlink" title="三. 可伸缩性"></a>三. 可伸缩性</h2><p>可伸缩性是从提升系统服务能力的角度衡量的一个因素，如果能通过不断向集群中加入服务器就能提高系统的处理能力，来应对不断增长的用户并发访问，则系统是具有可伸缩性的。</p><p>系统可伸缩性的设计思路：</p><ol><li>应用服务无状态化，对任何一个请求集群中任何一台服务器处理都能做到无差异化。</li><li>缓存服务器的伸缩可能导致缓存路由失效，可通过一致性Hash算法来降低缓存路由失效的比率。</li><li>关系型数据库很难通过集群实现可伸缩性，需要在数据库之外实现，如分库分表（不到万不得已不要使用分表）。</li><li>NoSQL，本身就具备良好的伸缩性，如HDFS。</li></ol><h2 id="四-可扩展性"><a href="#四-可扩展性" class="headerlink" title="四. 可扩展性"></a>四. 可扩展性</h2><p>系统的可扩展性关注功能性需求，衡量系统能否快速响应需求变化，即增加一个功能基本不需要修改现有系统或调整很少。</p><p>系统可扩展性的设计思路：</p><ol><li>解耦，事件驱动架构，生产者、消费者模式，如基于消息队列</li><li>拆分，将复杂业务拆分成简单的职责单一的，高内聚、低耦合的服务单元，新增服务对现有服务影响不大</li><li>复用，将比较固定的不常变动的服务下沉作为基础服务，新的业务功能基于基础服务的复用实现</li><li>开放服务，将平台服务能力通过开放接口的形式提供给第三方，拓展平台业务服务能力</li></ol><h2 id="五-安全"><a href="#五-安全" class="headerlink" title="五. 安全"></a>五. 安全</h2><p>攻击无处不在，衡量系统安全性的标准是系统针对现有的与潜在的各种攻击与窃密手段，是否有相应的可靠的应对策略。</p><p>系统的安全保障设计思路：</p><ol><li>信息加密，包括单项散列加密（如密码加密，MD5，SHA）、对称加密、非对称加密（公钥私钥，https传输）</li><li>信息过滤，如敏感词过滤，黑名单机制等</li><li>风险控制，通过规则引擎控制访问，或基于统计模型进行监控告警</li><li>限流，限制单位时间内的访问量，如手机验证码</li></ol><p>安全是相对的，没有绝对安全的系统，只能通过一些保障手段使攻击成本大于其获利成本来保障系统免受攻击。</p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>本文主要参考《大型网站技术架构》，对软件系统的几个核心的非功能性要素及其设计思路进行了介绍与总结，为软件系统的设计提供参考。</p><p>———————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于具备一定复杂度的软件系统，我们一般都会进行架构设计。架构设计中涉及功能要素与非功能要素，功能要素对应业务需求，关注需要实现的业务模块与功能，非功能要素对应系统本身的运行需求，一般包括性能、可用性、可伸缩性、可扩展性、安全等几个方面，软件系统的非功能架构设计，就是通过一些技术手段来满足这几个方面的运行需求。&lt;br&gt;
    
    </summary>
    
      <category term="Architecture" scheme="http://blog.jboost.cn/categories/Architecture/"/>
    
    
      <category term="arch" scheme="http://blog.jboost.cn/tags/arch/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot（十二）：LocalDateTime格式化处理</title>
    <link href="http://blog.jboost.cn/springboot-localdatetime.html"/>
    <id>http://blog.jboost.cn/springboot-localdatetime.html</id>
    <published>2019-11-01T09:37:24.000Z</published>
    <updated>2019-11-01T10:08:21.753Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8之后，日期类的处理建议使用java.time包中对应的LocalDateTime, LocalDate, LocalTime类。（参考<a href="/jdk8.html">Java8新特性</a>）</p><a id="more"></a><p>在Spring Boot中（验证版本：2.1.5.RELEASE），日期类的序列化格式可能不是自己所希望的，需要定义为自己的格式。有两种方式实现。</p><h2 id="1-注解方式"><a href="#1-注解方式" class="headerlink" title="1. 注解方式"></a>1. 注解方式</h2><p>分别使用 @JsonFormat， @DateTimeFormat 来定义序列化（bean转json）与反序列（json转bean）时的格式，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="keyword">private</span> LocalDateTime dateTime;</span><br></pre></td></tr></table></figure><h2 id="2-统一配置方式"><a href="#2-统一配置方式" class="headerlink" title="2. 统一配置方式"></a>2. 统一配置方式</h2><p>定义一个配置类，对ObjectMapper对象进行定制，指定日期类对应的序列化与反序列化处理对象，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateTimeFormatConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DATE_TIME_PATTERN = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DATE_PATTERN = <span class="string">"yyyy-MM-dd"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_TIME_PATTERN = <span class="string">"HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">objectMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        JavaTimeModule javaTimeModule = <span class="keyword">new</span> JavaTimeModule();</span><br><span class="line">        javaTimeModule.addSerializer(LocalDateTime.class, <span class="keyword">new</span> LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_PATTERN)));</span><br><span class="line">        javaTimeModule.addSerializer(LocalDate.class, <span class="keyword">new</span> LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_PATTERN)));</span><br><span class="line">        javaTimeModule.addSerializer(LocalTime.class, <span class="keyword">new</span> LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_PATTERN)));</span><br><span class="line">        javaTimeModule.addDeserializer(LocalDateTime.class, <span class="keyword">new</span> LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_PATTERN)));</span><br><span class="line">        javaTimeModule.addDeserializer(LocalDate.class, <span class="keyword">new</span> LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_PATTERN)));</span><br><span class="line">        javaTimeModule.addDeserializer(LocalTime.class, <span class="keyword">new</span> LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_PATTERN)));</span><br><span class="line">        objectMapper.registerModule(javaTimeModule);</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>注解的方式需要在每个属性上进行标注，如果日期类属性较多则较为繁琐，自定义配置类方式可以对日期进行统一的格式化处理。两者都存在的情况下，以注解为准，即注解方式会覆盖统一配置方式。</p><p>———————————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8之后，日期类的处理建议使用java.time包中对应的LocalDateTime, LocalDate, LocalTime类。（参考&lt;a href=&quot;/jdk8.html&quot;&gt;Java8新特性&lt;/a&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>nginx（一）：基本用途与用法</title>
    <link href="http://blog.jboost.cn/nginx-1.html"/>
    <id>http://blog.jboost.cn/nginx-1.html</id>
    <published>2019-10-07T05:34:02.000Z</published>
    <updated>2019-11-01T07:45:53.758Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于事情较多，加上个人的懈怠，有一段时间没更新了。习惯的养成很难，但一旦养成，从中的受益也常会超乎意料，还是得坚持。接下来准备对一些开发维护过程中常用的工具软件与服务进行整理，如本系列的nginx，后续的redis，消息队列，jenkins等，欢迎关注。</p><p>nginx是一个轻量级的高性能的HTTP服务器，在Web应用部署中很常见。也正因为很常见，所以掌握其基本原理与用法显得很有必要，本系列文章对nginx的相关内容进行梳理，以供初学者参考、熟悉者回顾。<br><a id="more"></a></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>在nginx以前，比较流行的HTTP服务器应属Apache（LAMP中A就是指Apache）。但根据netcraft的调查显示，近两年nginx已经超越Apache，成为市场占有率第一的HTTP服务器。如下图<br><img src="/assets/httpserver-trend.png" alt="httpserver-trend"></p><p>nginx能战胜Apache有几个主要原因，一是其足够轻量，不管是安装与维护，还是资源的占用都非常简单与轻量；二是其高性能，nginx基于事件驱动机制，具备非常好的性能，据称能支持高达50000个并发连接数；三是其具有很高的稳定性，相对其它HTTP服务器在访问负载很高时会导致内存耗尽进而可能失去响应，nginx采用分阶段资源分配技术，CPU与内存占有率都很低，在高并发场景下，稳定性更高。</p><p>在日常使用中，nginx主要在三个方面为我们提供服务：</p><ol><li>作为静态服务器提供静态资源的访问，如html网站，文件等</li><li>为后端服务提供反向代理</li><li>为反向代理的后端服务集群提供负载均衡</li></ol><h2 id="2-静态服务器"><a href="#2-静态服务器" class="headerlink" title="2. 静态服务器"></a>2. 静态服务器</h2><p>静态服务器一般就是提供Web前端的一些静态资源，如html页面，js、css文件的访问，用法配置示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location /static/ &#123;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        alias /usr/local/nginx/html/garten-web/dist/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li>index指定网站的初始页，可以跟多个文件，空格隔开，nginx根据顺序检查文件是否存在，如上例如果用户直接输入/static则会访问/usr/local/nginx/html/garten-web/dist/index.html（如果不存在则再看index.htm是否存在）</li><li>alias是与root对应的用法，都用于访问本地文件系统的资源，在匹配到location配置的url路径后，在alias或root配置的目录寻找对应的资源，区别在于：alias就在配置的目录下寻找对应的资源，而root则会将location配置路径附加到root路径后，在拼接后的目录下寻找对应的资源。如上例中访问 /static/hello.html，使用alias则会访问到/usr/local/nginx/html/garten-web/dist/hello.html，使用root则会访问到/usr/local/nginx/html/garten-web/dist/static/hello.html</li></ul><blockquote><p>alias配置的目录后有没有“/”要与location后面的路径是否有“/”保持一致，否则找不到资源</p></blockquote><h2 id="3-反向代理"><a href="#3-反向代理" class="headerlink" title="3. 反向代理"></a>3. 反向代理</h2><p>了解反向代理之前先看看什么是正向代理。</p><p>举个不那么和谐的例子，当你需要访问某些国外网站的时候，直接输入域名是打不开的，这时可以找一台能访问这些网站的服务器来做代理（这台服务器能访问你访问不了的网站，你能访问这台服务器），你访问网站时，实际是通过代理来中转访问。这种情况，你是知道目标网站的地址的，但是服务器只知道请求来自于代理服务器，而不知道是你（真正的客户端）在访问，所以正向代理代理的是客户端，是对服务端隐藏了真实的客户端信息。</p><p>而对于反向代理，客户端是明确的，但具体在后端请求了哪个服务却不明确了，比如你请求的是 <a href="http://www.abc.com，" target="_blank" rel="noopener">www.abc.com，</a> 在反向代理端，它可能是 <a href="http://www.cba.com" target="_blank" rel="noopener">www.cba.com</a> 的代理，也可能是 <a href="http://www.ccc.com" target="_blank" rel="noopener">www.ccc.com</a> 的代理， 不看配置你是不知道它到底代理的谁。因此，反向代理代理的是服务器端，隐藏了服务端的信息。</p><p>nginx中配置反向代理很简单，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.0.120:8080/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用nginx的反向代理，可以解决两个问题：</p><ol><li>跨域问题：前后端分离情况下，前端网页访问后端接口存在跨域问题，对后端接口的访问统一通过前端网站域名访问，在nginx中通过对接口的路径进行匹配后反向代理到后端接口服务。如上例中访问接口login可通过 <a href="http://localhost/api/login" target="_blank" rel="noopener">http://localhost/api/login</a> 访问，nginx将会反向代理到 <a href="http://192.168.0.120:8080/login" target="_blank" rel="noopener">http://192.168.0.120:8080/login</a> 后端接口地址</li><li>负载均衡：如果后端服务部署的是服务器集群，则对服务的访问需要做负载均衡，nginx通过反向代理结合upstream来实现负载均衡</li></ol><p>反向代理的路径路由规则：如果proxy_pass配置的路径最后带“/”，则类似于alias，不会在proxy_pass的uri后面拼接location的路径，如果没带“/”，则会进行拼接，类似于root。<br>比如我们按上例配置访问 <a href="http://localhost/api/login" target="_blank" rel="noopener">http://localhost/api/login</a> 则代理到 <a href="http://192.168.0.120:8080/login" target="_blank" rel="noopener">http://192.168.0.120:8080/login</a></p><p>但如果是按以下配置（proxy_pass配置路径不带子路径，且后面没带“/”），<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /api/ &#123;</span><br><span class="line">    proxy_pass  http://192.168.0.120:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则会被代理到 <a href="http://192.168.0.120:8080/api/login，" target="_blank" rel="noopener">http://192.168.0.120:8080/api/login，</a> 将location的路径拼接了。</p><p>如果proxy_pass配置的路径带子路径，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /api/ &#123;</span><br><span class="line">    proxy_pass  http://192.168.0.120:8080/api/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则不管后面带不带“/”，都不会拼接location的路径，只是与/api/后面的部分进行拼接。</p><blockquote><p>注意：如果是不带“/”   proxy_pass  <a href="http://192.168.0.120:8080/api/login" target="_blank" rel="noopener">http://192.168.0.120:8080/api/login</a> 则会被代理到 proxy_pass  <a href="http://192.168.0.120:8080/apilogin" target="_blank" rel="noopener">http://192.168.0.120:8080/apilogin</a> 了， 这时，可通过将location与proxy_pass配置路径保持一致即可——要么都带“/”，要么都不带。</p></blockquote><h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h2><p>nginx通过反向代理proxy_pass结合upstream来对后端服务器集群实现负载均衡，在nginx配置的http节点下定义upstream，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 192.168.0.120:8080;</span><br><span class="line">    server 192.168.0.121:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在server节点下的location里配置反向代理，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /api/ &#123;</span><br><span class="line">    proxy_pass  http://backend/api/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就会将接收到的请求顺序循环分配到后端的服务器上，如果某个服务器宕机，也能自动将其剔除，不再分配请求，直到其恢复。这是默认的负载均衡策略，即轮询策略。</p><p>nginx负载均衡的策略包括:</p><ol><li>权重轮询，权重轮询在上述轮询策略的基础上加了服务器的请求分配权重，以根据服务器配置的不同，将更多的请求分配到配置更高的服务器上。如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 192.168.0.120:8080 weight=10;</span><br><span class="line">    server 192.168.0.121:8080 weight=20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>分配给121的请求将比分配给120的请求多一倍。</p><ol start="2"><li><p>ip_hash，通过对请求来源ip求hash值，将相同ip的请求分配到相同的服务器上，此种策略可以解决分布式session的问题。配置如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.0.120:8080;</span><br><span class="line">    server 192.168.0.121:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>url_hash，对访问url求hash值，将同一个url的请求分配到相同的服务器上，对有本地缓存的场景比较适用。配置如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 192.168.0.120:8080;</span><br><span class="line">    server 192.168.0.121:8080;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>hash_method指定hash算法</p><ol start="4"><li>fair，根据后端服务器的响应时间来合理分配请求，响应时间短的优先分配。配置如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 192.168.0.120:8080;</span><br><span class="line">    server 192.168.0.121:8080;</span><br><span class="line">    fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>nginx以其轻量级、高性能、高稳定性的特性成为HTTP服务器的主流，是不论开发者还是运维人员都必须了解掌握的服务软件。本文从静态服务器，反向代理，负载均衡三个日常使用场景的角度对nginx进行了简单介绍。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近由于事情较多，加上个人的懈怠，有一段时间没更新了。习惯的养成很难，但一旦养成，从中的受益也常会超乎意料，还是得坚持。接下来准备对一些开发维护过程中常用的工具软件与服务进行整理，如本系列的nginx，后续的redis，消息队列，jenkins等，欢迎关注。&lt;/p&gt;
&lt;p&gt;nginx是一个轻量级的高性能的HTTP服务器，在Web应用部署中很常见。也正因为很常见，所以掌握其基本原理与用法显得很有必要，本系列文章对nginx的相关内容进行梳理，以供初学者参考、熟悉者回顾。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="nginx" scheme="http://blog.jboost.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（十一）：Dockerfile详解与最佳实践</title>
    <link href="http://blog.jboost.cn/docker-11.html"/>
    <id>http://blog.jboost.cn/docker-11.html</id>
    <published>2019-09-21T10:55:26.000Z</published>
    <updated>2019-09-23T07:54:04.498Z</updated>
    
    <content type="html"><![CDATA[<p>Dockerfile是一个文本文件，包含了一条条指令，每条指令对应构建一层镜像，Docker基于它来构建一个完整镜像。本文介绍Dockerfile的常用指令及相应的最佳实践建议。<br><a id="more"></a></p><h2 id="1-理解构建上下文（build-context）"><a href="#1-理解构建上下文（build-context）" class="headerlink" title="1. 理解构建上下文（build context）"></a>1. 理解构建上下文（build context）</h2><p>Docker镜像通过<code>docker build</code>指令构建，该指令执行时当前的工作目录就是docker构建的上下文，即build context，上下文中的文件及目录都会作为构建上下文内容发送给Docker Daemon。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t helloapp:v2 -f dockerfiles/Dockerfile context</span><br></pre></td></tr></table></figure><p>如上 –no-cache 表示镜像构建时不使用缓存，-f 指定Dockerfile文件位置， context 指定build context目录。</p><p>将一些非必要的文件包含到build context中，会导致build context过大，从而导致镜像过大，会增加镜像构建、推送及拉取的时间，以及容器运行时的大小。</p><p>执行docker build时会显示build context的大小，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  187.8MB</span><br></pre></td></tr></table></figure></p><p><strong>最佳实践建议</strong></p><ol><li>使用.dockerignore来排除不需要加入到build context中的文件，类似于.gitignore</li><li>不要安装不必要的包，所有包含的东西都是镜像必须的，非必须的不要包含。</li><li>解耦应用，如果应用有分层，解耦应用到多个容器，便于横向扩展，如web应用程序栈包含web服务应用，数据库，缓存等。</li><li>最少化镜像层数：只有RUN、COPY、ADD指令会创建镜像层，其它指令创建临时的中间镜像，不会增大镜像构建的大小</li><li>如果可能，尽可能使用多阶段构建，只复制你需要的组件到最终镜像，这使得你可以在中间构建阶段包含工具与debug信息，同时又不会增大最终镜像的大小。</li><li>排序多行参数：将参数按字母排序，有利于避免包重复，及后续的维护与提高易读性</li></ol><h2 id="2-FROM"><a href="#2-FROM" class="headerlink" title="2. FROM"></a>2. FROM</h2><p><strong>作用</strong><br>FROM指定基础镜像，每一个定制镜像，必须以一个现有镜像为基础。因此一个Dockerfile中FROM是必须的指令，并且必须是第一条。使用格式，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释以<span class="comment">#开头。基础镜像的tag可不指定，默认使用latest</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例：FROM mysql:5.7</span></span><br></pre></td></tr></table></figure><p><strong>最佳实践建议</strong></p><ol><li>如果不想以任何镜像为基础，则可以使用<code>FROM scratch</code></li><li>尽量使用官方镜像作为基础镜像</li><li>推荐使用Alpine镜像，因为它足够轻量级（小于5MB），但麻雀虽小五脏俱全，基本具有Linux的基础功能</li></ol><h2 id="3-RUN"><a href="#3-RUN" class="headerlink" title="3. RUN"></a>3. RUN</h2><p><strong>作用</strong><br>用来执行命令行命令，是最常用的指令之一。使用格式，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shell格式，跟直接在命令行输入命令一行</span></span><br><span class="line">RUN &lt;命令&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例：RUN mkdir -p /usr/src/redis </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exec</span>格式，类似于函数调用</span></span><br><span class="line">RUN ["可执行文件", "参数1", "参数2"]</span><br></pre></td></tr></table></figure><p>RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建指令中指定–no-cache参数，如：<code>docker build --no-cache</code></p><p><strong>最佳实践建议</strong></p><ol><li>将比较长的复杂的指令通过 \ 分为多行，让Dockerfile文件可读性、可理解性、可维护性更高，将多个指令通过 &amp;&amp; 连接，减少镜像的层数</li><li>确保每一层只添加必需的东西，任何无关的东西都应该清理掉，如所有下载、展开的文件，apt 缓存文件等，以尽可能减少镜像各层的大小</li><li>将<code>RUN apt-get update</code> 与 <code>RUN apt-get install</code> 组合成一条RUN指令（将apt-get update单独作为一条指令会因为缓存问题导致后续的apt-get install 指令失败）</li></ol><p>比如先按如下Dockerfile创建了一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y curl</span><br></pre></td></tr></table></figure><p>一段时间后，再按以下Dockerfile创建另一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y curl nginx</span><br></pre></td></tr></table></figure><p>因为RUN指令创建的镜像层会被缓存，所以下面镜像的<code>RUN apt-get update</code>并不会执行，直接使用了前面构建的镜像层，这样，curl、nginx就可能安装已经过时的版本。</p><p>因此 在 <code>apt-get update</code> 之后立即接 <code>&amp;&amp; apt-get install -y</code> ，这叫做“ cache busting”（缓存破坏），也可以通过指定包的版本，来达到同样的目的，这叫“ version pinning” （版本指定）示例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    reprepro \</span><br><span class="line">    ruby1.9.1 \</span><br><span class="line">    ruby1.9.1-dev \</span><br><span class="line">    #删除apt 缓存减少镜像层的大小</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure></p><ol start="4"><li>使用管道（pipes）。一些RUN指令依赖于从一个指令管道输出到另一个，如<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN wget -O - https://some.site | wc -l &gt; /number</span><br></pre></td></tr></table></figure></li></ol><p>Docker使用/bin/sh -c 解释器来执行这些指令，只会评估管道最后一条命令的退出码来确定是否成功，如上例中只要wc -l成功了就算wget失败，也会认为是成功的。<br>如果要使管道命令的任何一步报错都导致指令失败，则可通过加 <code>set -o pipefile &amp;&amp;</code> 来实现，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number</span><br></pre></td></tr></table></figure></p><p>不是所有的shell都支持<code>-o pipefail</code>选项，如果不支持的话可以使用如下形式，显式地指定一个支持的shell<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN ["/bin/bash", "-c", "set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number"]</span><br></pre></td></tr></table></figure></p><h2 id="4-COPY-ADD"><a href="#4-COPY-ADD" class="headerlink" title="4. COPY | ADD"></a>4. COPY | ADD</h2><p><strong>作用</strong><br>COPY从构建上下文的目录中复制文件/目录到镜像层的目标路径。使用格式，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt; </span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</span><br></pre></td></tr></table></figure><p>同RUN一样，也有两种格式。源文件可以多个，甚至可以是通配符，目标路径是容器的绝对路径，可以是相对工作目录（WORKDIR指定）的相对路径，目标路径不存在时会自动创建。使用<code>--chown=&lt;user&gt;:&lt;group&gt;</code>来改变文件的所属用户与组。<br>ADD与COPY的使用格式与性质差不多，但功能更丰富，如源路径可以是URL（下载后放到目标路径下，文件权限为600），也可以为tar压缩包，压缩格式为gzip，bzip2及xz的情况下，ADD 指令将会自动解压缩这个压缩文件到目标路径去 </p><p><strong>最佳实践建议</strong></p><ol><li>如果在Dockerfile中有多处需要使用不同的文件，分别使用COPY，而不是一次性COPY所有的，这可以保证每一步的构建缓存只会在对应文件改变时，才会失效。比如<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY requirements.txt /tmp/</span><br><span class="line">RUN pip install --requirement /tmp/requirements.txt</span><br><span class="line">COPY . /tmp/</span><br></pre></td></tr></table></figure></li></ol><p>如果把<code>COPY . /tmp/</code> 放在RUN上面，将使RUN层镜像缓存失效的场景更多——因为 . 目录（当前目录）中任何一个文件的改变都会导致缓存失效。</p><ol start="2"><li>因为镜像大小的原因， 使用ADD来获取远程包是非常不推荐的，应该使用curl或wget，这种方式可以在不再需要使用时删除对应文件，而不需要增加额外的层，如，应避免如下用法<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD http://example.com/big.tar.xz /usr/src/things/</span><br><span class="line">RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span><br><span class="line">RUN make -C /usr/src/things all</span><br></pre></td></tr></table></figure></li></ol><p>而应使用<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /usr/src/things \</span><br><span class="line">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span><br><span class="line">    | tar -xJC /usr/src/things \</span><br><span class="line">    &amp;&amp; make -C /usr/src/things all</span><br></pre></td></tr></table></figure></p><ol start="3"><li>如果不需要使用ADD的自动解压特性，尽量使用COPY（语义更清晰）</li></ol><h2 id="5-CMD"><a href="#5-CMD" class="headerlink" title="5. CMD"></a>5. CMD</h2><p><strong>作用</strong><br>CMD指定容器的启动命令。容器实质就是进程，进程就需要启动命令及参数，CMD指令就是用于指定默认的容器主进程的启动命令的。使用格式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shell格式 </span></span><br><span class="line">CMD &lt;命令&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exec</span>格式</span></span><br><span class="line">CMD ["可执行文件", "参数1", "参数2"...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数列表格式，在指定了ENTRYPOINT指令后，用CMD来指定具体的参数</span></span><br><span class="line">CMD ["参数1", "参数2"...]</span><br></pre></td></tr></table></figure></p><p>在容器运行时可以指定新的命令来覆盖Dockerfile中设置的这个默认命令 </p><p><strong>最佳实践建议</strong></p><ol><li>服务类镜像建议：<code>CMD [&quot;apache2&quot;,&quot;-DFOREGROUND&quot;]</code>，<code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code> 容器进程都应以前台运行，不能以后台服务的形式运行，否则启动就退出了。</li><li>其它镜像，建议给一个交互式的shell，如bash，python，perl等：<code>CMD [&quot;python&quot;]</code>, <code>CMD [&quot;php&quot;, &quot;-a&quot;]</code></li></ol><h2 id="6-ENTRYPOINT"><a href="#6-ENTRYPOINT" class="headerlink" title="6. ENTRYPOINT"></a>6. ENTRYPOINT</h2><p><strong>作用</strong><br>ENTRYPOINT的目的和CMD一样，都是在指定容器启动是要运行的程序及参数。 ENTRYPOINT在运行时也可以替代，不过比CMD要略显繁琐，需要通过docker run的参数 –entrypoint 来指定。如果指定了ENTRYPOINT，则CMD将只是提供参数，传递给ENTRYPOINT。使用ENTRYPOINT可以在容器运行时直接为默认启动程序添加参数。 与RUN指令格式一样，ENTRYPOINT也分为exec格式和shell格式。</p><p><strong>最佳实践建议</strong></p><ol><li>ENTRYPOINT可用来指定镜像的主命令，允许镜像能像命令一样运行，可以使用CMD来作为默认的标志（参数），如<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT ["s3cmd"]</span><br><span class="line">CMD ["--help"]</span><br></pre></td></tr></table></figure></li></ol><p>直接run时，相当于执行了<code>s3cmd --help</code>。也可以使用shell脚本，在脚本中做一些预处理的工作，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY ./docker-entrypoint.sh /</span><br><span class="line">ENTRYPOINT ["/docker-entrypoint.sh"]</span><br><span class="line">CMD ["postgres"]</span><br></pre></td></tr></table></figure></p><h2 id="7-LABEL"><a href="#7-LABEL" class="headerlink" title="7. LABEL"></a>7. LABEL</h2><p><strong>作用</strong><br>为镜像添加label以方便组织镜像，记录licensce信息，帮助自动化实现等等。字符串中包含空格需要转义或包含在引号中， 如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Set one or more individual labels</span></span><br><span class="line">LABEL com.example.version="0.0.1-beta"</span><br><span class="line">LABEL vendor1="ACME Incorporated"</span><br><span class="line">LABEL com.example.release-date="2019-09-12"</span><br><span class="line">LABEL com.example.version.is-production=""</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set multiple labels on one line</span></span><br><span class="line">LABEL com.example.version="0.0.1-beta" com.example.release-date="2019-09-12"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set multiple labels at once, using line-continuation characters to <span class="built_in">break</span> long lines</span></span><br><span class="line">LABEL vendor=ACME\ Incorporated \</span><br><span class="line">      com.example.is-beta= \</span><br><span class="line">      com.example.is-production="" \</span><br><span class="line">      com.example.version="0.0.1-beta" \</span><br><span class="line">      com.example.release-date="2019-09-12"</span><br></pre></td></tr></table></figure><h2 id="8-ENV"><a href="#8-ENV" class="headerlink" title="8. ENV"></a>8. ENV</h2><p><strong>作用</strong><br>ENV设置环境变量，无论是后面的其它指令，如 RUN（使用 $环境变量key 的形式） ，还是运行时的应用，都可以直接使用这里定义的环境变量。 使用格式有两种，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">只能设置一个key value</span></span><br><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">可以设置多个，value中如果包含空格可以使用\来进行转义，也可以通过<span class="string">""</span>括起来；也可以用反斜线来续行</span></span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure></p><p>除了RUN，还有这些指令可以引用环境变量：ADD 、 COPY 、 ENV 、 EXPOSE 、 LABEL 、 USER 、 WORKDIR 、 VOLUME 、STOPSIGNAL 、 ONBUILD </p><p><strong>最佳实践建议</strong></p><ol><li>定义环境变量，更新PATH环境变量，如要使 CMD [“nginx”] 运行，可设置环境变量 <code>ENV PATH /usr/local/nginx/bin:$PATH</code></li><li>ENV也可以用于定义常量，便于维护</li></ol><h2 id="9-ARG"><a href="#9-ARG" class="headerlink" title="9. ARG"></a>9. ARG</h2><p><strong>作用</strong><br>ARG设置构建参数，即docker build命令时传入的参数。和ENV的效果差不多，都是设置环境变量，不同的是，ARG设置的是构建环境的环境变量，在容器运行时是不会存在这些环境变量的。<br>Dockerfile中的ARG指令是定义参数名称，以及默认值（可选）。该默认值可以在执行构建命令docker build时用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。使用格式，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure><p><strong>最佳实践建议</strong></p><ol><li>不要使用ARG来保存密码之类的信息，因为通过docker history还是可以看到docker build执行时的所有值</li><li>使用ARG，对于使用CI系统（持续集成），用同样的构建流程构建不同的 Dockerfile 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改 </li></ol><h2 id="10-WORKDIR"><a href="#10-WORKDIR" class="headerlink" title="10. WORKDIR"></a>10. WORKDIR</h2><p><strong>作用</strong><br>WORKDIR用于指定工作目录（或当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，会自动创建。使用格式，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &lt;工作目录路径&gt;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**最佳实践建议**</span><br><span class="line">1. WORKDIR应该使用绝对路径，显得更为清楚、可靠</span><br><span class="line">2. 使用WORKDIR，避免使用`RUN cd … &amp;&amp; do-something`，可读性差，难以维护</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 11. VOLUME</span></span></span><br><span class="line"></span><br><span class="line">**作用**</span><br><span class="line">VOLUME用于定义匿名卷。容器运行时应该尽量保持容器存储层不发生写操作，应该将数据写入存储卷。VOLUME就是为了防止运行时用户忘记将动态文件所保存的目录挂载为卷，我们事先在Dockerfile中指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。使用格式，</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure><p>如 <code>VOLUME /data</code>， 任何向/data目录写入的数据都会写入匿名卷。可以运行容器时覆盖这个挂载设置 <code>docker run -d -v host-path:/data xxxx</code></p><p><strong>最佳实践建议</strong></p><ol><li>VOLUME应该被用来暴露所有的数据存储，配置存储，或者被容器创建的文件、目录。</li><li>如果数据动态变化，强烈建议使用VOLUME。</li></ol><h2 id="12-EXPOSE"><a href="#12-EXPOSE" class="headerlink" title="12. EXPOSE"></a>12. EXPOSE</h2><p><strong>作用</strong><br>EXPOSE指令是声明运行时容器提供的服务端口，也只是一个声明，在容器运行时并不会因为这个声明应用就一定会开启这个端口的服务,容器启动时，还是需要通过 <code>-p host-port:container-port</code>来实现映射。EXPOSE主要是帮助镜像使用者了解这个镜像服务的监听端口，以方便进行映射配置，另一个用处是在运行时如果是使用随机端口映射，也就是通过 <code>docker run -P</code>的形式时，会自动随机映射EXPOSE声明的端口。使用格式，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**最佳实践建议**</span><br><span class="line">1. 应该使用常用的惯用的端口，如nginx 80，mongoDB 27017</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 13. USER</span></span></span><br><span class="line"></span><br><span class="line">**作用**</span><br><span class="line">USER指令和WORKDIR相似，都是改变环境状态并影响以后的层。 WORKDIR是改变工作目录， USER则是改变之后的层在执行RUN , CMD以及ENTRYPOINT这类命令时的身份。USER帮助你切换到指定的用户，这个用户必</span><br><span class="line">须是事先建立好的，否则无法切换。使用格式</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure><p><strong>最佳实践建议</strong></p><ol><li>如果一个服务不需要权限也能运行，则使用USER来切换到非root用户，如<code>RUN groupadd -r postgres &amp;&amp; useradd --no-log-init -r -g postgres postgres</code></li><li>避免使用sudo，因为可能存在一些不可预见的TTY与信号转发行为导致问题，如果实在需要，考虑使用“gosu”。为了减少镜像层数，应避免不断切换USER<br>使用gosu示例</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 gosu</span></span><br><span class="line">RUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/</span><br><span class="line">releases/download/1.7/gosu-amd64" \</span><br><span class="line">&amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">&amp;&amp; gosu nobody true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 CMD，并以另外的用户执行</span></span><br><span class="line">CMD [ "exec", "gosu", "redis", "redis-server" ]</span><br></pre></td></tr></table></figure><h2 id="14-HEALTHCHECK"><a href="#14-HEALTHCHECK" class="headerlink" title="14. HEALTHCHECK"></a>14. HEALTHCHECK</h2><p><strong>作用</strong><br>HEALTHCHECK用于检查容器的健康状态，Docker可通过健康状态来决定是否对容器进行重新调度。使用格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt;</span><br></pre></td></tr></table></figure><p>支持的选项为</p><ul><li>–interval=&lt;间隔&gt; ：两次健康检查的间隔，默认为30秒</li><li>–timeout=&lt;时长&gt; ：执行健康检查命令的超时时间，如果超时，则本次健康检查就被视为失败，默认30秒</li><li>–retries=&lt;次数&gt; ：当连续失败指定的次数后，将容器状态置为unhealthy ，默认3次</li></ul><p>命令的返回值决定了该次健康检查的成功与否—— 0 ：成功； 1 ：失败； 2 ：保留（不要使用这个值），如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib</span><br><span class="line">/apt/lists/*</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s \</span><br><span class="line">    CMD curl -fs http://localhost/ || exit 1</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">可以使用docker ps 或docker inspect来查看容器的健康状态。</span><br><span class="line"></span><br><span class="line">**最佳实践建议**</span><br><span class="line">1. 如果基础镜像有健康检查指令，想要屏蔽掉其健康检查，可以使用`HEALTHCHECK NONE`</span><br><span class="line">2. 对一些可能造成假死（进程还在， 但提供不了服务了）的服务建议提供健康检查，以便及时重新调度恢复服务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 15. ONBUILD</span></span></span><br><span class="line"></span><br><span class="line">**作用**</span><br><span class="line">ONBUILD后跟的指令，只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。使用格式</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">ONBUILD &lt;其它指令&gt;</span><br></pre></td></tr></table></figure><p>它后面跟的是其它指令，比如 RUN , COPY 等，这些指令在当前镜像构建时并不会被执行。<br>ONBUILD命令在本镜像的子镜像中执行，把ONBUILD想象为父镜像为子镜像声明的一条指令，Docker会在子镜像所有命令之前执行ONBUILD指令。</p><p><strong>最佳实践建议</strong></p><ol><li>当在ONBUILD指令中使用ADD或COPY时要注意，如果build context中没有指定的资源，可能导致灾难性的错误。</li></ol><h2 id="16-用缓存镜像提高效率"><a href="#16-用缓存镜像提高效率" class="headerlink" title="16. 用缓存镜像提高效率"></a>16. 用缓存镜像提高效率</h2><p>Docker在构建镜像时会复用缓存中已经存在的镜像，如果明确不使用缓存，则可加参数<code>docker build --no-cache=true</code><br>使用缓存镜像的规则</p><ol><li>从一个已存在于缓存的父镜像开始构建，则会将当前镜像的下一行指令与所有继承于那个父镜像的子镜像比较，如果其中没有一个是使用相同的指令构建的，则缓存失效</li><li>大部分情况下，将Dockerfile中的指令与其中一个子镜像简单比较就够了，但是某些指令需要更多的检查与说明：对于ADD，COPY指令，文件内容会被检查，会计算每一个文件的checksum，checksum中不会考虑最后修改及最后访问时间，在缓存中查找时，checksum会与已经存在的镜像进行比较，如果文件中有修改，则缓存失效。除了ADD，COPY命令，缓存检查不会查看容器中的文件来决定缓存匹配，如处理<code>RUN apt-get -y update</code>命令时，容器中文件的更新不会进行检查来确定缓存是否命中， 这种情况下， 只会检查指令字符串本身是否匹配。</li><li>一旦缓存失效，所有后续的指令都会产生新的镜像，不会再使用缓存。</li></ol><h2 id="17-其它镜像构建方式"><a href="#17-其它镜像构建方式" class="headerlink" title="17. 其它镜像构建方式"></a>17. 其它镜像构建方式</h2><ol><li>通过标准输入来生成Dockerfile构建，不会发送build context（从stdin读取build context，只包含Dockerfile），适用于一次性构建，不需要写Dockerfile<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将会构建一个名称与tag均为none的镜像</span></span><br><span class="line">echo -e 'FROM busybox\nRUN echo "hello world"' | docker build -</span><br><span class="line"><span class="meta">#</span><span class="bash">或 </span></span><br><span class="line">docker build - &lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">RUN echo "hello world"</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建一个命名的镜像</span></span><br><span class="line">docker build -t myimage:latest - &lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">RUN echo "hello world"</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ol><p>连字符 - 作为文件名告诉Docker从stdin读取Dockerfile</p><ol start="2"><li><p>使用stdin来生成Dockerfile， 但是使用当前目录作为build context</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> build an image using the current directory as context, and a Dockerfile passed through stdin</span></span><br><span class="line">docker build -t myimage:latest -f- . &lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">COPY somefile.txt .</span><br><span class="line">RUN cat /somefile.txt</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>使用远程git仓库构建镜像，从stdin生成Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myimage:latest -f - https://github.com/docker-library/hello-world.git &lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">COPY hello.c .</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ol><p><br><br>欢迎关注我的微信公众号：jboost-ksxy<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dockerfile是一个文本文件，包含了一条条指令，每条指令对应构建一层镜像，Docker基于它来构建一个完整镜像。本文介绍Dockerfile的常用指令及相应的最佳实践建议。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>JDK13，不如温习下Java8</title>
    <link href="http://blog.jboost.cn/jdk8.html"/>
    <id>http://blog.jboost.cn/jdk8.html</id>
    <published>2019-09-18T11:24:09.000Z</published>
    <updated>2019-09-18T11:36:40.834Z</updated>
    
    <content type="html"><![CDATA[<p>JDK13于昨天正式GA，版本新特性可参考： <a href="https://www.oschina.net/news/109934/jdk-13-released" target="_blank" rel="noopener">https://www.oschina.net/news/109934/jdk-13-released</a><br><a id="more"></a></p><p>虽然JDK更新迅速，但开发者貌似并不买账，据统计，目前仍以JDK8使用最多，预计可能还会延续好长一段时间。虽然JDK版本已至13，但对Java8的新特性，掌握程度如何呢？<br>本文对Java8的主要特性进行了梳理。供温习参考。</p><h2 id="1-接口默认方法"><a href="#1-接口默认方法" class="headerlink" title="1. 接口默认方法"></a>1. 接口默认方法</h2><p>以前的接口只允许有抽象方法（没有实现体），java8中提供了接口默认方法支持，即可以提供方法的默认实现，实现类可以直接继承，也可以覆盖。默认方法主要解决接口的修改导致现有实现类不兼容的问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceDefaultFunctionTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">func</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认方法</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//静态方法</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyFunction&lt;String&gt; myFunction = <span class="keyword">new</span> MyFunction&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">func</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(myFunction.func(<span class="string">"abc"</span>));</span><br><span class="line">        System.out.println(myFunction.func2(<span class="string">"abc"</span>));</span><br><span class="line">        LambdaTest.MyFunction.print(<span class="string">"efg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认方法通过关键字 default 声明。同时也可以在接口中定义静态方法。</p><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><p>函数式接口就是有且仅有一个抽象方法的接口（可以有其它非抽象方法），如1所示代码中 MyFunction 就是一个函数式接口，只有一个抽象方法 func， 其它非抽象方法如默认方法 func2， 静态方法 print 不影响其函数式接口的特性。</p><p>函数式接口可以使用注解 @FunctionalInterface 标注，该注解会去检查接口是否符合函数式接口的规范要求，不符合的话IDE会给出提示。</p><p>java中内置了一些函数式接口，</p><table><thead><tr><th style="text-align:center">函数式接口</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Consumer<t></t></td><td style="text-align:center">包含方法 void accept(T t)， 对类型为T的对象t进行操作</td></tr><tr><td style="text-align:center">Supplier<t></t></td><td style="text-align:center">包含方法 T get()，返回类型为T的对象</td></tr><tr><td style="text-align:center">Function&lt;T,R&gt;</td><td style="text-align:center">包含方法 R apply(T t)，对类型为T的对象进行操作，返回类型R的对象</td></tr><tr><td style="text-align:center">Predicat<t></t></td><td style="text-align:center">包含方法 boolean test(T t)， 判断类型为T的对象是否满足条件</td></tr></tbody></table><p>以及基于这些接口的其它变种或子接口，如BiConsumer&lt;T,U&gt;，BiFunction&lt;T,U,R&gt;等。还有如Runnable，Callable等接口，也属于函数式接口 —— 都只有一个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> BiConsumer&lt;T, U&gt; <span class="title">andThen</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (l, r) -&gt; &#123;</span><br><span class="line">            accept(l, r);</span><br><span class="line">            after.accept(l, r);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h2><p>lambda表达式实质就是一个匿名函数，在python中很常见，java到了jdk8提供了支持。<br>lambda表达式的格式形如： (参数) -&gt; {方法体语句}，当参数只有一个时，左边小括号可以省略，当方法体语句只有一条时，右边大括号可以省略。</p><p>Java的lambda表达式基本上是对函数式接口实现的一种简化 —— 用lambda表达式直接代替一个函数式接口的具体实现（抽象方法的实现）。当我们使用jdk8在IDE中编写1中代码时，IDE会给出提示，<br><img src="/assets/lambda-warn.png" alt="lambda-warn"></p><p>匿名实现类可以用lambda表达式替换。上述代码使用lambda表达式替换可调整为，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyFunction&lt;String&gt; myFunction = s -&gt; s.toUpperCase();</span><br><span class="line">    System.out.println(myFunction.func(<span class="string">"abc"</span>));</span><br><span class="line">    System.out.println(myFunction.func2(<span class="string">"abc"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda表达式甚至可作为方法参数传入（实质也是作为一个函数式接口的实现类实例）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">func</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(MyFunction&lt;String&gt; function, String s)</span></span>&#123;</span><br><span class="line">    System.out.println(function.func(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//将lambda表达式作为方法参数传入</span></span><br><span class="line">   print((String s) -&gt; s.toUpperCase(), <span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>局部变量在lambda表达式中是只读的，虽可不声明为final，但无法修改。如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//lambda表达式中无法修改局部变量i，将报编译错误</span></span><br><span class="line">    print((String s) -&gt; &#123;i = i+<span class="number">10</span>; <span class="keyword">return</span> s.toUpperCase();&#125;, <span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><p>当需要使用lambda表达式时，如果已经有了相同的实现方法，则可以使用方法引用来替代lambda表达式，几种场景示例如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例::实例方法</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s); <span class="comment">//lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; consumer2 = System.out::println; <span class="comment">//方法引用</span></span><br><span class="line">        consumer.accept(<span class="string">"abc"</span>);</span><br><span class="line">        consumer2.accept(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类::静态方法</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y); <span class="comment">//lambda表达式</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator2 = Integer::compare; <span class="comment">//方法引用</span></span><br><span class="line">        System.out.println(comparator.compare(<span class="number">10</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(comparator2.compare(<span class="number">10</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类::实例方法， 当引用方法是形如 a.func(b)时，用类::实例方法的形式</span></span><br><span class="line">        BiPredicate&lt;String, String&gt; biPredicate = (a, b) -&gt; a.equals(b); <span class="comment">//lambda表达式</span></span><br><span class="line">        BiPredicate&lt;String, String&gt; biPredicate2 = String::equals; <span class="comment">//方法引用</span></span><br><span class="line">        System.out.println(biPredicate.test(<span class="string">"abc"</span>, <span class="string">"abb"</span>));</span><br><span class="line">        System.out.println(biPredicate2.test(<span class="string">"abc"</span>,<span class="string">"abb"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//type[]::new 数组引用</span></span><br><span class="line">        Function&lt;Integer,Integer[]&gt; fun= n-&gt; <span class="keyword">new</span> Integer[n]; <span class="comment">//lambda表达式</span></span><br><span class="line">        Function&lt;Integer,Integer[]&gt; fun2=Integer[]::<span class="keyword">new</span>; <span class="comment">//方法引用</span></span><br><span class="line">        System.out.println(fun.apply(<span class="number">10</span>));</span><br><span class="line">        System.out.println(fun2.apply(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器引用</span></span><br><span class="line">        Function&lt;String,String&gt; func = n-&gt; <span class="keyword">new</span> String(n); <span class="comment">//lambda表达式</span></span><br><span class="line">        Function&lt;String,String&gt; func2 = String::<span class="keyword">new</span>; <span class="comment">//方法引用</span></span><br><span class="line">        System.out.println(func.apply(<span class="string">"aaa"</span>));</span><br><span class="line">        System.out.println(func2.apply(<span class="string">"aaa"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-Stream-API"><a href="#5-Stream-API" class="headerlink" title="5. Stream API"></a>5. Stream API</h2><p>Stream与lambda应该是java8最重要的两大特性。Stream 对集合的处理进行了抽象，可以对集合进行非常复杂的查找、过滤和映射等操作。提供了一种高效的且易于使用的处理数据的方式。<br>Stream的三个特性：</p><ul><li>Stream本身不会存储元素</li><li>Stream不会改变操作对象（即集合），会返回一个新的Stream</li><li>Stream的中间操作不会立刻执行，而是会等到需要结果的时候才执行</li></ul><p>Java8 的Collection接口包含了两个方法 stream(), parallelStream()， 分别返回一个顺序流与一个并行流，所有Collection类型（如List， ）的对象可以调用这两个方法生成流。<br>Java8 的Arrays类也提供了 stream(T[] array)等方法用以生成流。也可以使用静态方法 Stream.iterate() 和 Stream.generate() 来创建无限流。</p><p>Stream的中间操作包括</p><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">filter(Predicate p)</td><td style="text-align:center">接收 Lambda ， 从流中过滤出满足条件的元素</td></tr><tr><td style="text-align:center">distinct()</td><td style="text-align:center">通过hashCode() 和 equals() 去除重复元素</td></tr><tr><td style="text-align:center">limit(long maxSize)</td><td style="text-align:center">截断流，使元素的个数不超过给定数量</td></tr><tr><td style="text-align:center">skip(long n)</td><td style="text-align:center">跳过前面的n个元素，若流中元素不足n个，则返回一个空流</td></tr><tr><td style="text-align:center">map(Function f)</td><td style="text-align:center">将每个元素使用函数f执行，将其映射成一个新的元素</td></tr><tr><td style="text-align:center">mapToDouble(ToDoubleFunction f)</td><td style="text-align:center">将每个元素使用f执行，产生一个新的DoubleStream流</td></tr><tr><td style="text-align:center">mapToInt(ToIntFunction f)</td><td style="text-align:center">将每个元素使用f执行，产生一个新的IntStream流</td></tr><tr><td style="text-align:center">mapToLong(ToLongFunction f)</td><td style="text-align:center">将每个元素使用f执行，产生一个新的LongStream流</td></tr><tr><td style="text-align:center">flatMap(Function f)</td><td style="text-align:center">将流中的每个值都通过f转换成另一个流，然后把所有流连接成一个流</td></tr><tr><td style="text-align:center">sorted()</td><td style="text-align:center">按自然顺序排序，产生一个新流</td></tr><tr><td style="text-align:center">sorted(Comparator comp)</td><td style="text-align:center">根据比较器排序，产生一个新流</td></tr><tr><td style="text-align:center">allMatch(Predicate p)</td><td style="text-align:center">判断是否匹配所有元素</td></tr><tr><td style="text-align:center">anyMatch(Predicate p)</td><td style="text-align:center">判断是否匹配至少一个元素</td></tr><tr><td style="text-align:center">noneMatch(Predicate p)</td><td style="text-align:center">判断是否没有匹配任意元素</td></tr><tr><td style="text-align:center">findFirst()</td><td style="text-align:center">返回第一个元素</td></tr><tr><td style="text-align:center">findAny()</td><td style="text-align:center">返回任意一个元素</td></tr><tr><td style="text-align:center">reduce(T iden, BinaryOperator b)</td><td style="text-align:center">对流中的元素进行reduce操作，返回T类型对象</td></tr><tr><td style="text-align:center">reduce(BinaryOperator b)</td><td style="text-align:center">对流中的元素进行reduce操作，返回Optional<t>对象</t></td></tr></tbody></table><p>Stream的终止操作包括</p><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">count()</td><td style="text-align:center">返回元素总数</td></tr><tr><td style="text-align:center">max(Comparator c)</td><td style="text-align:center">返回最大值</td></tr><tr><td style="text-align:center">min(Comparator c)</td><td style="text-align:center">返回最小值</td></tr><tr><td style="text-align:center">forEach(Consumer c)</td><td style="text-align:center">内部迭代调用Consumer操作</td></tr><tr><td style="text-align:center">collect(Collector c)</td><td style="text-align:center">将流转换为其他形式，一般通过Collectors来实现</td></tr></tbody></table><p>Stream使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//转换为List，这里没啥意义，仅做示范</span></span><br><span class="line">    List&lt;User&gt; users = list.stream().collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//转换为Set</span></span><br><span class="line">    Set&lt;User&gt; users1 = list.stream().collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">//转换为Collection</span></span><br><span class="line">    Collection&lt;User&gt; users2 = list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">    <span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">long</span> count = list.stream().collect(Collectors.counting());</span><br><span class="line">    <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">int</span> total = list.stream().collect(Collectors.summingInt(User::getAge));</span><br><span class="line">    <span class="comment">//求平均值</span></span><br><span class="line">    <span class="keyword">double</span> avg= list.stream().collect(Collectors.averagingInt(User::getAge));</span><br><span class="line">    <span class="comment">//获取统计对象，通过该统计对象可获取最大值，最小值之类的数据</span></span><br><span class="line">    IntSummaryStatistics iss= list.stream().collect(Collectors.summarizingInt(User::getAge));</span><br><span class="line">    <span class="comment">//将值通过","拼接</span></span><br><span class="line">    String str= list.stream().map(User::getName).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    Optional&lt;User&gt; max= list.stream().collect(Collectors.maxBy(Comparator.comparingInt(User::getAge)));</span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    Optional&lt;User&gt; min = list.stream().collect(Collectors.minBy(Comparator.comparingInt(User::getAge)));</span><br><span class="line">    <span class="comment">//从累加器开始，对指定的值，这里是年龄，进行sum的reduce操作</span></span><br><span class="line">    <span class="keyword">int</span> t =list.stream().collect(Collectors.reducing(<span class="number">0</span>, User::getAge, Integer::sum));</span><br><span class="line">    <span class="comment">//对转换的结果再进行处理</span></span><br><span class="line">    <span class="keyword">int</span> how = list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br><span class="line">    <span class="comment">//分组</span></span><br><span class="line">    Map&lt;String, List&lt;User&gt;&gt; map= list.stream().collect(Collectors.groupingBy(User::getName));</span><br><span class="line">    <span class="comment">//根据条件进行分区</span></span><br><span class="line">    Map&lt;Boolean,List&lt;User&gt;&gt; vd= list.stream().collect(Collectors.partitioningBy(u -&gt; u.getName().startsWith(<span class="string">"W"</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-Optional类"><a href="#6-Optional类" class="headerlink" title="6. Optional类"></a>6. Optional类</h2><p>Optional是一个容器类，可以避免显式的null判断，基本使用示例如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOptional</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// of 不允许传入null值，否则抛出NPE</span></span><br><span class="line">        Optional&lt;Integer&gt; optional = Optional.of(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">        System.out.println(optional.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ofNullable 允许传入null，但是直接调用get会抛出NoSuchElementException异常，</span></span><br><span class="line">        <span class="comment">// 可通过isPresent判断是否存在值</span></span><br><span class="line">        Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(optional1.isPresent()) &#123;</span><br><span class="line">            System.out.println(optional1.get());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"optional1 is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// orElse 判断是否存在值，存在则返回，不存在则返回参数里的值</span></span><br><span class="line">        Integer value = optional1.orElse(<span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// map方法，如果optional有值，则对值进行处理返回新的Optional，</span></span><br><span class="line">        <span class="comment">// 如果没有值则返回Optional.empty()</span></span><br><span class="line">        optional = optional.map(x -&gt; x*x);</span><br><span class="line">        System.out.println(optional.get());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 与map类似，只是要求返回值必须是Optional，进一步避免空指针</span></span><br><span class="line">        optional = optional.flatMap(x -&gt;Optional.of(x*x));</span><br><span class="line">        System.out.println(optional.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7-Base64"><a href="#7-Base64" class="headerlink" title="7. Base64"></a>7. Base64</h2><p>在java8中，Base64成为了java类库的标准，可直接使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBase64</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//base64编码</span></span><br><span class="line">        String encode = Base64.getEncoder().encodeToString(<span class="string">"abc"</span>.getBytes());</span><br><span class="line">        System.out.println(encode);</span><br><span class="line">        <span class="comment">//base64解码</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(Base64.getDecoder().decode(encode)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="8-日期时间类"><a href="#8-日期时间类" class="headerlink" title="8. 日期时间类"></a>8. 日期时间类</h2><p>以前的Date类是非线程安全的，并且一些常用的日期时间运算需要自己编写util工具类。java8推出了java.time包，里面包含了如 LocalDate, LocalTime, LocalDateTime等类，可方便地进行日期时间的运算，如日期间隔、时间间隔，日期时间的加减，格式化等等。</p><p>—————————————————————————————<br>作者：空山新雨<br>欢迎关注我的微信公众号：jboost-ksxy<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK13于昨天正式GA，版本新特性可参考： &lt;a href=&quot;https://www.oschina.net/news/109934/jdk-13-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/109934/jdk-13-released&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（十）：使用Docker来搭建一套ELK日志分析系统</title>
    <link href="http://blog.jboost.cn/docker-elk.html"/>
    <id>http://blog.jboost.cn/docker-elk.html</id>
    <published>2019-09-07T05:43:37.000Z</published>
    <updated>2019-09-07T03:59:50.839Z</updated>
    
    <content type="html"><![CDATA[<p>一段时间没关注ELK（elasticsearch —— 搜索引擎，可用于存储、索引日志, logstash —— 可用于日志传输、转换，Kibana —— WebUI，将日志可视化），发现最新版已到7.4了。所以别问程序员为什么这么忙？因为不是在加班就是在学习新框架中。本文整理了使用Docker来快速搭建一套ELK日志分析系统的方法。<br><a id="more"></a></p><h2 id="1-部署elk"><a href="#1-部署elk" class="headerlink" title="1. 部署elk"></a>1. 部署elk</h2><p>github上有人整理了一套使用docker compose来部署elk的配置，可直接下载使用。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/deviantony/docker-elk.git</span><br></pre></td></tr></table></figure></p><p>如果没有git，那就安装一下（<code>yum install git</code>），或者直接下载github仓库的源码包。</p><p>当前是基于7.2.1版（docker-elk目录下.env文件中定义，可修改）。</p><p>调整一下相应的配置。</p><p>修改docker-compose，设置es密码等，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 在elasticsearch部分设置环境变量，将jvm堆内存增大到了1g，设置es elastic用户的密码</span></span><br><span class="line">  environment:</span><br><span class="line">        ES_JAVA_OPTS: "-Xmx1g -Xms1g"</span><br><span class="line">        ELASTIC_PASSWORD: Passw0rd</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 将logstash的端口映射从默认的5000改为5044，因为后面会用filebeat，不改也可以，对应就行</span></span><br><span class="line">  ports:</span><br><span class="line">        - "5044:5044"</span><br><span class="line">        - "9600:9600"</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 将jvm内存也增大一点</span></span><br><span class="line">  environment:</span><br><span class="line">        LS_JAVA_OPTS: "-Xmx512m -Xms512m"</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 在volumes部分增加es数据目录的挂载，对es数据持久化，避免容器销毁数据丢失</span></span><br><span class="line">  volumes:</span><br><span class="line">      - /mnt/elk/esdata:/usr/share/elasticsearch/data</span><br></pre></td></tr></table></figure></p><blockquote><p>注意： 因为es容器内部是以elasticsearch用户启动进程的，所以在做持久化数据目录挂载的时候，需要将目录权限进行设置，否则会因为没有访问权限而启动失败。elasticsearch的uid是1000，可以建一个uid为1000的用户，然后将目录所有者赋予该用户。</p></blockquote><p>修改es配置文件，将xpack从trial改为basic，禁用付费功能<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch/config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash">xpack.license.self_generated.type: trial</span></span><br><span class="line">  xpack.license.self_generated.type: basic</span><br></pre></td></tr></table></figure></p><p>修改logstash配置文件，设置es的用户名密码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim logstash/config/logstash.yml</span><br><span class="line"></span><br><span class="line">  xpack.monitoring.elasticsearch.username: elastic</span><br><span class="line">  xpack.monitoring.elasticsearch.password: Passw0rd</span><br></pre></td></tr></table></figure></p><p>修改logstash的pipeline配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim logstash/pipeline/logstash.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 这里codec根据具体情况配置 </span></span><br><span class="line">  input &#123;</span><br><span class="line">          beats &#123;</span><br><span class="line">                  port =&gt; 5044</span><br><span class="line">                  codec =&gt; "json" </span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment"># Add your filters / logstash plugins configuration here</span></span></span><br><span class="line">  output &#123;</span><br><span class="line">          elasticsearch &#123;</span><br><span class="line">                  hosts =&gt; "elasticsearch:9200"</span><br><span class="line">                  index =&gt; "%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;"</span><br><span class="line">                  user =&gt; "elastic"</span><br><span class="line">                  password =&gt; "Passw0rd"</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>修改kibana配置，设置es密码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim kibana/config/kibana.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment"># X-Pack security credentials</span></span></span><br><span class="line">  elasticsearch.username: elastic</span><br><span class="line">  elasticsearch.password: Passw0rd</span><br></pre></td></tr></table></figure></p><p>配置调整后，使用 <code>docker-compose up -d</code> 即可启动es，logstash，kibana三个容器。第一次启动需要下载所有镜像，会比较慢，启动完后，访问 elk所在服务器IP:5601即可进入kibana页面。</p><p>这里默认是起一个es容器，如果想起多个，参考： <a href="https://github.com/deviantony/docker-elk/wiki/Elasticsearch-cluster" target="_blank" rel="noopener">https://github.com/deviantony/docker-elk/wiki/Elasticsearch-cluster</a></p><h2 id="2-部署filebeat"><a href="#2-部署filebeat" class="headerlink" title="2. 部署filebeat"></a>2. 部署filebeat</h2><p>filebeat部署在产生日志的服务器上。先下载镜像，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.elastic.co/kibana/kibana:7.3.1</span><br></pre></td></tr></table></figure></p><p>下载一个示例配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://raw.githubusercontent.com/elastic/beats/7.3/deploy/docker/filebeat.docker.yml</span><br></pre></td></tr></table></figure></p><p>修改配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vim filebeat.docker.yml</span><br><span class="line"></span><br><span class="line">filebeat.config:</span><br><span class="line">  modules:</span><br><span class="line">    path: $&#123;path.config&#125;/modules.d/*.yml</span><br><span class="line">    reload.enabled: false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">filebeat.autodiscover:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  providers:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    - <span class="built_in">type</span>: docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      hints.enabled: <span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">processors:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">- add_cloud_metadata: ~</span></span><br><span class="line"><span class="meta">#</span><span class="bash">- add_host_metadata: ~</span></span><br><span class="line"></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">  - /var/log/elk/*.log</span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: ["你的elk服务器IP:5044"]</span><br></pre></td></tr></table></figure></p><p>去掉了一些不必要的配置，基本就是一个input, 一个output。input paths部分配置你日志所在目录，注意这里是容器内的目录，真正服务器的日志目录需要在启动容器时挂载到这里配置的目录。</p><p>启动容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name filebeat --user=root -v $(pwd)/filebeat.docker.yml:/usr/share/filebeat/filebeat.yml:ro \</span><br><span class="line">  -v /mnt/logs/elk/:/var/log/elk/ docker.elastic.co/beats/filebeat:7.3.1 filebeat -e -strict.perms=false</span><br></pre></td></tr></table></figure></p><p>对配置文件及实际日志目录与容器日志目录进行了挂载。</p><p>启动成功后，对应目录下的日志就会通过filebeat，logstash传输到es，进入kibana对日志数据建立索引进行查询了。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>前面用elk来搭建日志分析系统还是5.1版，两年时间已到7.4，配置方式，包括UI风格都做了很大的调整，很有一种人间一年，技术圈十载的感觉。<br>本文整理了基于Docker来搭建ELK框架的整个过程，供参考。<br><br><br>—————————————————————————————<br>作者：空山新雨<br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号）<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一段时间没关注ELK（elasticsearch —— 搜索引擎，可用于存储、索引日志, logstash —— 可用于日志传输、转换，Kibana —— WebUI，将日志可视化），发现最新版已到7.4了。所以别问程序员为什么这么忙？因为不是在加班就是在学习新框架中。本文整理了使用Docker来快速搭建一套ELK日志分析系统的方法。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
      <category term="elk" scheme="http://blog.jboost.cn/tags/elk/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（九）：网络管理</title>
    <link href="http://blog.jboost.cn/docker-9.html"/>
    <id>http://blog.jboost.cn/docker-9.html</id>
    <published>2019-08-30T05:14:57.000Z</published>
    <updated>2019-08-30T05:35:24.478Z</updated>
    
    <content type="html"><![CDATA[<p>Docker的应用运行在容器中，其相互之间或与外部之间是如何通信的，涉及到哪些知识点，本文对相关内容进行整理。因网络这块牵涉的面较多，因此只从日常使用或理解的角度出发，过于专业的就不深入探讨了。<br><a id="more"></a></p><h2 id="1-Docker默认的网络拓扑"><a href="#1-Docker默认的网络拓扑" class="headerlink" title="1. Docker默认的网络拓扑"></a>1. Docker默认的网络拓扑</h2><p>在<a href="/docker-2.html">Docker笔记（二）：Docker管理的对象</a>中，介绍了Docker通过一些驱动程序来实现容器之间或容器与外部的互联，包括bridge（默认的虚拟网桥形式），host（与主机共享网络栈），overlay（跨Docker Daemon容器间的互联），macvlan（为容器分配mac地址），none（禁用所有网络）等。</p><p>默认情况下，Docker启动时会创建一个虚拟网桥 docker0，可以理解为一个软件交换机。当创建一个 Docker 容器的时候，会创建一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0 ；另一端在宿主机本地并被挂载到 docker0 网桥，名称以veth 开头，如 veth340c305，docker0会在挂载到它上面的网口之间进行转发，从而实现主机与容器之间及容器与容器之间的相互通信。Docker默认的网络拓扑图如下：<br><img src="/assets/docker0.png" alt="docker0"></p><p>我们可以在宿主机上通过<code>ifconfig</code>查看相关的网络接口，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">~$ ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:46ff:fe26:ce0b  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:46:26:ce:0b  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 16868344  bytes 127838098551 (127.8 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 17929275  bytes 137867853738 (137.8 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">veth340c305: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::50f7:7ff:fe8f:6e72  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 52:f7:07:8f:6e:72  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 8093606  bytes 126893792744 (126.8 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8795102  bytes 10834735399 (10.8 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">veth6c803b7: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::1045:4cff:fe66:7f5a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 12:45:4c:66:7f:5a  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 140  bytes 9832 (9.8 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></p><p>通过<code>brctl show</code>可查看网络接口的挂载情况，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">docker08000.02424626ce0bnoveth340c305</span><br><span class="line">veth6c803b7</span><br></pre></td></tr></table></figure></p><p>由上可看出网络接口veth340c305，veth6c803b7都挂在虚拟网桥docker0上。</p><h2 id="2-容器与外部的互联"><a href="#2-容器与外部的互联" class="headerlink" title="2. 容器与外部的互联"></a>2. 容器与外部的互联</h2><p>我们前面的许多容器启动命令都有添加类似 -p 8080:8080 的参数，以指定将宿主机端口映射到容器端口，从而通过访问 <code>宿主机IP：宿主机端口</code> 的地址来访问对应端口的容器服务。<br>端口映射的完整格式为 <code>宿主机IP：宿主机端口：容器端口</code>，其中前两个是可以两者都取，或只取其一</p><ul><li><code>宿主机IP：宿主机端口：容器端口</code>：将指定宿主机IP的一个指定端口映射到容器端口，如<code>192.168.40.205:8090:8080</code></li><li><code>宿主机IP::容器端口</code>：将指定宿主机IP的一个随机端口映射到容器端口上，如果宿主机有多个IP，则可以通过这种格式指定绑定其中一个宿主机IP，随机端口范围为49000~49900</li><li><code>宿主机端口：容器端口</code>：将宿主机所有网络接口IP的指定端口映射到容器端口上，<code>8090:8080</code>等效于<code>0.0.0.0:8090:8080</code>（<code>0.0.0.0</code>即表示所有网络接口地址）</li></ul><p>可以使用 <code>docker port 容器ID或名称 容器端口</code>或<code>docker ps</code>命令来查看端口映射情况，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ docker port test-dev 8080</span><br><span class="line">0.0.0.0:32768</span><br><span class="line"></span><br><span class="line">~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">696a76944e72        cnbots:dev                                      "/bin/sh -c '/usr/lo…"   23 minutes ago      Up 23 minutes       0.0.0.0:32768-&gt;8080/tcp             test-dev</span><br></pre></td></tr></table></figure></p><p>在容器启动时，可以多次使用 -p 来指定映射多个端口。</p><p>如果不指定具体的宿主机端口，则可以使用 -P（大写）来分配一个宿主机的随机端口（范围为49000~49900）， 如<code>docker run -d -P --name test-dev test:dev</code>，然后通过<code>docker port 容器ID或名称 容器端口</code>或<code>docker ps</code>命令来查看具体映射到了哪个端口。</p><h2 id="3-容器之间的互联"><a href="#3-容器之间的互联" class="headerlink" title="3. 容器之间的互联"></a>3. 容器之间的互联</h2><p>同一个Docker Daemon下的容器，彼此之间是可以通过容器IP互相访问的（如何查看容器IP？用<code>docker inspect 容器ID或名称</code>命令），如果要实现两个容器之间可以通过容器名直接访问，则可以通过自建一个docker网络。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个自定义网络，-d 表示网络类型，可以为bridge（网桥，软件交换机），或overlay（跨Docker Daemon容器间的互联）</span></span><br><span class="line">~$ docker network create -d bridge my-net</span><br><span class="line">0c97fc265ed1cab67d84b9376d6914c9558419c73bb5abc040e75c945cd99f0a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个centos容器centos1，通过 --network 指定自定义网络</span></span><br><span class="line">~$ docker run -it --name centos1 --network my-net centos:7.3.1611 bash</span><br><span class="line">[root@3dcf507bd12a /]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再启动一个centos容器centos2（打开另一个窗口），指定同一个自定义网络</span></span><br><span class="line">~$ docker run -it --name centos2 --network my-net centos:7.3.1611 bash</span><br><span class="line">[root@16dcce660a89 /]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在centos1容器中直接ping centos2</span></span><br><span class="line">[root@3dcf507bd12a /]# ping centos2</span><br><span class="line">PING centos2 (172.19.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos2.my-net (172.19.0.2): icmp_seq=1 ttl=64 time=0.111 ms</span><br><span class="line">64 bytes from centos2.my-net (172.19.0.2): icmp_seq=2 ttl=64 time=0.058 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在centos2容器中直接ping centos1</span></span><br><span class="line">[root@16dcce660a89 /]# ping centos1</span><br><span class="line">PING centos1 (172.19.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos1.my-net (172.19.0.3): icmp_seq=1 ttl=64 time=0.061 ms</span><br><span class="line">64 bytes from centos1.my-net (172.19.0.3): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure></p><p>由上可见通过自定义网桥连接的容器可以通过容器名称互相访问。如果需要多个容器之间互联，则可以使用Docker Compose。</p><h2 id="4-配置容器的DNS"><a href="#4-配置容器的DNS" class="headerlink" title="4. 配置容器的DNS"></a>4. 配置容器的DNS</h2><p>如果要自定义所有容器的DNS，则可以在 /etc/docker/daemon.json 中增加<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"dns"</span> : [</span><br><span class="line">        <span class="string">"114.114.114.114"</span>,</span><br><span class="line">        <span class="string">"8.8.8.8"</span></span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以在启动容器时通过参数指定单个容器的DNS配置，<code>--dns=IP_ADDRESS</code>，这会将指定DNS的地址添加到容器的 /etc/resolv.conf 文件中，让容器用这个DNS服务器来解析所有不在 /etc/hosts 中的主机名。 </p><h2 id="5-Docker网络的底层实现"><a href="#5-Docker网络的底层实现" class="headerlink" title="5. Docker网络的底层实现"></a>5. Docker网络的底层实现</h2><p>容器的网络访问控制，主要是通过Linux上的<strong>iptables防火墙</strong>来实现与管理的。</p><ol><li><strong>容器访问外部网络</strong><br>容器访问外部网络，需要通过本地系统的转发，可以通过如下命令查看转发是否打开<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sysctl net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为1为打开，为0则未打开，可通过如下命令打开，也可以在Docker服务启动时通过参数--ip-forward=<span class="literal">true</span>打开</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sysctl -w net.ipv4.ip_forward=1</span></span><br></pre></td></tr></table></figure></li></ol><p>容器所有到外部网络的访问，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 iptables 的源地址伪装操作实现的，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~# iptables -t nat -nL</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0</span><br></pre></td></tr></table></figure><p>上述规则将所有源地址在 172.17.0.0/16 的网段（容器IP所在网段），目标地址为任意网段（包括外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。 </p><ol start="2"><li><strong>外部访问容器</strong></li></ol><p>通过 -p 或 -P 指定端口映射，允许外部访问容器端口，实质也是在本地的 iptable 的 nat 表中添加相应的规则，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~# iptables -t nat -nL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination                 </span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:3306 to:172.17.0.2:3306</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:11090 to:172.17.0.3:11090</span><br></pre></td></tr></table></figure></p><p>这里的规则映射了 0.0.0.0 ，意味着将接受主机来自所有网络接口的流量。</p><ol start="3"><li><strong>容器之间的访问</strong><br>容器之间能互相访问，需要满足两个条件：1）容器的网络拓扑是否已经互联，默认情况下容器都连接到docker0网桥上，默认是互联的。2）本地系统的防火墙iptables是否允许通过。当容器启动时通过–link互联时，也是在iptables中创建对应规则来实现。</li></ol><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文整理了Docker网络相关知识，对容器之间及容器与外部之间的通信机制应该有了一定的了解。除了默认的网络实现，Docker还提供了网络的配置及自定义网络，出于篇幅，本文介绍到这，后续再补充。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker的应用运行在容器中，其相互之间或与外部之间是如何通信的，涉及到哪些知识点，本文对相关内容进行整理。因网络这块牵涉的面较多，因此只从日常使用或理解的角度出发，过于专业的就不深入探讨了。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>开发人员需要掌握的日常Linux命令集</title>
    <link href="http://blog.jboost.cn/linux-cmd.html"/>
    <id>http://blog.jboost.cn/linux-cmd.html</id>
    <published>2019-08-27T02:58:43.000Z</published>
    <updated>2019-08-27T10:46:50.460Z</updated>
    
    <content type="html"><![CDATA[<p>不会运维的开发不是好测试。<br><a id="more"></a></p><p>本文整理了开发人员日常用到的linux相关命令，供参考。</p><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p><code>cd</code> # 进入某个目录，不接参数进入当前用户目录（等同于cd ~），如/home/devuser，可接绝对路径或相对路径（../..表示上上级目录），也可以接 “-” 回到上次所在目录</p><p><code>pwd</code> # 显示当前所在目录</p><p><code>ls -la</code> # 列出当前目录所有对象，-a表示包含以.开头的隐藏文件或目录<br><code>ll -h</code> # ll 等同于 ls -l， -h表示按K M G 显示文件大小</p><p><code>df -h</code> # 显示系统各盘符的空间使用情况<br><code>du -h --max-depth=1</code> # 显示当前目录下各文件大小，–max-depth=1只列出当前目录下的文件或目录，不会列出子目录下的文件</p><p><code>mv test.log /home/devuser/</code> # 移动文件（夹） 或重命名</p><p><code>cp [-r] test test.bak</code> # 复制文件，如果是文件夹则加 -r，表示复制文件夹下所有子文件夹内容<br><code>rm -[r]f /home/devuser/</code> # 删除文件，如果删除文件夹则加 -r </p><p><code>find / -name test.log</code> # 在根目录下查找文件名为test.log的文件<br><code>find /var/log/ -size +50M -exec rm -f {} \;</code> # 在/var/log/目录下查找大于50M的文件并删除，建议先将rm改为ls确认<br><code>find /var/log/ -type f -atime +10</code> # 搜索在过去10天内未被使用过的文件<br><code>find /var/log/ -type f -mtime -10</code> # 搜索在10天内被创建或者修改过的文件<br><code>find /var/log/ -type f -atime +10|xargs rm -f</code> # |xargs 作用与 -exec类似<br><code>find ./ -name &quot;*.log&quot; -exec &#39;cat&#39; {} \; &gt; test.log</code> # 将当前目录下所有.log文件内容合并到一个文件test.log</p><p><code>which java</code> # 在系统PATH路径下查找java可执行文件<br><code>whereis java</code> # 查找二进制、源文件、man文件，从文件索引中查找，而不仅仅从PATH路径下查找</p><p><code>zip test.zip test.log test2.log</code> # 创建一个zip格式的压缩包，可以接多个文件或文件夹<br><code>zip -r file.zip file1 file2 dir1</code> # 将几个文件和目录同时压缩成一个zip格式的压缩包<br><code>unzip test.zip</code> # 解压一个zip格式压缩包</p><p><code>tar -zcvf test.tar.gz</code> 要被压缩的文件名或目录 # 以gzip进行压缩 -z 按gzip，-c 压缩，-v 显示内容 -f 指定文件名<br><code>tar -zxvf test.tar.gz -C 解压缩到的目录</code> # 解压到指定目录 -x 解压<br><code>tar -ztvf test.tar.gz</code> # 不解压，只查看内容</p><p><code>tar -jcvf test.tar.bz2 要被压缩的文件名或目录</code> # 以bzip2进行压缩<br><code>tar -jxvf test.tar.bz2 -C 解压缩到的目录</code> # 解压到指定目录</p><h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><p><code>touch test.log</code> # 创建空文件<br><code>echo -e &#39;abc\ncba&#39;&gt; test.log</code> # 覆盖的形式往文件写入内容 -e 解析转移字符，不然当成字符串<br><code>echo &#39;aaa&#39; &gt;&gt; test.log</code> # 追加的形式往文件写入内容</p><p><code>cat [-n] test.log |grep [-v] abc</code> # 过滤文件中包含 abc 的行， 加-v表示不包含， -n表示打印行号<br><code>cat test.log |grep  abc|wc -l</code> # 计算文件中包含 abc 的行数</p><p><code>head -n 2 test.log</code> # 查看一个文件的前两行<br><code>tail -n 2 test.log</code> # 查看一个文件的最后两行<br><code>tail -n +1000 test.log</code> # 从1000行开始显示，显示1000行以后的<br><code>cat test.log | head -n 2000 | tail -n +1000</code> # 显示1000行到2000行的<br><code>cat test.log | tail -n +1000 | head -n 1000</code> # 从第1000行开始，显示1000行</p><p><code>more test.log</code> # 一页一页地查看文件内容，空格键往后一页，B键往前一页，不能通过上下键控制翻滚，会一次加载整个文件<br><code>less test.log</code> # 一页一页地显示文件内容，可以通过上下键控制往前往后翻，可以向上向下搜，不需一次加载整个文件，所以速度比more快，“less is more”， less比more更强大</p><p><code>tail -200f test.log</code> # 查看最后200行，根据文件描述符进行追踪，当文件改名或被删除，追踪停止<br><code>tail -F test.log</code> # 查看最后10行，只要对应文件名存在，就保持监视，即使文件被删除或改名后，如果再次创建相同的文件名，也会继续追踪</p><p><code>grep abc test.log</code> # 在文件中查找关键词”abc”，类似于 <code>cat test.log|grep abc</code><br><code>grep ^abc test.log</code> # 在文件中查找以”abc”开始的词汇<br><code>grep [0-9] test.log</code> # 选择文件中所有包含数字的行<br><code>grep abc -R /var/log</code>/* # 在目录 ‘/var/log’ 及随后的目录中搜索字符串”abc”</p><p><code>sed &#39;s/abc/ccc/g&#39; test.log</code> # 将test.log文件中的 “abc” 替换成 “ccc”并打印，不改变原有文件<br><code>sed &#39;/^$/d&#39; test.log</code> # 从文件中删除所有空白行并打印，不改变原有文件</p><p><code>paste test.log test2.log</code> # 按两列合并两个文件每行的内容并打印，test.log在左边，test2.log在右边<br><code>paste -d &#39;+&#39; file1 file2</code> # 合并两个文件每行的内容并打印，中间用”+”拼接</p><p><code>sort test.log</code> # 对文件内容进行排序，每行首字母排序<br><code>sort test.log test2.log</code> # 排序两个文件的内容<br><code>sort test.log test2.log | uniq</code> # 取出两个文件的并集(重复的行只保留一份)<br><code>sort test.log test2.log | uniq -u</code> # 删除交集，留下其他的行<br><code>sort test.log test2.log | uniq -d</code> # 取出两个文件的交集(同时存在于两个文件中的行)</p><p># comm 类似于集合的差集运算，需要两个文件都是排序的<br><code>comm -1 test.log test2.log</code> # 比较两个文件的内容只删除test.log所包含的内容<br><code>comm -2 test.log test2.log</code> # 比较两个文件的内容只删除test2.log所包含的内容<br><code>comm -3 test.log test2.log</code> # 比较两个文件的内容删除两个文件共有的内容</p><h2 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h2><p><code>chmod +x test.sh</code> # 为一个文件增加可执行权限<br><code>chmod ugo+rwx test.sh</code> # 设置文件的所有者(u)、群组(g)以及其他人(o)读（r，4 ）、写(w，2)和执行(x，1)的权限，+ 改为 - 即删除权限<br><code>chmod 755 test.sh</code> # 对文件所有者，群组，其他人分别设置7（rwx=4+2+1），5（rx=4+1）,5（rx=4+1）的权限</p><p><code>chown [-R] 用户名:群组名 test.log</code> #改变一个文件的所有者和群组，如果是作用于文件夹下所有文件或目录，则加 -R<br><code>chgrp 群组名 test.log</code> # 改变文件的群组</p><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><p><code>top</code> # 实时显示系统中各个进程的资源占用状况<br><code>top -H -p 进程号</code> # 列出进程的所有线程，按1键根据CPU占有率排序<br><code>ps -ef|grep 进程名称</code> # 查看某个进程，一般用户找进程ID<br><code>kill -9 进程ID</code> # 停止某个进程<br><code>jps</code> # 查看所有java进程</p><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><p><code>ifconfig</code> # 查看系统各网卡信息（IP，mac地址，子网掩码等）<br><code>ss -s</code> # 查看当前系统tcp、udp连接数</p><p><code>netstat -ano|grep 端口号</code> # 查看某个端口是否起来<br><code>lsof -i:端口号</code> # 查看某个端口对应的进程信息，lsof可能需要额外安装 （sudo yum install lsof）</p><p><code>ssh devuser@192.168.40.206</code> # 远程连接另一台linux主机</p><p><code>curl http://www.baidu.com</code> # get方式请求某个地址<br><code>curl -i -X POST -H &quot;Content-type:application/json&quot; -d &#39;{&quot;a&quot;:&quot;x&quot;,&quot;b&quot;:[&quot;y&quot;]}&#39;  http://xxx</code> # POST方式请求某个接口</p><p><code>wget http://xxx.zip</code> # 下载文件</p><p><code>scp test.log devuser@192.168.40.206:/home/devuser/</code># 传输文件到另一台主机的目录下，如果是文件夹则加 -r<br># nc 传输，可用于文件传输（scp需要密码，nc不需要密码），需要安装 sudo yum install nc<br><code>nc -l 1234 &gt; test.log</code> # 接收方，监听1234端口，将接收内容存于test.log<br><code>nc 192.168.40.205 1234 &lt; test.log</code> # 发送方，向接收方(ip为192.168.40.205)发送test.log的内容</p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><p><code>top</code> # 查看CPU、内存使用情况，即各进程使用情况<br><code>free -g</code> # 查看内存使用情况<br><code>date</code> # 查看系统当前时间<br><code>uptime</code> # 查看当前CPU使用负载情况，及系统已运行时间，相当于top的第一行<br><code>su</code> # 切换到root用户<br><code>su devuser</code> # 切换到devuser用户<br><br><br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不会运维的开发不是好测试。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="linux" scheme="http://blog.jboost.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>k8s云集群混搭模式，可能帮你节省50%的服务成本</title>
    <link href="http://blog.jboost.cn/mix-eci.html"/>
    <id>http://blog.jboost.cn/mix-eci.html</id>
    <published>2019-08-21T07:32:30.000Z</published>
    <updated>2019-08-22T03:49:19.484Z</updated>
    
    <content type="html"><![CDATA[<p>现在大部分中小企业或团队都是使用云平台来部署自己的服务，如阿里云，亚马逊云等。一般来说，业务的负载都具备一定的规律，比如每天集中在某几个小时，或呈现时间段周期性波峰、波谷交替的现象，如下图<br><img src="/assets/load-trend.png" alt="业务负载周期性"></p><p>如果使用ECS来部署服务，则可能大部分时间ECS的资源没有得到充分利用，造成成本浪费，尤其对于像GPU之类成本较高的资源就更加了。这个时候，我们可以考虑使用云集群的混搭模式来节约成本。</p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>假设有一个这样的业务场景，包括如下特点及要求：</p><ol><li>整个系统包括业务服务与两层视觉服务</li><li>各层服务之间调用需做负载均衡</li><li>每天的业务量主要集中在上午几个小时</li><li>平时业务量较低时仍要保证服务可用</li><li>尽可能降低成本，尤其是GPU服务器成本（GPU贵啊）</li></ol><p><img src="/assets/biz-top.png" alt="业务部署架构"></p><h2 id="k8s云集群混搭模式"><a href="#k8s云集群混搭模式" class="headerlink" title="k8s云集群混搭模式"></a>k8s云集群混搭模式</h2><p>现在各大云平台都已经提供容器云服务，如阿里云有基于ECI（弹性容器实例）的Serverless Kubernetes集群服务，基于ECS节点不需要提供master的Kubernetes托管版集群服务，及自己提供master的Kubernetes专有版集群服务等。为了迎合类似上述业务场景的需求，也提供了Kubernetes + virtual node（虚拟节点）的混合集群服务，如下图所示</p><p><img src="/assets/k8s-vn.png" alt="k8s-vn"></p><p>其中的虚拟节点基于ECI支持多种功能，如GPU容器实例、大规格容器实例等，增强了Kubernetes集群的弹性，使集群不局限于ECS节点的资源，做到弹性无限扩容。</p><h2 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h2><p>结合前面的业务场景，我们可以采用k8s的混合集群服务来部署我们的项目，如下图</p><p><img src="/assets/biz-deploy.png" alt="biz-deploy"></p><p>实现步骤：</p><ol><li>创建Kubernetes托管版集群</li><li>加入已有ECS节点</li><li>添加一个虚拟节点，通过添加应用 ack-virtual-node 来实现</li><li>分别创建无状态的业务Deployment、AI-1 Deployment、AI-2 Deployment（对应三层服务）</li><li>分别在业务Deployment上创建公网SLB，AI-1 Deployment、AI-2 Deployment上创建内网SLB</li><li>分别在各Deployment上根据CPU或内存使用阈值配置弹性水平伸缩HPA</li><li>根据需要可以在某个或某些Deployment上配置定时伸缩，通过添加应用 ack-kubernetes-cronhpa-controller 来实现</li></ol><blockquote><p>因为水平伸缩一般需要一定时间，延迟可能会对业务造成影响，所以在业务负载比较规律的时候，可以通过定时伸缩（就是定时扩展到多少个容器，再定时收缩到多少个容器）来改善；目前定时伸缩配置的查看与更新只能通过kubectl命令行进行。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按照官方文档的计费方式，一个普通的2核8G的ECS一年大概费用是2600左右，如果通过容器服务的方式（按秒计费），假设每天起8小时，则一年大概费用1550左右，如果业务负载再集中到几个小时，费用会更低，对于比较稀缺又昂贵的GPU服务就更加了。但是如果服务全部按容器24小时租赁，其成本就又比ECS贵了（一年约4600），所以在平时业务负载较低的时候，可以将容器调度到ECS上保障服务的提供，业务负载高时，通过HPA或cronHPA的方式动态伸缩到虚拟节点上。对于业务负载具有一定规律的服务来说，采用这种混搭的部署方式将极大地降低你的云服务成本。不过目前k8s云集群服务应该推出时间不久，产品的易用性还比较低，对不具备一定容器与编排基础的人使用门槛相对较高。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在大部分中小企业或团队都是使用云平台来部署自己的服务，如阿里云，亚马逊云等。一般来说，业务的负载都具备一定的规律，比如每天集中在某几个小时，或呈现时间段周期性波峰、波谷交替的现象，如下图&lt;br&gt;&lt;img src=&quot;/assets/load-trend.png&quot; alt=&quot;
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>小技巧：如何自定义logback日志文件的名称</title>
    <link href="http://blog.jboost.cn/trick-logback-prop.html"/>
    <id>http://blog.jboost.cn/trick-logback-prop.html</id>
    <published>2019-08-20T09:42:28.000Z</published>
    <updated>2019-08-20T11:04:34.498Z</updated>
    
    <content type="html"><![CDATA[<p>在logback.xml中获取自定义变量值。<br><a id="more"></a></p><p>我们可以通过在logback.xml中配置appender来指定日志输出格式及输出文件路径，这在一台主机或一个文件系统上部署单个实例没有问题，但是如果部署多个实例（比如通过容器的方式），多个实例同时往同一文件写日志可能就会引起问题。这时可以将每个实例的日志文件加以区分，如IP或UUID，或两者结合的形式。</p><p>可以有4种方式来实现logback.xml中获取自定义变量值：</p><ol><li>通过设置环境变量或传递系统属性（比如在程序启动时通过-D传递）的方式，两者是可以直接在logback.xml中通过 <code>${变量名}</code> 获取的。</li><li>自定义logback.xml的加载时机，在其加载前将需要设置的属性注入到logback的context中，这种方式相对复杂，本文不讨论。</li><li>通过实现PropertyDefiner接口来提供属性值设置</li><li>通过实现LoggerContextListener接口来设置属性值</li></ol><p>第一种方式简单，但不能通过程序生成属性值，第二种方式稍显复杂，本文主要介绍后两种方式。</p><h2 id="PropertyDefiner方式"><a href="#PropertyDefiner方式" class="headerlink" title="PropertyDefiner方式"></a>PropertyDefiner方式</h2><p>首先定义一个类，实现PropertyDefiner接口，可以通过继承PropertyDefinerBase会更方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.core.PropertyDefinerBase;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 将本地IP拼接到日志文件名中，以区分不同实例，避免存储到同一位置时的覆盖冲突问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20 16:17   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPLogDefiner</span> <span class="keyword">extends</span> <span class="title">PropertyDefinerBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(IPLogDefiner.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUniqName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String localIp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            localIp = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">"fail to get ip..."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        String uniqName = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (localIp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqName = localIp + <span class="string">"-"</span> + uniqName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPropertyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getUniqName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现方法 <code>getPropertyValue</code> 中返回你需要生成的值，本例中是返回 <code>本地IP-UUID</code> 的形式。</p><p>然后在logback.xml中，添加 <code>&lt;define&gt;</code> 配置，指定属性名（本例中为localIP）及获取属性值的实现类，这样就可以在配置中通过 <code>${localIP}</code>来引用该属性值了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">define</span> <span class="attr">name</span>=<span class="string">"localIP"</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.IPLogDefiner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLogFile"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>D:\\logs\\elk\\interface-$&#123;localIP&#125;.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"># 省略了其它配置</span><br></pre></td></tr></table></figure></p><h2 id="LoggerContextListener方式"><a href="#LoggerContextListener方式" class="headerlink" title="LoggerContextListener方式"></a>LoggerContextListener方式</h2><p>定义一个实现LoggerContextListener接口的类，在start方法中，将需要设置的属性设置到logback的Context中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Level;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.spi.LoggerContextListener;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.Context;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.spi.ContextAwareBase;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.spi.LifeCycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 第二种实现方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20 18:45   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerStartupListener</span> <span class="keyword">extends</span> <span class="title">ContextAwareBase</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LoggerContextListener</span>, <span class="title">LifeCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (started) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        context.putProperty(<span class="string">"localIP"</span>, getUniqName());</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUniqName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String localIp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            localIp = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">//LOG.error("fail to get ip...", e);</span></span><br><span class="line">        &#125;</span><br><span class="line">        String uniqName = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (localIp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqName = localIp + <span class="string">"-"</span> + uniqName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//省略了其它函数</span></span><br></pre></td></tr></table></figure><p>然后在logback.xml中，配置如上监听器类，这样就可以通过 <code>${localIP}</code> 获取到上面 <code>context.putProperty(&quot;localIP&quot;, getUniqName());</code> 设置的值了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;define name="localIP" class="com.cnbot.common.IPLogDefiner"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextListener</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.LoggerStartupListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">define</span> <span class="attr">name</span>=<span class="string">"localIP"</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.IPLogDefiner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLogFile"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>D:\\logs\\elk\\interface-$&#123;localIP&#125;.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"># 省略了其它配置</span><br></pre></td></tr></table></figure></p><p>这种方式能设置任意个数的属性值，比前一种方式灵活。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在logback.xml中获取自定义属性值，主要是需要在加载前将对应的属性值进行设置，这样加载时才能有效获取。本文虽是自定义日志文件名称，但不局限于此，所有需要动态获取的变量都可以按这种方式实现。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在logback.xml中获取自定义变量值。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（八）：数据管理</title>
    <link href="http://blog.jboost.cn/docker-8.html"/>
    <id>http://blog.jboost.cn/docker-8.html</id>
    <published>2019-08-12T08:50:37.000Z</published>
    <updated>2019-08-12T13:01:44.281Z</updated>
    
    <content type="html"><![CDATA[<p>前面（哪个前面我也忘了）有说过，如果我们需要对数据进行持久化保存，不应使其存储在容器中，因为容器中的数据会随着容器的删除而丢失，而因通过将数据存储于宿主机文件系统的形式来持久化。在Docker容器中管理数据主要有数据卷、宿主机目录挂载两种方式<br><a id="more"></a></p><h2 id="1-数据卷的方式"><a href="#1-数据卷的方式" class="headerlink" title="1. 数据卷的方式"></a>1. 数据卷的方式</h2><p>数据卷是一个特殊的文件目录（或文件），具备如下特性：</p><ol><li>可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>数据卷的更新，不会影响到镜像</li><li>数据卷默认会一直存在，不会随容器的删除而消亡</li></ol><h3 id="1-1-创建数据卷"><a href="#1-1-创建数据卷" class="headerlink" title="1.1 创建数据卷"></a>1.1 创建数据卷</h3><p>可以使用<code>docker volume create 数据卷名称</code>的命令来创建一个数据卷，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume create volume1</span><br><span class="line">volume1</span><br></pre></td></tr></table></figure></p><h3 id="1-2-查看数据卷"><a href="#1-2-查看数据卷" class="headerlink" title="1.2 查看数据卷"></a>1.2 查看数据卷</h3><p>创建完后，这个数据卷具体对应宿主机哪个文件目录在上面是没法得知的，可以通过<code>docker volume inspect 数据卷名称</code>来查看，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume inspect volume1</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "CreatedAt": "2019-08-12T19:43:47+08:00",</span><br><span class="line">        "Driver": "local",</span><br><span class="line">        "Labels": &#123;&#125;,</span><br><span class="line">        "Mountpoint": "/var/lib/docker/volumes/volume1/_data",</span><br><span class="line">        "Name": "volume1",</span><br><span class="line">        "Options": &#123;&#125;,</span><br><span class="line">        "Scope": "local"</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可以看到数据卷volume1对应的文件目录是“/var/lib/docker/volumes/volume1/_data”。</p><p><code>docker inspect xxx</code>这个命令挺有用的，不论是查看镜像相关信息（<code>docker image inspect 镜像名/镜像ID</code>），还是查看容器相关信息（<code>docker container inspect 容器名/容器ID</code>），都可以使用，其中的image,container,volume是可以省略的，只要xxx部分不冲突就行。</p><p>可以通过<code>docker volume ls</code> 命令来查看所有数据卷，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               volume1</span><br></pre></td></tr></table></figure></p><h3 id="1-3-使用数据卷"><a href="#1-3-使用数据卷" class="headerlink" title="1.3 使用数据卷"></a>1.3 使用数据卷</h3><p>可以在启动容器时通过 -v 或 –mount 的方式将一个数据卷挂载到容器的某个目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu1 -v volume1:/vol1 ubuntu:18.04</span><br><span class="line">b060e793d44de2ca871da257b47598334658952943a13d1c478df5c3ae91a01c</span><br></pre></td></tr></table></figure></p><p>按照 <code>-v 数据卷名:容器目录</code> 的格式，也可以使用 –mount 按照 <code>--mount source=数据卷名,target=容器目录</code> 的格式，如我们再启动一个挂载相同数据卷的容器 ubuntu2，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount source=volume1,target=/vol2 ubuntu:18.04</span><br><span class="line">b30971f8a4bbadee10774fce0b4568b5b7b1c9cde36f4bf84ac911a4cdaf6c8d</span><br></pre></td></tr></table></figure></p><p>可以在数据卷所在目录中创建一个文件来看看效果，先创建文件 hello.txt<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# cd /var/lib/docker/volumes/volume1/_data</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ _data]# touch hello.txt</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ _data]# ls</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>然后通过<code>docker exec</code>来查看容器ubuntu1目录/vol1，及容器ubuntu2目录/vol2的内容<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu1 ls /vol1</span><br><span class="line">hello.txt</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu2 ls /vol2</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>可以看到通过挂载目录 /vol1， /vol2 都可以访问到数据卷volume1对应目录下的内容。这就像linux的软链接一样，将容器目录链接到了数据卷目录。并且上述示例也说明，同一个数据卷是可以在被多个容器共享的。</p><p>数据卷的共享也可以通过 <code>volumes-from 容器名称/容器ID</code> 参数来实现，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu3 --volumes-from ubuntu2 ubuntu:18.04</span><br><span class="line">bb5c6d61a1e6eeb18ba8c889e471b2f3215f97efca79b311eeca5968b2700df8</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu3 ls /vol2</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>通过<code>--volumes-from ubuntu2</code>来直接使用ubuntu2挂载的容器配置。</p><h3 id="1-4-删除数据卷"><a href="#1-4-删除数据卷" class="headerlink" title="1.4 删除数据卷"></a>1.4 删除数据卷</h3><p>数据卷不会随着容器的删除而自动删除。<br>如果一个数据卷还被某个容器使用，则不能删除；<br>如果一个数据卷只被一个容器使用，则可在删除容器时通过指定 <code>-v</code> 参数同时删除其挂载的数据卷；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker rm -v ubuntu3</span><br><span class="line">ubuntu3</span><br></pre></td></tr></table></figure></p><p>可以通过 <code>docker volume rm 数据卷名称</code> 来删除某个数据卷；<br>可以通过 <code>docker volume prune</code> 清理掉所有未被任何容器使用的数据卷。</p><h2 id="2-宿主机目录挂载方式"><a href="#2-宿主机目录挂载方式" class="headerlink" title="2. 宿主机目录挂载方式"></a>2. 宿主机目录挂载方式</h2><p>在容器启动时，使用 <code>-v 宿主机目录:容器目录</code> 或 <code>--mount type=bind,source=宿主机目录,target=容器目录</code>的参数格式指定将宿主机目录挂载到容器目录上。宿主机目录必须是绝对路径。两者之间的区别是 <code>-v</code> 如果在宿主机目录不存在时会自动创建目录，而<code>--mount</code>不会。如，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu1 -v /root/v1:/vol1 ubuntu:18.04</span><br><span class="line">25c91911709eebc9290b47b483666f7b7be840df947117f7cad323583905b9f1</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount type=bind,source=/root/v2,target=/vol1 ubuntu:18.04</span><br><span class="line">docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /root/v2.</span><br><span class="line">See 'docker run --help'.</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# mkdir /root/v2</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount type=bind,source=/root/v2,target=/vol1 ubuntu:18.04</span><br><span class="line">5a57285e9261d048dc71cf0476055a290f80538afff2cefd2a24f8b4468b5171</span><br></pre></td></tr></table></figure></p><p>/root/v1,/root/v2都没有事先创建，用 <code>-v</code> 不会报错，会自动创建； <code>--mount</code>则会报错，目录必须先存在。</p><p>docker不仅支持目录的挂载，也支持文件的挂载，如，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run --rm -it -v $HOME/.bash_history:/root/.bash_history ubuntu:18.04 bash </span><br><span class="line">root@3ae4ed4e687d:/# history</span><br><span class="line">    1  ll webapps/</span><br><span class="line">    2  ll confluence/images/</span><br></pre></td></tr></table></figure></p><p>通过将宿主机当前用户的历史操作文件挂载到容器的root用户下的历史操作文件，可在容器中通过<code>history</code>命令查看到宿主机的操作历史。</p><p>可通过 <code>docker inspect</code>来查看容器的挂载情况<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker inspect ubuntu1</span><br><span class="line">--省略了其它信息--</span><br><span class="line">"Mounts": [</span><br><span class="line">            &#123;</span><br><span class="line">                "Type": "bind",</span><br><span class="line">                "Source": "/root/v1",</span><br><span class="line">                "Destination": "/vol1",</span><br><span class="line">                "Mode": "",</span><br><span class="line">                "RW": true,</span><br><span class="line">                "Propagation": "rprivate"</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">--省略了其它信息--</span><br></pre></td></tr></table></figure></p><p>可在“Mounts”部分看到挂载信息。</p><h2 id="3-只读控制"><a href="#3-只读控制" class="headerlink" title="3. 只读控制"></a>3. 只读控制</h2><p>有时候，为了数据安全，我们不允许容器对挂载目录的内容进行修改，即对容器来说，挂载目录是只读的，这可以通过在挂载参数后面加限制实现。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu3 -v /root/v1:/vol1:ro ubuntu:18.04</span><br><span class="line">25eca348ed307afcbef92bc03f0a1304b31b52e6db1fa07772b5dbd1040ff7b6</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu3 bash</span><br><span class="line">root@25eca348ed30:/# touch /vol1/hello.txt</span><br><span class="line">touch: cannot touch '/vol1/hello.txt': Read-only file system</span><br></pre></td></tr></table></figure></p><p><code>-v</code>是在后面加<code>ro</code>（read-only），<code>--mount</code>则是形如<code>--mount type=bind,source=宿主机目录,target=容器目录,read only</code>的格式，可自行试验。<br>加了read only的挂载我们再通过<code>docker inspect</code>命令查看，可看到两者之间的差异 —— Mode与RW的值。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">            &#123;</span><br><span class="line">                "Type": "bind",</span><br><span class="line">                "Source": "/root/v1",</span><br><span class="line">                "Destination": "/vol1",</span><br><span class="line">                "Mode": "ro",</span><br><span class="line">                "RW": false,</span><br><span class="line">                "Propagation": "rprivate"</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>如果要对数据进行持久化管理或在容器之间共享数据，则需要将数据通过数据卷或宿主机目录（或文件）挂载的方式来将数据存储于宿主机上，使得数据的生命周期独立于容器的生命周期。这类似于我们不要把重要文件放在系统盘，而应放在其它数据盘一样，因为系统盘会由于重装系统或系统故障导致文件丢失。本文对Docker的数据管理进行了整理，后续对Docker的网络配置管理部分进行整理，欢迎持续关注。</p><p><br><br>我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面（哪个前面我也忘了）有说过，如果我们需要对数据进行持久化保存，不应使其存储在容器中，因为容器中的数据会随着容器的删除而丢失，而因通过将数据存储于宿主机文件系统的形式来持久化。在Docker容器中管理数据主要有数据卷、宿主机目录挂载两种方式&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>就业，该去小公司还是大公司？</title>
    <link href="http://blog.jboost.cn/company-choice.html"/>
    <id>http://blog.jboost.cn/company-choice.html</id>
    <published>2019-08-09T05:29:58.000Z</published>
    <updated>2019-08-12T04:00:24.375Z</updated>
    
    <content type="html"><![CDATA[<p>前几天跟一朋友交流，他说一个表弟明年就要毕业了，马上面临找工作，是去一线城市找大公司的工作好，还是留在二线城市中小公司发展好。我说，去大公司好。为什么会有这个结论，这篇文章结合自己的经历说说我的一些感受。<br><a id="more"></a></p><p>我的第一份工作是在一家外企，当时抱着“逃离”上海的想法去了二线城市的分公司，但是管理文化氛围跟总部几乎都是一样的，这份工作经历对我后面的工作不论是做事风格、习惯上还是思考问题的方式方法上都有很大的影响。后面陆续进入国企，民企，再进入初创公司，从公司规模上可以说各种类型的都有过体验。下面从环境因素，平台效应因素等几个角度说说自己的感受。</p><h2 id="环境因素"><a href="#环境因素" class="headerlink" title="环境因素"></a>环境因素</h2><p>环境对一个人的影响还是很重要的，不论是大家熟知的“近朱者赤近墨者黑”的说法，还是令我们中国人挤破脑袋的“学区房”现象，都说明环境对一个人的成长起着至关重要的作用。</p><p>小公司与大公司的环境差异首先体现在人员的素养、水平上。大公司的准入门槛相对高一些，所以人员的素质、水平也相对要高一些，如果你周围牛人比较多的话，跟牛人待久了，你也可能慢慢就步入牛人之列了——“近朱者赤”。而小公司，尤其是初创公司，为了尽快招人干活，往往人员的素质、水平会良莠不齐，你可能很难找到一个各方面让你信服，想跟着他学的真正的“牛人”。</p><p>其次在制度、流程规范上。大公司在制度、流程、规范方面相对健全完善，不论是人事管理还是日常合作分工都比较明确，你知道什么时候应该干什么（因为都给你安排好了），处理什么事情应该找谁，都有章可循，有人可找。而在小公司，可能很多人感觉的就一个字——“乱”，人员职责、分工、权限没有明确定义，没有人引导，不知道在什么阶段应该干什么，或者怎么干，明明是个小兵，老板却恨不得你是个全才，啥事都希望你能搞定。有人把在大公司工作比喻是做一颗螺丝钉，而觉得在小公司才能锻炼综合能力，但我觉得在一定的阶段，螺丝钉似的工作才能让你在专业能力上面得到更大的提升，而小公司所谓的综合能力，往往演变的是“打杂”能力，老板为了节约成本，充分发挥（压榨）每个人的能力（价值），往往一人要分饰多角，比如做人事的既要管招聘，又要管行政，甚至还可能被拉去监督项目进度，很难让你在一个专业的领域深度成长。</p><p>再次在产品规模上，大公司产品的日活规模可能少则上百万，多则上亿，不论是在技术实现还是产品运营上，都需要较高的要求与水准，你在其中能学习的技能与套路是小公司日活几千或几万的产品规模无法比拟的。</p><p>最后在文化氛围上，一般大公司都有形成自己的企业文化，包括周围人的工作风格、习惯，都会对你产生潜移默化的影响。比如我现在的不论是写代码，还是写文字，都会反复检查好几遍的习惯就是在第一家公司工作时养成的。因为你的每一行代码你的leader可能都会仔细帮你review，找出有问题的地方让你反复修正直到合格，你的每一封邮件都会被别人（在外企很多时候还包括美国人、印度人）认真查看，所以促使你在发出前会仔细核查是否有遗漏的点，是否存在错别字或语法错误，久而久之，就养成了这种反复检查的比较严谨的做事风格。而在小公司，一般很难在短时间内形成自己的企业文化，很多事情的处理都比较粗放，缺乏对细节的把握，你很难从企业文化氛围上受益。</p><p>如果用游泳来比喻大公司与小公司的差异，我觉得大公司就像是一个掌握各项泳姿、动作标准的游泳运动员，有规范有节奏，从而游得更远；而小公司则更像一个会“狗爬式”的乡下野孩子，虽然路子野，但有效——尽管比较费力，但是能游起来，但能游多远，得看方向对不对，人能不能坚持。</p><h2 id="平台效应因素"><a href="#平台效应因素" class="headerlink" title="平台效应因素"></a>平台效应因素</h2><p>现在有些企业招聘，都明确要求毕业院校必须是985、211，甚至有些岗位直接面向BAT。前不久看到一个案例，上海交大硕博毕业因本科不是211，而被招聘企业直接拒绝。<br><img src="/assets/case-10.jpg" alt="case1">    <img src="/assets/case-11.jpg" alt="case2"></p><p>现实就是这样，看背景，看出身。名企工作与名校毕业一样，对后面的跳槽都会有较大的加分与优势。从小公司跳大公司难，但从大公司跳小公司就容易很多，见过许多阿里系的普通技术人员跳到中小企业做技术管理者的情况。</p><p>名企光环，除了对后面的就业与跳槽方面具备优势，在社会活动上也具备一定的优势，比如现在很多技术书籍，相当一部分出自阿里系，不是说非阿里系的人不具备这个能力，而是因为有着阿里这个名企光环，出的东西更容易被人接受与认可，尽管不一定水平有多好。</p><h2 id="什么人适合去小公司"><a href="#什么人适合去小公司" class="headerlink" title="什么人适合去小公司"></a>什么人适合去小公司</h2><p>毕竟不是每个人都能去大公司，那么什么人适合去小公司呢？我觉得可能主要包括两类，一类是自己在某个领域已经取得了较好的成长，具备了独当一面或者懂得如何带领他人来做事情的能力，这种情况一般是为了追求高薪或对某个领域或公司比较看好，有自己想法的人；另一类是目前还不具备进入大公司的资本与能力的人，人总得工作与生活，所以不得不先进入小公司成长，但这部分人除非自身公司发展特别好，否则还是应该尽力往大公司靠，努力进入大公司体验其管理模式与文化氛围，对你整个职业生涯是有很大帮助的。</p><h2 id="选择什么样的小公司"><a href="#选择什么样的小公司" class="headerlink" title="选择什么样的小公司"></a>选择什么样的小公司</h2><p>选择什么样的小公司比较好，虽然很多时候也没有太多的选择，毕竟好的小公司也是可遇不可求的事情，但如果有的话，我觉得还是尽力选择满足如下四个条件的小公司比较好。</p><ol><li>靠谱的老板。小公司的管理文化与前途基本由老板的品质与能力决定，所以一个有能力、靠谱的老板是第一要素。</li><li>高水平的管理团队，技术、管理、营销各方面。管理团队对于创业公司来说非常重要，只有一个稳定的各方面成熟的团队，成功的几率才会大一点，你在里面能获得的成长空间也更多一些。</li><li>产品项目具备长远发展的潜力。企业经营就是做一个别人愿意花钱购买的产品，并寻找一个将产品源源不断卖不出的方式，所以产品是不是刚需，有没有人买单，能不能长久很重要。</li><li>可靠的资源与渠道。有可靠的资源与渠道，才能将产品源源不断地卖出去，企业才能保持可持续发展。</li></ol><p>以上四点从上往下重要性依次递减，同时满足四个条件的小公司应该是极少的，是可遇不可求的事情，可以按从上往下的重要性进行选择。</p><p>另外进入小公司，可能常见的一个东西是期权，我认为期权是一个美丽的梦，如果以上四点都靠谱，没有期权也能获得很好的锻炼与成长，如果不靠谱，那么就算拿了期权大概率也是一个美丽的梦，看起来很美好，但不会成真的那种，所以面对期权（画饼），也要保持理性。</p><h2 id="职场没有伊甸园"><a href="#职场没有伊甸园" class="headerlink" title="职场没有伊甸园"></a>职场没有伊甸园</h2><p>最后，不论是大公司，还是小公司，都不存在职场的伊甸园，只有自己不断成长，进步，自己强大了，才有更多的选择空间。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天跟一朋友交流，他说一个表弟明年就要毕业了，马上面临找工作，是去一线城市找大公司的工作好，还是留在二线城市中小公司发展好。我说，去大公司好。为什么会有这个结论，这篇文章结合自己的经历说说我的一些感受。&lt;br&gt;
    
    </summary>
    
      <category term="Career" scheme="http://blog.jboost.cn/categories/Career/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker笔记（七）：常用服务安装——Nginx、MySql、Redis</title>
    <link href="http://blog.jboost.cn/docker-7.html"/>
    <id>http://blog.jboost.cn/docker-7.html</id>
    <published>2019-08-07T05:29:45.000Z</published>
    <updated>2019-08-07T10:18:30.564Z</updated>
    
    <content type="html"><![CDATA[<p>开发中经常需要安装一些常用的服务软件，如Nginx、MySql、Redis等，如果按照普通的安装方法，一般都相对比较繁琐 —— 要经过下载软件或源码包，编译安装，配置，启动等步骤，使用 Docker 来安装这些服务软件能极大地简化安装过程，且速度也很快。<br><a id="more"></a></p><p>本文以下操作假定你已经装好了docker，并做好了镜像配置。如果没有，请参考 <a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a></p><h2 id="1-MySql-安装"><a href="#1-MySql-安装" class="headerlink" title="1. MySql 安装"></a>1. MySql 安装</h2><h3 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1 下载镜像"></a>1.1 下载镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull mysql:5.7</span><br></pre></td></tr></table></figure><h3 id="1-2-创建挂载目录"><a href="#1-2-创建挂载目录" class="headerlink" title="1.2 创建挂载目录"></a>1.2 创建挂载目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir -p apps/mysql/conf apps/mysql/data apps/mysql/logs</span><br></pre></td></tr></table></figure><p>如上分别创建了配置文件目录，数据存放目录，以及日志文件目录</p><h3 id="1-3-启动容器实例"><a href="#1-3-启动容器实例" class="headerlink" title="1.3 启动容器实例"></a>1.3 启动容器实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 3306:3306 --name mysql -v /home/devuser/apps/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf -v /home/devuser/apps/mysql/logs:/var/log/mysql -v /home/devuser/apps/mysql/data:/var/lib/mysql --restart=always -e MYSQL_ROOT_PASSWORD=Passw0rd mysql:5.7</span><br></pre></td></tr></table></figure><p>其中<br>-d： 表示在后台运行<br>-p： 宿主机端口与容器端口映射<br>–name： 容器名称<br>-v： 宿主机目录与容器目录映射<br>–restart=always：除非被<code>docker stop</code>命令明确停止，否则一直尝试重启处于停止态的容器；如果Docker重启，也会自动启动容器<br>-e： 设置环境变量，这里设置了mysql root用户的密码为Passw0rd</p><p>如此，MySql服务就跑起来了，很快很简单有木有。</p><h2 id="2-Redis-安装"><a href="#2-Redis-安装" class="headerlink" title="2. Redis 安装"></a>2. Redis 安装</h2><h3 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull redis:5.0.5</span><br></pre></td></tr></table></figure><h3 id="2-2-启动容器"><a href="#2-2-启动容器" class="headerlink" title="2.2 启动容器"></a>2.2 启动容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d --name redis -p 6379:6379 -v /home/devuser/apps/redis/data:/data --restart=always redis:5.0.5 redis-server --appendonly yes --requirepass "Passw1rd"</span><br></pre></td></tr></table></figure><p>-p， -v 与上同，不赘述<br>redis-server –appendonly yes : 在容器启动时执行redis-server命令，并打开redis持久化配置<br>–requirepass： 设置密码</p><h3 id="2-3-连接"><a href="#2-3-连接" class="headerlink" title="2.3 连接"></a>2.3 连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ docker exec -it redis redis-cli -h 172.17.0.4 -p 6379 -a Passw1rd</span><br><span class="line">Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.</span><br><span class="line">172.17.0.4:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">172.17.0.4:6379&gt;</span><br></pre></td></tr></table></figure><p>这种方式把密码暴露了，其它登录用户通过history即可看到密码，不是太安全。可改用如下方式，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~$ docker exec -it redis redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 'Passw1rd'</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><h2 id="3-Nginx-安装"><a href="#3-Nginx-安装" class="headerlink" title="3. Nginx 安装"></a>3. Nginx 安装</h2><h3 id="3-1-拉取镜像"><a href="#3-1-拉取镜像" class="headerlink" title="3.1 拉取镜像"></a>3.1 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull nginx</span><br></pre></td></tr></table></figure><p>会拉取最新的（latest）镜像</p><h3 id="3-2-创建目录"><a href="#3-2-创建目录" class="headerlink" title="3.2 创建目录"></a>3.2 创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir -p apps/nginx/html apps/nginx/logs apps/nginx/conf</span><br></pre></td></tr></table></figure><h3 id="3-3-先不指定映射路径启动一个容器"><a href="#3-3-先不指定映射路径启动一个容器" class="headerlink" title="3.3 先不指定映射路径启动一个容器"></a>3.3 先不指定映射路径启动一个容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 80:80 --name nginx nginx</span><br><span class="line">1fdcd13457a6eaacb511878e10d84ffbe48fe63fd1fb3705f58b2d4195b151d8</span><br></pre></td></tr></table></figure><p>这里如果直接指定映射路径运行会报错，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 80:80 --name nginx -v ~/apps/nginx/html:/usr/share/nginx/html -v ~/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/apps/nginx/logs:/var/log/nginx nginx</span><br><span class="line">dab56c13f9e76aad37fcf73411c78d495a6466f1c0d214949650dbae44adddf4</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused "process_linux.go:424: container init caused \"rootfs_linux.go:58: mounting \\\"/home/devuser/apps/nginx/conf/nginx.conf\\\" to rootfs \\\"/home/docker_image/overlay2/e40ccaf4d845a9af92487b47cbc4d505c5c776800ef8887c5b43833b10661427/merged\\\" at \\\"/home/docker_image/overlay2/e40ccaf4d845a9af92487b47cbc4d505c5c776800ef8887c5b43833b10661427/merged/etc/nginx/nginx.conf\\\" caused \\\"not a directory\\\"\"": unknown: Are you trying to mount a directory onto a file (or vice-versa)? Check if the specified host path exists and is the expected type.</span><br></pre></td></tr></table></figure></p><h3 id="3-4-将运行容器的配置文件复制到宿主机目录下"><a href="#3-4-将运行容器的配置文件复制到宿主机目录下" class="headerlink" title="3.4 将运行容器的配置文件复制到宿主机目录下"></a>3.4 将运行容器的配置文件复制到宿主机目录下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker cp 1fdcd13457a6:/etc/nginx/nginx.conf ~/apps/nginx/conf/</span><br></pre></td></tr></table></figure><h3 id="3-5-删除容器并重新运行"><a href="#3-5-删除容器并重新运行" class="headerlink" title="3.5 删除容器并重新运行"></a>3.5 删除容器并重新运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker stop 1fdcd1345</span><br><span class="line">~$ docker rm 1fdcd1345</span><br><span class="line">~$ docker run -d -p 80:80 --name nginx -v ~/apps/nginx/html:/usr/share/nginx/html -v ~/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/apps/nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure><h3 id="3-6-更新配置后重新加载"><a href="#3-6-更新配置后重新加载" class="headerlink" title="3.6 更新配置后重新加载"></a>3.6 更新配置后重新加载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker kill -s HUP nginx</span><br></pre></td></tr></table></figure><p>类似于 <code>nginx -s reload</code></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文没有总结。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中经常需要安装一些常用的服务软件，如Nginx、MySql、Redis等，如果按照普通的安装方法，一般都相对比较繁琐 —— 要经过下载软件或源码包，编译安装，配置，启动等步骤，使用 Docker 来安装这些服务软件能极大地简化安装过程，且速度也很快。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot（十一）：注解结合JWT实现简单的接口鉴权</title>
    <link href="http://blog.jboost.cn/springboot-simpleauth.html"/>
    <id>http://blog.jboost.cn/springboot-simpleauth.html</id>
    <published>2019-08-01T12:45:59.000Z</published>
    <updated>2019-08-12T04:00:24.375Z</updated>
    
    <content type="html"><![CDATA[<p>一般服务的安全包括认证（Authentication）与授权（Authorization）两部分，认证即证明一个用户是合法的用户，比如通过用户名密码的形式，授权则是控制某个用户可以访问哪些资源。比较成熟的框架有Shiro、Spring Security，如果要实现第三方授权模式，则可采用OAuth2。但如果是一些简单的应用，比如一个只需要鉴别用户是否登录的APP，则可以简单地通过注解+拦截器的方式来实现。本文介绍了具体实现过程，虽基于Spring Boot实现，但稍作修改（主要是拦截器配置）就可以引入其它Spring MVC的项目。<br><a id="more"></a></p><h2 id="1-涉及的知识点"><a href="#1-涉及的知识点" class="headerlink" title="1. 涉及的知识点"></a>1. 涉及的知识点</h2><ol><li>注解：用来标记某个接口是否需要登录</li><li>拦截器：拦截所有请求，判断请求的接口是否需要登录验证（基于是否标记了注解），如果需要，验证相应的信息（token），通过则放行，否则返回错误信息</li><li>JWT： Json Web Token，一种流行的认证解决方案，它可以生成携带信息的token，但token一旦生成，其过期时间就不好更新，如果需要实现用户有操作就自动延长过期时间的场景，就相对比较麻烦。我们这里只用来生成token，过期通过redis实现</li><li>RedisTemplate： 将token存在redis中，通过redis的过期机制来控制token的有效期</li><li>ThreadLocal：可以将一次请求中多个环节需要访问的变量通过ThreadLocal来传递，比如userId</li></ol><h2 id="2-依赖配置"><a href="#2-依赖配置" class="headerlink" title="2. 依赖配置"></a>2. 依赖配置</h2><p>在pom.xml中添加JWT与redis依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jwt.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在application.yml配置文件中添加redis相关配置属性<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123654</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">    jedis:</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        min-idle:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        max-idle:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        max-active:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        max-wait:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure></p><h2 id="3-定义注解"><a href="#3-定义注解" class="headerlink" title="3. 定义注解"></a>3. 定义注解</h2><p>注解的定义你可以根据项目的具体场景，比如需要登录的接口比较多，就可以定义如 @SkipAuth 的注解来标记不需要登录的接口，反之，则可以定义如 @NeedAuth 的注解来标记需要登录的接口，总之就是让标记接口这个操作尽可能少。但也可以基于另一种考虑，万一需要登录的接口忘了加不就存在安全问题吗，所以用 @SkipAuth 相对要保险点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SkipAuth &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-定义token管理器"><a href="#4-定义token管理器" class="headerlink" title="4. 定义token管理器"></a>4. 定义token管理器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTokenManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成TOKEN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createToken</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用uuid作为源token</span></span><br><span class="line">        String token = Jwts.builder().setId(userId).setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">            .signWith(SignatureAlgorithm.HS256, JwtConstant.JWT_SECRET).compact();</span><br><span class="line">        <span class="comment">//存储到redis并设置过期时间</span></span><br><span class="line">        redisTemplate.boundValueOps(JwtConstant.AUTHORIZATION + <span class="string">":"</span> + userId)</span><br><span class="line">            .set(token, JwtConstant.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkToken</span><span class="params">(TokenModel model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = redisTemplate.boundValueOps(JwtConstant.AUTHORIZATION + <span class="string">":"</span> </span><br><span class="line">            + model.getUserId()).get();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> || !token.equals(model.getToken())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果验证成功，说明此用户进行了一次有效操作，延长token的过期时间</span></span><br><span class="line">        redisTemplate.boundValueOps(model.getUserId())</span><br><span class="line">            .expire(JwtConstant.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteToken</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        redisTemplate.delete(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在登录接口通过时，调用 <code>createToken</code> 创建token，并保存到redis中，设置过期时间， 在调用未被 @SkipAuth 注解标记的接口时，调用 <code>checkToken</code> 来验证，并更新token的过期时间， 退出登录时，删除token。</p><h2 id="5-定义拦截器"><a href="#5-定义拦截器" class="headerlink" title="5. 定义拦截器"></a>5. 定义拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTokenManager tokenManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                             HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String requestPath = request.getRequestURI().substring(request.getContextPath().length());</span><br><span class="line">        <span class="comment">// 如果不是映射到方法直接通过</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line">        <span class="comment">// 如果方法注明了 SkipAuth，则不需要登录token验证</span></span><br><span class="line">        <span class="keyword">if</span> (method.getAnnotation(SkipAuth.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从header中得到token</span></span><br><span class="line">        String authorization = request.getHeader(JwtConstant.AUTHORIZATION);</span><br><span class="line">        <span class="comment">// 验证token</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(authorization))&#123;</span><br><span class="line">            WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"未提供有效Token！"</span>), response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = Jwts.parser().setSigningKey(JwtConstant.JWT_SECRET)</span><br><span class="line">                .parseClaimsJws(authorization).getBody();</span><br><span class="line">            String userId = claims.getId();</span><br><span class="line">            TokenModel model = <span class="keyword">new</span> TokenModel(userId, authorization);</span><br><span class="line">            <span class="keyword">if</span> (tokenManager.checkToken(model)) &#123;</span><br><span class="line">                <span class="comment">// 通过ThreadLocal设置下游需要访问的值</span></span><br><span class="line">                AuthUtil.setUserId(model.getUserId());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"连接"</span> + requestPath + <span class="string">"拒绝"</span>);</span><br><span class="line">                WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"未提供有效Token！"</span>), response);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"连接"</span> + requestPath + <span class="string">"发生错误:"</span>, e);</span><br><span class="line">            WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"校验Token发生异常！"</span>), response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结束后清除，否则由于线程池复用，导致ThreadLocal的值被其他用户获取</span></span><br><span class="line">        AuthUtil.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器通过对请求方法是否标记注解 @SkipAuth 来判断是否需要进行token验证，如果验证通过，则从JWT token中解析出userId，通过AuthUtil工具方法保存到ThreadLocal中，供下游访问。在请求处理结束调用 <code>afterCompletion</code> 方法中，要清除掉ThreadLocal中的值，否则由于线程池的复用，导致被其他用户获取。</p><p>然后，注册拦截器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AuthInterceptor authInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthInterceptor</span><span class="params">(AuthInterceptor authInterceptor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authInterceptor = authInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注册鉴权拦截器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(authInterceptor)</span><br><span class="line">            .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">"/error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里将 /error 这个接口排除了，因为如果接口处理过程中出现异常，则spring boot会自动跳转到 /error 接口，又会进入拦截器校验（因为/error接口没有标注 @SkipAuth 注解）。</p><h2 id="6-验证"><a href="#6-验证" class="headerlink" title="6. 验证"></a>6. 验证</h2><p>通过以上几步，一个简单的接口认证功能就实现了，我们可以通过添加一个登录接口，两个测试接口（一个需要认证，一个不需要认证）来验证下。<br>登录接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SkipAuth</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">login</span><span class="params">(@RequestBody Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">    String username = MapUtils.getString(params, <span class="string">"username"</span>);</span><br><span class="line">    String password = MapUtils.getString(params, <span class="string">"password"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"ksxy"</span>.equals(username) &amp;&amp; <span class="string">"jboost"</span>.equals(password))&#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(tokenManager.createToken(username));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.failed(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>登录成功后，通过<code>createToken</code>方法创建了JWT token。<br>测试接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SkipAuth</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/skip-auth"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">skipAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ApiResponse.success(<span class="string">"不需要认证的接口调用"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/need-auth"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">needAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiResponse.success(<span class="string">"username: "</span> + AuthUtil.getUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>本文介绍了一个简单的接口认证方案，适用于不需要基于用户角色进行授权的场景。如果有较复杂的授权需求，则还是基于Shiro， Spring Security， OAuth2等框架来实现。这里也可以不用JWT，但是需要自己去做一些处理，比如将userId以某种形式包含在token中，解析时取出。<br>本文完整实例代码：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-simpleauth" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-simpleauth</a><br><br><br><img src="/assets/card-2.png" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般服务的安全包括认证（Authentication）与授权（Authorization）两部分，认证即证明一个用户是合法的用户，比如通过用户名密码的形式，授权则是控制某个用户可以访问哪些资源。比较成熟的框架有Shiro、Spring Security，如果要实现第三方授权模式，则可采用OAuth2。但如果是一些简单的应用，比如一个只需要鉴别用户是否登录的APP，则可以简单地通过注解+拦截器的方式来实现。本文介绍了具体实现过程，虽基于Spring Boot实现，但稍作修改（主要是拦截器配置）就可以引入其它Spring MVC的项目。&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
</feed>
