<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半路雨歌</title>
  
  <subtitle>Sing In The Storm</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jboost.cn/"/>
  <updated>2021-01-25T04:54:03.481Z</updated>
  <id>http://blog.jboost.cn/</id>
  
  <author>
    <name>雨歌</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写一个自己的脚手架——权限管理篇</title>
    <link href="http://blog.jboost.cn/framework-auth.html"/>
    <id>http://blog.jboost.cn/framework-auth.html</id>
    <published>2021-01-25T04:35:54.000Z</published>
    <updated>2021-01-25T04:54:03.481Z</updated>
    
    <content type="html"><![CDATA[<p>权限管理是每个项目必备的功能，只是各自要求的复杂程度不同，简单的项目可能一个 Filter 或 Interceptor 就解决了，复杂一点的就可能会引入安全框架，如 Shiro， Spring Security 等。<br>其中 Spring Security 因其涉及的流程、类过多，看起来比较复杂难懂而被诟病。但如果能捋清其中的关键环节、关键类，Spring Security 其实也没有传说中那么复杂。本文结合脚手架框架的权限管理实现（<code>jboost-auth</code> 模块），对 Spring Security 的认证、授权机制进行深入分析。</p><a id="more"></a><h3 id="使用-Spring-Security-认证、鉴权机制"><a href="#使用-Spring-Security-认证、鉴权机制" class="headerlink" title="使用 Spring Security 认证、鉴权机制"></a>使用 Spring Security 认证、鉴权机制</h3><p>Spring Security 主要实现了 Authentication（认证——你是谁？）、Authorization（鉴权——你能干什么？）</p><h3 id="认证（登录）流程"><a href="#认证（登录）流程" class="headerlink" title="认证（登录）流程"></a>认证（登录）流程</h3><p>Spring Security 的认证流程及涉及的主要类如下图，</p><p><img src="/assets/authentication.png" alt="SpringSecurity认证"></p><p>认证入口为 AbstractAuthenticationProcessingFilter，一般实现有 UsernamePasswordAuthenticationFilter</p><ol><li>filter 解析请求参数，将客户端提交的用户名、密码等封装为 Authentication，Authentication 一般实现有 UsernamePasswordAuthenticationToken</li><li>filter 调用 AuthenticationManager 的 <code>authenticate()</code> 方法对 Authentication 进行认证，AuthenticationManager 的默认实现是<br>ProviderManager</li><li>ProviderManager 认证时，委托给一个 AuthenticationProvider 列表，调用列表中 AuthenticationProvider 的 <code>authenticate()</code><br>方法来进行认证，只要有一个通过，则认证成功，否则抛出 AuthenticationException 异常（AuthenticationProvider 还有一个 <code>supports()</code> 方法，用来判断该 Provider<br>是否对当前类型的 Authentication 进行认证）</li><li>认证完成后，filter 通过 AuthenticationSuccessHandler（成功时） 或 AuthenticationFailureHandler（失败时）来对认证结果进行处理，如返回 token 或 认证错误提示  </li></ol><h3 id="认证涉及的关键类"><a href="#认证涉及的关键类" class="headerlink" title="认证涉及的关键类"></a>认证涉及的关键类</h3><ol><li>登录认证入口 UsernamePasswordAuthenticationFilter</li></ol><p>项目中 RestAuthenticationFilter 继承了 UsernamePasswordAuthenticationFilter， UsernamePasswordAuthenticationFilter 将客户端提交的参数封装为<br>UsernamePasswordAuthenticationToken，供 AuthenticationManager 进行认证。</p><p>RestAuthenticationFilter 覆写了 UsernamePasswordAuthenticationFilter 的 <code>attemptAuthentication(request,response)</code> 方法逻辑，根据<br>loginType 的值来将登录参数封装到认证信息 Authentication 中，（loginType 为 USER 时为 UsernameAuthenticationToken，<br>loginType 为 Phone 时为 PhoneAuthenticationToken），供下游 AuthenticationManager 进行认证。</p><ol start="2"><li>认证信息 Authentication</li></ol><p>使用 Authentication 的实现来保存认证信息，一般为 UsernamePasswordAuthenticationToken，包括</p><ul><li>principal：身份主体，通常是用户名或手机号</li><li>credentials：身份凭证，通常是密码或手机验证码</li><li>authorities：授权信息，通常是角色 Role</li><li>isAuthenticated：认证状态，表示是否已认证</li></ul><p>本项目中的 Authentication 实现：</p><ul><li><p>UsernameAuthenticationToken： 使用用户名登录时封装的 Authentication</p><ul><li>principal =&gt; username</li><li>credentials =&gt; password</li><li>扩展了两个属性： uuid， code，用来验证图形验证码</li></ul></li><li><p>PhoneAuthenticationToken： 使用手机验证码登录时封装的 Authentication</p><ul><li>principal =&gt; phone（手机号）</li><li>credentials =&gt; code（验证码）</li></ul></li></ul><p>两者都继承了 UsernamePasswordAuthenticationToken。</p><ol start="3"><li>认证管理器 AuthenticationManager</li></ol><p>认证管理器接口 AuthenticationManager，包含一个 <code>authenticate(authentication)</code> 方法。<br>ProviderManager 是 AuthenticationManager 的实现，管理一个 AuthenticationProvider（具体认证逻辑提供者）列表。在其 <code>authenticate(authentication)</code> 方法中，对 AuthenticationProvider 列表中每一个 AuthenticationProvider，调用其 <code>supports(Class&lt;?&gt; authentication)</code> 方法来判断是否采用该<br>Provider 来对 Authentication 进行认证，如果适用则调用 AuthenticationProvider 的 <code>authenticate(authentication)</code><br>来完成认证，只要其中一个完成认证，则返回。</p><ol start="4"><li>认证提供者 AuthenticationProvider</li></ol><p>由3可知认证的真正逻辑由 AuthenticationProvider 提供，本项目的认证逻辑提供者包括</p><ul><li>UsernameAuthenticationProvider： 支持对 UsernameAuthenticationToken 类型的认证信息进行认证。同时使用 PasswordRetryUserDetailsChecker<br>来对密码错误次数超过5次的用户，在10分钟内限制其登录操作</li><li>PhoneAuthenticationProvider： 支持对 PhoneAuthenticationToken 类型的认证信息进行认证</li></ul><p>两者都继承了 DaoAuthenticationProvider —— 通过 UserDetailsService 的 <code>loadUserByUsername(String username)</code> 获取保存的用户信息<br>UserDetails，再与客户端提交的认证信息 Authentication 进行比较（如与 UsernameAuthenticationToken 的密码进行比对），来完成认证。</p><ol start="5"><li>用户信息获取 UserDetailsService</li></ol><p>UserDetailsService 提供 <code>loadUserByUsername(username)</code> 方法，可获取已保存的用户信息（如保存在数据库中的用户账号信息）。</p><p>本项目的 UserDetailsService 实现包括</p><ul><li>UsernameUserDetailsService：通过用户名从数据库获取账号信息</li><li>PhoneUserDetailsService：通过手机号码从数据库获取账号信息</li></ul><ol start="6"><li>认证结果处理</li></ol><p>认证成功，调用 AuthenticationSuccessHandler 的 <code>onAuthenticationSuccess(request,response, authentication)</code> 方法，在 SecurityConfiguration 中注入 RestAuthenticationFilter 时进行了设置。 本项目中认证成功后，生成 jwt token返回客户端。</p><p>认证失败（账号校验失败或过程中抛出异常），调用 AuthenticationFailureHandler 的 <code>onAuthenticationFailure(request,response, exception)</code> 方法，在 SecurityConfiguration 中注入 RestAuthenticationFilter 时进行了设置，返回错误信息。</p><blockquote><p>以上关键类及其关联基本都在 SecurityConfiguration 进行配置。</p></blockquote><ol start="7"><li>工具类</li></ol><p>SecurityContextHolder 是 SecurityContext 的容器，默认使用 ThreadLocal 存储，使得在相同线程的方法中都可访问到 SecurityContext。<br>SecurityContext 主要是存储应用的 principal 信息，在 Spring Security 中用 Authentication 来表示。在<br>AbstractAuthenticationProcessingFilter 中，认证成功后，调用 <code>successfulAuthentication()</code> 方法使用 SecurityContextHolder 来保存<br>Authentication，并调用 AuthenticationSuccessHandler 来完成后续工作（比如返回token等）。</p><p>使用 SecurityContextHolder 来获取用户信息示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line"><span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails) &#123;</span><br><span class="line">    String username = ((UserDetails)principal).getUsername();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    String username = principal.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="鉴权流程"><a href="#鉴权流程" class="headerlink" title="鉴权流程"></a>鉴权流程</h3><p>Spring Security 的鉴权（授权）有两种实现机制：</p><ul><li>FilterSecurityInterceptor：通过 Filter 对 HTTP 资源的访问进行鉴权</li><li>MethodSecurityInterceptor：通过 AOP 对方法的调用进行鉴权。在 GlobalMethodSecurityConfiguration 中注入，<br>需要在配置类上添加注解 <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code> 使 GlobalMethodSecurityConfiguration 配置生效。</li></ul><p>鉴权流程及涉及的主要类如下图，</p><p><img src="/assets/authorization.png" alt="springsecurity鉴权"></p><ol><li>登录完成后，一般返回 token 供下次调用时携带进行身份认证，生成 Authentication</li><li>FilterSecurityInterceptor 拦截器通过 FilterInvocationSecurityMetadataSource 获取访问当前资源需要的权限</li><li>FilterSecurityInterceptor 调用鉴权管理器 AccessDecisionManager 的 decide 方法进行鉴权</li><li>AccessDecisionManager 通过 AccessDecisionVoter 列表的鉴权投票，确定是否通过鉴权，如果不通过则抛出 AccessDeniedException 异常</li><li>MethodSecurityInterceptor 流程与 FilterSecurityInterceptor 类似</li></ol><h3 id="鉴权涉及的关键类"><a href="#鉴权涉及的关键类" class="headerlink" title="鉴权涉及的关键类"></a>鉴权涉及的关键类</h3><ol><li>认证信息提取 RestAuthorizationFilter</li></ol><p>对于前后端分离项目，登录完成后，接下来我们一般通过登录时返回的 token 来访问接口。</p><p>在鉴权开始前，我们需要将 token 进行验证，然后生成认证信息 Authentication 交给下游进行鉴权（授权）。</p><p>本项目 RestAuthorizationFilter 将客户端上报的 jwt token 进行解析，得到 UserDetails， 并对 token 进行有效性校验，并生成<br>Authentication（UsernamePasswordAuthenticationToken），通过<br>SecurityContextHolder 存入 SecurityContext 中供下游使用。 </p><ol start="2"><li>鉴权入口 AbstractSecurityInterceptor</li></ol><p>三个实现：</p><ul><li>FilterSecurityInterceptor：基于 Filter 的鉴权实现，作用于 Http 接口层级。FilterSecurityInterceptor 从 SecurityMetadataSource 的实现 DefaultFilterInvocationSecurityMetadataSource 获取要访问资源所需要的权限<br>Collection<ConfigAttribute>，然后调用 AccessDecisionManager 进行授权决策投票，若投票通过，则允许访问资源，否则将禁止访问。</li><li>MethodSecurityInterceptor：基于 AOP 的鉴权实现，作用于方法层级。</li><li>AspectJMethodSecurityInterceptor：用来支持 AspectJ JointPoint 的 MethodSecurityInterceptor</li></ul><ol start="3"><li>获取资源权限信息 SecurityMetadataSource </li></ol><p>SecurityMetadataSource 读取访问资源所需的权限信息，读取的内容，就是我们配置的访问规则，如我们在配置类中配置的访问规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .antMatchers(excludes).anonymous()</span><br><span class="line">        .antMatchers(<span class="string">"/api1"</span>).hasAuthority(<span class="string">"permission1"</span>)</span><br><span class="line">        .antMatchers(<span class="string">"/api2"</span>).hasAuthority(<span class="string">"permission2"</span>)</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以自定义一个 SecurityMetadataSource 来从数据库或其它存储中获取资源权限规则信息。</p><ol start="4"><li>鉴权管理器 AccessDecisionManager</li></ol><p>AccessDecisionManager 接口的 <code>decide(authentication, object, configAttributes)</code> 方法对本次请求进行鉴权，其中</p><ul><li>authentication：本次请求的认证信息，包含 authority（如角色） 信息</li><li>object：当前被调用的被保护对象，如接口</li><li>configAttributes：与被保护对象关联的配置属性，表示要访问被保护对象需要满足的条件，如角色</li></ul><p>AccessDecisionManager 接口的实现者鉴权时，最终是通过调用其内部 <code>List&lt;AccessDecisionVoter&lt;?&gt;&gt;</code> 列表中每一个元素的 <code>vote(authentication, object, attributes)</code><br>方法来进行的，根据决策的不同分为如下三种实现</p><ul><li>AffirmativeBased：一票通过权策略。只要有一个 AccessDecisionVoter 通过（<code>AccessDecisionVoter.vote</code> 返回 AccessDecisionVoter.<br> ACCESS_GRANTED），则鉴权通过。为默认实现</li><li>ConsensusBased：少数服从多数策略。多数 AccessDecisionVoter 通过，则鉴权通过，如果赞成票与反对票相等，则根据变量 allowIfEqualGrantedDeniedDecisions<br> 的值来决定，该值默认为 true</li><li>UnanimousBased：全票通过策略。所有 AccessDecisionVoter 通过或弃权（返回 AccessDecisionVoter.<br> ACCESS_ABSTAIN），无一反对则通过，只要有一个反对就拒绝；如果全部弃权，则根据变量 allowIfAllAbstainDecisions 的值来决定，该值默认为 false</li></ul><ol start="5"><li>鉴权投票者 AccessDecisionVoter</li></ol><p>与 AuthenticationProvider 类似，AccessDecisionVoter 也包含 <code>supports(attribute)</code> 方法（是否采用该 Voter 来对请求进行鉴权投票） 与 <code>vote(authentication, object, attributes)</code> 方法（具体的鉴权投票逻辑）</p><p>FilterSecurityInterceptor 的 AccessDecisionManager 的投票者列表（AbstractInterceptUrlConfigurer.createFilterSecurityInterceptor() 中设置）包括：</p><ul><li>WebExpressionVoter：验证 Authentication 的 authenticated。</li></ul><p>MethodSecurityInterceptor 的 AccessDecisionManager 的投票者列表（GlobalMethodSecurityConfiguration.accessDecisionManager()<br>中设置）包括：</p><ul><li>PreInvocationAuthorizationAdviceVoter： 如果 @EnableGlobalMethodSecurity 注解开启了 prePostEnabled，则添加该 Voter，对使用了 @PreAuthorize 注解的方法进行鉴权投票</li><li>Jsr250Voter：如果 @EnableGlobalMethodSecurity 注解开启了 jsr250Enabled，则添加该 Voter，对 @Secured 注解的方法进行鉴权投票</li><li>RoleVoter：总是添加, 如果 <code>ConfigAttribute.getAttribute()</code> 以 <code>ROLE_</code> 开头，则参与鉴权投票</li><li>AuthenticatedVoter：总是添加，如果 <code>ConfigAttribute.getAttribute()</code> 值为<br><code>IS_AUTHENTICATED_FULLY</code>，<code>IS_AUTHENTICATED_REMEMBERED</code>，<code>IS_AUTHENTICATED_ANONYMOUSLY</code> 其中一个，则参与鉴权投票</li></ul><ol start="6"><li>鉴权结果处理</li></ol><p>ExceptionTranslationFilter 异常处理 Filter， 对认证鉴权过程中抛出的异常进行处理，包括：</p><ul><li>authenticationEntryPoint： 对过滤器链中抛出 AuthenticationException 或 AccessDeniedException 但 Authentication 为<br>AnonymousAuthenticationToken 的情况进行处理。如果 token 校验失败，如 token 错误或过期，则通过 ExceptionTranslationFilter 的 AuthenticationEntryPoint 进行处理，本项目使用 RestAuthenticationEntryPoint 来返回统一格式的错误信息</li><li>accessDeniedHandler： 对过滤器链中抛出 AccessDeniedException 但 Authentication 不为 AnonymousAuthenticationToken 的情况进行处理，本项目使用 RestAccessDeniedHandler 来返回统一格式的错误信息</li></ul><blockquote><p>如果是 MethodSecurityInterceptor 鉴权时抛出 AccessDeniedException，并且通过 @RestControllerAdvice 提供了统一异常处理，则将由统一异常处理类处理，因为<br>MethodSecurityInterceptor 是 AOP 机制，可由 @RestControllerAdvice 捕获。</p></blockquote><p>本项目中， RestAuthorizationFilter 在 Filter 链中位于 ExceptionTranslationFilter 的前面，所以其中抛出的异常也不能被 ExceptionTranslationFilter 捕获， 由 cn.jboost.base.starter.web.ExceptionHandlerFilter 捕获处理。</p><p>也可以将 RestAuthorizationFilter 放入 ExceptionTranslationFilter 之后，但在 RestAuthorizationFilter 中需要对 <code>SecurityContextHolder.getContext().getAuthentication()</code> 进行 AnonymousAuthenticationToken 的判断，因为 AnonymousAuthenticationFilter 位于 ExceptionTranslationFilter 前面，会对 Authentication 为空的请求生成一个<br>AnonymousAuthenticationToken，放入 SecurityContext 中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安全框架一般包括认证与授权两部分，认证解决你是谁的问题，即确定你是否有合法的访问身份，授权解决你是否有权限访问对应资源的问题。Spring Security 使用 Filter 来实现认证，使用 Filter（接口层级） + AOP（方法层级）的方式来实现授权。本文相对偏理论，但也结合了脚手架中的实现，对照查看，应该更易理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;权限管理是每个项目必备的功能，只是各自要求的复杂程度不同，简单的项目可能一个 Filter 或 Interceptor 就解决了，复杂一点的就可能会引入安全框架，如 Shiro， Spring Security 等。&lt;br&gt;其中 Spring Security 因其涉及的流程、类过多，看起来比较复杂难懂而被诟病。但如果能捋清其中的关键环节、关键类，Spring Security 其实也没有传说中那么复杂。本文结合脚手架框架的权限管理实现（&lt;code&gt;jboost-auth&lt;/code&gt; 模块），对 Spring Security 的认证、授权机制进行深入分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Framework" scheme="http://blog.jboost.cn/categories/Framework/"/>
    
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>写一个自己的脚手架——单体应用篇</title>
    <link href="http://blog.jboost.cn/framework-boot.html"/>
    <id>http://blog.jboost.cn/framework-boot.html</id>
    <published>2021-01-21T06:20:51.000Z</published>
    <updated>2021-01-22T09:55:56.212Z</updated>
    
    <content type="html"><![CDATA[<p>接上一篇 <a href="/framework-base.html">写一个自己的脚手架——基础组件篇</a>，本篇为基于基础组件搭建的单体应用框架介绍。单体应用框架提供常见的一些基础通用功能实现，目前主要为权限管理，提供前后端分离的后端 Spring Boot 项目与前端 Vue 项目。</p><p>本项目还在持续完善中。</p><a id="more"></a><h3 id="后端-Spring-Boot-项目"><a href="#后端-Spring-Boot-项目" class="headerlink" title="后端 Spring Boot 项目"></a>后端 Spring Boot 项目</h3><p>依赖基础组件项目：<a href="https://github.com/ronwxy/jboost-base" target="_blank" rel="noopener">https://github.com/ronwxy/jboost-base</a></p><p>目前包含模块：</p><ol><li><p>jboost-auth： 权限管理，</p><p>包含基本功能：</p><ul><li>登录、鉴权</li><li>用户管理</li><li>角色管理</li><li>部门管理</li><li>菜单管理</li></ul></li><li><p>jboost-bootstrap： 项目启动入口</p><p>目前暂无其它功能</p></li></ol><p>开发规范</p><ol><li><p>模块命名使用 <code>jboost-模块名</code>，如 <code>jboost-auth</code></p></li><li><p>模块根包命名使用 <code>cn.jboost.boot.模块名</code> 开头，如 <code>cn.jboost.boot.auth</code></p><p>但 <code>jboost-bootstrap</code> 模块根包名为 <code>cn.jboost.boot</code>，便于启动类扫描整个项目</p></li><li><p>各模块包含基本结构：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- controller    </span><br><span class="line">-- mapper   </span><br><span class="line">-- pojo       </span><br><span class="line">   -- dto</span><br><span class="line">      -- converter  </span><br><span class="line">   -- entity</span><br><span class="line">   -- query </span><br><span class="line">-- service</span><br></pre></td></tr></table></figure><ol start="4"><li><p>Service 层对于只有一个实现的，无需定义 Interface</p></li><li><p>包名、类名都使用单数形式，如 User， 而不是 Users</p></li></ol><p>以上代码结构可使用 jboost-base 中的 jboost-generator 生成，生成配置参考项目 <code>resource/generator.yaml</code> 中的注释说明。</p><h3 id="前端-Vue-项目"><a href="#前端-Vue-项目" class="headerlink" title="前端 Vue 项目"></a>前端 Vue 项目</h3><p>基于 <a href="http://panjiachen.github.io/vue-admin-template" target="_blank" rel="noopener">vue-admin-template</a> 搭建</p><blockquote><p>vue-admin-template 是一个极简的 vue admin 管理后台。它只包含了 Element UI &amp; axios &amp; iconfont &amp; permission control &amp; lint，这些搭建后台必要的东西。</p></blockquote><p>项目包含基本的登录，含用户名登录与手机验证码登录（需自行配置 sms 服务），登录页效果如图</p><p><img src="/assets/jboost-admin-1.png" alt="jboost-admin-login"></p><p>及基本的系统管理功能，如下图所示</p><p><img src="/assets/jboost-admin-2.png" alt="jboost-admin-main"></p><p>项目的运行及打包可参考项目的 README 文档。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单体应用框架包含一个系统常用的基础功能，基于此可进行其它业务模块开发，提高开发效率。本文对单体应用框架的前后端项目进行了简单介绍，目前项目只包含基本的权限管理功能，其它基础功能待持续完善。因水平有限，疏漏、错误之处难免，欢迎指正。</p><p>单体应用框架项目源码： </p><ul><li>服务端： <a href="https://github.com/ronwxy/jboost-boot.git" target="_blank" rel="noopener">https://github.com/ronwxy/jboost-boot.git</a></li><li>Web端： <a href="https://github.com/ronwxy/jboost-admin.git" target="_blank" rel="noopener">https://github.com/ronwxy/jboost-admin.git</a> </li></ul><p>如对你有帮助，可以大方地 star 一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上一篇 &lt;a href=&quot;/framework-base.html&quot;&gt;写一个自己的脚手架——基础组件篇&lt;/a&gt;，本篇为基于基础组件搭建的单体应用框架介绍。单体应用框架提供常见的一些基础通用功能实现，目前主要为权限管理，提供前后端分离的后端 Spring Boot 项目与前端 Vue 项目。&lt;/p&gt;
&lt;p&gt;本项目还在持续完善中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Framework" scheme="http://blog.jboost.cn/categories/Framework/"/>
    
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>写一个自己的脚手架——基础组件篇</title>
    <link href="http://blog.jboost.cn/framework-base.html"/>
    <id>http://blog.jboost.cn/framework-base.html</id>
    <published>2021-01-15T10:44:57.000Z</published>
    <updated>2021-01-16T03:51:39.070Z</updated>
    
    <content type="html"><![CDATA[<p>现在很多 Web 项目，包括普通的前后端分离项目，微服务项目，都基于 Spring Boot 搭建，项目中一般需要包含一些通用的特性或功能，如统一异常处理、切面日志功能、权限管理功能等。写一个自己的脚手架，对一些基本规范、基础功能进行沉淀，基于此可只需要关注业务实现，提高开发效率。</p><p>目前整个脚手架包含三部分：</p><ol><li>基础组件：对单个项目（服务）的一些基本特性、功能等进行封装，便于复用，或达到常说的“开箱即用”</li><li>Spring Boot 单体项目脚手架：基于基础组件，提供常见的一些基础通用功能实现的单体项目框架，如权限管理，提供前后端分离的后端 Spring Boot 项目与前端 Vue 项目</li><li>Spring Cloud（包含 Spring Cloud Alibaba）微服务项目框架：基于基础组件，提供微服务框架的基础组件与功能实现，如网关（Spring Cloud Gateway），服务注册中心与配置管理（Nacos），服务限流降级（Sentinel），统一权限管理（Spring Security Oauth2）等。</li></ol><p>本项目还在持续完善中，本篇为基础组件介绍。</p><a id="more"></a><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>基础组件提供</p><ol><li>jboost-common：基础工具类，常量类</li><li>jboost-dependencies：统一依赖版本管理</li><li>jboost-generator：代码生成，根据数据库表自动生成各层源代码</li><li>jboost-parent：父项目，集成了数据库、redis、统一异常处理、统一响应封装、切面日志等功能</li><li>jboost-starters：常用功能 starter<ol><li>jboost-starter-alimq：阿里 RocketMq 消息队列</li><li>jboost-starter-alioss：阿里云对象服务，上传图片、视频等</li><li>jboost-starter-alisms：阿里短信服务</li><li>jboost-starter-error：统一异常处理</li><li>jboost-starter-limiter：基于 Redis 的分布式锁，基于 Guava RateLimiter（令牌桶算法）的限速，及基于 Redis Lua 的限量（时间窗口内限制访问量）实现</li><li>jboost-starter-logging：切面日志功能</li><li>jboost-starter-web：日期格式化、跨域、添加请求ID、请求响应封装、Swagger集成等</li></ol></li></ol><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ronwxy/jboost-base.git</span><br><span class="line">cd jboost-base</span><br><span class="line"><span class="meta">#</span><span class="bash">安装到本地</span></span><br><span class="line">mvn clean install </span><br><span class="line"><span class="meta">#</span><span class="bash">部署到maven仓库</span></span><br><span class="line"><span class="meta">#</span><span class="bash">mvn clean deploy</span></span><br></pre></td></tr></table></figure><h3 id="jboost-common"><a href="#jboost-common" class="headerlink" title="jboost-common"></a>jboost-common</h3><p>基础类库，包括工具类，常量类等</p><h4 id="Bean-转换"><a href="#Bean-转换" class="headerlink" title="Bean 转换"></a>Bean 转换</h4><p>BaseConverter： Bean 转换，主要用于 entity 与 dto 之间的转换，使用 MapStruct 框架。</p><p>针对需要转换的 Bean，创建相应接口，示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = BaseConverter.SPRING,uses = &#123;&#125;,unmappedTargetPolicy = ReportingPolicy.IGNORE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserConverter</span> <span class="keyword">extends</span> <span class="title">BaseConverter</span>&lt;<span class="title">User</span>, <span class="title">UserDTO</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常定义"><a href="#异常定义" class="headerlink" title="异常定义"></a>异常定义</h4><ol><li>BizException： 业务异常基类</li><li>ClientSideException： 客户端异常，如参数错误</li><li>UnauthorizedException： 鉴权失败异常，如token过期</li><li>ForbiddenException： 访问受限异常，如访问资源未授权</li><li>ServerSideException： 服务端异常，服务端内部操作异常，如数据库访问出错</li><li>ExceptionUtil： 异常工具类</li></ol><p>业务中处理异常有两种形式。</p><ol><li>根据条件抛出异常，交由统一异常处理机制处理（如记录日志，返回客户端错误提示）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User existUser = findUserByName(name);</span><br><span class="line"><span class="keyword">if</span> (existUser != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ExceptionUtil.rethrowClientSideException(<span class="string">"用户名已存在"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>捕获异常后重新抛出异常，交由统一异常处理机制处理（如记录日志，返回客户端错误提示）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    aliSmsProvider.sendVerifyCode(phone, verifyCode.getCode());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException ex) &#123;</span><br><span class="line">    ExceptionUtil.rethrowServerSideException(<span class="string">"发送验证码失败，请稍后重试"</span>, ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息队列抽象"><a href="#消息队列抽象" class="headerlink" title="消息队列抽象"></a>消息队列抽象</h4><p>使用消息队列的地方可以基于该接口与消息对象调用，屏蔽具体消息中间件信息</p><ul><li>MqMessage：消息对象，自身包含 topic, tag, key 等信息</li><li>IMqProducer：消息生产者接口，使用具体消息中间件时，生产者服务实现该接口</li></ul><h4 id="其它工具与常量类"><a href="#其它工具与常量类" class="headerlink" title="其它工具与常量类"></a>其它工具与常量类</h4><p>安全相关：</p><ol><li>EncryptUtil：RSA非对称加密（公钥/私钥）工具类</li><li>JwtUser：用于 Spring Security 认证的 user bean</li><li>JwtUtil：Jwt 工具类</li><li>SecurityUtil：Security 工具类，可获取当前登录用户的相关信息</li></ol><p>其它：</p><ol><li>EasyPoiUtil：文件上传工具类</li><li>FileUtil：文件操作工具类</li><li>LocalDateTimeUtil：日期工具类</li><li>MyBatisUtil：可用于 mybatis xml 文件条件判断的工具类</li><li>ResponseWrapper：客户端响应封装</li><li>VerifyCodeUtil：图形验证码工具类</li><li>WebUtil：Web工具类，设置req-id；获取客户端IP；输出响应</li></ol><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>jboost-dependencies：依赖版本管理，管理常用依赖库的版本，其它继承或以 <code>dependencyManagement</code> 引入 jboost-dependencies 的项目引用依赖时可省略版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboost-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>jboost-generator： 代码生成工具，采用 mybatis-plus-generator 实现，配置详见 <code>resource/generator.yaml</code> 文件示例</p><p>针对每个数据库表，可生成如下代码结构</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">--controller</span></span><br><span class="line">    <span class="string">UserController.java</span></span><br><span class="line"><span class="string">--mapper</span></span><br><span class="line">    <span class="string">UserMapper.java</span></span><br><span class="line"><span class="string">--pojo</span></span><br><span class="line"><span class="string">----dto</span></span><br><span class="line"><span class="string">------converter</span></span><br><span class="line">        <span class="string">UserConverter.java</span></span><br><span class="line">      <span class="string">UserDTO.java</span></span><br><span class="line"><span class="string">----entity</span></span><br><span class="line">      <span class="string">UserEntity.java</span></span><br><span class="line"><span class="string">----query</span></span><br><span class="line">      <span class="string">UserQuery.java</span></span><br><span class="line"><span class="string">--service</span></span><br><span class="line">    <span class="string">UserService.java</span></span><br></pre></td></tr></table></figure><h3 id="父项目"><a href="#父项目" class="headerlink" title="父项目"></a>父项目</h3><p>jboost-parent：父项目，集成了数据库、redis、统一异常处理、统一响应封装、切面日志等功能</p><h3 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h3><p>jboost-starters</p><h4 id="jboost-starter-alimq"><a href="#jboost-starter-alimq" class="headerlink" title="jboost-starter-alimq"></a>jboost-starter-alimq</h4><p>阿里 RocketMq 消息队列使用示例</p><ol><li><p>项目 pom.xml 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboost-starter-alimq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.yaml 文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">rocketmq:</span></span><br><span class="line">    <span class="attr">accessKey:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">namesrvAddr:</span> <span class="string">http://xxx.mqrest.cn-hangzhou.aliyuncs.com</span></span><br><span class="line">    <span class="attr">sendMsgTimeoutMillis:</span> <span class="number">3000</span></span><br><span class="line">    <span class="comment">#topic 所属实例ID</span></span><br><span class="line">    <span class="attr">instanceId:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">groupId:</span> <span class="string">xxxx</span></span><br></pre></td></tr></table></figure></li><li><p>使用生产者发送消息（RocketMqAutoConfiguration 已配置了本地开发测试环境走HTTP协议 RocketMqRemoteProducer，云端生产环境走TCP协议 RocketMqInternalProducer）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;socket.mq.topic&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String socketMqTopic;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;socket.mq.tag&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String socketMqTag;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IMqProducer mqProducer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noticeWeb</span><span class="params">(String macAddress, String data)</span> </span>&#123;</span><br><span class="line">    SocketMqMessage socketMqMessage = <span class="keyword">new</span> SocketMqMessage(macAddress, data);</span><br><span class="line">    mqProducer.sendMessage(<span class="keyword">new</span> MqMessage(socketMqTopic, socketMqTag, SocketMQCommandEnum.noticeWebChannel.getCode(), socketMqMessage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>消息消费者</li></ol><h4 id="jboost-starter-alioss"><a href="#jboost-starter-alioss" class="headerlink" title="jboost-starter-alioss"></a>jboost-starter-alioss</h4><p>阿里云对象服务，上传图片、视频等</p><ol><li><p>项目 pom.xml 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboost-starter-alioss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.yaml 文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">oss:</span></span><br><span class="line">    <span class="attr">accessKeyId:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">accessKeySecret:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">bucket:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">domain:</span> <span class="string">http://xxx.oss-cn-hangzhou.aliyuncs.com/</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">https://oss-cn-hangzhou.aliyuncs.com</span></span><br></pre></td></tr></table></figure></li><li><p>使用 AliOssProvider 来上传文件，或对文件路径进行签名（针对需要授权访问的资源）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AliOssProvider aliOssProvider;</span><br><span class="line"><span class="comment">//保存文件</span></span><br><span class="line"><span class="function">String <span class="title">fileSave</span><span class="params">(String bizType, File file, String fileName)</span></span>;</span><br><span class="line"><span class="comment">//url签名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signUrl</span><span class="params">(List&lt;T&gt; list, List&lt;String&gt; urlFields, String bucketName, <span class="keyword">long</span> expire)</span></span></span><br></pre></td></tr></table></figure><p>更多方法参考 <code>cn.jboost.base.starter.alioss.AliOssProvider</code></p><h4 id="jboost-starter-alisms"><a href="#jboost-starter-alisms" class="headerlink" title="jboost-starter-alisms"></a>jboost-starter-alisms</h4><p>阿里短信服务</p><ol><li>项目 pom.xml 中引入依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboost-starter-alisms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>application.yaml 中添加配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="comment">#阿里短信</span></span><br><span class="line">  <span class="attr">sms:</span></span><br><span class="line">    <span class="attr">accessKeyId:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">accessKeySecret:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">signName:</span> <span class="string">签名</span></span><br><span class="line">    <span class="attr">templateCode:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">regionId:</span> <span class="string">xxxx</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AliSmsProvider aliSmsProvider;</span><br><span class="line"><span class="comment">//发送验证码</span></span><br><span class="line">aliSmsProvider.sendVerifyCode(phone, verifyCode.getCode());</span><br><span class="line"><span class="comment">//发送短信,支持以逗号分隔的形式进行批量调用，批量上限为20个手机号码,批量调用相对于单条调用及时性稍有延迟,验证码类型的短信推荐使用单条调用的方式</span></span><br><span class="line">aliSmsProvider.sendSms(String phoneNumber, String signName, String smsTempCode, String tempParam)</span><br></pre></td></tr></table></figure><h4 id="jboost-starter-error"><a href="#jboost-starter-error" class="headerlink" title="jboost-starter-error"></a>jboost-starter-error</h4><p>统一异常处理</p><ol><li>项目 pom.xml 中引入依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboost-starter-error<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 @RestControllerAdvice + @ExceptionHandler 统一处理抛出的异常</li></ol><ul><li>BizException：以 400 返回异常消息</li><li>AccessDeniedException：以 403 返回异常消息</li><li>IllegalArgumentException，IllegalStateException：以 400 返回异常消息</li><li>Exception： 以 500 返回异常消息</li></ul><ol start="3"><li>打印异常栈</li></ol><ul><li>针对 profile “default”,”local”,”dev”， 打印异常栈；</li><li>针对 profile “test”, “formal”, “prod”，不打印异常栈。</li></ul><blockquote><p><code>org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController</code> 现在通过 request 传 trace=true 参数的方式来控制是否打印异常栈，后续可做相应调整</p></blockquote><h4 id="jboost-starter-limiter"><a href="#jboost-starter-limiter" class="headerlink" title="jboost-starter-limiter"></a>jboost-starter-limiter</h4><p>提供基于 Redis 的分布式锁，基于 Guava RateLimiter（令牌桶算法） 的限速，及基于 Redis Lua 的限量实现</p><ol><li><p>项目 pom.xml 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboost-starter-limiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分布式锁<br>在方法上添加注解 @DistributedLockable，对方法进行分布式环境下的同步，</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DistributedLockable</span>(key=<span class="string">""</span>, prefix=<span class="string">"disLock:"</span>, expire=<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncDistributed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>key：redis 使用 prefix+key 来作为缓存key</li><li>prefix：redis key 前缀，默认为 <code>disLock:</code></li><li>expire：过期时间，默认为10s</li></ul><ol start="3"><li>限流</li></ol><p>限速：使用 @RateLimit 注解严格控制访问速率，在一次访问后，必须经过设定的时间间隔才能进行下一次访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/rate"</span>)</span><br><span class="line"><span class="meta">@RateLimit</span>(rate = <span class="number">1.0</span>/<span class="number">5</span>, burst = <span class="number">5.0</span>, expire = <span class="number">120</span>, timeout = <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">rateLimit</span><span class="params">(@RequestParam(<span class="string">"key"</span>)</span> String key)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test rate limiter..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例表示以限制访问速度为5秒1次，一次访问后，直到5s之后才能再次访问。</p><p>支持的属性配置：</p><ul><li>key： redis 使用 prefix+key 来作为缓存 key</li><li>prefix：redis key 前缀， 默认为 “rateLimit:”;</li><li>expire：表示令牌桶模型 RedisPermits redis key 的过期时间/秒，默认为 60; </li><li>rate：permitsPerSecond 值，表示以每秒rate的速率放置令牌，默认为 1.0; </li><li>burst：maxBurstSeconds 值，表示最多保留burst秒的令牌，默认为 1.0;</li><li>timeout：取令牌的超时时间，秒，默认为 0，表示不等待立即返回;</li><li>limitType： 默认 LimitType.METHOD;</li></ul><p>LimitType 主要用于控制 key 的值，支持类型如下，</p><ul><li>IP：根据客户端IP限流</li><li>USER：根据用户限流，用户已经登录，通过<code>SecurityUtil.getUserId()</code>获取当前用户ID</li><li>METHOD：根据方法名全局限流</li><li>CUSTOM：自定义，需要设置 key 的值，自定义 key 支持表达式，如 <code>#{id}</code>, <code>#{user.id}</code></li></ul><p>限量：使用 @CountLimit 注解来控制在一个时间窗口内，允许访问的次数，在允许次数内对访问速率不限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/count"</span>)</span><br><span class="line"><span class="meta">@CountLimit</span>(key = <span class="string">"#&#123;key&#125;"</span>, limit = <span class="number">2</span>, period = <span class="number">10</span>, limitType = LimitType.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countLimit</span><span class="params">(@RequestParam(<span class="string">"key"</span>)</span> String key)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test count limiter..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例表示在10s内限制访问2次，至于这两次以什么样的时间间隔访问不做限制。</p><p>支持的属性配置：</p><ul><li>key：redis 使用 prefix+key 来作为缓存 key</li><li>prefix：key 前缀，默认 “countLimit:”; </li><li>limit：period 时间段内限制访问的次数，默认1;  </li><li>period：表示时间段/秒，默认1; </li><li>limitType： 默认 LimitType.METHOD;</li></ul><p>非注解形式限流：也可以使用如下形式对某段代码进行限流控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/rate2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRateLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RedisRateLimiter limiter = redisRateLimiterFactory.build(<span class="string">"LimiterController.testRateLimit"</span>, <span class="number">1.0</span>/<span class="number">30</span>, <span class="number">30</span>, <span class="number">120</span>);</span><br><span class="line">    <span class="keyword">if</span>(!limiter.tryAcquire(<span class="string">"app.limiter"</span>, <span class="number">0</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        ExceptionUtil.rethrowClientSideException(<span class="string">"您的访问过于频繁，请稍后重试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test rate limiter 2..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细内容参考 <a href="http://blog.jboost.cn/distributedratelimiter.html">一个轻量级的基于RateLimiter的分布式限流实现</a> </p><h4 id="jboost-starter-logging"><a href="#jboost-starter-logging" class="headerlink" title="jboost-starter-logging"></a>jboost-starter-logging</h4><p>切面日志功能</p><p>对用注解 <code>cn.jboost.base.starter.logging.annotation.Log</code> 修饰的类方法进行日志记录</p><ol><li><p>项目 pom.xml 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboost-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在方法或类上（对类内所有方法有效，一般用于 Controller 类上）添加注解 @Log，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.jboost.base.starter.logging.annotation.Log;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>日志打印<br>添加注解 @Log 后，当方法被调用时，默认将打印调用与返回日志，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jboost-boot - [2021-01-09 09:41:21] [http-nio-8000-exec-1] INFO  [5ff909c1a94b6d1f4c62f021 - ] c.j.b.auth.controller.AuthController - call: getCaptcha()</span><br><span class="line">jboost-boot - [2021-01-09 09:41:21] [http-nio-8000-exec-1] INFO  [5ff909c1a94b6d1f4c62f021 - 216] c.j.b.auth.controller.AuthController - return: getCaptcha():VerifyCodeUtil.VerifyCode(code=xqho, uuid=9d8ffc7e9e324ed2a5a9566d9a7f115d)</span><br></pre></td></tr></table></figure></li><li><p>其它配置</p></li></ol><p>@Log 注解提供了两个属性配置</p><ul><li>logPoint：可配置在什么位置打印日志，有 LogPoint.IN（调用时打印）, LogPoint.OUT（返回时打印）, LogPoint.BOTH（调用与返回时都打印）</li><li>logException：是否对异常进行日志记录，默认为true</li></ul><p>可对日志输出的实现进行定制化，默认使用 <code>cn.jboost.base.starter.logging.provider.Slf4jLogProvider</code>，采用项目中slf4j的框架进行输出，如logback,log4j2等。<br>如果要自定义日志输出，则可提供一个 <code>cn.jboost.base.starter.logging.provider.ILogProvider</code> 接口的实现类，然后配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aoplog:</span></span><br><span class="line">  <span class="attr">service-impl-class:</span> <span class="string">aop日志记录实现类，默认为</span> <span class="string">cn.jboost.base.starter.logging.service.Slf4jLogService</span></span><br><span class="line">  <span class="attr">collection-depth-threshold:</span> <span class="number">5</span>   <span class="comment">#集合类参数输出元素个数，默认为10</span></span><br></pre></td></tr></table></figure><h4 id="jboost-starter-web"><a href="#jboost-starter-web" class="headerlink" title="jboost-starter-web"></a>jboost-starter-web</h4><p>日期格式化、跨域、添加请求ID、请求响应封装、Swagger集成等</p><ol><li><p>项目 pom.xml 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboost-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>日期格式化（序列化与反序列化时）</p></li></ol><ul><li>LocalDateTime： <code>yyyy-MM-dd HH:mm:ss</code></li><li>LocalDate： <code>yyyy-MM-dd</code></li><li>LocalTime： <code>HH:mm:ss</code></li></ul><ol start="3"><li>跨域</li></ol><p>默认开启，如要关闭，配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">  <span class="attr">cors:</span> <span class="string">disable</span>  <span class="comment"># 关闭跨域</span></span><br></pre></td></tr></table></figure><ol start="4"><li>添加请求ID</li></ol><p>默认开启，如要关闭，配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">  <span class="attr">reqId:</span> <span class="string">disable</span> <span class="comment"># 关闭日志中加入请求id</span></span><br></pre></td></tr></table></figure><p>开启后，会在每一个请求的 Header 中添加 key 为 <code>Req-Id</code>， value 为 uuid 的 header，下游可通过 <code>WebUtil.getRequestId()</code> 获取（例如将其存入MDC中，在日志打印时输出请求ID，将日志进行串联）</p><ol start="5"><li>请求响应封装</li></ol><p>默认开启，如要关闭，配置（建议默认开启，如果关闭，还需要在异常处理中将响应格式进行处理）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">  <span class="attr">responseWrapper:</span> <span class="string">disable</span> <span class="comment"># 关闭响应消息封装</span></span><br></pre></td></tr></table></figure><p>开启后，对请求响应按照 <code>cn.jboost.base.common.util.ResponseWrapper</code> 的结构进行封装</p><ol start="6"><li>swagger集成</li></ol><p>默认关闭，如要开启，配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">swagger:</span></span><br><span class="line">  <span class="comment">#是否开启 swagger-ui</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#定义扫描包,可配置多条扫描包,包之间用逗号隔开</span></span><br><span class="line">  <span class="attr">basePackages:</span> <span class="string">cn.jboost</span></span><br><span class="line">  <span class="comment">#其它配置，可省略，使用默认配置</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">"服务端接口文档"</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">1.0</span></span><br><span class="line">  <span class="attr">tokenHeader:</span> <span class="string">Authorization</span></span><br></pre></td></tr></table></figure><p>建议只在开发环境（application-dev.yaml）中开启</p><ol start="7"><li>过滤器中异常处理</li></ol><p>主要是对响应结果进行封装统一： <code>cn.jboost.base.starter.web.ExceptionHandlerFilter</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基础组件是后续单体应用框架、微服务项目框架的基础。本文对基础组件目前提供的功能、特性进行了介绍，因水平有限，疏漏、错误之处难免，欢迎指正。<br>基础组件项目源码： <a href="https://github.com/ronwxy/jboost-base.git，" target="_blank" rel="noopener">https://github.com/ronwxy/jboost-base.git，</a> 如对你有帮助，可以大方地 star 一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在很多 Web 项目，包括普通的前后端分离项目，微服务项目，都基于 Spring Boot 搭建，项目中一般需要包含一些通用的特性或功能，如统一异常处理、切面日志功能、权限管理功能等。写一个自己的脚手架，对一些基本规范、基础功能进行沉淀，基于此可只需要关注业务实现，提高开发效率。&lt;/p&gt;
&lt;p&gt;目前整个脚手架包含三部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础组件：对单个项目（服务）的一些基本特性、功能等进行封装，便于复用，或达到常说的“开箱即用”&lt;/li&gt;
&lt;li&gt;Spring Boot 单体项目脚手架：基于基础组件，提供常见的一些基础通用功能实现的单体项目框架，如权限管理，提供前后端分离的后端 Spring Boot 项目与前端 Vue 项目&lt;/li&gt;
&lt;li&gt;Spring Cloud（包含 Spring Cloud Alibaba）微服务项目框架：基于基础组件，提供微服务框架的基础组件与功能实现，如网关（Spring Cloud Gateway），服务注册中心与配置管理（Nacos），服务限流降级（Sentinel），统一权限管理（Spring Security Oauth2）等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本项目还在持续完善中，本篇为基础组件介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Framework" scheme="http://blog.jboost.cn/categories/Framework/"/>
    
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（十）：配置管理，除了Config，还有Nacos</title>
    <link href="http://blog.jboost.cn/springcloud-10.html"/>
    <id>http://blog.jboost.cn/springcloud-10.html</id>
    <published>2020-12-12T07:26:21.000Z</published>
    <updated>2020-12-17T11:17:06.210Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Spring Cloud Config 我们可以实现配置的集中化管理，但 Spring Cloud Config 如果要实现配置的动态更新， 则需要借助 Spring Cloud Bus（参考 <a href="/spring-cloud-8.html">Spring Cloud（八）：使用Spring Cloud Bus来实现配置动态更新</a>）。 Nacos 不仅可作为服务注册中心，同时还可以作为配置的集中化管理中心，且其自身默认就支持动态更新，集成非常方便。</p><a id="more"></a><h2 id="Nacos-配置管理集成"><a href="#Nacos-配置管理集成" class="headerlink" title="Nacos 配置管理集成"></a>Nacos 配置管理集成</h2><ol><li>pom.xml 中添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>bootstrap.yaml 中添加配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span>  <span class="comment"># 默认是properties格式</span></span><br></pre></td></tr></table></figure><blockquote><p><code>spring.cloud.nacos.config.server-addr</code> 如果配置的是域名， 则端口不能省略， 即便是 80 端口也不能省略。</p></blockquote><ol start="3"><li>访问配置</li></ol><p>在程序中可通过 @Value 注解或 @ConfigurationProperties 修饰的类来访问配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;test.hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span>String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hello + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Nacos 默认是支持动态更新配置的，当你在控制台修改后，本地立即可获取到更新的配置，但如果需要程序动态更新，则仍需要在相应类上添加 @RefreshScope 注解</p></blockquote><ol start="4"><li>控制台添加配置</li></ol><p>在 Nacos 控制台“配置管理”中，可以针对项目添加配置，如图</p><p><img src="/assets/nacos-config-1.png" alt="nacos配置管理"></p><p>每一个配置通过 Group 与 DataId 来确定，Group 默认为 DEFAULT_GROUP（可通过 <code>spring.cloud.nacos.config.group</code> 指定）， 如图</p><p><img src="/assets/nacos-config-2.png" alt="nacos添加配置"></p><p>配置格式需要与前面配置的 <code>spring.cloud.nacos.config.file-extension</code> 一致，默认是 properties 格式。</p><p>配置支持 profile，<code>spring.profiles.active</code> 必须配置在 bootstrap.properties（yaml） 文件中。</p><p>启动项目时， 启动日志中能看到如下信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Located property source: [BootstrapPropertySource &#123;name='bootstrapProperties-robot-dev.yaml,DEFAULT_GROUP'&#125;, BootstrapPropertySource &#123;name='bootstrapProperties-robot.yaml,DEFAULT_GROUP'&#125;, BootstrapPropertySource &#123;name='bootstrapProperties-robot,DEFAULT_GROUP'&#125;]</span><br></pre></td></tr></table></figure><p>Nacos 默认会加载 DataId 为 {spring.application.name}-{spring.profiles.active}.yaml，{spring.application.name}.yaml，{spring.application.name} 的配置源，其中文件扩展名 yaml 与你配置有关，默认为 properties。配置优先级顺序为从前往后依次降低。</p><h2 id="动态更新"><a href="#动态更新" class="headerlink" title="动态更新"></a>动态更新</h2><p>Nacos 默认是支持动态更新配置，如果要禁用，可配置 <code>spring.cloud.nacos.config.refresh-enabled=false</code>。<br>如果需要程序不重启实现配置的动态更新，还需在相应类上添加 @RefreshScope 注解</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>Nacos 支持自定义 namespace， 在多租户环境中，或同一租户的不同环境中（如，开发环境、测试环境、生产环境）可以使用不同的 namespace 来进行配置隔离。</p><p>在 Nacos 控制台，我们可以根据需要添加命名空间，如图</p><p><img src="/assets/nacos-config-3.png" alt="Nacos命名空间"></p><p>然后在 bootstrap.yaml 中，针对不同的 profile， 指定不同的 namespace ID， 如下 dev 环境指定 namespace 名称为 dev 的 ID。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">1a743385-86e7-4405-b73f-0108df042710</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">1a743385-86e7-4405-b73f-0108df042710</span></span><br></pre></td></tr></table></figure><p>上述配置在服务以 <code>spring.profiles.active=dev</code> 启动后，将注册到 dev namespace 中，并从 dev namespace 中获取配置。</p><blockquote><p>如果<code>spring.cloud.nacos.config.namespace</code>未指定，则默认使用 Public</p></blockquote><h2 id="自定义-DataId"><a href="#自定义-DataId" class="headerlink" title="自定义 DataId"></a>自定义 DataId</h2><p>DataId 名称默认情况下从如下三个配置获取，</p><ol><li>spring.cloud.nacos.config.prefix</li><li>spring.cloud.nacos.config.name</li><li>spring.application.name</li></ol><p>首先取 prefix，如果没有则取 name， 最后才取 <code>spring.application.name</code>。</p><p>我们可以通过 extension-configs 来自定义 DataId， 示例如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 默认使用 DEFAULT_GROUP，不支持配置的动态更新 </span></span><br><span class="line"><span class="string">spring.cloud.nacos.config.extension-configs[0].data-id=ext-config-1.properties</span>  <span class="comment"># 可以配置多个data id，逗号隔开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 指定 Group，不支持配置的动态更新</span></span><br><span class="line"><span class="string">spring.cloud.nacos.config.extension-configs[1].data-id=ext-config-2.properties</span> </span><br><span class="line"><span class="string">spring.cloud.nacos.config.extension-configs[1].group=GLOBALE_GROUP</span>  <span class="comment"># 可以配置多个group</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 指定 Group，支持配置的动态更新</span></span><br><span class="line"><span class="string">spring.cloud.nacos.config.extension-configs[2].data-id=ext-config-3.properties</span> </span><br><span class="line"><span class="string">spring.cloud.nacos.config.extension-configs[2].group=REFRESH_GROUP</span> </span><br><span class="line"><span class="string">spring.cloud.nacos.config.extension-configs[2].refresh=true</span></span><br></pre></td></tr></table></figure><p>自定义 DataId 必须有文件扩展名（properties 或 yaml/yml），这与 <code>spring.cloud.nacos.config.file-extension</code> 配置的扩展名没什么干系。<br>自定义 DataId 默认不支持动态更新，需显示配置。<br>自定义 DataId 配置的优先级与 extension-configs[n] 中的 n 有关，n 越大， 优先级越高。</p><p>extension-configs 的 DataId 配置优先级与默认 DataId 的优先级要低。</p><p>我们将配置调整如下， </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">extension-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">ext-config-1.properties</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">ext-config-2.properties</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>重启服务，从启动日志中我们也可以看到配置的优先级顺序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Located property source: [BootstrapPropertySource &#123;name='bootstrapProperties-robot-dev.yaml,DEFAULT_GROUP'&#125;, BootstrapPropertySource &#123;name='bootstrapProperties-robot.yaml,DEFAULT_GROUP'&#125;, BootstrapPropertySource &#123;name='bootstrapProperties-robot,DEFAULT_GROUP'&#125;, BootstrapPropertySource &#123;name='bootstrapProperties-ext-config-2.properties,DEFAULT_GROUP'&#125;, BootstrapPropertySource &#123;name='bootstrapProperties-ext-config-1.properties,DEFAULT_GROUP'&#125;]</span><br></pre></td></tr></table></figure><ol><li>robot-dev.yaml</li><li>robot.yaml</li><li>robot</li><li>ext-config-2.properties</li><li>ext-config-1.properties</li></ol><p>从上到下优先级依次降低。</p><h2 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h2><p>自定义的 data id 可以在多个应用之间共享配置，或一个应用使用多个配置，共享配置与自定义配置类似，只需将 extension-configs 改为 shared-configs，如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">extension-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">ext-config-1.properties</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">commom.properties</span></span><br></pre></td></tr></table></figure><p>shared-configs 配置中， 后面的优于前面的；shared-configs 的 data id 也必须有扩展名，<code>spring.cloud.nacos.config.file-extension</code> 定义的扩展名对它没什么影响。</p><p>从启动日志中我们也可以看到共享 DataId 配置（shared-configs）的优先级低于自定义 DataId 配置（extension-configs）。</p><p>extension-configs 与 shared-configs 配置对应 <code>com.alibaba.cloud.nacos.NacosConfigProperties.Config</code> 类，支持三个属性：</p><ol><li>dataId：DataId 名称</li><li>group： DataId 所在的 Group，默认为 DEFAULT_GROUP</li><li>refresh： 是否支持动态更新，默认为 false</li></ol><h2 id="Nacos-Config-配置属性"><a href="#Nacos-Config-配置属性" class="headerlink" title="Nacos Config 配置属性"></a>Nacos Config 配置属性</h2><p>Nacos 配置管理的属性汇总（属性前缀均为 <code>spring.cloud.nacos.config</code>）</p><table><thead><tr><th align="center">属性</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">server-addr</td><td align="center"></td><td align="center">nacos 服务的 IP：端口</td></tr><tr><td align="center">prefix</td><td align="center"></td><td align="center">DataId 名称首先从 prefix 获取，如果为空则从 name 获取，最后从 <code>spring.application.name</code> 获取</td></tr><tr><td align="center">name</td><td align="center"></td><td align="center">同上</td></tr><tr><td align="center">encode</td><td align="center"></td><td align="center">配置内容的编码字符集</td></tr><tr><td align="center">namespace</td><td align="center">public</td><td align="center">命名空间，用于隔离管理</td></tr><tr><td align="center">group</td><td align="center">DEFAULT_GROUP</td><td align="center">DataId 所在 group</td></tr><tr><td align="center">fileExtension</td><td align="center">properties</td><td align="center">DataId 的后缀或扩展名，支持properties 或 yaml(yml)</td></tr><tr><td align="center">timeout</td><td align="center">3000</td><td align="center">从 nacos 获取配置的超时时间，单位毫秒</td></tr><tr><td align="center">endpoint</td><td align="center"></td><td align="center">nacos 服务名称，服务器地址可通过它动态获取</td></tr><tr><td align="center">accessKey</td><td align="center"></td><td align="center">阿里云账号的 accesskey</td></tr><tr><td align="center">secretKey</td><td align="center"></td><td align="center">阿里云账号的 secretkey</td></tr><tr><td align="center">contextPath</td><td align="center"></td><td align="center">nacos 服务上下文路径</td></tr><tr><td align="center">clusterName</td><td align="center"></td><td align="center">Nacos 服务集群名称</td></tr><tr><td align="center">extensionConfigs</td><td align="center"></td><td align="center">自定义 DataId， 一个列表，以Config 类构建，支持三个属性： dataId, group 与 refresh</td></tr><tr><td align="center">sharedConfigs</td><td align="center"></td><td align="center">共享配置列表，与 extensionConfigs 类似</td></tr></tbody></table><h2 id="actuator-接口"><a href="#actuator-接口" class="headerlink" title="actuator 接口"></a>actuator 接口</h2><p>nacos config 提供了一个 actuator endpoint （nacos-config）来暴露三个属性：</p><ul><li>Sources：当前应用配置的数据信息，包括 dataId 与 上一次同步时间</li><li>RefreshHistory：配置刷新历史</li><li>NacosConfigProperties： 当前服务的基本 Nacos 配置及包含的 sharedConfigs， extensionConfigs， configServiceProperties，以及向后兼容的 extConfig， sharedDataids 等</li></ul><p>通过访问：<a href="http://localhost:8080/actuator/nacos-config" target="_blank" rel="noopener">http://localhost:8080/actuator/nacos-config</a> 可查看。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Nacos 配置以 namespace, group, dataId 的组织形式进行管理，可通过 namespace 来隔离不同环境或不同租户。</li><li>配置支持 profile，<code>spring.profiles.active</code> 必须配置在 bootstrap.properties（yaml） 文件中。</li><li>Nacos 默认支持动态更新配置，需要程序不重启实现配置的动态更新，还需在相应类上添加 @RefreshScope 注解。</li><li>Nacos 配置包括默认 DataId（按 prefix, name, spring.application.name 顺序获取），自定义 DataId（extensionConfigs）， 共享 DataId（sharedConfigs），其优先级按默认-自定义-共享依次降低。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Spring Cloud Config 我们可以实现配置的集中化管理，但 Spring Cloud Config 如果要实现配置的动态更新， 则需要借助 Spring Cloud Bus（参考 &lt;a href=&quot;/spring-cloud-8.html&quot;&gt;Spring Cloud（八）：使用Spring Cloud Bus来实现配置动态更新&lt;/a&gt;）。 Nacos 不仅可作为服务注册中心，同时还可以作为配置的集中化管理中心，且其自身默认就支持动态更新，集成非常方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="nacos" scheme="http://blog.jboost.cn/tags/nacos/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（九）：服务发现，除了Eureka，还有Nacos</title>
    <link href="http://blog.jboost.cn/springcloud-9.html"/>
    <id>http://blog.jboost.cn/springcloud-9.html</id>
    <published>2020-12-05T02:59:41.000Z</published>
    <updated>2020-12-08T00:51:49.204Z</updated>
    
    <content type="html"><![CDATA[<p>服务注册中心是微服务的核心组件之一，目前常见的服务注册中心包括Eureka（参考：<a href="http://blog.jboost.cn/springcloud-1.html">Spring Cloud（一）：服务注册中心Eureka</a>），Zookeeper，Consul，CoreDNS，及 Nacos。</p><a id="more"></a><h2 id="Nacos-介绍"><a href="#Nacos-介绍" class="headerlink" title="Nacos 介绍"></a>Nacos 介绍</h2><p>Nacos 是阿里开源的一个服务注册与配置管理的实现，提供动态的服务发现、服务配置、服务元数据及流量管理等功能。项目地址： <a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">https://github.com/alibaba/nacos</a></p><p>Nacos的关键特性包括：</p><ul><li>服务发现与服务健康监测</li></ul><p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用原生 SDK、OpenAPI、或一个独立的 Agent TODO 注册服务后，服务消费者可以使用 DNS TODO 或 HTTP&amp;API 来发现服务。<br>同时，Nacos 提供对服务的实时健康检查，阻止向不健康的服务实例发送请求。Nacos 支持传输层 (PING 或 TCP) 和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。</p><ul><li>动态配置服务</li></ul><p>动态配置服务可以以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。动态配置使得配置更新时，服务不需要重启就能完成动态更新。配置的中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。<br>Nacos 提供了一个简洁易用的控制台界面来管理所有的服务和应用的配置。Nacos 还提供了包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</p><ul><li>动态 DNS 服务</li></ul><p>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。Nacos 提供了一些简单的 DNS APIs TODO 帮助您管理服务的关联域名和可用的 IP:PORT 列表。</p><ul><li>服务及其元数据管理</li></ul><p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</p><h2 id="Nacos-部署"><a href="#Nacos-部署" class="headerlink" title="Nacos 部署"></a>Nacos 部署</h2><p>下载：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a> ， 目前最新版 1.4.0</p><h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><p>启动</p><p>windows 下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nacos-1.3.2\bin\startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>linux下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nacos-1.3.2\bin\startup.sh -m standalone</span><br></pre></td></tr></table></figure><p>单机模式适合在本地或开发测试环境中使用，如果是生产环境，则需要搭建集群模式或通过 k8s 部署来实现高可用。</p><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><ol><li>集群配置</li></ol><p>将 nacos conf 目录下的 cluster.conf.example 文件重命名为 cluster.conf，添加集群节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#it is ip</span><br><span class="line">#example</span><br><span class="line">192.168.40.111:8848</span><br><span class="line">192.168.40.112:8848</span><br><span class="line">192.168.40.113:8848</span><br></pre></td></tr></table></figure><p>需要配置3个或3个以上的 Nacos 节点才能构成集群。</p><ol start="2"><li>数据源配置 </li></ol><p>使用 <a href="https://github.com/alibaba/nacos/blob/master/distribution/conf/nacos-mysql.sql" target="_blank" rel="noopener">数据库脚本文件</a> 创建 MySQL 数据库<br>在 conf 目录下的 application.properties 配置文件中配置数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#*************** Config Module Related Configurations ***************#</span><br><span class="line">### If use MySQL as datasource:</span><br><span class="line">spring.datasource.platform&#x3D;mysql</span><br><span class="line"></span><br><span class="line">### Count of DB:</span><br><span class="line">db.num&#x3D;1</span><br><span class="line"></span><br><span class="line">### Connect URL of DB:</span><br><span class="line">db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.40.113:3306&#x2F;nacos?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">db.user&#x3D;nacos</span><br><span class="line">db.password&#x3D;nacos</span><br></pre></td></tr></table></figure><p>生产环境可采用主备模式，或者高可用数据库。</p><ol start="3"><li>启动服务器</li></ol><p>在三台服务器节点上依次启动。</p><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh shutdown.sh</span><br></pre></td></tr></table></figure><p>可以结合使用 keepalived 来实现集群的访问，部署结构如图（因作者使用 k8s 部署，集群的具体部署实现这里不详述，可自行查阅 keepalived 相关资料）</p><p><img src="/assets/nacos-cluster.png" alt="nacos-cluster"></p><h3 id="k8s部署"><a href="#k8s部署" class="headerlink" title="k8s部署"></a>k8s部署</h3><p>Nacos 也可以以 StatefulSet 类型的控制器部署在 k8s 中，并且可借助 NFS 与 MySQL 来实现自动扩容缩容和数据持久化功能。如何在 k8s 中部署，我们后续再单独详细介绍。</p><h2 id="Nacos-注册中心集成"><a href="#Nacos-注册中心集成" class="headerlink" title="Nacos 注册中心集成"></a>Nacos 注册中心集成</h2><p>在 Spring Cloud 中使用 Nacos，只需要简单的配置就可以完成服务的注册与发现。</p><ol><li>pom.xml 中添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>bootstrap.yaml 中添加配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="comment"># 此部分为动态配置服务相关</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在启动类上添加 @EnableDiscoveryClient 注解。不加也没关系。</li></ol><p>启动服务后，其它注册到 Nacos 的服务就可以通过 Feign 或 @LoadBalance 注解的 RestTemplate 来负载均衡地调用该服务接口了。</p><ol start="4"><li>访问 Nacos 控制台</li></ol><p>浏览器访问 <a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a> ，账号密码默认为： nacos/nacos。</p><p>点击 服务管理/服务列表，即可看到已经注册的服务，如图</p><p><img src="/assets/nacos-reg1.png" alt="nacos-reg1"></p><p>进入 服务详情，可对服务的元数据，服务下线、上线进行编辑控制，如图</p><p><img src="/assets/nacos-reg2.png" alt="nacos-reg2"></p><p>对服务实例进行下线后，其它服务将不再往该服务实例发送请求（可能有数秒的延迟）。</p><ol start="5"><li>openAPI支持</li></ol><p>服务注册： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;127.0.0.1:8848&#x2F;nacos&#x2F;v1&#x2F;ns&#x2F;instance?serviceName&#x3D;nacos.naming.serviceName&amp;ip&#x3D;192.168.40.234&amp;port&#x3D;8080&#39;</span><br></pre></td></tr></table></figure><p>服务发现： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#39;http:&#x2F;&#x2F;127.0.0.1:8848&#x2F;nacos&#x2F;v1&#x2F;ns&#x2F;instance&#x2F;list?serviceName&#x3D;nacos.naming.serviceName&#39;</span><br></pre></td></tr></table></figure><h2 id="其它注册中心了解"><a href="#其它注册中心了解" class="headerlink" title="其它注册中心了解"></a>其它注册中心了解</h2><ul><li><p>Eureka：Eureka 包含 Eureka Server 与 Eureka Client 两个端，Eureka Client 通过服务注册接口将微服务所在的 IP，端口，hostname，健康检查 url 等信息注册到 Eureka Server，其它微服务可通过服务发现接口从 Eureka Server 获取服务列表信息。Eureka Server 可以运行多个实例来构成集群，提供注册服务的高可用。Eureka Server 集群采用的是 Peer to Peer 去中心化的架构，每一个实例都是对等的，彼此通过相互注册与数据复制同步来提高可用性。从 CAP 原则的角度说，Eureka 遵循的是 AP，即 Eureka 保障可用性与分区容忍性，但不保障一致性。这样 Eureka Client 获取服务列表信息时，有可能存在不一致性，比如针对某个服务新增一个实例，在注册信息还未在各个 Eureka Server 之间完成同步时，有可能部分 Eureka Client 能获取该实例信息，部分获取不到。但这对服务间的交互影响并不大，因为服务调用最终是通过负载均衡从服务实例列表中选取一个进行的。 Eureka 的具体介绍可参考 <a href="http://blog.jboost.cn/springcloud-1.html">Spring Cloud（一）：服务注册中心Eureka</a>。</p></li><li><p>Zookeeper: Zookeeper 就是个分布式的协调服务，服务提供者通过在 Zookeeper 的某一路径上创建一个 znode 节点完成服务注册，该节点存储了服务的 IP，端口，调用方式等信息。服务消费者通过 Zookeeper 获取到相应服务的 IP 地址列表，通过负载均衡算法从 IP 地址列表中取一个进行服务调用。与 Eureka 不同， Zookeeper 集群采用 Master/Slave 架构，如果集群中的 Master 挂了，集群就要进行 Master 的选举，在此过程中是无法处理请求的。因此 Zookeeper 在 CAP 原则中遵循的是 CP，保证了强一致性与分区容忍性，但并不保证高可用。</p></li><li><p>Consul: Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。Consul 使用 Go 语言编写，内置了服务注册与发现框架、分布式一致性协议实现、健康检查、Key/Value 存储、多数据中心方案等，Consul 不需要依赖其他工具（比如 ZooKeeper 等），使用起来也较为简单。Consul 同样遵循 CAP 原理中的 CP 原则，保证了强一致性和分区容错性。但服务注册的时间会稍长一些，因为 Consul 的 Raft 协议要求必须过半数的节点都写入成功才认为注册成功。并且同样在 leader 挂掉了之后，重新选举出 leader 之前会导致 Consul 服务的不可用。</p></li><li><p>CoreDNS: CoreDNS 是目前 Kubernetes 默认的 DNS 方案，其目标是成为云原生环境下的 DNS 服务器和服务发现解决方案。CoreDNS 采用 Go 编写，区别于 kube-dns，CoreDNS 编译出来就是一个单独的二进制可执行文件，内置了 cache，backend storage ，health check 等功能，无需第三方组件来辅助实现其他功能，从而使得部署更方便，内存管理更为安全。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Nacos 不仅能提供动态服务注册发现功能， 也能提供动态配置管理功能（不需要重启服务就能使配置生效）。从注册中心的功能角色来说，一致性要求并不太高，因此遵循 AP 的 Eureka 与 Nacos（Nacos 在服务注册中遵循 AP， 在配置管理中遵循 CP）更适合用于注册中心。但因为 Eureka 2.x Netflix 已经停止更新维护了，所以新项目可以使用 Nacos 来充当服务注册与配置管理的服务。</p><p>参考：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务注册中心是微服务的核心组件之一，目前常见的服务注册中心包括Eureka（参考：&lt;a href=&quot;http://blog.jboost.cn/springcloud-1.html&quot;&gt;Spring Cloud（一）：服务注册中心Eureka&lt;/a&gt;），Zookeeper，Consul，CoreDNS，及 Nacos。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/categories/SpringCloud/"/>
    
    
      <category term="nacos" scheme="http://blog.jboost.cn/tags/nacos/"/>
    
      <category term="SpringCloud" scheme="http://blog.jboost.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>像程序员一样思考——提高解决问题的能力</title>
    <link href="http://blog.jboost.cn/think-like-a-programmer.html"/>
    <id>http://blog.jboost.cn/think-like-a-programmer.html</id>
    <published>2020-11-04T08:54:41.000Z</published>
    <updated>2020-11-05T07:26:32.742Z</updated>
    
    <content type="html"><![CDATA[<p>在以前的文章中，曾经提过“技术人员的价值，不在于你能写出多么优美的代码，也不在于你能设计出一个多么大而全的高屋建瓴的架构，而在于你实实在在的解决问题的能力，在于你使用技术手段服务于业务的能力”。</p><p>最近一段时间，因工作中遇到一些现象，让我重又想起这句话，并且试图思考如何来提高解决问题的能力，有没有一种方法论的手段或者技术性的框架来实践？</p><a id="more"></a><p>先罗列一两个遇到的现象：</p><ol><li><p>某同事汇报，测试提了一个Bug，当某个用户绑定的卡信息超过50个的时候，后台显示数据就会出现混乱，问能不能限制绑定的卡不超过50个。我问：数据显示出现混乱是什么意思？答：不清楚；我再问：为什么超过50个就会混乱了，少于50个有没有可能出现混乱，造成混乱的原因是什么？答：不知道。我说你先去搞清楚什么叫“混乱”，然后再搞清楚为什么会出现“混乱”再来说解决办法。经过与测试人员的一番沟通后，跟我反馈说不是显示混乱，是显示不全，自己通过查看实现是因为在服务端做了字符串拼接，超过多少就被截断了。</p></li><li><p>某同事在抱怨，这个问题很难复现，我不知道怎么解决，要不要把这块整体优化下算了。我问他你优化的目的是什么，是优化目前实现的流程、结构？还是通过优化来解决这个难以复现的问题？答：来解决这个问题。我说你问题都没定位到，怎么通过优化来解决，不怕老问题没解决，优化出新的问题出来了？</p></li></ol><p>你有没有也曾经说过或听过“这个问题太复杂了， 我解决不了”，“这个功能我没办法实现”，“我也不知道为什么会出现这个问题”之类的话语。</p><p>以上的现象与话语，可能都是一个人解决问题的能力或方式方法还不成熟的体现。那么如何来提高解决问题的能力，我想首先需要先从思维方式或思维习惯上寻求改变。在网上看到有这么一篇文章——《How to think like a programmer — lessons in problem solving》（文章地址见文末参考部分），介绍了通过5个步骤来帮忙人们建立高效解决问题的思维框架。本文以这5个步骤为基础，结合自身的理解与体会进行介绍。</p><p><img src="/assets/Jobs.png" alt="Jobs"></p><p>“这个国家的每个人都应该学计算机编程，因为它会教你如何思考” </p><h2 id="像程序员一样思考"><a href="#像程序员一样思考" class="headerlink" title="像程序员一样思考"></a>像程序员一样思考</h2><p>像程序员一样思考，到底意味着什么，需要如何来做？</p><p>像程序员一样思考本质上来说，是一种更为有效的解决问题的方法。</p><h2 id="解决问题的能力是一项元技能"><a href="#解决问题的能力是一项元技能" class="headerlink" title="解决问题的能力是一项元技能"></a>解决问题的能力是一项元技能</h2><p>什么叫元技能？<br>类比于元数据——描述数据的数据叫元数据，我理解元技能就是提升技能的技能，就是说当你掌握了解决问题的能力，你就可以通过这种能力去提升其它各项专业技能。</p><p>解决问题的能力也是最重要的能力，比精通编程语言，调试能力，以及系统设计能力都更为重要。</p><h2 id="提高解决问题能力的方法"><a href="#提高解决问题能力的方法" class="headerlink" title="提高解决问题能力的方法"></a>提高解决问题能力的方法</h2><p>我们平时解决问题的方式可能是：</p><ol><li>尝试一种解决方案。</li><li>如果这种解决方案无效，再尝试另一种方案。</li><li>如果还是没有用，重复第二步直到你碰巧把问题解决了。</li></ol><p>这种方法被作者 Richard Reis 定义为解决问题最糟糕的方式。因为它不但浪费时间，而且能不能达到目的还得看运气。</p><p>经过对优秀程序员在编程时的思维框架的分析，作者总结出提高解决问题能力的最好方法包括：</p><ol><li>有一个处理问题的框架</li><li>按照这个框架反复练习</li></ol><p>那么，当你遇到一个新的问题时，该如何来解决？</p><h3 id="第一步：理解"><a href="#第一步：理解" class="headerlink" title="第一步：理解"></a>第一步：理解</h3><p>遇到问题时，我们应该先要弄明白问题本身。大部分情况下，问题之所以难解决只是因为你没真正理解它们（很多时候是出于沟通的不充分），理解问题是解决问题的第一步。</p><p>如何确定自己是否真正理解一个问题？</p><p>最有效的方法是，尝试用自己的语言来说出它，看有没有逻辑漏洞。当你能讲清楚一个问题时，说明你理解了它。优秀的程序员编程时，一般都会写下自己遇到的问题，画出流程或序列草图，或同产品经理、其它开发人员、测试人员等一起讨论确认。这个过程，就是在确定自己对问题的理解有没有偏差。</p><p>“如果你不能用简单的语言来解释一个事情，那意味着你根本就没有理解它” —— Richard Feynman</p><p>面对一个新需求时，你应该了解这个需求产生的场景——什么人，在什么时候通过执行什么操作，来达到什么目的？这个场景及其中的行为逻辑是否合理，设计是否存在漏洞，然后带着问题来与需求提出方讨论确认，而不是断章取义或不经任何思考直接编码开干。不做代码的搬运工，要做有思想的程序员。</p><p>同样，面对一个 Bug 时，你应该首先了解这个 Bug 产生的场景——什么人，在什么场景，通过什么操作会产生这个问题？要追本溯源，定位问题的本源在哪里。<br>我认为定位问题的本源比解决问题更重要！因为你只有正确地找到了问题的症结，才有可能去解决它，而解决办法却可能有多种。且从花费的时间来说，定位问题往往会占整个解决问题时间的一半以上。</p><p>如果没有找到问题的本源，只是头痛医头脚痛医脚，那么可能不仅对解决问题无事无补，甚至还可能引进新的问题。常见的头痛医头脚痛医脚的处理方式包括，CPU占用高了，内存溢出了——升级服务器配置（可能过两天又得升级了！）；接口超时了——增大超时时间（可能导致用户投诉或其它依赖的服务级联超时），等等。</p><p>那么日常工作中，如何来定位问题的根源？对于一般问题来说，可能通过查看日志大致就能找到问题所在，对于比较棘手的问题，针对问题的性质一般可通过如下方法进行定位：</p><ul><li>对于易复现的问题： 常用的就是 Debug，通过 IDE 断点来跟踪数据的流转与变更，一个个环节检查数据输入输出是否正确来进行排查。可借助条件断点、异常断点等技巧来提高 Debug 效率。</li><li>对于不易复现的问题：可通过对比法——对比其它地方的类似功能或实现，寻找两者之间的差异，差异之处往往就是问题所在；分析法——走读整体流程代码，捋清各个环节的逻辑，分析定位问题；日志法——在各个关键环节添加日志，将场景镜像下来，当下次复现的时候，通过分析日志定位问题。</li></ul><h3 id="第二步：计划"><a href="#第二步：计划" class="headerlink" title="第二步：计划"></a>第二步：计划</h3><p>理解了问题，接下来就是解决问题的方案。没有明确的方案计划时，不要轻易去着手解决问题，不要寄希望于碰运气蒙混过关。许多开发人员习惯于快速扫一眼需求，就打开 IDE 开始垒代码，垒完发现要么与需求不符，要么漏洞百出。</p><p><img src="/assets/nobug.png" alt="nobug"></p><p>制定计划，就是制定解决问题的战略步骤。</p><p>不论面对需求还是 Bug，都应该好好计划你的解决方案。设计好解决方案中的各个环节，如业务需求的数据表设计、接口设计、流程逻辑，Bug 修复的具体实施步骤。并给自己一点时间思考与预演，该解决方案可能存在的漏洞与影响有哪些，除了这样处理，还有没有另外更好的解决方案。</p><p>在没有想清楚解决方案时，不要直接上来就撸代码，暂停一下，给你的大脑一些分析问题和处理信息的时间。</p><h3 id="第三步：分解"><a href="#第三步：分解" class="headerlink" title="第三步：分解"></a>第三步：分解</h3><p>这是思维框架中最重要的一步。</p><p>分解，就是化繁为简，就是我们常说的分治思想，拆分法——将大问题拆分为若干个小问题，然后逐个击破各个小问题，再合并总结。微服务架构，MapReduce 算法，都是这一思维（或思想）的体现。</p><p>不要尝试一次解决一个复杂的大问题，而应把复杂的大问题分解成若干个简单的小问题（或子问题），从最简单的子问题开始（最简单意味着你知道怎么解决它或它更容易被解决，也或者这个子问题的解决不需要依赖于其它子问题），一个一个逐步解决。一旦你解决了所有的子问题，把它们串联起来，一般就意味着你解决了之前的那个复杂的大问题。</p><p>分解问题的能力是解决问题的基石。这也是优秀的程序员在编程中最常用到的技能，对于他们来说，分解问题的能力，要比编程语言的熟练度、系统设计等技术更为重要。</p><h3 id="第四步：卡壳了怎么办？"><a href="#第四步：卡壳了怎么办？" class="headerlink" title="第四步：卡壳了怎么办？"></a>第四步：卡壳了怎么办？</h3><p>当你理解了问题，做出了解决方案的计划，将复杂问题分解为子问题后，在处理子问题时依然卡壳了怎么办？</p><p>首先，淡定！然后告诉自己，这很正常，每个人都会遇到。</p><p>优秀程序员或解决问题的高手，与普通人之间的差别就在于，他们对问题更有求知欲，更有耐心，他们的注意力更多地是在如何解决问题上，而不是为此恼火或甩锅发牢骚。</p><p>当遇到卡壳的情况时，可以试试这几种方法：</p><ol><li><p>Debug：与前面定位问题一样，一步一步调试，直到找出究竟哪里出错了。<br>“Debug 的艺术关键在于你究竟让软件干了些啥，而不是你以为你让软件干了些啥。”—— Andrew Singer</p></li><li><p>重新评估问题：退回去，从另一个角度重新审视问题，别让自己迷失在细节里，有时候我们容易迷失在具体的细节中而忽略了更一般的原则。重新评估问题的另一种途径是推倒重来，可以删除（回滚）所有已做的事，重新开始，有时这是非常行之有效的方式。</p></li><li><p>搜索解决方案：利用搜索引擎找到类似问题的解决办法，向他们学习。使用搜索引擎需要学会提炼关键字，关键字越有代表性，越容易找到答案。对搜索结果应该抱着参考的态度，而不是照搬，要明白为什么如此这般处理就能解决问题，并在解决问题后能依次延伸了解其上下游或相关知识，比如SQL查询慢，发现是索引未生效，则可以延伸了解都有哪些场景会导致索引失效；比如并发问题，则可以依此了解如何保证线程安全，同步机制，锁机制等相关知识。事实上，即使问题已经解决，你也可以经常这么做，因为这样你可以从其他人的解决方案中及上下游知识中学到更多。</p></li><li><p>寻求支援：当通过以上方法都无法获得解决办法时，向你的同事、上级或朋友求援，如果是开源项目，到开源社区、技术群，或 github 的 issue 列表中发帖求援。</p></li><li><p>记录问题与解决方案：将你本次遇到的问题与最终的解决方案用（电子）笔记本记录下来，便于后面回顾或参考。</p></li></ol><h3 id="第五步：练习"><a href="#第五步：练习" class="headerlink" title="第五步：练习"></a>第五步：练习</h3><p>罗马不是一天建成的，你也不可能期盼通过解决一两个问题就能成为解决问题的高手。但是，如果你能以学习的态度来寻求问题的解决办法，通过以上四个步骤来建立一套解决问题的思维框架，每一个问题的处理都是提高你能力的机会。那么距离成为一个解决问题的高手，就只差一步了，那就是：练习，练习，再练习。在问题中练习，训练你的思维方式与习惯。</p><p><img src="/assets/lixiaolong.png" alt="lixiaolong"><br>“我不害怕一次练习1000个踢打动作的人，但我害怕将一个踢打动作练习1000次的人”</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，解决问题的能力，不论在IT技术领域，还是在其它各个领域，都是一种最基本的技能。当你在说出“这个问题我解决不了”，“这个问题我没办法定位”前，试试本文介绍的理解、计划、分解、卡壳时怎么处理的建议方法，多一些耐心，一步步实践，说不定慢慢就看到曙光了。按照这个处理模式或习惯，在日积月累的问题处理中，你可能已在不知不觉成为了解决问题的高手。</p><p>参考： </p><ol><li><a href="https://www.freecodecamp.org/news/how-to-think-like-a-programmer-lessons-in-problem-solving-d1d8bf1de7d2/" target="_blank" rel="noopener">https://www.freecodecamp.org/news/how-to-think-like-a-programmer-lessons-in-problem-solving-d1d8bf1de7d2/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在以前的文章中，曾经提过“技术人员的价值，不在于你能写出多么优美的代码，也不在于你能设计出一个多么大而全的高屋建瓴的架构，而在于你实实在在的解决问题的能力，在于你使用技术手段服务于业务的能力”。&lt;/p&gt;
&lt;p&gt;最近一段时间，因工作中遇到一些现象，让我重又想起这句话，并且试图思考如何来提高解决问题的能力，有没有一种方法论的手段或者技术性的框架来实践？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Career" scheme="http://blog.jboost.cn/categories/Career/"/>
    
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（八）：K8s中的日志采集实践——使用log-pilot（适配ELK7.x）</title>
    <link href="http://blog.jboost.cn/k8s8-logpilot-2.html"/>
    <id>http://blog.jboost.cn/k8s8-logpilot-2.html</id>
    <published>2020-09-26T02:26:20.000Z</published>
    <updated>2020-09-26T02:42:48.251Z</updated>
    
    <content type="html"><![CDATA[<p>前文<a href="/k8s7-logpilot-1.html">Kubernetes笔记（七）：K8s中的日志采集实践——log-pilot介绍</a>我们对 k8s 集群中常用日志采集模式及阿里开源的 log-pilot 进行了介绍，本文介绍如何使 log-pilot 适配 ELK 7.x 及如何将 log-pilot 部署到 k8s 集群中进行日志采集。</p><a id="more"></a><h2 id="1-下载-log-pilot-源码"><a href="#1-下载-log-pilot-源码" class="headerlink" title="1. 下载 log-pilot 源码"></a>1. 下载 log-pilot 源码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AliyunContainerService/log-pilot</span><br></pre></td></tr></table></figure><p>如果直接使用作者已经调整过的基于 filebeat 7.3.1 的版本或直接使用作者已经构建好的 Docker 镜像，可直接跳到第4步。</p><h2 id="2-升级-filebeat-版本"><a href="#2-升级-filebeat-版本" class="headerlink" title="2. 升级 filebeat 版本"></a>2. 升级 filebeat 版本</h2><p>修改 Dockerfile.filebeat 文件，将</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> FILEBEAT_VERSION=<span class="number">6.1</span>.<span class="number">1</span>-<span class="number">3</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> assets/glibc/glibc-2.26-r0.apk /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; \ </span></span><br><span class="line">    apk <span class="keyword">add</span><span class="bash"> python &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add wget &amp;&amp; \</span></span><br><span class="line"><span class="bash">    update-ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    wget http://acs-logging.oss-cn-hangzhou.aliyuncs.com/beats/filebeat/filebeat-<span class="variable">$&#123;FILEBEAT_VERSION&#125;</span>-linux-x86_64.tar.gz -P /tmp/ &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mkdir -p /etc/filebeat /var/lib/filebeat /var/<span class="built_in">log</span>/filebeat &amp;&amp; \</span></span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> FILEBEAT_VERSION=<span class="number">7.3</span>.<span class="number">1</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> assets/glibc/glibc-2.26-r0.apk /tmp/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> filebeat-<span class="variable">$&#123;FILEBEAT_VERSION&#125;</span>-linux-x86_64.tar.gz /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; \ </span></span><br><span class="line">    apk <span class="keyword">add</span><span class="bash"> python &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add wget &amp;&amp; \</span></span><br><span class="line"><span class="bash">    update-ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mkdir -p /etc/filebeat /var/lib/filebeat /var/<span class="built_in">log</span>/filebeat &amp;&amp; \</span></span><br></pre></td></tr></table></figure><p>这里先将 filebeat 包下载下来放到 log-pilot 目录下，避免打镜像时下载太慢。</p><h2 id="3-更新-filebeat-配置"><a href="#3-更新-filebeat-配置" class="headerlink" title="3. 更新 filebeat 配置"></a>3. 更新 filebeat 配置</h2><p>修改 assets/filebeat/config.filebeat 文件，</p><p>移除 <code>filebeat.registry_file: /var/lib/filebeat/registry</code><br>将 <code>filebeat.config.prospectors:</code> 改为 <code>filebeat.config.inputs:</code></p><p>调整后，配置文件为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">base() &#123;</span><br><span class="line">cat &gt;&gt; $FILEBEAT_CONFIG &lt;&lt; EOF</span><br><span class="line">path.config: &#x2F;etc&#x2F;filebeat</span><br><span class="line">path.logs: &#x2F;var&#x2F;log&#x2F;filebeat</span><br><span class="line">path.data: &#x2F;var&#x2F;lib&#x2F;filebeat&#x2F;data</span><br><span class="line">filebeat.shutdown_timeout: $&#123;FILEBEAT_SHUTDOWN_TIMEOUT:-0&#125;</span><br><span class="line">logging.level: $&#123;FILEBEAT_LOG_LEVEL:-info&#125;</span><br><span class="line">logging.metrics.enabled: $&#123;FILEBEAT_METRICS_ENABLED:-false&#125;</span><br><span class="line">logging.files.rotateeverybytes: $&#123;FILEBEAT_LOG_MAX_SIZE:-104857600&#125;</span><br><span class="line">logging.files.keepfiles: $&#123;FILEBEAT_LOG_MAX_FILE:-10&#125;</span><br><span class="line">logging.files.permissions: $&#123;FILEBEAT_LOG_PERMISSION:-0600&#125;</span><br><span class="line">$&#123;FILEBEAT_MAX_PROCS:+max_procs: $&#123;FILEBEAT_MAX_PROCS&#125;&#125;</span><br><span class="line">setup.template.name: &quot;$&#123;FILEBEAT_INDEX:-filebeat&#125;&quot;</span><br><span class="line">setup.template.pattern: &quot;$&#123;FILEBEAT_INDEX:-filebeat&#125;-*&quot;</span><br><span class="line">filebeat.config.inputs:</span><br><span class="line">        enabled: true</span><br><span class="line">        path: \$&#123;path.config&#125;&#x2F;prospectors.d&#x2F;*.yml</span><br><span class="line">        reload.enabled: true</span><br><span class="line">        reload.period: 10s</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-获取-Docker-镜像"><a href="#4-获取-Docker-镜像" class="headerlink" title="4. 获取 Docker 镜像"></a>4. 获取 Docker 镜像</h2><p>1.如果是自己修改官方源码，则执行 <code>./build-image.sh</code></p><p>2.如果是下载作者源码，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ronwxy/<span class="built_in">log</span>-pilot.git</span></span><br><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> <span class="built_in">cd</span> <span class="built_in">log</span>-pilot/ </span></span><br><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> git checkout filebeat-7.3.1</span></span><br><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> ./build-image.sh</span></span><br></pre></td></tr></table></figure><p>3.直接下载作者已经构建好的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root@kmaster]#</span><span class="bash"> docker pull registry.cn-hangzhou.aliyuncs.com/jboost/<span class="built_in">log</span>-pilot:filebeat-7.3.1</span></span><br></pre></td></tr></table></figure><h2 id="5-在-k8s-中部署-log-pilot"><a href="#5-在-k8s-中部署-log-pilot" class="headerlink" title="5. 在 k8s 中部署 log-pilot"></a>5. 在 k8s 中部署 log-pilot</h2><p>我们以 DaemonSet 的方式（一个 Node 一个 Pod）将 log-pilot 部署在 k8s 中，部署配置文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">log-pilot-filebeat</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">log-pilot-filebeat</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">log-pilot-filebeat</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-pilot-filebeat</span></span><br><span class="line">        <span class="comment">#image: registry.cn-hangzhou.aliyuncs.com/acs/log-pilot:0.9.7-filebeat</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/jboost/log-pilot:filebeat-7.3.1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"NODE_NAME"</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">spec.nodeName</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"PILOT_LOG_PREFIX"</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"k8s"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"LOGGING_OUTPUT"</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"logstash"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"LOGSTASH_HOST"</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"&#123;your-logstash-host&#125;"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"LOGSTASH_PORT"</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"5044"</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sock</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/host</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlib</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/filebeat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log/filebeat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">localtime</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/localtime</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/pilot/healthz</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">capabilities:</span></span><br><span class="line">            <span class="attr">add:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">SYS_ADMIN</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sock</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlib</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/filebeat</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log/filebeat</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">localtime</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/etc/localtime</span></span><br></pre></td></tr></table></figure><h2 id="6-应用容器部署配置"><a href="#6-应用容器部署配置" class="headerlink" title="6. 应用容器部署配置"></a>6. 应用容器部署配置</h2><p>在部署应用容器时，以声明式的方式在 Deployment 配置文件的容器部分添加配置即可对容器日志进行自动采集， 如下所示，只列出了与日志配置相关部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">      containers:</span><br><span class="line">      - env:</span><br><span class="line">        - name: k8s_logs_frameworktest</span><br><span class="line">          value: &#x2F;mnt&#x2F;logs&#x2F;app*.log</span><br><span class="line"></span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &#x2F;mnt&#x2F;logs</span><br><span class="line">          name: app-log</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - emptyDir: &#123;&#125;</span><br><span class="line">        name: app-log</span><br></pre></td></tr></table></figure><h2 id="7-按环境与应用建立索引"><a href="#7-按环境与应用建立索引" class="headerlink" title="7. 按环境与应用建立索引"></a>7. 按环境与应用建立索引</h2><p>我们可以在 logstash 中根据不同的环境（这里将环境以 namespace 进行划分），及容器名称（即不同的应用）来创建不同的 elasticsearch 的索引。配置参考如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">        if [k8s_pod_namespace] &#x3D;&#x3D; &quot;develop&quot; &#123;</span><br><span class="line">           elasticsearch &#123;</span><br><span class="line">                hosts &#x3D;&gt; &quot;elasticsearch:9200&quot;</span><br><span class="line">                index &#x3D;&gt; &quot;dev-%&#123;[k8s_container_name]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">                user &#x3D;&gt; &quot;elastic&quot;</span><br><span class="line">                password &#x3D;&gt; &quot;xxxxxx&quot;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           elasticsearch &#123;</span><br><span class="line">                hosts &#x3D;&gt; &quot;elasticsearch:9200&quot;</span><br><span class="line">                index &#x3D;&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">                user &#x3D;&gt; &quot;elastic&quot;</span><br><span class="line">                password &#x3D;&gt; &quot;xxxxxx&quot;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-相关源码与镜像"><a href="#8-相关源码与镜像" class="headerlink" title="8. 相关源码与镜像"></a>8. 相关源码与镜像</h2><p>log-pilot 官方源码地址：<a href="https://github.com/AliyunContainerService/log-pilot" target="_blank" rel="noopener">https://github.com/AliyunContainerService/log-pilot</a><br>适配 ELK 7.x 源码地址： <a href="https://github.com/ronwxy/log-pilot/tree/filebeat-7.3.1" target="_blank" rel="noopener">https://github.com/ronwxy/log-pilot/tree/filebeat-7.3.1</a><br>适配 ELK 7.x Docker 镜像地址： registry.cn-hangzhou.aliyuncs.com/jboost/log-pilot:filebeat-7.3.1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文&lt;a href=&quot;/k8s7-logpilot-1.html&quot;&gt;Kubernetes笔记（七）：K8s中的日志采集实践——log-pilot介绍&lt;/a&gt;我们对 k8s 集群中常用日志采集模式及阿里开源的 log-pilot 进行了介绍，本文介绍如何使 log-pilot 适配 ELK 7.x 及如何将 log-pilot 部署到 k8s 集群中进行日志采集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（七）：K8s中的日志采集实践——log-pilot介绍</title>
    <link href="http://blog.jboost.cn/k8s7-logpilot-1.html"/>
    <id>http://blog.jboost.cn/k8s7-logpilot-1.html</id>
    <published>2020-09-25T03:49:52.000Z</published>
    <updated>2020-09-26T02:35:58.064Z</updated>
    
    <content type="html"><![CDATA[<p>日志是应用服务运行过程中的一个关键环节，借助日志，我们可以排查定位问题，也可以借助集中化的日志管理平台（如ELK）来做一些必要的数据统计分析与监控告警。在 K8s 环境中，容器的日志有可能是通过 STDOUT/STDERR 输出（对于标准输出，前面 <a href="/docker-13.html">Docker笔记（十三）：容器日志采集实践</a> 有相关介绍可参考），并且一般也推荐将日志写到标准输出，但是也有一些特殊的场景，应用直接将日志写在容器内部的日志文件。对于容器的标准输出日志来说，Docker Engine 本身就提供了一个很好的日志采集能力，但是对于容器内部的文件日志采集，现在却并没有一个很好的工具能够去动态发现采集。因为在分布式的容器集群中，容器随着 Pod 调度被动态创建或删除，我们无法像虚拟机环境那样事先配置好日志采集路径等信息，目前的采集工具都是需要我们事先手动配置好日志采集方式和路径等信息，它无法自动感知到容器的生命周期变化或者动态漂移（一个 Pod 挂了，可能是在另一个节点上启动一个新的 Pod），无法进行动态的配置。因此，在 K8s 中进行日志采集将变得更为复杂。</p><a id="more"></a><h2 id="1-K8s-的日志采集模式"><a href="#1-K8s-的日志采集模式" class="headerlink" title="1. K8s 的日志采集模式"></a>1. K8s 的日志采集模式</h2><p>综观 K8s 下的日志采集模式，大致有三种：</p><h3 id="1-Node-代理模式"><a href="#1-Node-代理模式" class="headerlink" title="1.Node 代理模式"></a>1.Node 代理模式</h3><p>就是在每个 Node 上部署一个日志采集代理程序（如 filebeat，fluentd，或 logstash 等），一般是以 DaemonSet 的形式在每个 Node 上部署一个 Pod，来采集这个 Node 上所有容器的日志。这种模式的优点是资源消耗少，一个节点一个 Pod， 且对应用无侵入。</p><h3 id="2-SideCar-模式"><a href="#2-SideCar-模式" class="headerlink" title="2.SideCar 模式"></a>2.SideCar 模式</h3><p>这种模式就是在 Pod 中除了运行我们的应用程序容器， 再起一个负责日志采集的容器，比如再起一个 logstash 或 fluentd 容器。当 Pod 数量一多，这种方案资源消耗很大，对日志存储后端也会占用过多的连接数，并且日志不输出到标准输出，不能通过 kubectl logs 命令查看。</p><h3 id="3-应用程序推送模式"><a href="#3-应用程序推送模式" class="headerlink" title="3.应用程序推送模式"></a>3.应用程序推送模式</h3><p>直接在应用程序里将日志内容发送到日志采集服务，比如在程序里将日志发到 kafka， 再使用 logstash 从 kafka 拉取到 elasticsearch。这种方案对应用具有侵入性。</p><p>有没有一种方案或工具，既能采集 k8s 中标准输出日志，又能采集到容器内部的日志文件输出日志，并且资源消耗小，对应用无侵入呢。拒作者了解，阿里开源的 log-pilot 基本能满足要求，只是更新较慢，目前版本基于 ELK 6，如果要适配到 ELK 7 或以上，需进行一些必要的调整。</p><h2 id="2-log-pilot-介绍"><a href="#2-log-pilot-介绍" class="headerlink" title="2. log-pilot 介绍"></a>2. log-pilot 介绍</h2><p>log-pilot 是阿里开源的一个同时支持容器标准输出日志采集与容器内部文件日志动态配置采集的组件。log-pilot 具备如下特性。</p><h3 id="1-采集目标多"><a href="#1-采集目标多" class="headerlink" title="1. 采集目标多"></a>1. 采集目标多</h3><p>log-pilot 同时支持采集标准输出日志和动态发现配置采集容器内部文件日志。</p><h3 id="2-声明式的日志配置"><a href="#2-声明式的日志配置" class="headerlink" title="2. 声明式的日志配置"></a>2. 声明式的日志配置</h3><p>log-pilot 支持声明式日志配置，可以依据容器的 Label 或者 ENV 来动态地生成日志采集的配置文件。这里主要说明两个变量：</p><ul><li>name：我们自定义的一个字符串，它在不同的场景下指代不同的含义。当日志采集到 ElasticSearch 的时候， name 表示的是 Index；当日志采集到 Kafka 的时候， name 表示的是 Topic；当日志采集到阿里云日志服务的时候，name 表示的就是 LogstoreName。</li><li>path：支持两种形式，一种是约定关键字 stdout，表示的是采集容器的标准输出日志，第二种是容器内部的具体文件日志路径，可以支持通配符的方式。比如我们要采集 tomcat 容器日志，我们可以通过配置标签 <code>aliyun.logs.catalina=stdout</code> 来采集 tomcat 标准输出日志，通过配置标签 <code>aliyun.logs.access=/usr/local/tomcat/logs/*.log</code> 来采集 tomcat 容器内部文件日志。</li></ul><p><img src="/assets/log-pilot-1.png" alt="声明式的日志配置"></p><h3 id="3-动态配置的能力"><a href="#3-动态配置的能力" class="headerlink" title="3. 动态配置的能力"></a>3. 动态配置的能力</h3><p>log-pilot 本身分为三部分，其中一部分就是容器的事件管理，它能够动态地监听容器的事件变化（如创建、删除），然后依据容器的标签来进行解析，生成日志采集配置文件，然后交由采集插件来进行日志采集。通过全量扫描加事件监听的方式，比如采集工具进程在起来的时候，注册事件监听，然后全量扫描一遍宿主机上的所有容器列表，然后依据容器的声明式配置来进行日志采集配置文件的动态生成。</p><h3 id="4-防重复和丢失"><a href="#4-防重复和丢失" class="headerlink" title="4. 防重复和丢失"></a>4. 防重复和丢失</h3><p>log-pilot 内部具有 CheckPoint 和句柄保持的机制。</p><ul><li>checkPoint机制： log-pilot 内部会实时跟踪日志采集的偏移量，然后维持日志文件信息与偏移量的映射关系，最后定期地持久化到磁盘中。采用偏移量的方式我们可以避免日志采集丢失和重复的问题，同时即使当采集工具宕掉再起来，它也可以通过加载持久化在磁盘上的元数据信息，从指定的日志偏移位置上继续采集日志。</li><li>句柄保持机制： log-pilot 在监测到配置的日志路径目录下有新的日志文件产生时会主动地打开其句柄，并维持打开状态，这样是为了防止因日志采集工具比较慢或者应用日志输出速率特别大，比如说当前已经生成五个日志文件但只采集到第三个，后面两个还没有开始采集，一旦这个容器退出就可能导致后面两个文件的日志丢失了。</li></ul><h3 id="5-明确日志来源"><a href="#5-明确日志来源" class="headerlink" title="5. 明确日志来源"></a>5. 明确日志来源</h3><p>支持日志自动数据打标。log-pilot 在采集容器日志的时候，同时也会收集容器的元数据信息，包括容器的名称，容器所属的服务名称以及容器所属的应用名称，同时在 Kubernetes 里面也会采集容器所属的 Pod 信息，包括 Pod 的名称，Pod 所属的 namespace 以及 Pod 所在的节点信息。这样排查问题时，就可以很方便地知道这个日志是来源于哪个节点上的哪个应用容器。</p><p><img src="/assets/log-pilot-2.png" alt="自动数据打标"></p><h3 id="6-支持自定义-Tag"><a href="#6-支持自定义-Tag" class="headerlink" title="6. 支持自定义 Tag"></a>6. 支持自定义 Tag</h3><p>log-pilot 支持自定义Tag，我们可以在容器的标签或者环境变量里配置 <code>aliyun.logs.$name.tags: k=v</code>，那么在采集日志的时候就会将k=v采集到容器的日志输出中。比如针对不同的环境（如开发环境、测试环境），可以使用 tag 来进行区分。也可以使用自定义 tag 来进行日志的统计、路由与过滤等。</p><p><img src="/assets/log-pilot-3.png" alt="自定义tag"></p><h3 id="7-支持多种日志解析格式"><a href="#7-支持多种日志解析格式" class="headerlink" title="7. 支持多种日志解析格式"></a>7. 支持多种日志解析格式</h3><p>log-pilot 支持多种日志解析格式，通过 <code>aliyun.logs.$name.format: &lt;format&gt;</code> 标签就可以告诉 log-pilot 在采集日志的时候，同时以什么样的格式来解析日志记录。目前主要支持六种：</p><ul><li>none：默认格式，指不对日志记录做任何解析，整行采集出来直接输出到日志存储后端。</li><li>json：log-pilot 在采集日志的同时会将每一行日志以 json 的方式进行解析，解析出多个 KV 对，然后输出到日志存储后端。</li><li>csv：主要是针对 csv 格式的日志采集配置（需配置 fluentd 插件）。</li><li>nginx：主要是针对 Nginx 的日志采集配置（需配置 fluentd 插件）。</li><li>apache2：主要是针对 Apache 的日志采集配置（需配置 fluentd 插件）。</li><li>regexp：用户可以通过 format 标签来自定义正则表达式，告诉 log-pilot 在解析日志记录的时候以什么样的格式来进行解析（需配置 fluentd 插件）。</li></ul><p><img src="/assets/log-pilot-4.png" alt="多种解析格式"></p><h3 id="8-支持自定义输出Target"><a href="#8-支持自定义输出Target" class="headerlink" title="8. 支持自定义输出Target"></a>8. 支持自定义输出Target</h3><p>假设我们同时有一个生产环境和一个测试环境，应用日志都需要被采集到同一套 Kafka 中，然后由不同的 consumer 去消费。但是我们希望对环境进行区分，某条日志是由生产环境的应用容器产生的，还是测试环境的应用容器产生的，但我们在测试环境中的应用容器已经配置了 aliyun.logs.svc=stdout 标签，那么当这些应用容器的标准输出日志被采集到 kafka 中，它最终会被路由到 topic=svc 的消息队列中，那么订阅了 topic=svc 的 consumer 就能够接收测试环境的应用容器产生的日志。但当我们将该应用发布到生产环境时，希望它产生的日志只能交由生产环境的 consumer 来接收处理，那么我们就可以通过 target 的方式，给生产环境的应用容器额外定义一个 target=pro-svc，那么生产环境的应用日志在被采集到 Kafka 中时，最终会被路由到 topic 为 pro-svc 的消息队列中，那么订阅了 topic =pro-svc 的 consumer 就可以正常地接收到来自于生产环境的容器产生的日志。</p><p>因此这里的 target 本身也有三种含义：</p><ol><li>日志对接到 ElasticeSearch 时，这个 target 字符串是 Index；</li><li>对接到 Kafka 时，它指代的是 topic；</li><li>对接到阿里云日志服务时，它代表的是 Logstore Name。</li></ol><p><img src="/assets/log-pilot-5.png" alt="自定义输出target"></p><h3 id="9-支持多种采集插件"><a href="#9-支持多种采集插件" class="headerlink" title="9. 支持多种采集插件"></a>9. 支持多种采集插件</h3><p>目前 log-pilot 支持两种采集插件：一个是 CNCF 社区的 Fluentd 插件，一个是 Elastic 的 Filebeat 插件；同时支持对接多种存储后端，目前 Fluentd 和 Filebeat 都支持 Elasticsearch、Kafka、File、Console 作为日志存储后端，而 Fluentd 还支持 Graylog、阿里云日志服务 以及 Mongodb 作为存储后端。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>本文对 k8s 集群中日志采集的常见模式，及阿里开源的 log-pilot 支持的特性进行了介绍。但 log-pilot 目前基于 ELK 6 版本， 如果需要适配 ELK 7 或以上版本，需要对其进行必要的调整。下文将介绍如何进行适配调整及如何将 log-pilot 部署到 k8s 集群中进行日志采集。</p><p>参考：</p><p>容器日志采集利器 Log-Pilot： <a href="https://developer.aliyun.com/article/674327" target="_blank" rel="noopener">https://developer.aliyun.com/article/674327</a><br>log-pilot 官方源码地址：<a href="https://github.com/AliyunContainerService/log-pilot" target="_blank" rel="noopener">https://github.com/AliyunContainerService/log-pilot</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志是应用服务运行过程中的一个关键环节，借助日志，我们可以排查定位问题，也可以借助集中化的日志管理平台（如ELK）来做一些必要的数据统计分析与监控告警。在 K8s 环境中，容器的日志有可能是通过 STDOUT/STDERR 输出（对于标准输出，前面 &lt;a href=&quot;/docker-13.html&quot;&gt;Docker笔记（十三）：容器日志采集实践&lt;/a&gt; 有相关介绍可参考），并且一般也推荐将日志写到标准输出，但是也有一些特殊的场景，应用直接将日志写在容器内部的日志文件。对于容器的标准输出日志来说，Docker Engine 本身就提供了一个很好的日志采集能力，但是对于容器内部的文件日志采集，现在却并没有一个很好的工具能够去动态发现采集。因为在分布式的容器集群中，容器随着 Pod 调度被动态创建或删除，我们无法像虚拟机环境那样事先配置好日志采集路径等信息，目前的采集工具都是需要我们事先手动配置好日志采集方式和路径等信息，它无法自动感知到容器的生命周期变化或者动态漂移（一个 Pod 挂了，可能是在另一个节点上启动一个新的 Pod），无法进行动态的配置。因此，在 K8s 中进行日志采集将变得更为复杂。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（六）：了解控制器 —— Deployment</title>
    <link href="http://blog.jboost.cn/k8s6-deploy.html"/>
    <id>http://blog.jboost.cn/k8s6-deploy.html</id>
    <published>2020-08-21T03:49:52.000Z</published>
    <updated>2020-08-26T01:44:35.532Z</updated>
    
    <content type="html"><![CDATA[<p>Pod（容器组）是 Kubernetes 中最小的调度单元，可以通过 yaml 定义文件直接创建一个 Pod。但 Pod 本身并不具备自我恢复（self-healing）功能。如果一个 Pod 所在的节点出现故障，或者调度程序自身出现问题，以及节点资源不够或节点进入维护而驱逐 Pod 时，Pod 将被删除，且不能自我恢复。</p><p>因此，Kubernetes 中我们一般不直接创建 Pod， 而是通过 Controller（控制器）来管理 Pod。</p><a id="more"></a><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>Controller 能为 Pod 提供如下特性：</p><ul><li>水平扩展，控制 Pod 运行的副本数</li><li>rollout，即版本更新</li><li>self-healing，即自我恢复。当节点出现故障时，控制器可以自动地在另一个节点调度一个配置完全一样的 Pod，以替换故障节点上的 Pod。</li></ul><p>Kubernetes 中支持的控制器包括：</p><ul><li>ReplicationController：用来维护一个数量稳定的 Pod 副本集合的控制器</li><li>ReplicaSet：是 ReplicationController 的升级版，比 ReplicationController 多一个特性：支持基于集合的选择器。 不支持滚动更新（RollingUpdate）</li><li>Deployment：包含了 ReplicaSet，可通过声明式、滚动更新的方式更新 ReplicaSet 及其 Pod。对于无状态应用，推荐使用 Deployment 部署</li><li>StatefulSet：用于管理有状态的应用程序</li><li>DaemonSet：在节点上以守护进程的方式运行一个指定的 Pod 副本，例如监控节点、收集节点上的日志时，可使用 DaemonSet</li><li>CronJob：按照预定的时间计划创建 Job，类似于 linux 的crontab</li><li>Job：使用 Job 执行任务，执行完后结束</li></ul><h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><p>Kubernetes 中，虽然一般使用 Deployment 来管理 Pod， 但 Deployment 中也是通过 ReplicaSet 来维护 Pod 的副本集合的，因此此处也对 ReplicaSet 进行简单介绍。</p><p>在 ReplicaSet 的定义中，包含三部分：</p><ol><li>selector： 标签选择器，用于指定哪些 Pod 归该 ReplicaSet 管理，通过 <code>matchLabels</code> 来与 Pod 的 label 匹配。</li><li>replicas： 期望的 Pod 副本数，指定该 ReplicaSet 应该维持多少个 Pod 副本，默认为1。</li><li>template： Pod 定义模板，ReplicaSet 使用该模板的定义来创建 Pod。</li></ol><p>ReplicaSet 的示例定义文档如下所示，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  <span class="comment"># api版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span>     <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span>            <span class="comment"># 元数据定义</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ds</span>     <span class="comment"># ReplicaSet 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span>        <span class="comment"># Pod 副本数量，默认1</span></span><br><span class="line">  <span class="attr">selector:</span>          <span class="comment"># 标签选择器</span></span><br><span class="line">     <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span>          <span class="comment"># Pod 定义模板</span></span><br><span class="line">    <span class="attr">metadata:</span>        <span class="comment"># Pod 元数据定义</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># Pod 标签</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span>    <span class="comment"># 容器定义</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>ReplicaSet 通过创建、删除 Pod 容器组来确保符合 selector 选择器的 Pod 数量等于 replicas 指定的数量。 ReplicaSet 创建的 Pod 中，都有一个字段 <code>metadata.ownerReferences</code> 用于标识该 Pod 从属于哪一个 ReplicaSet。可通过 <code>kubectl get pod pod-name -o yaml</code> 来查看 Pod 的 ownerReference。</p><p>ReplicaSet 通过 selector 字段的定义，识别哪些 Pod 应该由其管理， 不论该 Pod 是否由该 ReplicaSet 创建，即只要 selector 匹配， 通过外部定义创建的 Pod 也会被该 ReplicaSet 管理。因此需要注意 <code>.spec.selector.matchLabels</code> 与 <code>.spec.template.metadata.labels</code> 的定义一致， 且避免与其他控制器的 selector 重合，造成混乱。</p><p>ReplicaSet 不支持滚动更新，所以对于无状态应用，一般使用 Deployment来部署， 而不直接使用 ReplicaSet。ReplicaSet 主要是被用作 Deployment 中负责 Pod 创建、删除、更新的一种手段。</p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>Deployment 对象包含 ReplicaSet 作为从属对象，并且可通过声明式、滚动更新的方式来更新 ReplicaSet 及其 Pod。ReplicaSet 现在主要是被用作 Deployment 中负责 Pod 创建、删除、更新的一种手段。使用 Deployment 时，无需关心由 Deployment 创建的 ReplicaSet，Deployment 将处理所有与之相关的细节。同时，Deployment 还能以“声明式”的方式管理 Pod 和 ReplicaSet （其本质是将一些特定场景的一系列运维步骤固化下来，以便快速准确无误的执行），并提供版本（revision）回退功能。</p><p>Deployment 定义示例，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>        <span class="comment"># 对象类型，固定为 Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span>    <span class="comment"># Deployment 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>    <span class="comment"># 命名空间，默认为 default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>          <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span>           <span class="comment"># Pod 副本数，默认1</span></span><br><span class="line">  <span class="attr">strategy:</span>  </span><br><span class="line">    <span class="attr">rollingUpdate:</span>      <span class="comment"># 升级策略为滚动升级，由于replicas为4,则整个升级过程pod个数在3-5个之间</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span>       <span class="comment"># 滚动升级时超过 replicas 的最大 pod 数，也可以为百分比（replicas的百分比），默认为1</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 滚动升级时不可用的最大 pod 数，也可为百分比（replicas的百分比），默认为1</span></span><br><span class="line">  <span class="attr">selector:</span>             <span class="comment"># 标签选择器，通过标签选择该 Deployment 管理的 Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span>             <span class="comment"># Pod 定义模板</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>      <span class="comment"># Pod 标签</span></span><br><span class="line">    <span class="attr">spec:</span>               <span class="comment"># 定义容器模板，可以包含多个容器</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>可通过 <code>kubectl explain xxx</code> 来查看支持哪些配置选项，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 deployment 配置项</span></span><br><span class="line">[root@kmaster ~]# kubectl explain deployment</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 deployment.spec 模块的配置项</span></span><br><span class="line">[root@kmaster ~]# kubectl explain deployment.spec</span><br><span class="line">KIND:     Deployment</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">RESOURCE: spec &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     Specification of the desired behavior of the Deployment.</span><br><span class="line"></span><br><span class="line">     DeploymentSpec is the specification of the desired behavior of the</span><br><span class="line">     Deployment.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   minReadySeconds&lt;integer&gt;</span><br><span class="line">     Minimum number of seconds for which a newly created pod should be ready</span><br><span class="line">     without any of its container crashing, for it to be considered available.</span><br><span class="line">     Defaults to 0 (pod will be considered available as soon as it is ready)</span><br><span class="line"></span><br><span class="line">   paused&lt;boolean&gt;</span><br><span class="line">     Indicates that the deployment is paused.</span><br><span class="line"></span><br><span class="line">   progressDeadlineSeconds&lt;integer&gt;</span><br><span class="line">     The maximum time in seconds for a deployment to make progress before it is</span><br><span class="line">     considered to be failed. The deployment controller will continue to process</span><br><span class="line">     failed deployments and a condition with a ProgressDeadlineExceeded reason</span><br><span class="line">     will be surfaced in the deployment status. Note that progress will not be</span><br><span class="line">     estimated during the time a deployment is paused. Defaults to 600s.</span><br><span class="line"></span><br><span class="line">   replicas&lt;integer&gt;</span><br><span class="line">     Number of desired pods. This is a pointer to distinguish between explicit</span><br><span class="line">     zero and not specified. Defaults to 1.</span><br><span class="line"></span><br><span class="line">   revisionHistoryLimit&lt;integer&gt;</span><br><span class="line">     The number of old ReplicaSets to retain to allow rollback. This is a</span><br><span class="line">     pointer to distinguish between explicit zero and not specified. Defaults to</span><br><span class="line">     10.</span><br><span class="line"></span><br><span class="line">   selector&lt;Object&gt; -required-</span><br><span class="line">     Label selector for pods. Existing ReplicaSets whose pods are selected by</span><br><span class="line">     this will be the ones affected by this deployment. It must match the pod</span><br><span class="line">     template's labels.</span><br><span class="line"></span><br><span class="line">   strategy&lt;Object&gt;</span><br><span class="line">     The deployment strategy to use to replace existing pods with new ones.</span><br><span class="line"></span><br><span class="line">   template&lt;Object&gt; -required-</span><br></pre></td></tr></table></figure><p>其它配置项说明：</p><ul><li><code>.spec.minReadySeconds</code>：用来控制应用升级的速度。升级过程中，新创建的 Pod 一旦成功响应了就绪探测即被认为是可用状态，然后进行下一轮的替换。 <code>.spec.minReadySeconds</code> 定义了在新的 Pod 对象创建后至少需要等待多长的时间才能会被认为其就绪，在该段时间内，更新操作会被阻塞。</li><li><code>.spec.progressDeadlineSeconds</code>：用来指定在系统报告 Deployment 失败 —— 表现为状态中的 <code>type=Progressing、Status=False、 Reason=ProgressDeadlineExceeded</code> 前可以等待的 Deployment 进行的秒数。Deployment controller 会继续重试该 Deployment。如果设置该参数，该值必须大于 <code>.spec.minReadySeconds</code>。</li><li><code>.spec.revisionHistoryLimit</code>：用来指定可以保留的旧的 ReplicaSet 或 revision（版本） 的数量。默认所有旧的 Replicaset 都会被保留。如果删除了一个旧的 RepelicaSet，则 Deployment 将无法再回退到那个 revison。如果将该值设置为0，所有具有0个 Pod 副本的 ReplicaSet 都会被删除，这时候 Deployment 将无法回退，因为 revision history 都被清理掉了。</li></ul><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl apply -f nginx-deploy.yaml --record</span><br></pre></td></tr></table></figure><p><code>--record</code> 会将此次命令写入 Deployment 的 kubernetes.io/change-cause 注解中。可在后面查看某一个 Deployment 版本变化的原因。</p><h3 id="2-查看"><a href="#2-查看" class="headerlink" title="2. 查看"></a>2. 查看</h3><p>创建 Deployment 后，Deployment 控制器将立刻创建一个 ReplicaSet，并由 ReplicaSet 创建所需要的 Pod。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 Deployment</span></span><br><span class="line">[root@kmaster test]# kubectl get deploy</span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deploy   0/2     2            0           64s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 ReplicaSet</span></span><br><span class="line">[root@kmaster test]# kubectl get rs</span><br><span class="line">NAME                     DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-59c9f8dff   2         2         1       2m16s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Pod，显示调度的节点，及标签</span></span><br><span class="line">[root@kmaster test]# kubectl get pod -o wide --show-labels</span><br><span class="line">NAME                           READY   STATUS      RESTARTS   AGE     IP            NODE     NOMINATED NODE   READINESS GATES   LABELS</span><br><span class="line">nginx-deploy-59c9f8dff-47bgd   1/1     Running     0          5m14s   10.244.1.91   knode2   &lt;none&gt;           &lt;none&gt;            app=nginx,pod-template-hash=59c9f8dff</span><br><span class="line">nginx-deploy-59c9f8dff-q4zb8   1/1     Running     0          5m14s   10.244.3.47   knode3   &lt;none&gt;           &lt;none&gt;            app=nginx,pod-template-hash=59c9f8dff</span><br></pre></td></tr></table></figure><p><code>pod-template-hash</code> 标签是 Deployment 创建 ReplicaSet 时添加到 ReplicaSet 上的，ReplicaSet 进而将此标签添加到 Pod 上。这个标签用于区分 Deployment 中哪个 ReplicaSet 创建了哪些 Pod。该标签的值是 <code>.spec.template</code> 的 hash 值，不要去修改这个标签。由上可看出 ReplicaSet、 Pod 的命名分别遵循 <code>&lt;Deployment-name&gt;-&lt;Pod-template-hash&gt;</code>、<code>&lt;Deployment-name&gt;-&lt;Pod-template-hash&gt;-xxx</code> 的格式。</p><h3 id="3-发布更新（rollout）"><a href="#3-发布更新（rollout）" class="headerlink" title="3. 发布更新（rollout）"></a>3. 发布更新（rollout）</h3><p>当且仅当 Deployment 的 Pod template（<code>.spec.template</code>）字段中的内容发生变更时（例如标签或容器的镜像被改变），Deployment 的发布更新（rollout）才会被触发。Deployment 中其他字段的变化（例如修改 <code>.spec.replicas</code> 字段）将不会触发 Deployment 的发布更新。</p><p>更新 Deployment 中 Pod 的定义（例如，发布新版本的容器镜像）。此时 Deployment 控制器将为该 Deployment 创建一个新的 ReplicaSet，并且逐步在新的 ReplicaSet 中创建 Pod，在旧的 ReplicaSet 中删除 Pod，以达到滚动更新的效果。</p><p>比如我们将上面 Deployment 的容器镜像进行修改，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式一：直接使用 kubectl 命令设置修改 </span></span><br><span class="line">[root@kmaster ~]# kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record</span><br><span class="line">deployment.apps/nginx-deploy image updated</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二：使用 kubectl edit 编辑yaml修改</span></span><br><span class="line">[root@kmaster ~]# kubectl edit deploy nginx-deploy</span><br></pre></td></tr></table></figure><p>查看发布更新（rollout）的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl rollout status deploy nginx-deploy</span><br><span class="line">Waiting for deployment "nginx-deploy" rollout to finish: 2 out of 4 new replicas have been updated...</span><br></pre></td></tr></table></figure><p>查看 ReplicaSet，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl get rs</span><br><span class="line">NAME                     DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-59c9f8dff   1         1         1       3d6h</span><br><span class="line">nginx-deploy-d47dbbb7c   4         4         2       3m41s</span><br></pre></td></tr></table></figure><p>我们可以看到 Deployment 的更新是通过创建一个新的4个副本的 ReplicaSet，并同时将旧的 ReplicaSet 的副本数缩容到0个副本来达成的。</p><p>因为前面我们将 maxSurge， 与 maxUnavailable 都设置为了1， 因此在更新的过程中，任何时刻两个 ReplicaSet 的 Pod 数至多为5个（4 replicas +1 maxSurge），且可用的 Pod 数至少为3个（4 replicas - 1 maxUnavailable）。</p><p>使用 <code>kubectl describe</code> 命令查看 Deployment 的事件部分，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl describe deploy nginx-deploy</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age    From                   Message</span><br><span class="line">  ----    ------             ----   ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  12m    deployment-controller  Scaled up replica set nginx-deploy-d47dbbb7c to 1</span><br><span class="line">  Normal  ScalingReplicaSet  12m    deployment-controller  Scaled down replica set nginx-deploy-59c9f8dff to 3</span><br><span class="line">  Normal  ScalingReplicaSet  12m    deployment-controller  Scaled up replica set nginx-deploy-d47dbbb7c to 2</span><br><span class="line">  Normal  ScalingReplicaSet  10m    deployment-controller  Scaled down replica set nginx-deploy-59c9f8dff to 2</span><br><span class="line">  Normal  ScalingReplicaSet  10m    deployment-controller  Scaled up replica set nginx-deploy-d47dbbb7c to 3</span><br><span class="line">  Normal  ScalingReplicaSet  8m56s  deployment-controller  Scaled down replica set nginx-deploy-59c9f8dff to 1</span><br><span class="line">  Normal  ScalingReplicaSet  8m56s  deployment-controller  Scaled up replica set nginx-deploy-d47dbbb7c to 4</span><br><span class="line">  Normal  ScalingReplicaSet  5m55s  deployment-controller  Scaled down replica set nginx-deploy-59c9f8dff to 0</span><br></pre></td></tr></table></figure><p>当更新了 Deployment 的 Pod Template 时，Deployment Controller 会创建一个新的 ReplicaSet (nginx-deploy-d47dbbb7c) ，并将其 scale up 到 1 个副本，同时将旧的 ReplicaSet（nginx-deploy-59c9f8dff） scale down 到3个副本。接下来 Deployment Controller 继续 scale up 新的 ReplicaSet 并 scale down 旧的 ReplicaSet，直到新的 ReplicaSet 拥有 replicas 个数的 Pod， 旧的 ReplicaSet Pod 数缩放到0。这个过程称为 rollout（发布更新）。</p><p>通过 <code>.spec.strategy</code> 字段，可以指定更新策略，除了上述使用的 RollingUpdate（滚动更新），另一个可取的值为 Recreate（重新创建）。选择重新创建，Deployment 将先删除原有 ReplicaSet 中的所有 Pod，然后再创建新的 ReplicaSet 和新的 Pod，更新过程中将出现一段应用程序不可用的情况。因此，线上环境一般使用 RollingUpdate。</p><h3 id="4-回滚"><a href="#4-回滚" class="headerlink" title="4. 回滚"></a>4. 回滚</h3><p>默认情况下，kubernetes 将保存 Deployment 的所有更新（rollout）历史。可以通过设定 revision history limit（<code>.spec.revisionHistoryLimit</code> 配置项）来指定保存的历史版本数量。</p><p>当且仅当 Deployment 的 <code>.spec.template</code> 字段被修改时（例如修改容器的镜像），kubernetes 才为其创建一个 Deployment revision（版本）。Deployment 的其他更新（例如：修改 <code>.spec.replicas</code> 字段）将不会创建新的 Deployment revision（版本）。</p><p>查看 Deployment 的 revision，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br><span class="line">2         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br></pre></td></tr></table></figure><p>如果前面更新 Deployment 时没有添加 <code>--record=true</code>，则此处 CHANGE-CAUSE 将为空。</p><p>我们通过将镜像修改为一个不存在的版本来模拟一次失败的更新，并回滚到前一个版本的场景，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 修改镜像版本到一个不存在的值</span></span><br><span class="line">[root@kmaster ~]# kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record</span><br><span class="line">deployment.apps/nginx-deploy image updated</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看 ReplicaSet</span></span><br><span class="line">[root@kmaster ~]# kubectl  get rs</span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-58f69cfc57   2         2         0       2m7s</span><br><span class="line">nginx-deploy-59c9f8dff    0         0         0       3d7h</span><br><span class="line">nginx-deploy-d47dbbb7c    3         3         3       81m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看 Pod 状态</span></span><br><span class="line">[root@kmaster ~]# kubect get pod</span><br><span class="line">NAME                            READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-deploy-58f69cfc57-5968g   0/1     ContainerCreating   0          42s</span><br><span class="line">nginx-deploy-58f69cfc57-tk7c5   0/1     ErrImagePull        0          42s</span><br><span class="line">nginx-deploy-d47dbbb7c-2chgx    1/1     Running             0          77m</span><br><span class="line">nginx-deploy-d47dbbb7c-8fcb9    1/1     Running             0          80m</span><br><span class="line">nginx-deploy-d47dbbb7c-gnwjj    1/1     Running             0          78m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 查看 Deployment 详情</span></span><br><span class="line">[root@kmaster ~]# kubectl describe deploy nginx-deploy</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age    From                   Message</span><br><span class="line">  ----    ------             ----   ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  3m57s  deployment-controller  Scaled up replica set nginx-deploy-58f69cfc57 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  3m57s  deployment-controller  Scaled down replica set nginx-deploy-d47dbbb7c to 3</span><br><span class="line">  Normal  ScalingReplicaSet  3m57s  deployment-controller  Scaled up replica set nginx-deploy-58f69cfc57 to 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看 Deployment 的历史版本</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br><span class="line">2         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br><span class="line">3         kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 查看某个版本的详情</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy --revision=3</span><br><span class="line">deployment.apps/nginx-deploy with revision #3</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:app=nginx</span><br><span class="line">pod-template-hash=58f69cfc57</span><br><span class="line">  Annotations:kubernetes.io/change-cause: kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:nginx:1.161</span><br><span class="line">    Port:80/TCP</span><br><span class="line">    Host Port:0/TCP</span><br><span class="line">    Environment:&lt;none&gt;</span><br><span class="line">    Mounts:&lt;none&gt;</span><br><span class="line">  Volumes:&lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 回滚到前一个版本</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout undo deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy rolled back</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 回滚到指定的版本</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout undo deploy nginx-deploy --to-revision=1</span><br><span class="line">deployment.apps/nginx-deploy rolled back</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. 查看历史版本信息</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">3         kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line">4         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br><span class="line">5         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br></pre></td></tr></table></figure><p>通过 <code>kubectl rollout undo</code> 命令可回滚到上一个版本或指定的版本，上述示例也可看出，回滚到历史版本，会将历史版本的序号设置为最新序号。如前所述，我们可以通过设置 Deployment 的 <code>.spec.revisionHistoryLimit</code> 来指定保留多少个旧的 ReplicaSet（或 revision），超出该数字的将在后台进行垃圾回收。如果该字段被设为 0，Kubernetes 将清理掉该 Deployment 的所有历史版本（revision），此时，将无法对该 Deployment 执行回滚操作了。</p><h3 id="5-伸缩"><a href="#5-伸缩" class="headerlink" title="5. 伸缩"></a>5. 伸缩</h3><p>可以通过 <code>kubectl scale</code> 命令或 <code>kubectl edit</code> 修改定义的方式来对 Deployment 进行伸缩，增加或减少 Pod 的副本数，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 Pod 数缩放到2个</span></span><br><span class="line">[root@kmaster ~]# kubectl scale deploy nginx-deploy --replicas=2</span><br><span class="line">deployment.apps/nginx-deploy scaled</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Pod</span></span><br><span class="line">[root@kmaster ~]# kubectl  get pod</span><br><span class="line">NAME                           READY   STATUS        RESTARTS   AGE</span><br><span class="line">nginx-deploy-59c9f8dff-7bpjp   1/1     Running       0          9m48s</span><br><span class="line">nginx-deploy-59c9f8dff-tpxzf   0/1     Terminating   0          8m57s</span><br><span class="line">nginx-deploy-59c9f8dff-v8fgz   0/1     Terminating   0          10m</span><br><span class="line">nginx-deploy-59c9f8dff-w8s9z   1/1     Running       0          10m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 ReplicaSet，DESIRED 变为2了</span></span><br><span class="line">[root@kmaster ~]# kubectl get rs</span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-58f69cfc57   0         0         0       22m</span><br><span class="line">nginx-deploy-59c9f8dff    2         2         2       3d8h</span><br><span class="line">nginx-deploy-d47dbbb7c    0         0         0       102m</span><br></pre></td></tr></table></figure><h3 id="6-自动伸缩（HPA）"><a href="#6-自动伸缩（HPA）" class="headerlink" title="6. 自动伸缩（HPA）"></a>6. 自动伸缩（HPA）</h3><p>如果集群启用了自动伸缩（HPA —— Horizontal Pod Autoscaling），则可以基于 CPU、 内存的使用率在一个最大和最小的区间对 Deployment 实现自动伸缩，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个 HPA</span></span><br><span class="line">[root@kmaster ~]# kubectl autoscale deploy nginx-deploy --min=2 --max=4 --cpu-percent=80</span><br><span class="line">horizontalpodautoscaler.autoscaling/nginx-deploy autoscaled</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 HPA</span></span><br><span class="line">[root@kmaster ~]# kubectl get hpa</span><br><span class="line">NAME           REFERENCE                 TARGETS         MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">nginx-deploy   Deployment/nginx-deploy   &lt;unknown&gt;/80%   2         4         2          16s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 HPA</span></span><br><span class="line">[root@kmaster ~]# kubectl delete hpa nginx-deploy</span><br><span class="line">horizontalpodautoscaler.autoscaling "nginx-deploy" deleted</span><br></pre></td></tr></table></figure><h3 id="7-暂停与恢复"><a href="#7-暂停与恢复" class="headerlink" title="7. 暂停与恢复"></a>7. 暂停与恢复</h3><p>我们可以将一个 Deployment 暂停（pause），然后在它上面做一个或多个更新，此时 Deployment 并不会触发更新，只有再恢复（resume）该 Deployment，才会执行该时间段内的所有更新。这种做法可以在暂停和恢复中间对 Deployment 做多次更新，而不会触发不必要的滚动更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 暂停 Deployment</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout pause deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy paused</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 更新容器镜像</span></span><br><span class="line">[root@kmaster ~]# kubectl set image deploy nginx-deploy nginx=nginx:1.9.1 --record</span><br><span class="line">deployment.apps/nginx-deploy image updated</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看版本历史， 此时并没有触发更新</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">3         kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line">4         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br><span class="line">5         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 更新 Resource 限制，同样并不会触发更新</span></span><br><span class="line">[root@kmaster ~]# kubectl set resources deploy nginx-deploy -c=nginx --limits=memory=512Mi,cpu=500m</span><br><span class="line">deployment.apps/nginx-deploy resource requirements updated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看修改，Pod 定义已被更新</span></span><br><span class="line">[root@kmaster ~]# kubectl describe deploy nginx-deploy</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:      nginx:1.9.1</span><br><span class="line">    Port:       80/TCP</span><br><span class="line">    Host Port:  0/TCP</span><br><span class="line">    Limits:</span><br><span class="line">      cpu:        500m</span><br><span class="line">      memory:     512Mi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 恢复 Deployment</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout resume deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy resumed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 查看版本历史，可见两次修改只做了一次 rollout</span></span><br><span class="line">[root@kmaster ~]# kubectl rollout history deploy nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">3         kubectl set image deploy nginx-deploy nginx=nginx:1.161 --record=true</span><br><span class="line">4         kubectl set image deploy nginx-deploy nginx=nginx:1.16.1 --record=true</span><br><span class="line">5         kubectl apply --filename=nginx-deploy.yaml --record=true</span><br><span class="line">6         kubectl set image deploy nginx-deploy nginx=nginx:1.9.1 --record=true</span><br></pre></td></tr></table></figure><p>在更新容器镜像时，因为 Deployment 处于暂停状态，所以并不会生成新的版本（Revision），当 Deployment 恢复时，才将这段时间的更新生效，执行滚动更新，生成新的版本。在暂停中的 Deployment 上做的更新， 因为没有生成版本，因此也不能回滚（rollback）。也不能对处于暂停状态的 Deployment 执行回滚操作，只有在恢复（Resume）之后才能执行回滚操作。</p><h3 id="8-金丝雀发布"><a href="#8-金丝雀发布" class="headerlink" title="8. 金丝雀发布"></a>8. 金丝雀发布</h3><p>金丝雀发布也叫灰度发布。当我们需要发布新版本时，可以针对新版本新建一个 Deployment，与旧版本的 Deployment 同时挂在一个 Service 下（通过 label match）， 通过 Service 的负载均衡将用户请求流量分发到新版 Deployment 的 Pod 上，观察新版运行情况，如果没有问题再将旧版 Deployment 的版本更新到新版完成滚动更新，最后删除新建的 Deployment。很明显这种金丝雀发布具有一定的局限性，无法根据用户或地域来分流，如果要更充分地实现金丝雀发布，则可能需要引入 Istio 等。</p><blockquote><p>金丝雀发布名称的由来： 以前，旷工在下矿洞时面临的一个重要危险是矿井中的毒气，他们想到一个办法来辨别矿井中是否有毒气，矿工们随身携带一只金丝雀下矿井，金丝雀对毒气的抵抗能力比人类要弱，在毒气环境下会先挂掉从而起到预警的作用。它背后的原理是：用较小的代价试错，即使出现了严重的错误（出现了毒气），系统总体的损失也是可承受的或者是非常小的（失去了一只金丝雀）。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kubernetes 中最小的调度单元是 Pod， 负载创建 Pod 并控制其按一定的副本数运行的是 ReplicaSet， 而 Deployment 可以以“声明式”的方式来管理 Pod 和 ReplicaSet，并提供滚动更新与版本（revision）回退功能。所以，一般使用 Deployment 来部署应用， 而不直接操作 ReplicaSet 或 Pod。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pod（容器组）是 Kubernetes 中最小的调度单元，可以通过 yaml 定义文件直接创建一个 Pod。但 Pod 本身并不具备自我恢复（self-healing）功能。如果一个 Pod 所在的节点出现故障，或者调度程序自身出现问题，以及节点资源不够或节点进入维护而驱逐 Pod 时，Pod 将被删除，且不能自我恢复。&lt;/p&gt;
&lt;p&gt;因此，Kubernetes 中我们一般不直接创建 Pod， 而是通过 Controller（控制器）来管理 Pod。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>在 Kubernetes Ingress 中支持 Websocket/Socket 服务</title>
    <link href="http://blog.jboost.cn/k8s-tcp-service.html"/>
    <id>http://blog.jboost.cn/k8s-tcp-service.html</id>
    <published>2020-08-05T07:50:08.000Z</published>
    <updated>2020-08-26T01:44:01.286Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes Ingress 可将集群内部的 Service 通过 HTTP/HTTPS 的方式暴露供外部访问，并通过路径匹配规则定义服务的路由。但是 Ingress 对 TCP/UDP 的服务却支持的不那么好。如果我们服务中有使用 Websocket 或 Socket， 需要暴露给外部访问，在 Kubernetes 中该如何配置呢？</p><a id="more"></a><p>大致有两种方式[见参考文档1]：</p><ol><li>使用 NodePort， 使用节点 IP 与 NodePort 暴露的端口访问</li><li>使用 ClusterIp + Ingress + ConfigMap</li></ol><p>使用 NodePort 将端口直接暴露，需要节点有外网 IP，且该方式可能绕过现有的 TLS， 存在安全性的问题。</p><p>ClusterIp 只能在集群内部访问，由 Ingress 进行代理对外暴露，但对于 TCP/UDP， Ingress 不支持直接代理， 需要借助 ConfigMap 进行映射。 </p><p>NodePort 的方式比较简单， 本文介绍 ClusterIp + Ingress + ConfigMap 的方式。</p><h2 id="创建-ClusterIp-服务"><a href="#创建-ClusterIp-服务" class="headerlink" title="创建 ClusterIp 服务"></a>创建 ClusterIp 服务</h2><p>假设有一个 Websocket/Socket 服务，暴露端口 8828， 针对该服务定义 ClusterIp 配置如下（不声明 type， 默认即为 ClusterIp），</p><figure class="highlight yaml"><figcaption><span>my-websocket-svc.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-websocket-svc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">develop</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">socket</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8828</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8828</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-websocket</span></span><br></pre></td></tr></table></figure><p>创建 ClusterIp，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl apply -f my-websocket-svc.yaml</span><br></pre></td></tr></table></figure><h2 id="创建-ConfigMap"><a href="#创建-ConfigMap" class="headerlink" title="创建 ConfigMap"></a>创建 ConfigMap</h2><p>在 ingress-nginx-controller 所在的 namespace 下创建 ConfigMap（如果已经有 ConfigMap 了， 则可在已有 ConfigMap 的 data 部分添加下面配置中的 data 条目）</p><figure class="highlight yaml"><figcaption><span>tcp-service-configmap.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcp-services</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">8828:</span> <span class="string">"develop/my-websocket-svc:8828"</span></span><br></pre></td></tr></table></figure><p>data 部分的格式为： <code>&lt;namespace/service name&gt;:&lt;service port&gt;:[PROXY]:[PROXY]</code>， <code>[PROXY]:[PROXY]</code> 部分为可选。 上述配置表示将宿主机的 8828 端口 映射到 develop namespace 下 my-websocket-svc 服务的 8828 端口上。</p><p>创建 ConfigMap，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster k8s-deploy]# kubectl apply -f tcp-service-configmap.yaml</span><br></pre></td></tr></table></figure><h2 id="配置-ingress-nginx-controller"><a href="#配置-ingress-nginx-controller" class="headerlink" title="配置 ingress-nginx-controller"></a>配置 ingress-nginx-controller</h2><p>修改 ingress-nginx-controller 的配置，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl edit deploy ingress-nginx-controller -n ingress-nginx</span><br></pre></td></tr></table></figure><p>在 <code>.spec.template.spec.containers[].args[]</code> 部分添加 <code>--tcp-services-configmap=$(POD_NAMESPACE)/tcp-services</code> （或针对 UDP， <code>--udp-services-configmap=$(POD_NAMESPACE)/udp-services</code>）， 如下图所示</p><p><img src="/assets/ingress-tcp.png" alt="ingress-tcp"></p><p>在<code>.spec.template.spec.containers[].ports[]</code> 部分添加 port 映射，如图</p><p><img src="/assets/ingress-tcp-port.png" alt="ingress-tcp-port"></p><blockquote><p>经验证，不加该部分 port 映射配置也没问题</p></blockquote><p>保存，应用配置更新，nginx-ingress-controller 将会自动重启 Pod，使配置生效。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在 nginx-ingress-controller Pod 所在节点上执行如下命令查看是否监听了 TCP 端口，</p><p><img src="/assets/ingress-tcp-check.png" alt="ingress-tcp-check"></p><p>如上，8828 端口已被 nginx-ingress 监听。</p><p>对于 Websocket 应用， 可使用 wscat 进行调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;wscat -c ws://域名:8828</span><br><span class="line">Connected (press CTRL+C to quit)</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>wscat 安装： <code>npm install -g wscat</code></p></blockquote><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li>注意 ConfigMap 的 namesapce 与 nginx-ingress-controller 一致，否则将 <code>--tcp-services-configmap=$(POD_NAMESPACE)/tcp-services</code> 中的 <code>$(POD_NAMESPACE)</code> 改为 ConfigMap 具体的 namesapce</li><li>如果将 nginx-ingress-controller 绑定了节点，则重启可能导致失败（因为端口分配冲突），可先删除（<code>kubectl delete deploy ingress-nginx-controller -n ingress-nginx</code>），再新建（<code>kubectl apply -f nginx-ingress.yaml</code>），该操作会影响服务可用性，生产环境需慎重</li><li>如果配置后未生效，可通过查看 nginx-ingress-controller Pod 的日志定位原因 <code>kubectl logs ingress-nginx-controller-58fdbbc68d-wqtlr -n ingress-nginx</code></li></ol><p><em>参考文档：</em></p><ol><li><a href="https://www.ibm.com/support/knowledgecenter/en/SSSHTQ/omnibus/helms/all_helms/wip/reference/hlm_expose_probe.html" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/en/SSSHTQ/omnibus/helms/all_helms/wip/reference/hlm_expose_probe.html</a></li><li><a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/exposing-tcp-udp-services.md" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/exposing-tcp-udp-services.md</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes Ingress 可将集群内部的 Service 通过 HTTP/HTTPS 的方式暴露供外部访问，并通过路径匹配规则定义服务的路由。但是 Ingress 对 TCP/UDP 的服务却支持的不那么好。如果我们服务中有使用 Websocket 或 Socket， 需要暴露给外部访问，在 Kubernetes 中该如何配置呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（五）：了解Pod（容器组）</title>
    <link href="http://blog.jboost.cn/k8s5-pod.html"/>
    <id>http://blog.jboost.cn/k8s5-pod.html</id>
    <published>2020-07-28T09:17:37.000Z</published>
    <updated>2020-08-26T01:44:23.358Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes 中， 容器总是以 Pod（容器组）的方式进行调度与运行。因此对 Pod 的理解与掌握是学习 Kubernetes 的基础。</p><a id="more"></a><h2 id="理解-Pod"><a href="#理解-Pod" class="headerlink" title="理解 Pod"></a>理解 Pod</h2><p>Pod（容器组）是 Kubernetes 中最小的调度单元，每一个Pod都是某个应用程序的一个运行实例。以前我们的 Web 应用都是以 Tomcat 等 Web 容器进程的形式运行在操作系统中，在 Kubernetes 中，我们需要将 Web 应用打成镜像，以容器的方式运行在 Pod 中。</p><p>Kubernetes 不会直接管理容器，而是通过 Pod 来管理。一个Pod包含如下内容：</p><ol><li>一个或多个容器， 一般是一个，除非多个容器紧密耦合共享资源才放在一个 Pod 中；</li><li>共享的存储资源（如数据卷），一个 Pod 中的容器是可以共享存储空间的；</li><li>一个共享的 IP 地址，Pod 中容器之间可以通过 localhost:port 彼此访问；</li><li>定义容器该如何运行的选项。</li></ol><p>Pod 中的容器可包括两种类型：</p><ol><li>工作容器：就是我们通常运行服务进程的容器</li><li>初始化容器：完成一些初始化操作的容器，初始化容器在工作容器之前运行，所有的初始化容器成功执行后，才开始启动工作容器</li></ol><h2 id="管理-Pod"><a href="#管理-Pod" class="headerlink" title="管理 Pod"></a>管理 Pod</h2><h3 id="创建-Pod"><a href="#创建-Pod" class="headerlink" title="创建 Pod"></a>创建 Pod</h3><p>在 Kubernetes 中，我们一般不直接创建 Pod，而是通过控制器来调度管理（Deployment，StatefulSet，DaemonSet 等），这里为了便于了解，先通过 yaml 配置文件的方式定义 Pod 来直接创建 Pod。定义配置文件 pod-test.yaml 如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-test</span>  <span class="comment"># pod 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># pod 创建的 namespace</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span>     <span class="comment"># pod 中容器定义</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span> <span class="comment"># 重启策略</span></span><br><span class="line">  <span class="attr">volumes:</span>                 <span class="comment"># 数据卷定义</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><p>其中 spec 部分的 containers 定义了该 Pod 中运行的容器，从 containers 的复数形式也可以看出一个 Pod 中是可以运行多个容器的。</p><p>执行 <code>kubectl create</code> 或 <code>kubectl apply</code> 命令创建 Pod，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl create -f pod-test.yaml</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">[root@kmaster test]# kubectl apply -f pod-test.yaml</span><br></pre></td></tr></table></figure><p>该 Pod 创建后将会拉取一个最新的 nginx 镜像，运行一个 nginx 容器，并将容器的 80 端口映射到宿主机的 8081 端口。</p><h3 id="查看-Pod"><a href="#查看-Pod" class="headerlink" title="查看 Pod"></a>查看 Pod</h3><p>可使用 <code>kubectl get pods</code> 命令查看当前 namesapce 下的所有 Pod，加 Pod 名称查看具体某个 Pod。 如果需要查看 Pod 调度到了哪个节点，可加 <code>-o wide</code> 选项，如果查看 yaml 文件信息则可加 <code>-o yaml</code> 选项， 如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl get pods</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-test                       1/1     Running   0          116s</span><br><span class="line"></span><br><span class="line">[root@kmaster test]# kubectl get pods pod-test -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE     IP            NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">pod-test                       1/1     Running   0          2m19s   10.244.1.42   knode2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">[root@kmaster test]# kubectl get pods pod-test -o yaml</span><br></pre></td></tr></table></figure><p>如果要查看更多的信息，可使用 <code>kubectl describe</code> 命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl describe pod pod-test</span><br></pre></td></tr></table></figure><p>该命令输出内容如下图，</p><p><img src="/assets/describe-pod.png" alt="describe-pod"></p><p>各部分说明：</p><ol><li>Status: Pending， 表示 Pod 的整体状态，当前处于 Pending 状态；</li><li>State: Waiting，Pod 中每个容器都有一个自己的状态 State， 当前容器 nginx 处于 Waiting 状态，Reason: ContainerCreating 表示容器还处于创建中，Ready：False 表明容器还未就绪，还不能对外提供服务；</li><li>Conditions， 这部分聚合了一些状态，第一个 Initialized：True，表明已经完成了初始化；而第二个 Ready：False，表明 Pod 还未就绪；ContainersReady：False，表明容器还未就绪；  PodScheduled：True，表明 Pod 已经被调度到某个具体的节点上了；</li><li>3中不同的状态之间的转换都会发生相应的事件，事件类型包括 Normal 与 Warning 两种， 从上图可看到一个 Pulling image 的 Normal 事件，表示当前正在拉取 Pod 中容器的镜像。</li></ol><p>当 Pod 在调度或运行中出现问题时，我们都可以使用 <code>kubectl describe</code> 命令来进行排查，通过其中的状态及事件来判断问题产生的可能原因。</p><h3 id="进入-Pod-容器"><a href="#进入-Pod-容器" class="headerlink" title="进入 Pod 容器"></a>进入 Pod 容器</h3><p>通过 <code>kubectl exec</code> 命令可进入 Pod， 类似于 <code>docker exec</code>， 如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果 Pod 中只有一个容器</span></span><br><span class="line">[root@kmaster test]# kubectl exec -it pod-test bash</span><br><span class="line">root@pod-test:/#</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果 Pod 中有多个容器</span></span><br><span class="line">kubectl exec -it pod-name -c container-name /bin/bash</span><br></pre></td></tr></table></figure><p>如果一个 Pod 中有多个容器，则需要通过 <code>-c</code> 指定进入哪个容器。</p><h3 id="更新-删除-Pod"><a href="#更新-删除-Pod" class="headerlink" title="更新/删除 Pod"></a>更新/删除 Pod</h3><p>Kubernetes 对 Pod 的更新做了限制，除了更改 Pod 中容器（包括工作容器与初始化容器）的镜像，以及 activeDeadlineSeconds （对 Job 类型的 Pod 定义失败重试的最大时间）， tolerations （Pod 对污点的容忍），修改其它部分将不会产生作用，如我们可以尝试在前面 Pod 定义文档 pod-test.yaml 中将宿主机端口 8081 改为 8082，重新执行 <code>kubectl apply</code>， 将提示如下错误，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl apply -f pod-test.yaml</span><br><span class="line">The Pod "pod-test" is invalid: spec: Forbidden: pod updates may not change fields other than `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds` or `spec.tolerations` (only additions to existing tolerations)</span><br></pre></td></tr></table></figure><p>通过 <code>kubectl delete</code> 命令可删除一个 Pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster test]# kubectl delete pod pod-test</span><br></pre></td></tr></table></figure><p>在 Kubernetes 中，一般不直接创建，更新或删除单个 Pod，而是通过 Kubernetes 的 Controller（控制器）来管理 Pod，包括 ReplicSet（一般也不直接用，推荐Deployment方式）， Deployment，StatefulSet，DaemonSet 等。</p><p>控制器提供如下功能：</p><ol><li>水平伸缩，控制运行 Pod 指定个数的副本</li><li>rollout，即版本更新</li><li>故障恢复，当一个节点出现故障，或资源不够，或进入维护中，控制器会自动在另一个合适的节点调度一个一样的 Pod，以保障 Pod 以一定的副本数运行</li></ol><h2 id="Pod-状态"><a href="#Pod-状态" class="headerlink" title="Pod 状态"></a>Pod 状态</h2><p>Pod状态并不是容器的状态，容器的状态一般包括：</p><p>Waiting： 容器的初始状态，处于 Waiting 状态的容器，表示仍然有对应的操作在执行，例如：拉取镜像、应用 Secrets等<br>Running： 容器处于正常运行的状态<br>Terminated： 容器处于结束运行的状态</p><p>而Pod的状态一般包括：</p><ul><li>Pending： Kubernetes 已经创建并确认该 Pod，可能两种情况： 1. Pod 还未完成调度（例如没有合适的节点）；2. 正在从 docker registry 下载镜像</li><li>Running： 该 Pod 已经被绑定到一个节点，并且该 Pod 所有的容器都已经成功创建，其中至少有一个容器正在运行，或者正在启动/重启</li><li>Succeeded：Pod 中的所有容器都已经成功终止，并且不会再被重启</li><li>Failed：Pod 中的所有容器都已经终止，至少一个容器终止于失败状态：容器的进程退出码不是 0，或者被系统 kill</li><li>Unknown： 因为某些未知原因，不能确定 Pod 的状态，通常的原因是 master 与 Pod 所在节点之间的通信故障</li></ul><p>状态之间的变迁关系如图</p><p><img src="/assets/pod-status-trans.png" alt="pod-status-trans"></p><p>Pod 刚开始处于 Pending 的状态，接下来可能会转换到 Running，也可能转换到 Unknown，甚至可能转换到 Failed。然后，当 Running 执行了一段时间之后，它可以转换到类似像 Successded 或者是 Failed。 当出现 Unknown 这个状态时，可能由于一些状态的恢复，它会重新恢复到 Running 或者 Successded 或者是 Failed。</p><h2 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h2><p>定义 Pod 或工作负载时，可以指定 restartPolicy，可选的值有：</p><ol><li>Always：默认值，只要退出就重启</li><li>OnFailure：失败退出时（exit code 不为 0）才重启</li><li>Never： 永远不重启</li></ol><p>restartPolicy 作用于 Pod 中的所有容器。kubelete 将在五分钟内，按照递延的时间间隔（10s, 20s, 40s …）尝试重启已退出的容器，并在十分钟后再次启动这个循环，直到容器成功启动，或者 Pod 被删除。在控制器 Deployment/StatefulSet/DaemonSet 中，只支持 Always 这一个选项，不支持 OnFailure 和 Never 选项。</p><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>提高应用服务的可用性与稳定性，一般可从两个方面来进行：</p><ol><li>首先是提高应用的可观测性，如对应用的健康状态，资源的使用情况，应用日志等可进行实时的观测</li><li>第二是提高应用的可恢复能力，在应用出现故障时，能通过自动重启等方式进行恢复</li></ol><p>Kubernetes 中对 Pod 的健康检查提供了两种方式：</p><ol><li>Readiness probe，就绪探测，用来判断一个 Pod 是否处于就绪状态，是否能对外提供相应服务了。当Pod处于就绪状态时，负载均衡器才会将流量打到这个 Pod，否则将把流量从这个 Pod 上面摘除。</li><li>Liveness probe，存活探测，用来判断一个 Pod 是否处于存活状态，如果一个 Pod 被探测到不处于存活状态，则由上层判断机制来处理，如果上层配置重启策略为 restart always 的话，Pod 就会被重启。</li></ol><p>Liveness probe 适用场景是支持那些可以重新拉起的应用，而 Readiness probe 主要应对的是启动之后无法立即对外提供服务的应用。</p><p>就绪探测、存活探测目前支持三种不同的探测方式：</p><ol><li>httpGet，通过发送http Get请求来判断，返回状态码在 200-399之间，认为是探测成功</li><li>Exec，通过执行容器中的一个命令来判断服务是否正常，如果命令的退出状态码为 0，表示成功</li><li>tcpSocket，通过容器的IP，端口来进行TCP连接检查，如果TCP连接能被正常建立，则认为成功</li></ol><p>以 httpGet 为例，示例配置文件如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="comment"># ... 与前同</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">httpHeaders:</span> <span class="comment"># 此处header无意义，仅作示例</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">purpose</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">for-test</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="comment"># ... 与前同</span></span><br></pre></td></tr></table></figure><p>删除之前的 Pod， 重新创建，使用 <code>kubectl describe</code> 查看，可看到 Events 部分如下图，</p><p><img src="/assets/liveness-probe.png" alt="liveness-probe"></p><p>Http 存活探测失败，状态码返回 403， 导致容器重启。出现这个错误的原因是前面做目录挂载时将 nginx 的 html 目录挂载到了宿主机的 /tmp 目录， 而 /tmp 目录没有 index.html 文件，导致请求返回403， 在 Pod 调度到的宿主机 /tmp 目录下创建 index.html 文件即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo '&lt;h1&gt;Hello, K8s!&lt;/h1&gt;' &gt; /tmp/index.html</span><br></pre></td></tr></table></figure><p>其它 Exec，tcpSocket 探测的配置示例如下（配置在 containers 元素下），</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec</span></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tcpSocket</span></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">tcpSocket:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>支持的参数说明：</p><ul><li>initialDelaySeconds：延迟探测时间，表示 Pod 启动延迟多久后进行一次检查，比如某个应用启动时间如果较长的话，可以设置该值为略大于启动时间；</li><li>periodSeconds：探测频率，表示探测的时间间隔，正常默认的这个值是 10 秒；</li><li>timeoutSeconds：超时时间，表示探测的超时时间，当超时时间之内没有检测成功，那会认为失败；</li><li>successThreshold：健康阈值，表示当这个 Pod 从探测失败到再一次判断探测成功，所需要的阈值次数，默认情况下是 1 次。如果之前探测失败，接下来的一次探测成功了，就会认为这个 Pod 是处在一个正常的状态；</li><li>failureThreshold： 不健康阈值，与 successThreshold 相对，表示认为探测失败需要重试的次数，默认值是 3。意思是当从一个健康的状态连续探测到 3 次失败，就会认为Pod 的状态处在一个失败的状态。</li></ul><p>readinessProbe 配置与 livenessProbe 类似。阿里云上配置就绪检查如图所示：</p><p><img src="/assets/aliyun-readiness-probe.png" alt="aliyun-readiness-probe"></p><p>健康检查的结果分为三种：</p><ol><li>Success，表示 container 通过了健康检查，也就是 Liveness probe 或 Readiness probe 是正常的一个状态；</li><li>Failure，表示 container 没有通过健康检查。针对 Readiness probe，service 层就会将没有通过 Readiness probe 的 pod 进行摘除，不再分发请求到该 Pod；针对 Liveness probe，就会将这个 pod 进行重新拉起，或者是删除。</li><li>Unknown，表示当前的执行机制没有进行完整的一个执行，可能是因为类似像超时或者像一些脚本没有及时返回，此时 Readiness probe 或 Liveness probe 不做任何操作，会等待下一次的机制来进行检查。</li></ol><p>健康检查的一些实践建议：</p><ol><li>如果容器中的进程在碰到问题时可以自己 crash，就不需要执行存活探测，因为 kubelet 可以自动的根据 Pod 的 restartPolicy（重启策略）来执行对应的动作；</li><li>如果希望在容器的进程无响应后，将容器重启，则指定一个存活探测 livenessProbe，并同时指定 restartPolicy（重启策略）为 Always 或者 OnFailure；</li><li>如果希望在 Pod 确实就绪之后才向其分发服务请求，就指定一个就绪检查 readinessProbe；</li><li>适当调大 exec 探测的超时阈值，因为在容器里面执行一个 shell 脚本，它的执行时长是非常长的，平时在一台虚机上执行可能 3 秒返回的一个脚本在容器里面可能需要 30 秒。可以适当调大超时阈值，来防止由于容器压力比较大的时候出现偶发的超时；</li><li>调整失败判断的次数，3 次的默认值有时候可能不一定是最佳实践，适当调整一下判断的次数也是一个比较好的方式；</li><li>使用 tcpSocket 方式进行判断的时候，如果遇到了 TLS 的服务，那可能会造成后边 TLS 里面有很多这种未鉴权的 tcp 连接，这时候需要自己针对业务场景判断这种连接是否会对业务造成影响。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对 Pod 的概念与基本的管理操作，Pod 的状态变迁机制与重启策略进行了介绍，对 Pod 的健康检查进行了详细的了解。但在 Kubernetes 中，我们一般不直接创建 Pod，而是通过控制器，如Deployment，StatefulSet，DaemonSet， 因为控制器能为我们提供水平伸缩，rollout（版本更新），self-healing（故障恢复）等能力。我们将在接下来的文章了解控制器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 中， 容器总是以 Pod（容器组）的方式进行调度与运行。因此对 Pod 的理解与掌握是学习 Kubernetes 的基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存常用策略及Vue应用的Nginx缓存设置</title>
    <link href="http://blog.jboost.cn/browser-cache.html"/>
    <id>http://blog.jboost.cn/browser-cache.html</id>
    <published>2020-07-22T05:59:42.000Z</published>
    <updated>2020-08-26T01:40:38.768Z</updated>
    
    <content type="html"><![CDATA[<p>最近一次移动端Vue应用的上线，导致某些用户使用某些功能时出现问题，经主动清空缓存后恢复。有时候清空微信应用的存储空间缓存仍不能解决问题，此时安卓机可借助微信TBS调试工具 <a href="http://debugx5.qq.com" target="_blank" rel="noopener">http://debugx5.qq.com</a> （微信中打开页面，勾选最下面四个选项清除缓存），但该工具目前只支持安卓手机，苹果机就比较麻烦了。为了找到问题的本质，从根本上避免问题，最近浏览了一些文章，其中有一篇对浏览器缓存的分析及在Nginx中对应的处理策略总结的比较好，这里分享给大家。</p><a id="more"></a><ul><li>原文标题：http常用缓存策略及vue-cli单页面应用服务器端(nginx)如何设置缓存</li><li>原文地址：<a href="http://www.shanhuxueyuan.com/news/detail/125.html" target="_blank" rel="noopener">http://www.shanhuxueyuan.com/news/detail/125.html</a></li></ul><p><em>以下为原文。</em></p><p>关于http或者是浏览器缓存策略，我认为可以分为这三种：</p><ul><li>不使用缓存</li><li>强制使用缓存</li><li>协商使用缓存</li></ul><h2 id="不使用缓存"><a href="#不使用缓存" class="headerlink" title="不使用缓存"></a>不使用缓存</h2><p>有时，我们希望浏览器永远都不要使用缓存，全部到服务器拉取数据，此时即为不使用缓存，我们可以在服务端通过Cache-Control为 no-store实现。</p><p><img src="/assets/httpcache1.png" alt="httpcache1"></p><p>服务器端针对上面文件设置了no-store，可以看到在请求的时候，无论怎么刷新，都是返回200，不会显示304，也不会显示“memory cache”或“disk cache”，说明真的都是从服务器重新拉取数据。</p><p>比如我们想设置html文件不缓存，可以在域名的解析配置中如下设置，当文件后缀为html或htm时add_header Cache-Control “no-store”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name yourdomain.com;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    root &#x2F;yourdir&#x2F;;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    if ($request_filename ~* .*\.(?:htm|html)$)</span><br><span class="line">    &#123;</span><br><span class="line">        add_header Cache-Control &quot;no-store&quot;;  &#x2F;&#x2F;对html文件设置永远不缓存</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式缺点就是每次都要去服务端拉取文件，即使文件没有更新，很明显这样增加了不必要的带宽消耗。</p><p>如果文件没有更新，我们就使用缓存，只有更新了才去拉取最新文件，这样多好，这就是协商缓存。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是浏览器携带文件缓存标识（如Last-Modified或ETag），向服务器发送请求，由服务器根据文件缓存标识来决定是否使用缓存，如果文件没有更新，则告诉浏览器使用本地缓存，如果文件更新了，则直接返回新文件内容。</p><p>可以看出，相比不使用缓存，协商缓存是会大大减少带宽消耗的。</p><ul><li>协商缓存生效，返回304 和 Not Modified</li></ul><p><img src="/assets/httpcache2.png" alt="httpcache2"></p><ul><li>协商缓存无效，返回200和请求文件</li></ul><p><img src="/assets/httpcache3.png" alt="httpcache3"></p><p>我们在浏览器调试页面，可以看到有304的，即是使用了协商缓存</p><p><img src="/assets/httpcache4.png" alt="httpcache4"></p><p>服务器返回的header中会有Last-Modified和ETag标识，而浏览器请求header中会包含If-Modified-Since和If-None-Match</p><p><img src="/assets/httpcache5.png" alt="httpcache5"></p><h3 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h3><p>在 http 1.0 版本中，第一次请求资源时服务器通过 Last-Modified 来设置响应头的缓存标识，并且把资源最后修改的时间作为值填入，然后将资源返回给浏览器。在第二次请求时，浏览器会首先带上 If-Modified-Since 请求头去访问服务器，服务器会将 If-Modified-Since 中携带的时间与资源修改的时间匹配，如果时间不一致，服务器会返回新的资源，并且将 Last-Modified 值更新，作为响应头返回给浏览器。如果时间一致，表示资源没有更新，服务器返回 304 状态码，浏览器拿到响应状态码后从本地缓存数据库中读取缓存资源。</p><p>这种方式有2个弊端，第一个就是当服务器中的资源增加了一个字符，后来又把这个字符删掉，本身资源文件并没有发生变化，但修改时间发生了变化。当下次请求过来时，服务器也会把这个本来没有变化的资源重新返回给浏览器；第二个就是修改时间的单位为秒，所以存在1s的间隙，即使更新了，也会认为没有更新。</p><h3 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h3><p>在 http 1.1 版本中，服务器通过 Etag 来设置响应头缓存标识。Etag 的值由服务端生成，可以认为是文件内容的hash值。在第一次请求时，服务器会将资源和 Etag 一并返回给浏览器，浏览器将两者缓存到本地缓存数据库。在第二次请求时，浏览器会将 Etag 信息放到 If-None-Match 请求头去访问服务器，服务器收到请求后，会将服务器中的文件标识与浏览器发来的标识进行对比，如果不相同，服务器返回更新的资源和新的 Etag ，如果相同，服务器返回 304 状态码，浏览器读取缓存。</p><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ul><li>首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</li><li>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</li><li>第三在优先级上，服务器校验优先考虑Etag</li></ul><h3 id="协商缓存服务端配置"><a href="#协商缓存服务端配置" class="headerlink" title="协商缓存服务端配置"></a>协商缓存服务端配置</h3><p>可以在服务端通过设置Cache-Control为 no-cache或者max-age=0来实现</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>有时我们希望文件强制使用缓存，比如通过vue-cli产生的js和css，文件名上带有hash值，所以如果文件名没有变的时候，我们希望文件永久缓存，这样可以减少网络请求。</p><p>强制缓存整体流程比较简单，就是在第一次访问服务器取到数据之后，在过期时间之内不会再去重复请求。实现这个流程的核心就是如何知道当前时间是否超过了过期时间。</p><p>强制缓存的过期时间通过第一次访问服务器时返回的响应头获取。在 http 1.0 和 http 1.1 版本中通过不同的响应头字段实现。</p><p>在 http 1.0 版本中，强制缓存通过 Expires 响应头来实现。 expires 表示未来资源会过期的时间。也就是说，当发起请求的时间超过了 expires 设定的时间，即表示资源缓存时间到期，会发送请求到服务器重新获取资源。而如果发起请求的时间在 expires 限定的时间之内，浏览器会直接读取本地缓存数据库中的信息（from memory or from disk），两种方式根据浏览器的策略随机获取。</p><p>在 http 1.1 版本中，可以设置Cache-Control中的 max-age=xxx ，来表示缓存的资源将在 xxx 秒后过期。一般来说，为了兼容，两个版本的强制缓存都会被实现。</p><p>为什么有了Expires，后来又增加了max-age呢，这是因为Expires是一个绝对时间，有可能客户端的时间和服务器不一致，导致缓存不能按照预期进行，而max-age则是个相对时间，比如3600s，自浏览器请求后3600s之内，都使用本地缓存，和客户端的时间没关系。</p><h2 id="vue-cli缓存策略"><a href="#vue-cli缓存策略" class="headerlink" title="vue-cli缓存策略"></a>vue-cli缓存策略</h2><p>由于打包后的js、css和图片，一般名称都带有hash值，名称中的hash变了，自然会拉取新文件，所以我们可以将这类文件设置为强制缓存，只要文件名不变，就一直缓存，比如缓存100天或者一年。</p><p>而html文件则不能设为强制缓存，一般html名称是没法带hash值的，所以html如果设置了强制缓存，则永远也没法更新，html不更新，其引用的js、css等名称也不会更新，则整个服务都没有更新，只能让用户清除缓存了。所以针对html文件，我们可以设置协商缓存或者直接不使用缓存，本身html文件都比较小，我是直接使用了不缓存，nginx配置如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name yourdomain.com;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    root &#x2F;yourdir&#x2F;;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    if ($request_filename ~* .*\.(js|css|woff|png|jpg|jpeg)$)</span><br><span class="line">    &#123;</span><br><span class="line">        expires    100d;  &#x2F;&#x2F;js、css、图片缓存100天</span><br><span class="line">        #add_header Cache-Control &quot;max-age &#x3D; 8640000&quot;; &#x2F;&#x2F;或者设置max-age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($request_filename ~* .*\.(?:htm|html)$)</span><br><span class="line">    &#123;</span><br><span class="line">        add_header Cache-Control &quot;no-store&quot;;  &#x2F;&#x2F;html不缓存</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一次移动端Vue应用的上线，导致某些用户使用某些功能时出现问题，经主动清空缓存后恢复。有时候清空微信应用的存储空间缓存仍不能解决问题，此时安卓机可借助微信TBS调试工具 &lt;a href=&quot;http://debugx5.qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://debugx5.qq.com&lt;/a&gt; （微信中打开页面，勾选最下面四个选项清除缓存），但该工具目前只支持安卓手机，苹果机就比较麻烦了。为了找到问题的本质，从根本上避免问题，最近浏览了一些文章，其中有一篇对浏览器缓存的分析及在Nginx中对应的处理策略总结的比较好，这里分享给大家。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="nginx" scheme="http://blog.jboost.cn/tags/nginx/"/>
    
      <category term="vue" scheme="http://blog.jboost.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>一个轻量级的基于RateLimiter的分布式限流实现</title>
    <link href="http://blog.jboost.cn/distributedratelimiter.html"/>
    <id>http://blog.jboost.cn/distributedratelimiter.html</id>
    <published>2020-07-13T03:21:43.000Z</published>
    <updated>2020-08-26T01:39:49.568Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章（<a href="http://blog.jboost.cn/ratelimiter.html">限流算法与Guava RateLimiter解析</a>）对常用的限流算法及Google Guava基于令牌桶算法的实现RateLimiter进行了介绍。RateLimiter通过线程锁控制同步，只适用于单机应用，在分布式环境下，虽然有像阿里Sentinel的限流开源框架，但对于一些小型应用来说未免过重，但限流的需求在小型项目中也是存在的，比如获取手机验证码的控制，对资源消耗较大操作的访问频率控制等。本文介绍最近写的一个基于RateLimiter，适用于分布式环境下的限流实现，并使用spring-boot-starter的形式发布，比较轻量级且“开箱即用”。</p><a id="more"></a><p>本文限流实现包括两种形式：</p><ol><li>基于RateLimiter令牌桶算法的限速控制（严格限制访问速度）</li><li>基于Lua脚本的限量控制（限制一个时间窗口内的访问量，对访问速度没有严格限制）</li></ol><h2 id="限速控制"><a href="#限速控制" class="headerlink" title="限速控制"></a>限速控制</h2><h3 id="1-令牌桶模型"><a href="#1-令牌桶模型" class="headerlink" title="1. 令牌桶模型"></a>1. 令牌桶模型</h3><p>首先定义令牌桶模型，与RateLimiter中类似，包括几个关键属性与关键方法。其中关键属性定义如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPermits</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大存储令牌数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> maxPermits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前存储令牌数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> storedPermits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加令牌的时间间隔/毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> intervalMillis;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下次请求可以获取令牌的时间，可以是过去（令牌积累）也可以是将来的时间（令牌预消费）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextFreeTicketMillis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>关键方法定义与RateLimiter也大同小异，方法注释基本已描述各方法用途，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建Redis令牌数据模型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permitsPerSecond     每秒放入的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxBurstSeconds      maxPermits由此字段计算，最大存储maxBurstSeconds秒生成的令牌</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextFreeTicketMillis 下次请求可以获取令牌的起始时间，默认当前系统时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisPermits</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> maxBurstSeconds, Long nextFreeTicketMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.maxPermits = permitsPerSecond * maxBurstSeconds;</span><br><span class="line">    <span class="keyword">this</span>.storedPermits = maxPermits;</span><br><span class="line">    <span class="keyword">this</span>.intervalMillis = TimeUnit.SECONDS.toMillis(<span class="number">1</span>) / permitsPerSecond;</span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMillis = nextFreeTicketMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于当前时间，若当前时间晚于nextFreeTicketMicros，则计算该段时间内可以生成多少令牌，将生成的令牌加入令牌桶中并更新数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMillis &gt; nextFreeTicketMillis) &#123;</span><br><span class="line">        <span class="keyword">double</span> newPermits = (nowMillis - nextFreeTicketMillis) / intervalMillis;</span><br><span class="line">        storedPermits = Math.min(maxPermits, storedPermits + newPermits);</span><br><span class="line">        nextFreeTicketMillis = nowMillis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 保留指定数量令牌，并返回需要等待的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">long</span> nowMillis, <span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    resync(nowMillis);</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = Math.min(permits, storedPermits); <span class="comment">// 可以消耗的令牌数</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = permits - storedPermitsToSpend; <span class="comment">// 需要等待的令牌数</span></span><br><span class="line">    <span class="keyword">long</span> waitMillis = (<span class="keyword">long</span>) (freshPermits * intervalMillis); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    nextFreeTicketMillis = LongMath.saturatedAdd(nextFreeTicketMillis, waitMillis);</span><br><span class="line">    storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> waitMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在超时时间内，是否有指定数量的令牌可用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAcquire</span><span class="params">(<span class="keyword">long</span> nowMillis, <span class="keyword">int</span> permits, <span class="keyword">long</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryEarliestAvailable(nowMillis, permits) &lt;= timeoutMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定数量令牌数可用需等待的时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits 需保留的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定数量令牌可用的等待时间，如果为0或负数，表示当前可用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">queryEarliestAvailable</span><span class="params">(<span class="keyword">long</span> nowMillis, <span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    resync(nowMillis);</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = Math.min(permits, storedPermits); <span class="comment">// 可以消耗的令牌数</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = permits - storedPermitsToSpend; <span class="comment">// 需要等待的令牌数</span></span><br><span class="line">    <span class="keyword">long</span> waitMillis = (<span class="keyword">long</span>) (freshPermits * intervalMillis); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LongMath.saturatedAdd(nextFreeTicketMillis - nowMillis, waitMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-令牌桶控制类"><a href="#2-令牌桶控制类" class="headerlink" title="2. 令牌桶控制类"></a>2. 令牌桶控制类</h3><p>Guava RateLimiter中的控制都在RateLimiter及其子类中（如SmoothBursty），本处涉及到分布式环境下的同步，因此将其解耦，令牌桶模型存储于Redis中，对其同步操作的控制放置在如下控制类，其中同步控制使用到了前面介绍的分布式锁（参考<a href="http://blog.jboost.cn/distributedlock.html">基于Redis分布式锁的正确打开方式</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRateLimiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个令牌，阻塞一直到获取令牌，返回阻塞等待时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 阻塞等待时间/毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">acquire</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> acquire(key, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定数量的令牌，如果令牌数不够，则一直阻塞，返回阻塞等待的时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需要获取的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 等待的时间/毫秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens值不能为负数或零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">acquire</span><span class="params">(String key, <span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> millisToWait = reserve(key, permits);</span><br><span class="line">        log.info(<span class="string">"acquire &#123;&#125; permits for key[&#123;&#125;], waiting for &#123;&#125;ms"</span>, permits, key, millisToWait);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(millisToWait);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Interrupted when trying to acquire &#123;&#125; permits for key[&#123;&#125;]"</span>, permits, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> millisToWait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定时间内获取一个令牌，如果获取不到则一直阻塞，直到超时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 最大等待时间（超时时间），为0则不等待立即返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取到令牌则true，否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(String key, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(key, <span class="number">1</span>, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定时间内获取指定数量的令牌，如果在指定时间内获取不到指定数量的令牌，则直接返回false，</span></span><br><span class="line"><span class="comment">     * 否则阻塞直到能获取到指定数量的令牌</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需要获取的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 最大等待时间（超时时间）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果在指定时间内能获取到指定令牌数，则true,否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens为负数或零，抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(String key, <span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timeoutMillis = Math.max(unit.toMillis(timeout), <span class="number">0</span>);</span><br><span class="line">        checkPermits(permits);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> millisToWait;</span><br><span class="line">        <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.lock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId(), <span class="number">60</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                <span class="keyword">long</span> nowMillis = getNowMillis();</span><br><span class="line">                RedisPermits permit = getPermits(key, nowMillis);</span><br><span class="line">                <span class="keyword">if</span> (!permit.canAcquire(nowMillis, permits, timeoutMillis)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    millisToWait = permit.reserveAndGetWaitLength(nowMillis, permits);</span><br><span class="line">                    permitsRedisTemplate.opsForValue().set(key, permit, expire, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//超时获取不到锁，也返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                lock.unLock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (millisToWait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(millisToWait);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保留指定的令牌数待用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需保留的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 令牌可用的等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens不能为负数或零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(String key, <span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        checkPermits(permits);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId(), <span class="number">60</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">long</span> nowMillis = getNowMillis();</span><br><span class="line">            RedisPermits permit = getPermits(key, nowMillis);</span><br><span class="line">            <span class="keyword">long</span> waitMillis = permit.reserveAndGetWaitLength(nowMillis, permits);</span><br><span class="line">            permitsRedisTemplate.opsForValue().set(key, permit, expire, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> waitMillis;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unLock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌桶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisPermits <span class="title">getPermits</span><span class="params">(String key, <span class="keyword">long</span> nowMillis)</span> </span>&#123;</span><br><span class="line">        RedisPermits permit = permitsRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (permit == <span class="keyword">null</span>) &#123;</span><br><span class="line">            permit = <span class="keyword">new</span> RedisPermits(permitsPerSecond, maxBurstSeconds, nowMillis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> permit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取redis服务器时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNowMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">"return redis.call('time')"</span>;</span><br><span class="line">        DefaultRedisScript&lt;List&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(luaScript, List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;String&gt; now = (List&lt;String&gt;)stringRedisTemplate.execute(redisScript, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> now == <span class="keyword">null</span> ? System.currentTimeMillis() : Long.valueOf(now.get(<span class="number">0</span>))*<span class="number">1000</span>+Long.valueOf(now.get(<span class="number">1</span>))/<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>acquire 是阻塞方法，如果没有可用的令牌，则一直阻塞直到获取到令牌。</li><li>tryAcquire 则是非阻塞方法，如果在指定超时时间内获取不到指定数量的令牌，则直接返回false，不阻塞等待。</li><li>getNowMillis 获取Redis服务器时间，避免业务服务器时间不一致导致的问题，如果业务服务器能保障时间同步，则可从本地获取提高效率。</li></ol><h3 id="3-令牌桶控制工厂类"><a href="#3-令牌桶控制工厂类" class="headerlink" title="3. 令牌桶控制工厂类"></a>3. 令牌桶控制工厂类</h3><p>工厂类负责管理令牌桶控制类，将其缓存在本地，这里使用了Guava中的Cache，一方面避免每次都新建控制类提高效率，另一方面通过控制缓存的最大容量来避免像用户粒度的限流占用过多的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRateLimiterFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PermitsRedisTemplate permitsRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> DistributedLock distributedLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String, RedisRateLimiter&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            .initialCapacity(<span class="number">100</span>)  <span class="comment">//初始大小</span></span><br><span class="line">            .maximumSize(<span class="number">10000</span>) <span class="comment">// 缓存的最大容量</span></span><br><span class="line">            .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES) <span class="comment">// 缓存在最后一次访问多久之后失效</span></span><br><span class="line">            .concurrencyLevel(Runtime.getRuntime().availableProcessors()) <span class="comment">// 设置并发级别</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisRateLimiterFactory</span><span class="params">(PermitsRedisTemplate permitsRedisTemplate, StringRedisTemplate stringRedisTemplate, DistributedLock distributedLock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.permitsRedisTemplate = permitsRedisTemplate;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="keyword">this</span>.distributedLock = distributedLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建RateLimiter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key              RedisRateLimiter本地缓存key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permitsPerSecond 每秒放入的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxBurstSeconds  最大存储maxBurstSeconds秒生成的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire           该令牌桶的redis tty/秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RateLimiter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisRateLimiter <span class="title">build</span><span class="params">(String key, <span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> maxBurstSeconds, <span class="keyword">int</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.getIfPresent(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache.getIfPresent(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cache.put(key, <span class="keyword">new</span> RedisRateLimiter(permitsRedisTemplate, stringRedisTemplate, distributedLock, permitsPerSecond,</span><br><span class="line">                            maxBurstSeconds, expire));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注解支持"><a href="#4-注解支持" class="headerlink" title="4. 注解支持"></a>4. 注解支持</h3><p>定义注解 @RateLimit 如下，表示以每秒rate的速率放置令牌，最多保留burst秒的令牌，取令牌的超时时间为timeout，limitType用于控制key类型，目前支持：</p><ol><li>IP, 根据客户端IP限流</li><li>USER, 根据用户限流，对于Spring Security可从SecurityContextHolder中获取当前用户信息，如userId</li><li>METHOD, 根据方法名全局限流，className.methodName，注意避免同时对同一个类中的同名方法做限流控制，否则需要修改获取key的逻辑</li><li>CUSTOM，自定义，支持表达式解析，如#{id}, #{user.id}</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimit &#123;</span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> "rateLimit:"</span>; <span class="comment">//key前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expire</span><span class="params">()</span> <span class="keyword">default</span> 60</span>; <span class="comment">// 表示令牌桶模型RedisPermits redis key的过期时间/秒</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> <span class="keyword">default</span> 1.0</span>; <span class="comment">// permitsPerSecond值</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">burst</span><span class="params">()</span> <span class="keyword">default</span> 1.0</span>; <span class="comment">// maxBurstSeconds值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; <span class="comment">// 超时时间/秒</span></span><br><span class="line">    <span class="function">LimitType <span class="title">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitType.METHOD</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过切面的前置增强来为添加了 @RateLimit 注解的方法提供限流控制，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLimitAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"@annotation(rateLimit)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rateLimit</span><span class="params">(JoinPoint  point, RateLimit rateLimit)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String key = getKey(point, rateLimit.limitType(), rateLimit.key(), rateLimit.prefix());</span><br><span class="line">        RedisRateLimiter redisRateLimiter = redisRateLimiterFactory.build(key, rateLimit.rate(), rateLimit.burst(), rateLimit.expire());</span><br><span class="line">        <span class="keyword">if</span>(!redisRateLimiter.tryAcquire(key, rateLimit.timeout(), TimeUnit.SECONDS))&#123;</span><br><span class="line">            ExceptionUtil.rethrowClientSideException(LIMIT_MESSAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><h2 id="限量控制"><a href="#限量控制" class="headerlink" title="限量控制"></a>限量控制</h2><h3 id="1-限量控制类"><a href="#1-限量控制类" class="headerlink" title="1. 限量控制类"></a>1. 限量控制类</h3><p>限制一个时间窗口内的访问量，可使用计数器算法，借助Lua脚本执行的原子性来实现。</p><p>Lua脚本逻辑：</p><ol><li>以需要控制的对象为key（如方法，用户ID，或IP等），当前访问次数为Value，时间窗口值为缓存的过期时间</li><li>如果key存在则将其增1，判断当前值是否大于访问量限制值，如果大于则返回0，表示该时间窗口内已达访问量上限，如果小于则返回1表示允许访问</li><li>如果key不存在，则将其初始化为1，并设置过期时间，返回1表示允许访问</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCountLimiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LUA_SCRIPT = <span class="string">"local c \nc = redis.call('get',KEYS[1]) \nif c and redis.call('incr',KEYS[1]) &gt; tonumber(ARGV[1]) then return 0 end"</span></span><br><span class="line">            + <span class="string">" \nif c then return 1 else \nredis.call('set', KEYS[1], 1) \nredis.call('expire', KEYS[1], tonumber(ARGV[2])) \nreturn 1 end"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUCCESS_RESULT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FAIL_RESULT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCountLimiter</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否允许访问</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key redis key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit 限制次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 时间段/秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取成功true，否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(String key, <span class="keyword">int</span> limit, <span class="keyword">int</span> expire)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        RedisScript&lt;Number&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(LUA_SCRIPT, Number<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Number result = stringRedisTemplate.execute(redisScript, Collections.singletonList(key), String.valueOf(limit), String.valueOf(expire));</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="keyword">null</span> &amp;&amp; result.intValue() == SUCCESS_RESULT) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-注解支持"><a href="#2-注解支持" class="headerlink" title="2. 注解支持"></a>2. 注解支持</h3><p>定义注解 @CountLimit 如下，表示在period时间窗口内，最多允许访问limit次，limitType用于控制key类型，取值与 @RateLimit 同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CountLimit &#123;</span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> "countLimit:"</span>; <span class="comment">//key前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;  <span class="comment">// expire时间段内限制访问次数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">period</span><span class="params">()</span> <span class="keyword">default</span> 1</span>; <span class="comment">// 表示时间段/秒</span></span><br><span class="line">    <span class="function">LimitType <span class="title">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitType.METHOD</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样采用前值增强来为添加了 @CountLimit 注解的方法提供限流控制，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"@annotation(countLimit)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countLimit</span><span class="params">(JoinPoint  point, CountLimit countLimit)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String key = getKey(point, countLimit.limitType(), countLimit.key(), countLimit.prefix());</span><br><span class="line">    <span class="keyword">if</span> (!redisCountLimiter.tryAcquire(key, countLimit.limit(), countLimit.period())) &#123;</span><br><span class="line">        ExceptionUtil.rethrowClientSideException(LIMIT_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>1.添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>limiter-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置redis相关参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">limiter-demo</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment">#数据库索引</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.92</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">    <span class="comment">#连接超时时间</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>3.测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"limiter"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimiterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/count"</span>)</span><br><span class="line">    <span class="meta">@CountLimit</span>(key = <span class="string">"#&#123;key&#125;"</span>, limit = <span class="number">2</span>, period = <span class="number">10</span>, limitType = LimitType.CUSTOM)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testCountLimit</span><span class="params">(@RequestParam(<span class="string">"key"</span>)</span> String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test count limiter..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/rate"</span>)</span><br><span class="line">    <span class="meta">@RateLimit</span>(rate = <span class="number">1.0</span>/<span class="number">5</span>, burst = <span class="number">5.0</span>, expire = <span class="number">120</span>, timeout = <span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRateLimit</span><span class="params">(@RequestParam(<span class="string">"key"</span>)</span> String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test rate limiter..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisRateLimiterFactory redisRateLimiterFactory;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码段形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/rate2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRateLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RedisRateLimiter limiter = redisRateLimiterFactory.build(<span class="string">"LimiterController.testRateLimit"</span>, <span class="number">1.0</span>/<span class="number">30</span>, <span class="number">30</span>, <span class="number">120</span>);</span><br><span class="line">        <span class="keyword">if</span>(!limiter.tryAcquire(<span class="string">"app.limiter"</span>, <span class="number">0</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            System.out.println(LocalDateTime.now());</span><br><span class="line">            ExceptionUtil.rethrowClientSideException(<span class="string">"您的访问过于频繁，请稍后重试"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test rate limiter 2..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.验证</p><p>启动测试项目，浏览器中访问 <a href="http://localhost:8080/limiter/rate?key=test" target="_blank" rel="noopener">http://localhost:8080/limiter/rate?key=test</a> ，第一次访问成功，如图</p><p><img src="/assets/ratelimiter1.png" alt="ratelimiter1"></p><p>持续刷新，将返回如下错误，直到5s之后再返回成功，限制5秒1次的访问速度</p><p><img src="/assets/ratelimiter2.png" alt="ratelimiter2"></p><p>注解的使用</p><ol><li>限流类型LimitType支持IP（客户端IP）、用户（userId）、方法（className.methodName）、自定义（CUSTOM）几种形式，默认为METHOD</li><li>LimitType为CUSTOM时，需要手动指定key（其它key自动为ip，userid，或methodname），key支持表达式形式，如#{id}, #{user.id}</li><li>针对某个时间窗口内限制访问一次的场景，既可以使用 @CountLimit， 也可以使用 @RateLimit，比如验证码一分钟内只允许获取一次，以下两种形式都能达到目的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同一个手机号码60s内最多访问一次</span></span><br><span class="line"><span class="meta">@CountLimit</span>(key = <span class="string">"#&#123;params.phone&#125;"</span>, limit = <span class="number">1</span>, period = <span class="number">60</span>, limitType = LimitType.CUSTOM)</span><br><span class="line"><span class="comment">//以1/60的速度放置令牌，最多保存60s的令牌（也就是最多保存一个），控制访问速度为1/60个每秒（1个每分钟）</span></span><br><span class="line"><span class="meta">@RateLimit</span>(key = <span class="string">"#&#123;params.phone&#125;"</span>, rate = <span class="number">1.0</span>/<span class="number">60</span>, burst = <span class="number">60</span>, expire = <span class="number">120</span>, limitType = LimitType.CUSTOM)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了适用于分布式环境的基于RateLimiter令牌桶算法的限速控制与基于计数器算法的限量控制，可应用于中小型项目中有相关需求的场景（注：本实现未做压力测试，如果用户并发量较大需验证效果）。</p><ul><li>本文完整代码见：<a href="https://github.com/ronwxy/base-spring-boot" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot</a> ，目录 spring-boot-autoconfigure/src/main/java/cn/jboost/springboot/autoconfig/limiter</li><li>示例项目代码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-limiter" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-limiter</a></li></ul><p>如果觉得有帮助，别忘了给个star ^_^。作者公众号：半路雨歌，欢迎关注查看更多干货文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章（&lt;a href=&quot;http://blog.jboost.cn/ratelimiter.html&quot;&gt;限流算法与Guava RateLimiter解析&lt;/a&gt;）对常用的限流算法及Google Guava基于令牌桶算法的实现RateLimiter进行了介绍。RateLimiter通过线程锁控制同步，只适用于单机应用，在分布式环境下，虽然有像阿里Sentinel的限流开源框架，但对于一些小型应用来说未免过重，但限流的需求在小型项目中也是存在的，比如获取手机验证码的控制，对资源消耗较大操作的访问频率控制等。本文介绍最近写的一个基于RateLimiter，适用于分布式环境下的限流实现，并使用spring-boot-starter的形式发布，比较轻量级且“开箱即用”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="redis" scheme="http://blog.jboost.cn/tags/redis/"/>
    
      <category term="RateLimiter" scheme="http://blog.jboost.cn/tags/RateLimiter/"/>
    
  </entry>
  
  <entry>
    <title>限流算法与Guava RateLimiter解析</title>
    <link href="http://blog.jboost.cn/ratelimiter.html"/>
    <id>http://blog.jboost.cn/ratelimiter.html</id>
    <published>2020-07-08T03:06:17.000Z</published>
    <updated>2020-08-26T01:36:12.561Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，应对高并发访问时，缓存、限流、降级是保护系统正常运行的常用方法。当请求量突发暴涨时，如果不加以限制访问，则可能导致整个系统崩溃，服务不可用。同时有一些业务场景，比如短信验证码，或者其它第三方API调用，也需要提供必要的访问限制支持。还有一些资源消耗过大的请求，比如数据导出等（参考 <a href="http://blog.jboost.cn/issue-cpu-high.html">记一次线上Java服务CPU 100%处理过程</a> ），也有限制访问频率的需求。</p><a id="more"></a><p>常见的限流算法有令牌桶算法，漏桶算法，与计数器算法。本文主要对三个算法的基本原理及Google Guava包中令牌桶算法的实现RateLimiter进行介绍，下一篇文章介绍最近写的一个以RateLimiter为参考的分布式限流实现及计数器限流实现。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法的原理就是以一个恒定的速度往桶里放入令牌，每一个请求的处理都需要从桶里先获取一个令牌，当桶里没有令牌时，则请求不会被处理，要么排队等待，要么降级处理，要么直接拒绝服务。当桶里令牌满时，新添加的令牌会被丢弃或拒绝。</p><p>令牌桶算法的处理示意图如下（图片来自网络）</p><p><img src="/assets/token-bucket.png" alt="token-bucket"></p><p>令牌桶算法主要是可以控制请求的平均处理速率，它允许预消费，即可以提前消费令牌，以应对突发请求，但是后面的请求需要为预消费买单（等待更长的时间），以满足请求处理的平均速率是一定的。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法的原理是水（请求）先进入漏桶中，漏桶以一定的速度出水（处理请求），当水流入速度大于流出速度导致水在桶内逐渐堆积直到桶满时，水会溢出（请求被拒绝）。</p><p>漏桶算法的处理示意图如下（图片来自网络）</p><p><img src="/assets/leaky-bucket.png" alt="leaky-bucket"></p><p>漏桶算法主要是控制请求的处理速率，平滑网络上的突发流量，请求可以以任意速度进入漏桶中，但请求的处理则以恒定的速度进行。</p><h2 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h2><p>计数器算法是限流算法中最简单的一种算法，限制在一个时间窗口内，至多处理多少个请求。比如每分钟最多处理10个请求，则从第一个请求进来的时间为起点，60s的时间窗口内只允许最多处理10个请求。下一个时间窗口又以前一时间窗口过后第一个请求进来的时间为起点。常见的比如一分钟内只能获取一次短信验证码的功能可以通过计数器算法来实现。</p><h2 id="Guava-RateLimiter解析"><a href="#Guava-RateLimiter解析" class="headerlink" title="Guava RateLimiter解析"></a>Guava RateLimiter解析</h2><p>Guava是Google开源的一个工具包，其中的RateLimiter是实现了令牌桶算法的一个限流工具类。在pom.xml中添加guava依赖，即可使用RateLimiter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下测试代码示例了RateLimiter的用法,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = RateLimiter.create(<span class="number">1</span>); <span class="comment">//创建一个每秒产生一个令牌的令牌桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> waitTime = rateLimiter.acquire(i); <span class="comment">//一次获取i个令牌</span></span><br><span class="line">        System.out.println(<span class="string">"acquire:"</span> + i + <span class="string">" waitTime:"</span> + waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，输出如下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acquire:1 waitTime:0.0</span><br><span class="line">acquire:2 waitTime:0.997729</span><br><span class="line">acquire:3 waitTime:1.998076</span><br><span class="line">acquire:4 waitTime:3.000303</span><br><span class="line">acquire:5 waitTime:4.000223</span><br></pre></td></tr></table></figure><p>第一次获取一个令牌时，等待0s立即可获取到（这里之所以不需要等待是因为令牌桶的预消费特性），第二次获取两个令牌，等待时间1s，这个1s就是前面获取一个令牌时因为预消费没有等待延到这次来等待的时间，这次获取两个又是预消费，所以下一次获取（取3个时）就要等待这次预消费需要的2s了，依此类推。可见预消费不需要等待的时间都由下一次来买单，以保障一定的平均处理速率（上例为1s一次）。</p><p>RateLimiter有两种实现：</p><ol><li>SmoothBursty： 令牌的生成速度恒定。使用 <code>RateLimiter.create(double permitsPerSecond)</code> 创建的是 SmoothBursty 实例。</li><li>SmoothWarmingUp：令牌的生成速度持续提升，直到达到一个稳定的值。WarmingUp，顾名思义就是有一个热身的过程。使用 <code>RateLimiter.create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)</code> 时创建就是 SmoothWarmingUp 实例，其中 warmupPeriod 就是热身达到稳定速度的时间。</li></ol><p>类结构如下</p><p><img src="/assets/ratelimiter-struct.png" alt="ratelimiter-struct"></p><p>关键属性及方法解析（以 SmoothBursty 为例）</p><p>1.关键属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 桶中当前拥有的令牌数. */</span></span><br><span class="line"><span class="keyword">double</span> storedPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 桶中最多可以保存多少秒存入的令牌数 */</span></span><br><span class="line"><span class="keyword">double</span> maxBurstSeconds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 桶中能存储的最大令牌数，等于storedPermits*maxBurstSeconds. */</span></span><br><span class="line"><span class="keyword">double</span> maxPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 放入令牌的时间间隔*/</span></span><br><span class="line"><span class="keyword">double</span> stableIntervalMicros;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 下次可获取令牌的时间点，可以是过去也可以是将来的时间点*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nextFreeTicketMicros = <span class="number">0L</span>;</span><br></pre></td></tr></table></figure><p>2.关键方法</p><p>调用 <code>RateLimiter.create(double permitsPerSecond)</code> 方法时，创建的是 SmoothBursty 实例，默认设置 maxBurstSeconds 为1s。SleepingStopwatch 是guava中的一个时钟类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, SleepingStopwatch stopwatch)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmoothBursty(SleepingStopwatch stopwatch, <span class="keyword">double</span> maxBurstSeconds) &#123;</span><br><span class="line">  <span class="keyword">super</span>(stopwatch);</span><br><span class="line">  <span class="keyword">this</span>.maxBurstSeconds = maxBurstSeconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并通过调用 <code>SmoothBursty.doSetRate(double, long)</code> 方法进行初始化，该方法中:</p><ol><li>调用 <code>resync(nowMicros)</code> 对 storedPermits 与 nextFreeTicketMicros 进行了调整——如果当前时间晚于 nextFreeTicketMicros，则计算这段时间内产生的令牌数，累加到 storedPermits 上，并更新下次可获取令牌时间 nextFreeTicketMicros 为当前时间。</li><li>计算 stableIntervalMicros 的值，1/permitsPerSecond。</li><li>调用 <code>doSetRate(double, double)</code> 方法计算 maxPermits 值（maxBurstSeconds*permitsPerSecond），并根据旧的 maxPermits 值对 storedPermits 进行调整。</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Updates &#123;<span class="doctag">@code</span> storedPermits&#125; and &#123;<span class="doctag">@code</span> nextFreeTicketMicros&#125; based on the current time. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">    <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">    storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">    nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don't special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = maxPermits;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">                ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">                : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>acquire(int)</code> 方法获取指定数量的令牌时，</p><ol><li>调用 <code>reserve(int)</code> 方法，该方法最终调用 <code>reserveEarliestAvailable(int, long)</code> 来更新下次可取令牌时间点与当前存储的令牌数，并返回本次可取令牌的时间点，根据该时间点计算需要等待的时间</li><li>阻塞等待1中返回的等待时间</li><li>返回等待的时间（秒）</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 获取指定数量（permits）的令牌，阻塞直到获取到令牌，返回等待的时间*/</span></span><br><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> microsToWait = reserve(permits);</span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">        <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回需要等待的时间*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 针对此次需要获取的令牌数更新下次可取令牌时间点与存储的令牌数，返回本次可取令牌的时间点*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros); <span class="comment">// 更新当前数据</span></span><br><span class="line">    <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits); <span class="comment">// 本次可消费的令牌数</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend; <span class="comment">// 需要新增的令牌数</span></span><br><span class="line">    <span class="keyword">long</span> waitMicros =</span><br><span class="line">        storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">            + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros); <span class="comment">// 更新下次可取令牌的时间点</span></span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend; <span class="comment">// 更新当前存储的令牌数</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire(int)</code> 方法是获取不到令牌时一直阻塞，直到获取到令牌，<code>tryAcquire(int,long,TimeUnit)</code> 方法则是在指定超时时间内尝试获取令牌，如果获取到或超时时间到则返回是否获取成功</p><ol><li>先判断是否能在指定超时时间内获取到令牌，通过 <code>nextFreeTicketMicros &lt;= timeoutMicros + nowMicros</code> 是否为true来判断，即可取令牌时间早于当前时间加超时时间则可取（预消费的特性），否则不可获取。</li><li>如果不可获取，立即返回false。</li><li>如果可获取，则调用 <code>reserveAndGetWaitLength(permits, nowMicros)</code> 来更新下次可取令牌时间点与当前存储的令牌数，返回等待时间（逻辑与前面相同），并阻塞等待相应的时间，返回true。</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timeoutMicros = max(unit.toMicros(timeout), <span class="number">0</span>);</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">long</span> microsToWait;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">        <span class="keyword">long</span> nowMicros = stopwatch.readMicros();</span><br><span class="line">        <span class="keyword">if</span> (!canAcquire(nowMicros, timeoutMicros)) &#123; <span class="comment">//判断是否能在超时时间内获取指定数量的令牌</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            microsToWait = reserveAndGetWaitLength(permits, nowMicros);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canAcquire</span><span class="params">(<span class="keyword">long</span> nowMicros, <span class="keyword">long</span> timeoutMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryEarliestAvailable(nowMicros) - timeoutMicros &lt;= nowMicros; <span class="comment">//只要可取时间小于当前时间+超时时间，则可获取（可预消费的特性！）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">queryEarliestAvailable</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextFreeTicketMicros;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 SmoothBursty 实现的基本处理流程。注意两点：</p><ol><li>RateLimiter 通过限制后面请求的等待时间，来支持一定程度的突发请求——预消费的特性。</li><li>RateLimiter 令牌桶的实现并不是起一个线程不断往桶里放令牌，而是以一种延迟计算的方式（参考<code>resync</code>函数），在每次获取令牌之前计算该段时间内可以产生多少令牌，将产生的令牌加入令牌桶中并更新数据来实现，比起一个线程来不断往桶里放令牌高效得多。（想想如果需要针对每个用户限制某个接口的访问，则针对每个用户都得创建一个RateLimiter，并起一个线程来控制令牌存放的话，如果在线用户数有几十上百万，起线程来控制是一件多么恐怖的事情）</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了限流的三种基本算法，其中令牌桶算法与漏桶算法主要用来限制请求处理的速度，可将其归为限速，计数器算法则是用来限制一个时间窗口内请求处理的数量，可将其归为限量（对速度不限制）。Guava 的 RateLimiter 是令牌桶算法的一种实现，但 RateLimiter 只适用于单机应用，在分布式环境下就不适用了。虽然已有一些开源项目可用于分布式环境下的限流管理，如阿里的Sentinel，但对于小型项目来说，引入Sentinel可能显得有点过重，但限流的需求在小型项目中也是存在的，下一篇文章就介绍下基于 RateLimiter 的分布式下的限流实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分布式系统中，应对高并发访问时，缓存、限流、降级是保护系统正常运行的常用方法。当请求量突发暴涨时，如果不加以限制访问，则可能导致整个系统崩溃，服务不可用。同时有一些业务场景，比如短信验证码，或者其它第三方API调用，也需要提供必要的访问限制支持。还有一些资源消耗过大的请求，比如数据导出等（参考 &lt;a href=&quot;http://blog.jboost.cn/issue-cpu-high.html&quot;&gt;记一次线上Java服务CPU 100%处理过程&lt;/a&gt; ），也有限制访问频率的需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="redis" scheme="http://blog.jboost.cn/tags/redis/"/>
    
      <category term="限流" scheme="http://blog.jboost.cn/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>基于Redis分布式锁的正确打开方式</title>
    <link href="http://blog.jboost.cn/distributedlock.html"/>
    <id>http://blog.jboost.cn/distributedlock.html</id>
    <published>2020-07-01T06:18:15.000Z</published>
    <updated>2020-08-26T01:39:56.844Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁是在分布式环境下（多个JVM进程）控制多个客户端对某一资源的同步访问的一种实现，与之相对应的是线程锁，线程锁控制的是同一个JVM进程内多个线程之间的同步。分布式锁的一般实现方法是在应用服务器之外通过一个共享的存储服务器存储锁资源，同一时刻只有一个客户端能占有锁资源来完成。通常有基于Zookeeper，Redis，或数据库三种实现形式。本文介绍基于Redis的实现方案。</p><a id="more"></a><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>基于Redis实现分布式锁需要满足如下几点要求：</p><ol><li>在分布式集群中，被分布式锁控制的方法或代码段同一时刻只能被一个客户端上面的一个线程执行，也就是互斥</li><li>锁信息需要设置过期时间，避免一个线程长期占有（比如在做解锁操作前异常退出）而导致死锁</li><li>加锁与解锁必须一致，谁加的锁，就由谁来解（或过期超时），一个客户端不能解开另一个客户端加的锁</li><li>加锁与解锁的过程必须保证原子性</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-加锁实现"><a href="#1-加锁实现" class="headerlink" title="1. 加锁实现"></a>1. 加锁实现</h3><p>基于Redis的分布式锁加锁操作一般使用 <code>SETNX</code> 命令，其含义是“将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作”。<br>在 Spring Boot 中，可以使用 StringRedisTemplate 来实现，如下，一行代码即可实现加锁过程。（下列代码给出两种调用形式——立即返回加锁结果与给定超时时间获取加锁结果）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取锁（立即返回）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key  锁的redis key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 锁的value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expire 过期时间/秒</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stringRedisTemplate.opsForValue().setIfAbsent(key, value, expire, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取锁，并至多等待timeout时长</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key  锁的redis key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 锁的value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expire 过期时间/秒</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> timeout 超时时长</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit    时间单位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value, <span class="keyword">long</span> expire, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> waitMillis = unit.toMillis(timeout);</span><br><span class="line">    <span class="keyword">long</span> waitAlready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stringRedisTemplate.opsForValue().setIfAbsent(key, value, expire, TimeUnit.SECONDS) &amp;&amp; waitAlready &lt; waitMillis) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(waitMillisPer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Interrupted when trying to get a lock. key: &#123;&#125;"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        waitAlready += waitMillisPer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitAlready &lt; waitMillis) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.warn(<span class="string">"&lt;====== lock &#123;&#125; failed after waiting for &#123;&#125; ms"</span>, key, waitAlready);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现如何满足前面提到的几点要求：</p><ol><li>客户端互斥： 可以将expire过期时间设置为大于同步代码的执行时间，比如同步代码块执行时间为1s，则可将expire设置为3s或5s。避免同步代码执行过程中expire时间到，其它客户端又可以获取锁执行同步代码块。</li><li>通过设置过期时间expire来避免某个客户端长期占有锁。</li><li>通过value来控制谁加的锁，由谁解的逻辑，比如可以使用requestId作为value，requestId唯一标记一次请求。</li><li>setIfAbsent方法 底层通过调用 Redis 的 <code>SETNX</code> 命令，操作具备原子性。</li></ol><p><strong>错误示例：</strong></p><p>网上有如下实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = stringRedisTemplate.opsForValue().setIfAbsent(key, value);</span><br><span class="line">    <span class="keyword">if</span>(result) &#123;</span><br><span class="line">        stringRedisTemplate.expire(key, expire, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现的问题是如果在result为true，但还没成功设置expire时，程序异常退出了，将导致该锁一直被占用而导致死锁，不满足第二点要求。</p><h3 id="2-解锁实现"><a href="#2-解锁实现" class="headerlink" title="2. 解锁实现"></a>2. 解锁实现</h3><p>解锁也需要满足前面所述的四个要求，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RELEASE_LOCK_LUA_SCRIPT = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_LOCK_SUCCESS_RESULT = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 释放锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key  锁的redis key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 锁的value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(RELEASE_LOCK_LUA_SCRIPT, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">long</span> result = stringRedisTemplate.execute(redisScript, Collections.singletonList(key), value);</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(result, RELEASE_LOCK_SUCCESS_RESULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段实现使用一个Lua脚本来实现解锁操作，保证操作的原子性。传入的value值需与该线程加锁时的value一致，可以使用requestId（具体实现下面给出）。</p><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        String oldValue = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(value.equals(oldValue)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现先获取锁的当前值，判断两值相等则删除。考虑一种极端情况，如果在判断为true时，刚好该锁过期时间到，另一个客户端加锁成功，则接下来的delete将不管三七二十一将别人加的锁直接删掉了，不满足第三点要求。该示例主要是因为没有保证解锁操作的原子性导致。</p><h3 id="3-注解支持"><a href="#3-注解支持" class="headerlink" title="3. 注解支持"></a>3. 注解支持</h3><p>为了方便使用，添加一个注解，可以放于方法上控制方法在分布式环境中的同步执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 标注在方法上的分布式锁注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DistributedLockable &#123;</span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> "disLock:"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">expire</span><span class="params">()</span> <span class="keyword">default</span> 10L</span>; <span class="comment">// 默认10s过期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一个切面来解析注解的处理，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分布式锁注解处理切面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLockAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DistributedLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedLockAspect</span><span class="params">(DistributedLock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在方法上执行同步锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"@annotation(lockable)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">distLock</span><span class="params">(ProceedingJoinPoint point, DistributedLockable lockable)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">        String key = lockable.prefix() + lockable.key();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.lock(key, WebUtil.getRequestId(), lockable.expire());</span><br><span class="line">            <span class="keyword">if</span>(locked) &#123;</span><br><span class="line">                <span class="keyword">return</span> point.proceed();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"Did not get a lock for key &#123;&#125;"</span>, key);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(locked) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!lock.unLock(key, WebUtil.getRequestId()))&#123;</span><br><span class="line">                    log.warn(<span class="string">"Unlock &#123;&#125; failed, maybe locked by another client already. "</span>, lockable.key());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestId 的实现如下，通过注册一个Filter，在请求开始时生成一个uuid存于ThreadLocal中，在请求返回时清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_ID_HEADER = <span class="string">"Req-Id"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; reqIdThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        reqIdThreadLocal.set(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRequestId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String requestId = reqIdThreadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(requestId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestId = ObjectId.next();</span><br><span class="line">            reqIdThreadLocal.set(requestId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reqIdThreadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestIdFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">        String reqId = httpServletRequest.getHeader(WebUtil.REQ_ID_HEADER);</span><br><span class="line">        <span class="comment">//没有则生成一个</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(reqId)) &#123;</span><br><span class="line">            reqId = ObjectId.next();</span><br><span class="line">        &#125;</span><br><span class="line">        WebUtil.setRequestId(reqId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            WebUtil.removeRequestId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在配置类中注册Filter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加RequestId</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">requestIdFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestIdFilter reqestIdFilter = <span class="keyword">new</span> RequestIdFilter();</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setFilter(reqestIdFilter);</span><br><span class="line">    List&lt;String&gt; urlPatterns = Collections.singletonList(<span class="string">"/*"</span>);</span><br><span class="line">    registrationBean.setUrlPatterns(urlPatterns);</span><br><span class="line">    registrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用注解"><a href="#4-使用注解" class="headerlink" title="4. 使用注解"></a>4. 使用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DistributedLockable</span>(key = <span class="string">"test"</span>, expire = <span class="number">10</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"线程-"</span>+Thread.currentThread().getName()+<span class="string">"开始执行..."</span> + LocalDateTime.now());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"线程-"</span>+Thread.currentThread().getName()+<span class="string">"结束执行..."</span> + LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文给出了基于Redis的分布式锁的实现方案与常见的错误示例。要保障分布式锁的正确运行，需满足本文所提的四个要求，尤其注意保证加锁解锁操作的原子性，设置过期时间，及对同一个锁的加锁解锁线程一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式锁是在分布式环境下（多个JVM进程）控制多个客户端对某一资源的同步访问的一种实现，与之相对应的是线程锁，线程锁控制的是同一个JVM进程内多个线程之间的同步。分布式锁的一般实现方法是在应用服务器之外通过一个共享的存储服务器存储锁资源，同一时刻只有一个客户端能占有锁资源来完成。通常有基于Zookeeper，Redis，或数据库三种实现形式。本文介绍基于Redis的实现方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="redis" scheme="http://blog.jboost.cn/tags/redis/"/>
    
      <category term="RateLimiter" scheme="http://blog.jboost.cn/tags/RateLimiter/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上Java服务CPU 100%处理过程</title>
    <link href="http://blog.jboost.cn/issue-cpu-high.html"/>
    <id>http://blog.jboost.cn/issue-cpu-high.html</id>
    <published>2020-06-16T05:56:05.000Z</published>
    <updated>2020-08-26T01:39:15.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><p>正在开会，突然钉钉告警声响个不停，同时市场人员反馈客户在投诉系统登不进了，报504错误。查看钉钉上的告警信息，几台业务服务器节点全部报CPU超过告警阈值，达100%。</p><p>赶紧从会上下来，SSH登录服务器，使用 <code>top</code> 命令查看，几个Java进程CPU占用达到180%，190%，这几个Java进程对应同一个业务服务的几个Pod（或容器）。</p><a id="more"></a><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ol><li><p>使用 <code>docker stats</code> 命令查看本节点容器资源使用情况，对占用CPU很高的容器使用 <code>docker exec -it &lt;容器ID&gt; bash</code> 进入。</p></li><li><p>在容器内部执行 <code>top</code> 命令查看，定位到占用CPU高的进程ID，使用 <code>top -Hp &lt;进程ID&gt;</code> 定位到占用CPU高的线程ID。</p></li><li><p>使用 <code>jstack &lt;进程ID&gt; &gt; jstack.txt</code> 将进程的线程栈打印输出。</p></li><li><p>退出容器， 使用 <code>docker cp &lt;容器ID&gt;:/usr/local/tomcat/jstack.txt ./</code> 命令将jstack文件复制到宿主机，便于查看。获取到jstack信息后，赶紧重启服务让服务恢复可用。</p></li><li><p>将2中占用CPU高的线程ID使用 <code>pringf &#39;%x\n&#39; &lt;线程ID&gt;</code> 命令将线程ID转换为十六进制形式。假设线程ID为133，则得到十六进制85。在jstack.txt文件中定位到 <code>nid=0x85</code>的位置，该位置即为占用CPU高线程的执行栈信息。如下图所示，</p></li></ol><p><img src="/assets/jstack.png" alt="jstack"></p><ol start="6"><li>与同事确认，该处为使用一个框架的excel导出功能，并且，导出excel时没有分页，没有限制！！！查看SQL查询记录，该导出功能一次导出50w条数据，并且每条数据都需要做转换计算，更为糟糕的是，操作者因为导出时久久没有响应，于是连续点击，几分钟内发起了10多次的导出请求。。。于是，CPU被打满，服务崩溃了，我也崩溃了。。</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>对于此类耗资源的操作，一定要做好相应的限制。比如可以限制请求量，控制最大分页大小，同时可以限制访问频率，比如同一用户一分钟内最多请求多少次。</p><h2 id="再发"><a href="#再发" class="headerlink" title="再发"></a>再发</h2><p>服务重启后恢复。到了下午，又一台服务器节点CPU告警，依前面步骤定位到占用CPU高的线程，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00007fa114020800 nid=0x10 runnable </span><br><span class="line"></span><br><span class="line">"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00007fa114022000 nid=0x11 runnable</span><br></pre></td></tr></table></figure><p>使用命令 <code>jstat -gcutil &lt;进程ID&gt; 2000 10</code> 查看GC情况，如图</p><p><img src="/assets/jstat.png" alt="jstat"></p><p>发现Full GC次数达到1000多次，且还在不断增长，同时Eden区，Old区已经被占满（也可使用<code>jmap -heap &lt;进程ID&gt;</code>查看堆内存各区的占用情况），使用jmap将内存使用情况dump出来，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=./jmap.dump 13</span><br></pre></td></tr></table></figure><p>退出容器，使用 <code>docker cp &lt;容器ID&gt;:/usr/local/tomcat/jmap.dump ./</code> 将dump文件复制到宿主机目录，下载到本地，使用 MemoryAnalyzer（下载地址：<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a> ）打开，如图</p><p><img src="/assets/jmap-mat.png" alt="jmap-mat"></p><blockquote><p>如果dump文件比较大，需要增大MemoryAnalyzer.ini配置文件中的-Xmx值</p></blockquote><p>发现占用内存最多的是char[], String对象，通过右键可以查看引用对象，但点开貌似也看不出所以然来，进入内存泄露报告页面，如图</p><p><img src="/assets/mat-leak-suspects.png" alt="mat-leak-suspects"></p><p>该页面统计了堆内存的占用情况，并且给出疑似泄露点，在上图中点开“see stacktrace”链接，进入线程栈页面，</p><p><img src="/assets/mat-thread-stack.png" alt="mat-thread-stack"></p><p>似曾熟悉的画面，还是跟excel导出有关，数据太多，导致内存溢出。。。于是GC频繁，于是CPU爆了。根源还是同一个。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文以处理一次线上服务CPU 100%的实战过程示例了在遇到Java服务造成服务器CPU消耗过高或内存溢出的一般处理方法，希望对大家定位线上类似问题提供参考。同时，开发实现功能时需要考虑的更深远一些，不能停留在解决当前的场景，需要考虑数据量不断增大时，你的实现是否还能适用。俗话说，初级程序员解决当前问题，中级程序员解决两年后的问题，高级程序员解决五年后的问题，^_^。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;告警&quot;&gt;&lt;a href=&quot;#告警&quot; class=&quot;headerlink&quot; title=&quot;告警&quot;&gt;&lt;/a&gt;告警&lt;/h2&gt;&lt;p&gt;正在开会，突然钉钉告警声响个不停，同时市场人员反馈客户在投诉系统登不进了，报504错误。查看钉钉上的告警信息，几台业务服务器节点全部报CPU超过告警阈值，达100%。&lt;/p&gt;
&lt;p&gt;赶紧从会上下来，SSH登录服务器，使用 &lt;code&gt;top&lt;/code&gt; 命令查看，几个Java进程CPU占用达到180%，190%，这几个Java进程对应同一个业务服务的几个Pod（或容器）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="cpu100%" scheme="http://blog.jboost.cn/tags/cpu100/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理导致session失效的问题处理</title>
    <link href="http://blog.jboost.cn/nginx-proxy.html"/>
    <id>http://blog.jboost.cn/nginx-proxy.html</id>
    <published>2020-06-02T01:50:00.000Z</published>
    <updated>2020-08-26T01:36:55.493Z</updated>
    
    <content type="html"><![CDATA[<p>一同事求援：后台系统的登录成功了，但不能成功登进系统，仍然跳转到登录页，但同一套代码另一个环境却没有问题。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>经了解，他对同一个项目使用tomcat部署了两个环境，一个在开发服务器上，一个在他本机，两个环境代码配置完全相同。两边通过同一个nginx进行反向代理，nginx配置大致如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;health&#x2F; &#123;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;192.168.40.159:8081&#x2F;health&#x2F;;  #无问题的配置</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;health-dev&#x2F; &#123;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;192.168.40.202:8080&#x2F;health&#x2F;;  #有问题的配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个反向代理到开发环境，一个反向代理到本机服务。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>既然代码配置完全相同，那么问题很大可能就出现在nginx的反向代理上。</p><p>因为两边location路径不同（即浏览器路径不同），但是反向代理的服务端路径却相同，结合session的基本原理，如下图，</p><p><img src="/assets/httpsession.png" alt="httpsession"></p><ol><li>当浏览器第一次打开页面时，服务端会为这次会话创建一个session，并将session id通过response的header传递给浏览器，header一般为 <code>Set-Cookie: JSESSIONID=xxxxx; Path=xxxx</code></li><li>浏览器接收到响应后，如果header Set-Cookie 中path的值与浏览器地址路径匹配，则将该header值存于浏览器的Cookie中</li><li>浏览器在下次请求服务器时，将Cookie中的JSESSIONID值通过request的header上报给服务端，header一般为 <code>Cookie: JSESSIONID=xxxx;</code></li><li>服务端可通过该JSESSIONID来定位到对应的session</li></ol><p>nginx反向代理按这种方式配置时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;health-dev&#x2F; &#123;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;192.168.40.202:8080&#x2F;health&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 <code>http://www.domian.com/health-dev</code> 时，服务端返回的 <code>Set-Cookie</code> 的 Path 值为 <code>/health</code>（因为中间有反向代理，服务端并不知道代理前的路径是啥，是按最终请求服务端的路径设置），如图</p><p><img src="/assets/nginx-proxy-cookie-1.png" alt="nginx-proxy-cookie-1"></p><p>因为浏览器访问地址的路径 <code>/health-dev</code> 与 <code>Set-Cookie</code> 的 Path <code>/health</code> 不匹配，所以浏览器并不会将其值存入Cookie中，如图</p><p><img src="/assets/nginx-proxy-cookie-2.png" alt="nginx-proxy-cookie-2"></p><p>因此在下次请求服务器时，浏览器无法设置request <code>Cookie</code> header的 <code>JSESSIONID</code> 值，服务器无法定位到对应的session，因此会将其当做第一次请求，创建一个新的session，如此反复，因此就算你登录认证通过了，但服务器返回的登录凭证（JSESSIONID）浏览器不会保存，并在下次请求时携带，导致服务器认为你是一个新的请求，当然就会又跳到登录页面了。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>nginx有一个命令 <code>proxy_cookie_path</code>（参考： <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_path" target="_blank" rel="noopener">proxy_cookie_path</a>）可将服务器返回的 <code>Set-Cookie</code> 中的path进行修改，格式为 <code>proxy_cookie_path 原路径 目标路径</code>，我们在配置中添加 <code>proxy_cookie_path</code> 如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;health-dev&#x2F; &#123;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;192.168.40.202:8080&#x2F;health&#x2F;;</span><br><span class="line">    proxy_cookie_path  &#x2F;health &#x2F;health-dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx，问题解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一同事求援：后台系统的登录成功了，但不能成功登进系统，仍然跳转到登录页，但同一套代码另一个环境却没有问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="nginx" scheme="http://blog.jboost.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记（四）：详解Namespace与资源限制ResourceQuota，LimitRange</title>
    <link href="http://blog.jboost.cn/k8s4-namespace.html"/>
    <id>http://blog.jboost.cn/k8s4-namespace.html</id>
    <published>2020-05-27T05:20:25.000Z</published>
    <updated>2020-08-26T01:44:31.062Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们对K8s的基本组件与概念有了个大致的印象，并且基于K8s实现了一个初步的CI/CD流程，但对里面涉及的各个对象（如Namespace, Pod, Deployment, Service, Ingress, PVC等）及各对象的管理可能还缺乏深入的理解与实践，接下来的文章就让我们一起深入K8s的各组件内部来一探究竟吧。下图是基于个人的理解梳理的一个K8s结构图，示例了各个组件（只包含了主要组件）如何协同。</p><a id="more"></a><p><img src="/assets/k8s-struct.png" alt="k8s-struct"></p><p>后续几篇文章围绕该图涉及组件进行整理介绍，本文主要探究Namespace及与Namespace管理相关的资源限制ResourceQuota/LimitRange部分。</p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>Namespace即命名空间，主要有两个方面的作用：</p><ol><li>资源隔离：可为不同的团队/用户（或项目）提供虚拟的集群空间，共享同一个Kubernetes集群的资源。比如可以为团队A创建一个Namespace ns-a，团队A的项目都部署运行在 ns-a 中，团队B创建另一个Namespace ns-b，其项目都部署运行在 ns-b 中，或者为开发、测试、生产环境创建不同的Namespace，以做到彼此之间相互隔离，互不影响。我们可以使用 ResourceQuota 与 Resource LimitRange 来指定与限制 各个namesapce的资源分配与使用</li><li>权限控制：可以指定某个namespace哪些用户可以访问，哪些用户不能访问</li></ol><p>Kubernetes 安装成功后，默认会创建三个namespace：</p><ul><li>default：默认的namespace，如果创建Kubernetes对象时不指定 metadata.namespace，该对象将在default namespace下创建</li><li>kube-system：Kubernetes系统创建的对象放在此namespace下，我们前面说的kube-apiserver，etcd，kube-proxy等都在该namespace下</li><li>kube-public：顾名思义，共享的namespace，所有用户对该namespace都是可读的。主要是为集群做预留，一般都不在该namespace下创建对象</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1.查看namesapce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespaces</span><br><span class="line">kubectl get namesapce</span><br><span class="line">kubectl get ns               # 三个操作等效</span><br><span class="line">kubectl get ns --show-labels # 显示namespace的label</span><br></pre></td></tr></table></figure><p>使用namesapces,namesapce,ns都是可以的。如下列出了当前集群中的所有namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl get ns</span><br><span class="line">NAME                   STATUS   AGE</span><br><span class="line">default                Active   34d</span><br><span class="line">develop                Active   17d</span><br><span class="line">ingress-nginx          Active   33d</span><br><span class="line">kube-node-lease        Active   34d</span><br><span class="line">kube-public            Active   34d</span><br><span class="line">kube-system            Active   34d</span><br><span class="line">kubernetes-dashboard   Active   31d</span><br><span class="line">pre-release            Active   17d</span><br></pre></td></tr></table></figure><p>可以使用 <code>kubectl describe</code> 命令来查看某个namespace的概要信息，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl describe ns default</span><br><span class="line">Name:         default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active</span><br><span class="line"></span><br><span class="line">No resource quota.</span><br><span class="line"></span><br><span class="line">No resource limits.</span><br></pre></td></tr></table></figure><p>2.创建namespace</p><p>有两种方式：通过yaml定义文件创建或直接使用命令创建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式1. 通过yaml定义文件创建</span></span><br><span class="line">[root@kmaster ~]# vim test-namespace.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: test     # namespace的名称</span><br><span class="line">  labels:</span><br><span class="line">    name: ns-test</span><br><span class="line">[root@kmaster ~]# kubectl create -f ./test-namespace.yaml  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式2. 直接使用命令创建</span></span><br><span class="line">[root@kmaster ~]# kubectl create ns test</span><br></pre></td></tr></table></figure><p>3.在namesapce中创建对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 在yaml中通过metadata.namesapce 指定</span></span><br><span class="line">[root@kmaster ~]# kubectl get deploy my-nginx -o yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    run: my-nginx</span><br><span class="line">  name: my-nginx</span><br><span class="line">  namespace: test  # 指定namespace</span><br><span class="line">spec:</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 在命令中通过 -n 或 --namesapce 指定</span></span><br><span class="line">[root@kmaster ~]# kubectl run dev-nginx --image=nginx:latest --replicas=3 -n test</span><br></pre></td></tr></table></figure><p>4.设定kubectl namesapce上下文</p><p>kubectl上下文即集群、namespace、用户的组合，设定kubectl上下文，即可以以上下文指定的用户，在上下文指定的集群与namespace中进行操作管理。查看当前集群kubectl上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前kubectl上下文</span></span><br><span class="line">[root@kmaster ~]# kubectl config view</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: DATA+OMITTED</span><br><span class="line">    server: https://192.168.40.111:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: kubernetes-admin</span><br><span class="line">  name: kubernetes-admin@kubernetes</span><br><span class="line">current-context: kubernetes-admin@kubernetes</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: kubernetes-admin</span><br><span class="line">  user:</span><br><span class="line">    client-certificate-data: REDACTED</span><br><span class="line">    client-key-data: REDACTED</span><br></pre></td></tr></table></figure><p>可见当前上下文为kubernetes-admin@kubernetes (current-context: kubernetes-admin@kubernetes)。</p><p>创建一个kubectl上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl config set-context test --namespace=test --cluster=kubernetes --user=kubernetes-admin</span><br><span class="line">Context "test" created.</span><br></pre></td></tr></table></figure><p>再次执行 <code>kubectl config view</code> 将可以看到上面创建的test上下文。</p><p>切换上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置当前上下文</span></span><br><span class="line">[root@kmaster ~]# kubectl config use-context test</span><br><span class="line">Switched to context "test".</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前所在的上下文</span></span><br><span class="line">[root@kmaster ~]# kubectl config current-context</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>指定了上下文，后续操作都在该上下文对应的namespace中进行，不需要再显式指定namespace。在上下文中创建对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前上下文中创建对象</span></span><br><span class="line">[root@kmaster ~]# kubectl run my-nginx --image=nginx:latest --replicas=2</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/my-nginx created</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看创建的对象，不需要指定namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl get deploy</span><br><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">my-nginx   2/2     2            2           25m</span><br><span class="line">[root@kmaster ~]# kubectl get pod</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">my-nginx-667764d77b-ldb78   1/1     Running   0          24m</span><br><span class="line">my-nginx-667764d77b-wpgxw   1/1     Running   0          24m</span><br></pre></td></tr></table></figure><p>删除上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl config delete-context test</span><br><span class="line">deleted context test from /root/.kube/config</span><br></pre></td></tr></table></figure><p>也可以使用如下命令直接切换默认的namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将默认namespace设置为<span class="built_in">test</span></span></span><br><span class="line">[root@kmaster ~]# kubectl config set-context --current --namespace=test</span><br></pre></td></tr></table></figure><p>5.删除namesapce</p><p>可以使用 <code>kubectl delete ns &lt;namespace名称&gt;</code> 来删除一个namesapce，该操作会删除namespace中的所有内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl delete ns test</span><br></pre></td></tr></table></figure><h2 id="Resource-Quota"><a href="#Resource-Quota" class="headerlink" title="Resource Quota"></a>Resource Quota</h2><p>Resource Quota即资源配额，限定单个namespace中可使用集群资源的总量，包括两个维度：</p><ol><li>限定某个对象类型（如Pod）可创建对象的总数；</li><li>限定某个对象类型可消耗的计算资源（CPU、内存）与存储资源（存储卷声明）总数</li></ol><p>如果在 namespace 中为计算资源 CPU 和内存设定了 ResourceQuota，用户在创建对象（Pod、Service等）时，必须指定 requests 和 limits；如果在创建或更新对象时申请的资源与 namespace 的 ResourceQuota 冲突，则 apiserver 会返回 HTTP 状态码 403，以及对应的错误提示信息。当集群中总的容量小于各个 namespace 资源配额的总和时，可能会发生资源争夺，此时 Kubernetes 将按照先到先得的方式分配资源。</p><h3 id="对象数量限制"><a href="#对象数量限制" class="headerlink" title="对象数量限制"></a>对象数量限制</h3><p>声明格式为： <code>count/&lt;resource&gt;.&lt;group&gt;</code>， 如下列出各类对象的声明格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">count&#x2F;persistentvolumeclaims </span><br><span class="line">count&#x2F;services</span><br><span class="line">count&#x2F;secrets</span><br><span class="line">count&#x2F;configmaps</span><br><span class="line">count&#x2F;replicationcontrollers</span><br><span class="line">count&#x2F;deployments.apps</span><br><span class="line">count&#x2F;replicasets.apps</span><br><span class="line">count&#x2F;statefulsets.apps</span><br><span class="line">count&#x2F;jobs.batch</span><br><span class="line">count&#x2F;cronjobs.batch</span><br><span class="line">count&#x2F;deployments.extensions</span><br></pre></td></tr></table></figure><h3 id="计算资源限制"><a href="#计算资源限制" class="headerlink" title="计算资源限制"></a>计算资源限制</h3><p>定义CPU、内存请求（requests）、限制（limits）使用的总量，包括</p><ul><li>limits.cpu：namespace中，所有非终止状态的 Pod 的 CPU 限制 resources.limits.cpu 总和不能超过该值</li><li>limits.memory：namespace中，所有非终止状态的 Pod 的内存限制 resources.limits.memory 总和不能超过该值</li><li>requests.cpu：namespace中，所有非终止状态的 Pod 的 CPU 请求 resources.requrest.cpu 总和不能超过该值</li><li>requests.memory：namespace中，所有非终止状态的 Pod 的 CPU 请求 resources.requests.memory 总和不能超过该值</li></ul><h3 id="存储资源限制"><a href="#存储资源限制" class="headerlink" title="存储资源限制"></a>存储资源限制</h3><p>定义存储卷声明请求的存储总量或创建存储卷声明数量的限制，包括</p><ul><li>requests.storage：namespace中，所有存储卷声明（PersistentVolumeClaim）请求的存储总量不能超过该值</li><li>persistentvolumeclaims：namespace中，可以创建的存储卷声明的总数不能超过该值</li><li><code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/requests.storage</code>：namespace中，所有与指定存储类（StorageClass）关联的存储卷声明请求的存储总量不能超过该值</li><li><code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/persistentvolumeclaims</code>：namespace中，所有与指定存储类关联的存储卷声明的总数不能超过该值</li></ul><p>除此之外，还可以对本地临时存储资源进行限制定义</p><ul><li>requests.ephemeral-storage：namespace中，所有 Pod 的本地临时存储（local ephemeral storage）请求的总和不能超过该值</li><li>limits.ephemeral-storage：namespace中，所有 Pod 的本地临时存储限定的总和不能超过此值</li></ul><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>查看是否开启 Resource Quota 支持，默认一般是开启的。如果没有，可在启动 apiserver 时为参数 –enable-admission-plugins 添加 ResourceQuota 配置项。<br><img src="/assets/resource-quota.png" alt="resource-quota.png"></p><p>1.创建ResourceQuota</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl create namespace test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑ResourceQuota定义文档</span></span><br><span class="line">[root@kmaster ~]# vim quota-test.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ResourceQuota</span><br><span class="line">metadata:</span><br><span class="line">  name: quota-test</span><br><span class="line">  namespace: test</span><br><span class="line">spec:</span><br><span class="line">  hard:</span><br><span class="line">    requests.cpu: "2"</span><br><span class="line">    requests.memory: 2Gi</span><br><span class="line">    limits.cpu: "4"</span><br><span class="line">    limits.memory: 4Gi</span><br><span class="line">    requests.nvidia.com/gpu: 4</span><br><span class="line">    pods: "3"</span><br><span class="line">    services: "6"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建ResourceQuota</span></span><br><span class="line">[root@kmaster ~]# kubectl apply -f quota-test.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@kmaster ~]# kubectl get quota -n test</span><br><span class="line">NAME         CREATED AT</span><br><span class="line">quota-test   2020-05-26T10:31:10Z</span><br><span class="line">[root@kmaster ~]# kubectl describe quota quota-test -n test</span><br><span class="line">Name:                    quota-test</span><br><span class="line">Namespace:               test</span><br><span class="line">Resource                 Used  Hard</span><br><span class="line">--------                 ----  ----</span><br><span class="line">limits.cpu               0     4</span><br><span class="line">limits.memory            0     4Gi</span><br><span class="line">pods                     0     3</span><br><span class="line">requests.cpu             0     2</span><br><span class="line">requests.memory          0     2Gi</span><br><span class="line">requests.nvidia.com/gpu  0     4</span><br><span class="line">services                 0     6</span><br></pre></td></tr></table></figure><p>或者使用kubectl命令，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kmaster ~]# kubectl create quota quota-test --hard=count/deployments.extensions=2,count/replicasets.extensions=4,count/pods=3,count/secrets=4 --namespace=test</span><br></pre></td></tr></table></figure><p>我们在namespace test中创建了一个ResourceQuota，限制CPU、内存请求为2、2GB，限制CPU、内存限定使用为4、4GB，限制Pod个数为3 等。</p><p>我们来尝试创建一个如下定义的Deployment来测试一下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个测试deploy</span></span><br><span class="line">[root@kmaster ~]# vim quota-test-deploy.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: quota-test-deploy</span><br><span class="line">spec:</span><br><span class="line"> selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      purpose: quota-test</span><br><span class="line"> replicas: 3</span><br><span class="line"> template:</span><br><span class="line">   metadata:</span><br><span class="line">     labels:</span><br><span class="line">       purpose: quota-test</span><br><span class="line">   spec:</span><br><span class="line">     containers:</span><br><span class="line">     - name: quota-test</span><br><span class="line">       image: nginx</span><br><span class="line">       resources:</span><br><span class="line">         limits:</span><br><span class="line">           memory: "2Gi"</span><br><span class="line">           cpu: "1"</span><br><span class="line">         requests:</span><br><span class="line">           memory: "500Mi"</span><br><span class="line">           cpu: "500m"</span><br><span class="line">[root@kmaster ~]# kubectl apply -f quota-test-deploy.yaml -n test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@kmaster ~]# kubectl get pod -n test</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">quota-test-deploy-6b89fdc686-2dthq   1/1     Running   0          3m54s</span><br><span class="line">quota-test-deploy-6b89fdc686-9m2qw   1/1     Running   0          3m54s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看deploy状态</span></span><br><span class="line">[root@kmaster ~]# kubectl get deploy quota-test-deploy -n test -o yaml</span><br><span class="line">  message: 'pods "quota-test-deploy-6b89fdc686-rmktq" is forbidden: exceeded quota:</span><br><span class="line">        quota-test, requested: limits.memory=2Gi, used: limits.memory=4Gi, limited:</span><br><span class="line">        limits.memory=4Gi'</span><br></pre></td></tr></table></figure><p> replicas: 3定义创建三个Pod副本，但只成功创建了两个Pod，在deploy的status部分（最后一条命令结果），我们可以看到message提示第三个Pod创建时被拒绝，因为内存已达到限定。我们也可以将limits.memory调整为1Gi，将replicas调整为4，来验证对Pod个数的限制。可看到最终只起了三个Pod，status部分message提示 <code>pods &quot;quota-test-deploy-9dc54f95c-gzqw7&quot; is forbidden: exceeded quota:quota-test, requested: pods=1, used: pods=3, limited: pods=3</code>。</p><h2 id="Resource-Limit-Range"><a href="#Resource-Limit-Range" class="headerlink" title="Resource Limit Range"></a>Resource Limit Range</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>Resource Quota 是对namespace中总体的资源使用进行限制，Resource Limit Range 则是对具体某个Pod或容器的资源使用进行限制。默认情况下，namespace中Pod或容器的资源消耗是不受限制的，这就可能导致某个容器应用内存泄露耗尽资源影响其它应用的情况。Limit Range可以用来限定namespace内Pod（或容器）可以消耗资源的数量。</p><p>使用LimitRange对象，我们可以：</p><ol><li>限制namespace中每个Pod或容器的最小与最大计算资源</li><li>限制namespace中每个Pod或容器计算资源request、limit之间的比例</li><li>限制namespace中每个存储卷声明（PersistentVolumeClaim）可使用的最小与最大存储空间</li><li>设置namespace中容器默认计算资源的request、limit，并在运行时自动注入到容器中</li></ol><p>如果创建或更新对象（Pod、容器、PersistentVolumeClaim）对资源的请求与LimitRange相冲突，apiserver会返回HTTP状态码403，以及相应的错误提示信息；如果namespace中定义了LimitRange 来限定CPU与内存等计算资源的使用，则用户创建Pod、容器时，必须指定CPU或内存的request与limit，否则将被系统拒绝；当namespace总的limit小于其中Pod、容器的limit之和时，将发生资源争夺，Pod或者容器将不能创建，但不影响已经创建的Pod或容器。</p><h3 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h3><p>创建一个测试namespace test-limitrange，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建测试namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl create namespace test-limitrange</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换默认的namespace</span></span><br><span class="line">[root@kmaster ~]# kubectl config set-context --current --namespace=test-limitrange</span><br></pre></td></tr></table></figure><p>创建LimitRange定义文件 lr-test.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lr-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Container</span>       <span class="comment">#资源类型</span></span><br><span class="line">    <span class="attr">max:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"1"</span>            <span class="comment">#限定最大CPU</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"1Gi"</span>       <span class="comment">#限定最大内存</span></span><br><span class="line">    <span class="attr">min:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"100m"</span>         <span class="comment">#限定最小CPU</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"100Mi"</span>     <span class="comment">#限定最小内存</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"900m"</span>         <span class="comment">#默认CPU限定</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"800Mi"</span>     <span class="comment">#默认内存限定</span></span><br><span class="line">    <span class="attr">defaultRequest:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"200m"</span>         <span class="comment">#默认CPU请求</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"200Mi"</span>     <span class="comment">#默认内存请求</span></span><br><span class="line">    <span class="attr">maxLimitRequestRatio:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="number">2</span>              <span class="comment">#限定CPU limit/request比值最大为2  </span></span><br><span class="line">      <span class="attr">memory:</span> <span class="number">1.5</span>         <span class="comment">#限定内存limit/request比值最大为1.5</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pod</span></span><br><span class="line">    <span class="attr">max:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"2"</span>            <span class="comment">#限定Pod最大CPU</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"2Gi"</span>       <span class="comment">#限定Pod最大内存</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line">    <span class="attr">max:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">2Gi</span>        <span class="comment">#限定PVC最大的requests.storage</span></span><br><span class="line">    <span class="attr">min:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span>        <span class="comment">#限定PVC最小的requests.storage</span></span><br></pre></td></tr></table></figure><p>该文件定义了在namespace <code>test-limitrange</code> 中，容器、Pod、PVC的资源限制，在该namesapce中，只有满足如下条件，对象才能创建成功</p><ul><li>容器的<code>resources.limits</code>部分CPU必须在100m-1之间，内存必须在100Mi-1Gi之间，否则创建失败</li><li>容器的<code>resources.limits</code>部分CPU与<code>resources.requests</code>部分CPU的比值最大为2，memory比值最大为1.5，否则创建失败</li><li>Pod内所有容器的<code>resources.limits</code>部分CPU总和最大为2，内存总和最大为2Gi，否则创建失败</li><li>PVC的<code>resources.requests.storage</code>最大为2Gi，最小为1Gi，否则创建失败</li></ul><blockquote><p>如果容器定义了<code>resources.requests</code>没有定义<code>resources.limits</code>，则LimitRange中的default部分将作为limit注入到容器中；如果容器定义了<code>resources.limits</code>却没有定义<code>resources.requests</code>，则将requests值也设置为limits的值；如果容器两者都没有定义，则使用LimitRange中default作为limits，defaultRequest作为requests值</p></blockquote><p>创建与查看LimitRange，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建LimitRange</span></span><br><span class="line">[root@kmaster ~]# kubectl apply -f lr-test.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@kmaster ~]# kubectl describe limits lr-test</span><br><span class="line">Name:                  lr-test</span><br><span class="line">Namespace:             test-limitrange</span><br><span class="line">Type                   Resource  Min    Max  Default Request  Default Limit  Max Limit/Request Ratio</span><br><span class="line">----                   --------  ---    ---  ---------------  -------------  -----------------------</span><br><span class="line">Container              cpu       100m   1    200m             900m           2</span><br><span class="line">Container              memory    100Mi  1Gi  200Mi            800Mi          1500m</span><br><span class="line">Pod                    cpu       -      2    -                -              -</span><br><span class="line">Pod                    memory    -      2Gi  -                -              -</span><br><span class="line">PersistentVolumeClaim  storage   1Gi    2Gi  -                -              -</span><br></pre></td></tr></table></figure><p>我们可以创建不同配置的容器或Pod对象来验证，出于篇幅不再列出验证步骤。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对K8s的Namespace及针对Namespace的资源限制管理ResourceQuota，LimitRange进行了较为深入的探索，其中ResourceQuota对整个Namespace的资源使用情况进行限制，LimitRange则对单个的Pod或容器的资源使用进行限制。Namespace的权限控制可基于RBAC来实现，后续再单独进行梳理介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们对K8s的基本组件与概念有了个大致的印象，并且基于K8s实现了一个初步的CI/CD流程，但对里面涉及的各个对象（如Namespace, Pod, Deployment, Service, Ingress, PVC等）及各对象的管理可能还缺乏深入的理解与实践，接下来的文章就让我们一起深入K8s的各组件内部来一探究竟吧。下图是基于个人的理解梳理的一个K8s结构图，示例了各个组件（只包含了主要组件）如何协同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>解决K8s “kernel:unregister_netdevice:waiting for vethxxx to become free. Usage count=1” 的问题（Kernel升级）</title>
    <link href="http://blog.jboost.cn/k8s-netdevice-issue.html"/>
    <id>http://blog.jboost.cn/k8s-netdevice-issue.html</id>
    <published>2020-05-22T03:35:05.000Z</published>
    <updated>2020-08-26T01:43:56.751Z</updated>
    
    <content type="html"><![CDATA[<p>k8s集群运行过程中，经常出现节点上报出类似 “kernel:unregister_netdevice:waiting for vethxxx to become free. Usage count=1” 的错误信息，一方面影响交互，另一方面，对于有些操作比如 <code>docker stop</code>，半天没有响应，处于hang住的状态。</p><a id="more"></a><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>操作系统及内核版本为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-2 ~]# cat /etc/redhat-release </span><br><span class="line">CentOS Linux release 7.6.1810 (Core) </span><br><span class="line"></span><br><span class="line">[root@dev-server-2 ~]# uname -a</span><br><span class="line">Linux dev-server-2 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>经常有节点报出类似如下错误</p><p><img src="/assets/docker-bug.png" alt="docker-bug"></p><p>查看一些网上资料，一般都说是Kernel的Bug，并且虽然有些地方说在先前版本已经修复，但是在较高版本上仍有出现。</p><p>有一些解决办法是停止syslog服务，让其不将错误信息显示到控制台，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-2 ~]# systemctl stop rsyslog</span><br></pre></td></tr></table></figure><p>但这只能解决影响交互的问题，对于容器引擎被hang住的问题并没有解决，治标不治本。</p><p>也有人对此Bug的原因进行了追踪分析，判断可能是net_device引用计数器泄露的原因（参考：<a href="https://zhuanlan.zhihu.com/p/66895097" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66895097</a> ），并给出了修复补丁，尝试着安装给出的补丁，但没有成功。</p><p>查看了目前elrepo的kernel的ml（mainline stable，稳定的主线版本）版本已经到了 5.6.14-1.el7.elrepo， 于是尝试着对kernel进行升级。</p><h2 id="升级Kernel"><a href="#升级Kernel" class="headerlink" title="升级Kernel"></a>升级Kernel</h2><ol><li>更新yum仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dev-server-2 ~]# yum -y update</span><br></pre></td></tr></table></figure><ol start="2"><li>导入elrepo仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">导入elrepo仓库的公钥</span></span><br><span class="line">[root@dev-server-2 ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"><span class="meta">#</span><span class="bash">安装ELRepo仓库的yum源</span></span><br><span class="line">[root@dev-server-2 ~]# rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash">查看可用的kerner版本</span></span><br><span class="line">[root@dev-server-2 ~]# yum --disablerepo="*" --enablerepo="elrepo-kernel" list available</span><br></pre></td></tr></table></figure><ol start="3"><li>升级内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装最新版的内核</span></span><br><span class="line">[root@dev-server-2 ~]# yum --enablerepo=elrepo-kernel install kernel-ml</span><br></pre></td></tr></table></figure><ol start="4"><li>设置默认启动内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看系统已有内核</span></span><br><span class="line">[root@dev-server-2 ~]# sudo awk -F\' '$1=="menuentry " &#123;print i++ " : " $2&#125;' /etc/grub2.cfg</span><br><span class="line">0 : CentOS Linux (5.6.14-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">1 : CentOS Linux (3.10.0-957.el7.x86_64) 7 (Core)</span><br><span class="line">2 : CentOS Linux (0-rescue-f638aa03cdcf42998b077254bde50b53) 7 (Core)</span><br><span class="line"><span class="meta">#</span><span class="bash">设置默认启动内核，其中0为上述查出内核的索引</span></span><br><span class="line">grub2-set-default 0</span><br><span class="line"><span class="meta">#</span><span class="bash">生成grub配置文件</span></span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><ol start="5"><li>重启验证</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">[root@dev-server-2 devuser]# reboot</span><br><span class="line"><span class="meta">#</span><span class="bash">查看当前内核版本</span></span><br><span class="line">[root@dev-server-2 devuser]# uname -a</span><br><span class="line">Linux dev-server-2 5.6.14-1.el7.elrepo.x86_64 #1 SMP Tue May 19 12:17:13 EDT 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><ol start="6"><li>删除旧内核</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看现有内核</span></span><br><span class="line">[root@dev-server-2 devuser]# rpm -qa | grep kernel</span><br><span class="line">kernel-tools-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-headers-3.10.0-1062.1.1.el7.x86_64</span><br><span class="line">kernel-debuginfo-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-tools-libs-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-debuginfo-common-x86_64-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-ml-5.6.14-1.el7.elrepo.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash">删除旧的内核</span></span><br><span class="line">[root@dev-server-2 devuser]# yum remove ernel-tools-3.10.0-957.el7.x86_64 kernel-headers-3.10.0-1062.1.1.el7.x86_64 kernel-debuginfo-3.10.0-957.el7.x86_64 kernel-tools-libs-3.10.0-957.el7.x86_64 kernel-debuginfo-common-x86_64-3.10.0-957.el7.x86_64 kernel-3.10.0-957.el7.x86_64</span><br></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>通过升级内核重启后，问题目前没有再复现。但是否彻底解决该Bug待进一步跟进（至少不需要重装系统了）。</p><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/66895097" target="_blank" rel="noopener">诊断修复 TiDB Operator 在 K8s 测试中遇到的 Linux 内核问题</a></li><li><a href="https://www.cnblogs.com/xzkzzz/p/9627658.html" target="_blank" rel="noopener">Centos7 升级内核版本</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;k8s集群运行过程中，经常出现节点上报出类似 “kernel:unregister_netdevice:waiting for vethxxx to become free. Usage count=1” 的错误信息，一方面影响交互，另一方面，对于有些操作比如 &lt;code&gt;docker stop&lt;/code&gt;，半天没有响应，处于hang住的状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.jboost.cn/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jboost.cn/tags/kubernetes/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>面试官：请写一个你认为比较“完美”的单例</title>
    <link href="http://blog.jboost.cn/patterns-singleton.html"/>
    <id>http://blog.jboost.cn/patterns-singleton.html</id>
    <published>2020-05-12T03:50:21.000Z</published>
    <updated>2020-08-26T01:36:48.632Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是保证一个类的实例有且只有一个，在需要控制资源（如数据库连接池），或资源共享（如有状态的工具类）的场景中比较适用。如果让我们写一个单例实现，估计绝大部分人都觉得自己没问题，但如果需要实现一个比较完美的单例，可能并没有你想象中简单。本文以主人公小雨的一次面试为背景，循序渐进地讨论如何实现一个较为“完美”的单例。本文人物与场景皆为虚构，如有雷同，纯属捏造。</p><a id="more"></a><p>小雨计算机专业毕业三年，对设计模式略有涉猎，能写一些简单的实现，掌握一些基本的JVM知识。在某次面试中，面试官要求现场写代码：请写一个你认为比较“完美”的单例。</p><h2 id="简单的单例实现"><a href="#简单的单例实现" class="headerlink" title="简单的单例实现"></a>简单的单例实现</h2><p>凭借着对单例的理解与印象，小雨写出了下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完后小雨审视了一遍，总觉得有点太简单了，离“完美”貌似还相差甚远。对，在多线程并发环境下，这个实现就玩不转了，如果两个线程同时调用 getInstance() 方法，同时执行到了 if 判断，则两边都认为 instance 实例为空，都会实例化一个 Singleton 对象，就会导致至少产生两个实例了，小雨心想。嗯，需要解决多线程并发环境下的同步问题，保证单例的线程安全。</p><h2 id="线程安全的单例"><a href="#线程安全的单例" class="headerlink" title="线程安全的单例"></a>线程安全的单例</h2><p>一提到并发同步问题，小雨就想到了锁。加个锁还不简单，synchronized 搞起，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小雨再次审视了一遍，发现貌似每次 getInstance() 被调用时，其它线程必须等待这个线程调用完才能执行（因为有锁锁住了嘛），但是加锁其实是想避免多个线程同时执行实例化操作导致产生多个实例，在单例被实例化后，后续调用 getInstance() 直接返回就行了，每次都加锁释放锁造成了不必要的开销。</p><p>经过一阵思索与回想之后，小雨记起了曾经看过一个叫 Double-Checked Locking 的东东，双重检查锁，嗯，再优化一下,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例在完成第一次实例化，后续再调用 getInstance() 先判空，如果不为空则直接返回，如果为空，就算两个线程同时判断为空，在同步块中还做了一次双重检查，可以确保只会实例化一次，省去了不必要的加锁开销，同时也保证了线程安全。并且令小雨感到自我满足的是他基于对JVM的一些了解加上了 volatile 关键字来避免实例化时由于指令重排序优化可能导致的问题，真是画龙点睛之笔啊。 简直——完美！</p><div class="note quote">            <p class='p subtitle'>Tips: volatile关键字的语义</p><ol><li>保证变量对所有线程的可见性。对变量写值的时候JMM（Java内存模型）会将当前线程的工作内存值刷新到主内存，读的时候JMM会从主内存读取变量的值而不是从工作内存读取，确保一个变量值被一个线程更新后，另一个线程能立即读取到更新后的值。</li><li>禁止指令重排序优化。JVM在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序，使用 volatile 可以禁止进行指令重排序优化。</li></ol><p>JVM创建一个新的实例时，主要需三步：</p><ol><li>分配内存</li><li>初始化构造器</li><li>将对象引用指向分配的内存地址</li></ol><p>如果一个线程在实例化时JVM做了指令重排，比如先执行了1，再执行3，最后执行2，则另一个线程可能获取到一个还没有完成初始化的对象引用，调用时可能导致问题，使用volatile可以禁止指令重排，避免这种问题。</p>          </div><p>小雨将答案交给面试官，面试官瞄了一眼说道：“基本可用了，但如果我用反射直接调用这个类的构造函数，是不是就不能保证单例了。”  小雨挠挠头，对哦，如果使用反射就可以在运行时改变单例构造器的可见性，直接调用构造器来创建一个新的实例了，比如通过下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;Singleton&gt; constructor = Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Singleton singleton = constructor.newInstance();</span><br></pre></td></tr></table></figure><p>小雨再次陷入了思考。</p><h2 id="反射安全的单例"><a href="#反射安全的单例" class="headerlink" title="反射安全的单例"></a>反射安全的单例</h2><p>怎么避免反射破坏单例呢，或许可以加一个静态变量来控制,让构造器只有从 getInstance() 内部调用才有效，不通过 getInstance() 直接调用则抛出异常，小雨按这个思路做了一番改造，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Please use getInstance() method to get the single instance."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态变量 flag 来控制，只有从 getInstance() 调用构造器才能正常实例化，否则抛出异常。但马上小雨就发现了存在的问题：既然可以通过反射来调用构造器，那么也可以通过反射来改变 flag 的值，这样苦心设置的 flag 控制逻辑不就被打破了吗。看来也没那么“完美”。虽然并不那么完美，但也一定程度上规避了使用反射直接调用构造器的场景，并且貌似也想不出更好的办法了，于是小雨提交了答案。</p><p>面试官露出迷之微笑：“想法挺好，反射的问题基本解决了，但如果我序列化这个单例对象，然后再反序列化出来一个对象，这两个对象还一样吗，还能保证单例吗。如果不能，怎么解决这个问题？”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SerializationSafeSingleton s1 = SerializationSafeSingleton.getInstance();</span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">oos.writeObject(s1);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">SerializationSafeSingleton s2 = (SerializationSafeSingleton) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>s1 == s2 吗？ 答案是否，如何解决呢。</p><h2 id="序列化安全的单例"><a href="#序列化安全的单例" class="headerlink" title="序列化安全的单例"></a>序列化安全的单例</h2><p>小雨思考了一会，想起了曾经学习序列化知识时接触的 readResolve() 方法，该方法在ObjectInputStream已经读取一个对象并在准备返回前调用，可以用来控制反序列化时直接返回一个对象，替换从流中读取的对象，于是在前面实现的基础上，小雨添加了一个 readResolve() 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Please use getInstance() method to get the single instance."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法代替了从流中读取对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过几个步骤的逐步改造优化，小雨完成了一个基本具备线程安全、反射安全、序列化安全的单例实现，心想这下应该足够完美了吧。面试官脸上继续保持着迷之微笑：“这个实现看起来还是显得有点复杂，并且也不能完全解决反射安全的问题，想想看还有其它实现方案吗。”</p><h2 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h2><p>小雨反复思考，前面的实现是通过加锁来实现线程安全，除此之外，还可以通过类的加载机制来实现线程安全——类的静态属性只会在第一次加载类时初始化，并且在初始化的过程中，JVM是不允许其它线程来访问的，于是又写出了下面两个版本</p><ol><li>静态初始化版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该版本借助JVM的类加载机制，本身线程安全，但只要 Singleton 类的某个静态对象（方法或属性）被访问，就会造成实例的初始化，而该实例可能根本不会被用到，造成资源浪费，另一方面也存在反射与序列化的安全性问题，也需要进行相应的处理。</p><ol start="2"><li>静态内部类版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该版本只有在调用 getInstance() 才会进行实例化，即延迟加载，避免资源浪费的问题，同时也能保障线程安全，但是同样存在反射与序列化的安全性问题，需要相应处理。</p><p>这貌似跟前面版本的复杂性差不多啊，依然都需要解决反射与安全性的问题，小雨心想，有没有一种既简单又能避免这些问题的方案呢。</p><h2 id="“完美”方案"><a href="#“完美”方案" class="headerlink" title="“完美”方案"></a>“完美”方案</h2><p>一阵苦思冥想之后，小雨突然脑中灵光闪现，枚举！（这也是《Effective Java》的作者推荐的方式啊）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接通过 Singleton.INSTANCE 来引用单例，非常简单的实现，并且既是线程安全的，同时也能应对反射与序列化的问题，面试官想要的估计就是它了吧。小雨再次提交了答案，这一次，面试官脸上的迷之微笑逐渐消失了……</p><div class="note quote">            <p class='p subtitle'>Tips：为什么枚举是线程、反射、序列化安全的？</p><ol><li>枚举实际是通过一个继承自Enum的final类来实现（通过反编译class文件可看到具体实现），在static代码块中对其成员进行初始化，因此借助类加载机制来保障其线程安全</li><li>枚举是不支持通过反射实例化的，在Constructor类的newInstance方法中可看到</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br></pre></td></tr></table></figure>3. 枚举在序列化的时候仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。并且，编译器是不允许任何对这种序列化机制的定制的，禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。枚举通过这种机制保障了序列化安全。          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>枚举方案近乎“完美”，但实际中，大部分情况下，我们使用双重检查锁方案或静态内部类方案基本都能满足我们的场景并能很好地运行。并且方案从来没有“完美”，只有更好或更合适。本文只是从单例实现的不断演进的过程中，了解或回顾如反射、序列化、线程安全、Java内存模型（volatile语义）、JVM类加载机制、JVM指令重排序优化等方面的知识，同时也是启示我们在设计或实现的过程中，多从各个角度思考，尽可能全面地考虑问题。或者，在相关面试中能更好地迎合面试官的“完美”期望。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是保证一个类的实例有且只有一个，在需要控制资源（如数据库连接池），或资源共享（如有状态的工具类）的场景中比较适用。如果让我们写一个单例实现，估计绝大部分人都觉得自己没问题，但如果需要实现一个比较完美的单例，可能并没有你想象中简单。本文以主人公小雨的一次面试为背景，循序渐进地讨论如何实现一个较为“完美”的单例。本文人物与场景皆为虚构，如有雷同，纯属捏造。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="设计模式" scheme="http://blog.jboost.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
