<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空山新雨的技术空间</title>
  
  <subtitle>技术与管理兼修</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jboost.cn/"/>
  <updated>2019-09-18T11:36:40.834Z</updated>
  <id>http://blog.jboost.cn/</id>
  
  <author>
    <name>空山新雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK13，不如温习下Java8</title>
    <link href="http://blog.jboost.cn/jdk8.html"/>
    <id>http://blog.jboost.cn/jdk8.html</id>
    <published>2019-09-18T11:24:09.000Z</published>
    <updated>2019-09-18T11:36:40.834Z</updated>
    
    <content type="html"><![CDATA[<p>JDK13于昨天正式GA，版本新特性可参考： <a href="https://www.oschina.net/news/109934/jdk-13-released" target="_blank" rel="noopener">https://www.oschina.net/news/109934/jdk-13-released</a><br><a id="more"></a></p><p>虽然JDK更新迅速，但开发者貌似并不买账，据统计，目前仍以JDK8使用最多，预计可能还会延续好长一段时间。虽然JDK版本已至13，但对Java8的新特性，掌握程度如何呢？<br>本文对Java8的主要特性进行了梳理。供温习参考。</p><h2 id="1-接口默认方法"><a href="#1-接口默认方法" class="headerlink" title="1. 接口默认方法"></a>1. 接口默认方法</h2><p>以前的接口只允许有抽象方法（没有实现体），java8中提供了接口默认方法支持，即可以提供方法的默认实现，实现类可以直接继承，也可以覆盖。默认方法主要解决接口的修改导致现有实现类不兼容的问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceDefaultFunctionTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">func</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认方法</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//静态方法</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyFunction&lt;String&gt; myFunction = <span class="keyword">new</span> MyFunction&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">func</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(myFunction.func(<span class="string">"abc"</span>));</span><br><span class="line">        System.out.println(myFunction.func2(<span class="string">"abc"</span>));</span><br><span class="line">        LambdaTest.MyFunction.print(<span class="string">"efg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认方法通过关键字 default 声明。同时也可以在接口中定义静态方法。</p><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><p>函数式接口就是有且仅有一个抽象方法的接口（可以有其它非抽象方法），如1所示代码中 MyFunction 就是一个函数式接口，只有一个抽象方法 func， 其它非抽象方法如默认方法 func2， 静态方法 print 不影响其函数式接口的特性。</p><p>函数式接口可以使用注解 @FunctionalInterface 标注，该注解会去检查接口是否符合函数式接口的规范要求，不符合的话IDE会给出提示。</p><p>java中内置了一些函数式接口，</p><table><thead><tr><th style="text-align:center">函数式接口</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Consumer<t></t></td><td style="text-align:center">包含方法 void accept(T t)， 对类型为T的对象t进行操作</td></tr><tr><td style="text-align:center">Supplier<t></t></td><td style="text-align:center">包含方法 T get()，返回类型为T的对象</td></tr><tr><td style="text-align:center">Function&lt;T,R&gt;</td><td style="text-align:center">包含方法 R apply(T t)，对类型为T的对象进行操作，返回类型R的对象</td></tr><tr><td style="text-align:center">Predicat<t></t></td><td style="text-align:center">包含方法 boolean test(T t)， 判断类型为T的对象是否满足条件</td></tr></tbody></table><p>以及基于这些接口的其它变种或子接口，如BiConsumer&lt;T,U&gt;，BiFunction&lt;T,U,R&gt;等。还有如Runnable，Callable等接口，也属于函数式接口 —— 都只有一个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> BiConsumer&lt;T, U&gt; <span class="title">andThen</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (l, r) -&gt; &#123;</span><br><span class="line">            accept(l, r);</span><br><span class="line">            after.accept(l, r);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h2><p>lambda表达式实质就是一个匿名函数，在python中很常见，java到了jdk8提供了支持。<br>lambda表达式的格式形如： (参数) -&gt; {方法体语句}，当参数只有一个时，左边小括号可以省略，当方法体语句只有一条时，右边大括号可以省略。</p><p>Java的lambda表达式基本上是对函数式接口实现的一种简化 —— 用lambda表达式直接代替一个函数式接口的具体实现（抽象方法的实现）。当我们使用jdk8在IDE中编写1中代码时，IDE会给出提示，<br><img src="/assets/lambda-warn.png" alt="lambda-warn"></p><p>匿名实现类可以用lambda表达式替换。上述代码使用lambda表达式替换可调整为，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyFunction&lt;String&gt; myFunction = s -&gt; s.toUpperCase();</span><br><span class="line">    System.out.println(myFunction.func(<span class="string">"abc"</span>));</span><br><span class="line">    System.out.println(myFunction.func2(<span class="string">"abc"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda表达式甚至可作为方法参数传入（实质也是作为一个函数式接口的实现类实例）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">func</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(MyFunction&lt;String&gt; function, String s)</span></span>&#123;</span><br><span class="line">    System.out.println(function.func(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//将lambda表达式作为方法参数传入</span></span><br><span class="line">   print((String s) -&gt; s.toUpperCase(), <span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>局部变量在lambda表达式中是只读的，虽可不声明为final，但无法修改。如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//lambda表达式中无法修改局部变量i，将报编译错误</span></span><br><span class="line">    print((String s) -&gt; &#123;i = i+<span class="number">10</span>; <span class="keyword">return</span> s.toUpperCase();&#125;, <span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><p>当需要使用lambda表达式时，如果已经有了相同的实现方法，则可以使用方法引用来替代lambda表达式，几种场景示例如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例::实例方法</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s); <span class="comment">//lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; consumer2 = System.out::println; <span class="comment">//方法引用</span></span><br><span class="line">        consumer.accept(<span class="string">"abc"</span>);</span><br><span class="line">        consumer2.accept(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类::静态方法</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y); <span class="comment">//lambda表达式</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator2 = Integer::compare; <span class="comment">//方法引用</span></span><br><span class="line">        System.out.println(comparator.compare(<span class="number">10</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(comparator2.compare(<span class="number">10</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类::实例方法， 当引用方法是形如 a.func(b)时，用类::实例方法的形式</span></span><br><span class="line">        BiPredicate&lt;String, String&gt; biPredicate = (a, b) -&gt; a.equals(b); <span class="comment">//lambda表达式</span></span><br><span class="line">        BiPredicate&lt;String, String&gt; biPredicate2 = String::equals; <span class="comment">//方法引用</span></span><br><span class="line">        System.out.println(biPredicate.test(<span class="string">"abc"</span>, <span class="string">"abb"</span>));</span><br><span class="line">        System.out.println(biPredicate2.test(<span class="string">"abc"</span>,<span class="string">"abb"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//type[]::new 数组引用</span></span><br><span class="line">        Function&lt;Integer,Integer[]&gt; fun= n-&gt; <span class="keyword">new</span> Integer[n]; <span class="comment">//lambda表达式</span></span><br><span class="line">        Function&lt;Integer,Integer[]&gt; fun2=Integer[]::<span class="keyword">new</span>; <span class="comment">//方法引用</span></span><br><span class="line">        System.out.println(fun.apply(<span class="number">10</span>));</span><br><span class="line">        System.out.println(fun2.apply(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器引用</span></span><br><span class="line">        Function&lt;String,String&gt; func = n-&gt; <span class="keyword">new</span> String(n); <span class="comment">//lambda表达式</span></span><br><span class="line">        Function&lt;String,String&gt; func2 = String::<span class="keyword">new</span>; <span class="comment">//方法引用</span></span><br><span class="line">        System.out.println(func.apply(<span class="string">"aaa"</span>));</span><br><span class="line">        System.out.println(func2.apply(<span class="string">"aaa"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-Stream-API"><a href="#5-Stream-API" class="headerlink" title="5. Stream API"></a>5. Stream API</h2><p>Stream与lambda应该是java8最重要的两大特性。Stream 对集合的处理进行了抽象，可以对集合进行非常复杂的查找、过滤和映射等操作。提供了一种高效的且易于使用的处理数据的方式。<br>Stream的三个特性：</p><ul><li>Stream本身不会存储元素</li><li>Stream不会改变操作对象（即集合），会返回一个新的Stream</li><li>Stream的中间操作不会立刻执行，而是会等到需要结果的时候才执行</li></ul><p>Java8 的Collection接口包含了两个方法 stream(), parallelStream()， 分别返回一个顺序流与一个并行流，所有Collection类型（如List， ）的对象可以调用这两个方法生成流。<br>Java8 的Arrays类也提供了 stream(T[] array)等方法用以生成流。也可以使用静态方法 Stream.iterate() 和 Stream.generate() 来创建无限流。</p><p>Stream的中间操作包括</p><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">filter(Predicate p)</td><td style="text-align:center">接收 Lambda ， 从流中过滤出满足条件的元素</td></tr><tr><td style="text-align:center">distinct()</td><td style="text-align:center">通过hashCode() 和 equals() 去除重复元素</td></tr><tr><td style="text-align:center">limit(long maxSize)</td><td style="text-align:center">截断流，使元素的个数不超过给定数量</td></tr><tr><td style="text-align:center">skip(long n)</td><td style="text-align:center">跳过前面的n个元素，若流中元素不足n个，则返回一个空流</td></tr><tr><td style="text-align:center">map(Function f)</td><td style="text-align:center">将每个元素使用函数f执行，将其映射成一个新的元素</td></tr><tr><td style="text-align:center">mapToDouble(ToDoubleFunction f)</td><td style="text-align:center">将每个元素使用f执行，产生一个新的DoubleStream流</td></tr><tr><td style="text-align:center">mapToInt(ToIntFunction f)</td><td style="text-align:center">将每个元素使用f执行，产生一个新的IntStream流</td></tr><tr><td style="text-align:center">mapToLong(ToLongFunction f)</td><td style="text-align:center">将每个元素使用f执行，产生一个新的LongStream流</td></tr><tr><td style="text-align:center">flatMap(Function f)</td><td style="text-align:center">将流中的每个值都通过f转换成另一个流，然后把所有流连接成一个流</td></tr><tr><td style="text-align:center">sorted()</td><td style="text-align:center">按自然顺序排序，产生一个新流</td></tr><tr><td style="text-align:center">sorted(Comparator comp)</td><td style="text-align:center">根据比较器排序，产生一个新流</td></tr><tr><td style="text-align:center">allMatch(Predicate p)</td><td style="text-align:center">判断是否匹配所有元素</td></tr><tr><td style="text-align:center">anyMatch(Predicate p)</td><td style="text-align:center">判断是否匹配至少一个元素</td></tr><tr><td style="text-align:center">noneMatch(Predicate p)</td><td style="text-align:center">判断是否没有匹配任意元素</td></tr><tr><td style="text-align:center">findFirst()</td><td style="text-align:center">返回第一个元素</td></tr><tr><td style="text-align:center">findAny()</td><td style="text-align:center">返回任意一个元素</td></tr><tr><td style="text-align:center">reduce(T iden, BinaryOperator b)</td><td style="text-align:center">对流中的元素进行reduce操作，返回T类型对象</td></tr><tr><td style="text-align:center">reduce(BinaryOperator b)</td><td style="text-align:center">对流中的元素进行reduce操作，返回Optional<t>对象</t></td></tr></tbody></table><p>Stream的终止操作包括</p><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">count()</td><td style="text-align:center">返回元素总数</td></tr><tr><td style="text-align:center">max(Comparator c)</td><td style="text-align:center">返回最大值</td></tr><tr><td style="text-align:center">min(Comparator c)</td><td style="text-align:center">返回最小值</td></tr><tr><td style="text-align:center">forEach(Consumer c)</td><td style="text-align:center">内部迭代调用Consumer操作</td></tr><tr><td style="text-align:center">collect(Collector c)</td><td style="text-align:center">将流转换为其他形式，一般通过Collectors来实现</td></tr></tbody></table><p>Stream使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//转换为List，这里没啥意义，仅做示范</span></span><br><span class="line">    List&lt;User&gt; users = list.stream().collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//转换为Set</span></span><br><span class="line">    Set&lt;User&gt; users1 = list.stream().collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">//转换为Collection</span></span><br><span class="line">    Collection&lt;User&gt; users2 = list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">    <span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">long</span> count = list.stream().collect(Collectors.counting());</span><br><span class="line">    <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">int</span> total = list.stream().collect(Collectors.summingInt(User::getAge));</span><br><span class="line">    <span class="comment">//求平均值</span></span><br><span class="line">    <span class="keyword">double</span> avg= list.stream().collect(Collectors.averagingInt(User::getAge));</span><br><span class="line">    <span class="comment">//获取统计对象，通过该统计对象可获取最大值，最小值之类的数据</span></span><br><span class="line">    IntSummaryStatistics iss= list.stream().collect(Collectors.summarizingInt(User::getAge));</span><br><span class="line">    <span class="comment">//将值通过","拼接</span></span><br><span class="line">    String str= list.stream().map(User::getName).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    Optional&lt;User&gt; max= list.stream().collect(Collectors.maxBy(Comparator.comparingInt(User::getAge)));</span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    Optional&lt;User&gt; min = list.stream().collect(Collectors.minBy(Comparator.comparingInt(User::getAge)));</span><br><span class="line">    <span class="comment">//从累加器开始，对指定的值，这里是年龄，进行sum的reduce操作</span></span><br><span class="line">    <span class="keyword">int</span> t =list.stream().collect(Collectors.reducing(<span class="number">0</span>, User::getAge, Integer::sum));</span><br><span class="line">    <span class="comment">//对转换的结果再进行处理</span></span><br><span class="line">    <span class="keyword">int</span> how = list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br><span class="line">    <span class="comment">//分组</span></span><br><span class="line">    Map&lt;String, List&lt;User&gt;&gt; map= list.stream().collect(Collectors.groupingBy(User::getName));</span><br><span class="line">    <span class="comment">//根据条件进行分区</span></span><br><span class="line">    Map&lt;Boolean,List&lt;User&gt;&gt; vd= list.stream().collect(Collectors.partitioningBy(u -&gt; u.getName().startsWith(<span class="string">"W"</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-Optional类"><a href="#6-Optional类" class="headerlink" title="6. Optional类"></a>6. Optional类</h2><p>Optional是一个容器类，可以避免显式的null判断，基本使用示例如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOptional</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// of 不允许传入null值，否则抛出NPE</span></span><br><span class="line">        Optional&lt;Integer&gt; optional = Optional.of(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">        System.out.println(optional.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ofNullable 允许传入null，但是直接调用get会抛出NoSuchElementException异常，</span></span><br><span class="line">        <span class="comment">// 可通过isPresent判断是否存在值</span></span><br><span class="line">        Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(optional1.isPresent()) &#123;</span><br><span class="line">            System.out.println(optional1.get());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"optional1 is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// orElse 判断是否存在值，存在则返回，不存在则返回参数里的值</span></span><br><span class="line">        Integer value = optional1.orElse(<span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// map方法，如果optional有值，则对值进行处理返回新的Optional，</span></span><br><span class="line">        <span class="comment">// 如果没有值则返回Optional.empty()</span></span><br><span class="line">        optional = optional.map(x -&gt; x*x);</span><br><span class="line">        System.out.println(optional.get());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 与map类似，只是要求返回值必须是Optional，进一步避免空指针</span></span><br><span class="line">        optional = optional.flatMap(x -&gt;Optional.of(x*x));</span><br><span class="line">        System.out.println(optional.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7-Base64"><a href="#7-Base64" class="headerlink" title="7. Base64"></a>7. Base64</h2><p>在java8中，Base64成为了java类库的标准，可直接使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBase64</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//base64编码</span></span><br><span class="line">        String encode = Base64.getEncoder().encodeToString(<span class="string">"abc"</span>.getBytes());</span><br><span class="line">        System.out.println(encode);</span><br><span class="line">        <span class="comment">//base64解码</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(Base64.getDecoder().decode(encode)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="8-日期时间类"><a href="#8-日期时间类" class="headerlink" title="8. 日期时间类"></a>8. 日期时间类</h2><p>以前的Date类是非线程安全的，并且一些常用的日期时间运算需要自己编写util工具类。java8推出了java.time包，里面包含了如 LocalDate, LocalTime, LocalDateTime等类，可方便地进行日期时间的运算，如日期间隔、时间间隔，日期时间的加减，格式化等等。</p><p>—————————————————————————————<br>作者：空山新雨<br>欢迎关注我的微信公众号：jboost-ksxy<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK13于昨天正式GA，版本新特性可参考： &lt;a href=&quot;https://www.oschina.net/news/109934/jdk-13-released&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/109934/jdk-13-released&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（十）：使用Docker来搭建一套ELK日志分析系统</title>
    <link href="http://blog.jboost.cn/docker-elk.html"/>
    <id>http://blog.jboost.cn/docker-elk.html</id>
    <published>2019-09-07T05:43:37.000Z</published>
    <updated>2019-09-07T03:59:50.839Z</updated>
    
    <content type="html"><![CDATA[<p>一段时间没关注ELK（elasticsearch —— 搜索引擎，可用于存储、索引日志, logstash —— 可用于日志传输、转换，Kibana —— WebUI，将日志可视化），发现最新版已到7.4了。所以别问程序员为什么这么忙？因为不是在加班就是在学习新框架中。本文整理了使用Docker来快速搭建一套ELK日志分析系统的方法。<br><a id="more"></a></p><h2 id="1-部署elk"><a href="#1-部署elk" class="headerlink" title="1. 部署elk"></a>1. 部署elk</h2><p>github上有人整理了一套使用docker compose来部署elk的配置，可直接下载使用。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/deviantony/docker-elk.git</span><br></pre></td></tr></table></figure></p><p>如果没有git，那就安装一下（<code>yum install git</code>），或者直接下载github仓库的源码包。</p><p>当前是基于7.2.1版（docker-elk目录下.env文件中定义，可修改）。</p><p>调整一下相应的配置。</p><p>修改docker-compose，设置es密码等，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 在elasticsearch部分设置环境变量，将jvm堆内存增大到了1g，设置es elastic用户的密码</span></span><br><span class="line">  environment:</span><br><span class="line">        ES_JAVA_OPTS: "-Xmx1g -Xms1g"</span><br><span class="line">        ELASTIC_PASSWORD: Passw0rd</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 将logstash的端口映射从默认的5000改为5044，因为后面会用filebeat，不改也可以，对应就行</span></span><br><span class="line">  ports:</span><br><span class="line">        - "5044:5044"</span><br><span class="line">        - "9600:9600"</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 将jvm内存也增大一点</span></span><br><span class="line">  environment:</span><br><span class="line">        LS_JAVA_OPTS: "-Xmx512m -Xms512m"</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 在volumes部分增加es数据目录的挂载，对es数据持久化，避免容器销毁数据丢失</span></span><br><span class="line">  volumes:</span><br><span class="line">      - /mnt/elk/esdata:/usr/share/elasticsearch/data</span><br></pre></td></tr></table></figure></p><blockquote><p>注意： 因为es容器内部是以elasticsearch用户启动进程的，所以在做持久化数据目录挂载的时候，需要将目录权限进行设置，否则会因为没有访问权限而启动失败。elasticsearch的uid是1000，可以建一个uid为1000的用户，然后将目录所有者赋予该用户。</p></blockquote><p>修改es配置文件，将xpack从trial改为basic，禁用付费功能<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch/config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash">xpack.license.self_generated.type: trial</span></span><br><span class="line">  xpack.license.self_generated.type: basic</span><br></pre></td></tr></table></figure></p><p>修改logstash配置文件，设置es的用户名密码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim logstash/config/logstash.yml</span><br><span class="line"></span><br><span class="line">  xpack.monitoring.elasticsearch.username: elastic</span><br><span class="line">  xpack.monitoring.elasticsearch.password: Passw0rd</span><br></pre></td></tr></table></figure></p><p>修改logstash的pipeline配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim logstash/pipeline/logstash.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 这里codec根据具体情况配置 </span></span><br><span class="line">  input &#123;</span><br><span class="line">          beats &#123;</span><br><span class="line">                  port =&gt; 5044</span><br><span class="line">                  codec =&gt; "json" </span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment"># Add your filters / logstash plugins configuration here</span></span></span><br><span class="line">  output &#123;</span><br><span class="line">          elasticsearch &#123;</span><br><span class="line">                  hosts =&gt; "elasticsearch:9200"</span><br><span class="line">                  index =&gt; "%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;"</span><br><span class="line">                  user =&gt; "elastic"</span><br><span class="line">                  password =&gt; "Passw0rd"</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>修改kibana配置，设置es密码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim kibana/config/kibana.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment"># X-Pack security credentials</span></span></span><br><span class="line">  elasticsearch.username: elastic</span><br><span class="line">  elasticsearch.password: Passw0rd</span><br></pre></td></tr></table></figure></p><p>配置调整后，使用 <code>docker-compose up -d</code> 即可启动es，logstash，kibana三个容器。第一次启动需要下载所有镜像，会比较慢，启动完后，访问 elk所在服务器IP:5601即可进入kibana页面。</p><p>这里默认是起一个es容器，如果想起多个，参考： <a href="https://github.com/deviantony/docker-elk/wiki/Elasticsearch-cluster" target="_blank" rel="noopener">https://github.com/deviantony/docker-elk/wiki/Elasticsearch-cluster</a></p><h2 id="2-部署filebeat"><a href="#2-部署filebeat" class="headerlink" title="2. 部署filebeat"></a>2. 部署filebeat</h2><p>filebeat部署在产生日志的服务器上。先下载镜像，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.elastic.co/kibana/kibana:7.3.1</span><br></pre></td></tr></table></figure></p><p>下载一个示例配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://raw.githubusercontent.com/elastic/beats/7.3/deploy/docker/filebeat.docker.yml</span><br></pre></td></tr></table></figure></p><p>修改配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vim filebeat.docker.yml</span><br><span class="line"></span><br><span class="line">filebeat.config:</span><br><span class="line">  modules:</span><br><span class="line">    path: $&#123;path.config&#125;/modules.d/*.yml</span><br><span class="line">    reload.enabled: false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">filebeat.autodiscover:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  providers:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    - <span class="built_in">type</span>: docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      hints.enabled: <span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">processors:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">- add_cloud_metadata: ~</span></span><br><span class="line"><span class="meta">#</span><span class="bash">- add_host_metadata: ~</span></span><br><span class="line"></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">  - /var/log/elk/*.log</span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: ["你的elk服务器IP:5044"]</span><br></pre></td></tr></table></figure></p><p>去掉了一些不必要的配置，基本就是一个input, 一个output。input paths部分配置你日志所在目录，注意这里是容器内的目录，真正服务器的日志目录需要在启动容器时挂载到这里配置的目录。</p><p>启动容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name filebeat --user=root -v $(pwd)/filebeat.docker.yml:/usr/share/filebeat/filebeat.yml:ro \</span><br><span class="line">  -v /mnt/logs/elk/:/var/log/elk/ docker.elastic.co/beats/filebeat:7.3.1 filebeat -e -strict.perms=false</span><br></pre></td></tr></table></figure></p><p>对配置文件及实际日志目录与容器日志目录进行了挂载。</p><p>启动成功后，对应目录下的日志就会通过filebeat，logstash传输到es，进入kibana对日志数据建立索引进行查询了。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>前面用elk来搭建日志分析系统还是5.1版，两年时间已到7.4，配置方式，包括UI风格都做了很大的调整，很有一种人间一年，技术圈十载的感觉。<br>本文整理了基于Docker来搭建ELK框架的整个过程，供参考。<br><br><br>—————————————————————————————<br>作者：空山新雨<br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号）<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一段时间没关注ELK（elasticsearch —— 搜索引擎，可用于存储、索引日志, logstash —— 可用于日志传输、转换，Kibana —— WebUI，将日志可视化），发现最新版已到7.4了。所以别问程序员为什么这么忙？因为不是在加班就是在学习新框架中。本文整理了使用Docker来快速搭建一套ELK日志分析系统的方法。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
      <category term="elk" scheme="http://blog.jboost.cn/tags/elk/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（九）：网络管理</title>
    <link href="http://blog.jboost.cn/docker-9.html"/>
    <id>http://blog.jboost.cn/docker-9.html</id>
    <published>2019-08-30T05:14:57.000Z</published>
    <updated>2019-08-30T05:35:24.478Z</updated>
    
    <content type="html"><![CDATA[<p>Docker的应用运行在容器中，其相互之间或与外部之间是如何通信的，涉及到哪些知识点，本文对相关内容进行整理。因网络这块牵涉的面较多，因此只从日常使用或理解的角度出发，过于专业的就不深入探讨了。<br><a id="more"></a></p><h2 id="1-Docker默认的网络拓扑"><a href="#1-Docker默认的网络拓扑" class="headerlink" title="1. Docker默认的网络拓扑"></a>1. Docker默认的网络拓扑</h2><p>在<a href="/docker-2.html">Docker笔记（二）：Docker管理的对象</a>中，介绍了Docker通过一些驱动程序来实现容器之间或容器与外部的互联，包括bridge（默认的虚拟网桥形式），host（与主机共享网络栈），overlay（跨Docker Daemon容器间的互联），macvlan（为容器分配mac地址），none（禁用所有网络）等。</p><p>默认情况下，Docker启动时会创建一个虚拟网桥 docker0，可以理解为一个软件交换机。当创建一个 Docker 容器的时候，会创建一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0 ；另一端在宿主机本地并被挂载到 docker0 网桥，名称以veth 开头，如 veth340c305，docker0会在挂载到它上面的网口之间进行转发，从而实现主机与容器之间及容器与容器之间的相互通信。Docker默认的网络拓扑图如下：<br><img src="/assets/docker0.png" alt="docker0"></p><p>我们可以在宿主机上通过<code>ifconfig</code>查看相关的网络接口，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">~$ ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:46ff:fe26:ce0b  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:46:26:ce:0b  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 16868344  bytes 127838098551 (127.8 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 17929275  bytes 137867853738 (137.8 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">veth340c305: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::50f7:7ff:fe8f:6e72  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 52:f7:07:8f:6e:72  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 8093606  bytes 126893792744 (126.8 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8795102  bytes 10834735399 (10.8 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">veth6c803b7: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::1045:4cff:fe66:7f5a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 12:45:4c:66:7f:5a  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 140  bytes 9832 (9.8 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></p><p>通过<code>brctl show</code>可查看网络接口的挂载情况，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">docker08000.02424626ce0bnoveth340c305</span><br><span class="line">veth6c803b7</span><br></pre></td></tr></table></figure></p><p>由上可看出网络接口veth340c305，veth6c803b7都挂在虚拟网桥docker0上。</p><h2 id="2-容器与外部的互联"><a href="#2-容器与外部的互联" class="headerlink" title="2. 容器与外部的互联"></a>2. 容器与外部的互联</h2><p>我们前面的许多容器启动命令都有添加类似 -p 8080:8080 的参数，以指定将宿主机端口映射到容器端口，从而通过访问 <code>宿主机IP：宿主机端口</code> 的地址来访问对应端口的容器服务。<br>端口映射的完整格式为 <code>宿主机IP：宿主机端口：容器端口</code>，其中前两个是可以两者都取，或只取其一</p><ul><li><code>宿主机IP：宿主机端口：容器端口</code>：将指定宿主机IP的一个指定端口映射到容器端口，如<code>192.168.40.205:8090:8080</code></li><li><code>宿主机IP::容器端口</code>：将指定宿主机IP的一个随机端口映射到容器端口上，如果宿主机有多个IP，则可以通过这种格式指定绑定其中一个宿主机IP，随机端口范围为49000~49900</li><li><code>宿主机端口：容器端口</code>：将宿主机所有网络接口IP的指定端口映射到容器端口上，<code>8090:8080</code>等效于<code>0.0.0.0:8090:8080</code>（<code>0.0.0.0</code>即表示所有网络接口地址）</li></ul><p>可以使用 <code>docker port 容器ID或名称 容器端口</code>或<code>docker ps</code>命令来查看端口映射情况，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ docker port test-dev 8080</span><br><span class="line">0.0.0.0:32768</span><br><span class="line"></span><br><span class="line">~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">696a76944e72        cnbots:dev                                      "/bin/sh -c '/usr/lo…"   23 minutes ago      Up 23 minutes       0.0.0.0:32768-&gt;8080/tcp             test-dev</span><br></pre></td></tr></table></figure></p><p>在容器启动时，可以多次使用 -p 来指定映射多个端口。</p><p>如果不指定具体的宿主机端口，则可以使用 -P（大写）来分配一个宿主机的随机端口（范围为49000~49900）， 如<code>docker run -d -P --name test-dev test:dev</code>，然后通过<code>docker port 容器ID或名称 容器端口</code>或<code>docker ps</code>命令来查看具体映射到了哪个端口。</p><h2 id="3-容器之间的互联"><a href="#3-容器之间的互联" class="headerlink" title="3. 容器之间的互联"></a>3. 容器之间的互联</h2><p>同一个Docker Daemon下的容器，彼此之间是可以通过容器IP互相访问的（如何查看容器IP？用<code>docker inspect 容器ID或名称</code>命令），如果要实现两个容器之间可以通过容器名直接访问，则可以通过自建一个docker网络。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个自定义网络，-d 表示网络类型，可以为bridge（网桥，软件交换机），或overlay（跨Docker Daemon容器间的互联）</span></span><br><span class="line">~$ docker network create -d bridge my-net</span><br><span class="line">0c97fc265ed1cab67d84b9376d6914c9558419c73bb5abc040e75c945cd99f0a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个centos容器centos1，通过 --network 指定自定义网络</span></span><br><span class="line">~$ docker run -it --name centos1 --network my-net centos:7.3.1611 bash</span><br><span class="line">[root@3dcf507bd12a /]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再启动一个centos容器centos2（打开另一个窗口），指定同一个自定义网络</span></span><br><span class="line">~$ docker run -it --name centos2 --network my-net centos:7.3.1611 bash</span><br><span class="line">[root@16dcce660a89 /]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在centos1容器中直接ping centos2</span></span><br><span class="line">[root@3dcf507bd12a /]# ping centos2</span><br><span class="line">PING centos2 (172.19.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos2.my-net (172.19.0.2): icmp_seq=1 ttl=64 time=0.111 ms</span><br><span class="line">64 bytes from centos2.my-net (172.19.0.2): icmp_seq=2 ttl=64 time=0.058 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在centos2容器中直接ping centos1</span></span><br><span class="line">[root@16dcce660a89 /]# ping centos1</span><br><span class="line">PING centos1 (172.19.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos1.my-net (172.19.0.3): icmp_seq=1 ttl=64 time=0.061 ms</span><br><span class="line">64 bytes from centos1.my-net (172.19.0.3): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure></p><p>由上可见通过自定义网桥连接的容器可以通过容器名称互相访问。如果需要多个容器之间互联，则可以使用Docker Compose。</p><h2 id="4-配置容器的DNS"><a href="#4-配置容器的DNS" class="headerlink" title="4. 配置容器的DNS"></a>4. 配置容器的DNS</h2><p>如果要自定义所有容器的DNS，则可以在 /etc/docker/daemon.json 中增加<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"dns"</span> : [</span><br><span class="line">        <span class="string">"114.114.114.114"</span>,</span><br><span class="line">        <span class="string">"8.8.8.8"</span></span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以在启动容器时通过参数指定单个容器的DNS配置，<code>--dns=IP_ADDRESS</code>，这会将指定DNS的地址添加到容器的 /etc/resolv.conf 文件中，让容器用这个DNS服务器来解析所有不在 /etc/hosts 中的主机名。 </p><h2 id="5-Docker网络的底层实现"><a href="#5-Docker网络的底层实现" class="headerlink" title="5. Docker网络的底层实现"></a>5. Docker网络的底层实现</h2><p>容器的网络访问控制，主要是通过Linux上的<strong>iptables防火墙</strong>来实现与管理的。</p><ol><li><strong>容器访问外部网络</strong><br>容器访问外部网络，需要通过本地系统的转发，可以通过如下命令查看转发是否打开<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sysctl net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为1为打开，为0则未打开，可通过如下命令打开，也可以在Docker服务启动时通过参数--ip-forward=<span class="literal">true</span>打开</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sysctl -w net.ipv4.ip_forward=1</span></span><br></pre></td></tr></table></figure></li></ol><p>容器所有到外部网络的访问，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 iptables 的源地址伪装操作实现的，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~# iptables -t nat -nL</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0</span><br></pre></td></tr></table></figure><p>上述规则将所有源地址在 172.17.0.0/16 的网段（容器IP所在网段），目标地址为任意网段（包括外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。 </p><ol start="2"><li><strong>外部访问容器</strong></li></ol><p>通过 -p 或 -P 指定端口映射，允许外部访问容器端口，实质也是在本地的 iptable 的 nat 表中添加相应的规则，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~# iptables -t nat -nL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination                 </span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:3306 to:172.17.0.2:3306</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:11090 to:172.17.0.3:11090</span><br></pre></td></tr></table></figure></p><p>这里的规则映射了 0.0.0.0 ，意味着将接受主机来自所有网络接口的流量。</p><ol start="3"><li><strong>容器之间的访问</strong><br>容器之间能互相访问，需要满足两个条件：1）容器的网络拓扑是否已经互联，默认情况下容器都连接到docker0网桥上，默认是互联的。2）本地系统的防火墙iptables是否允许通过。当容器启动时通过–link互联时，也是在iptables中创建对应规则来实现。</li></ol><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文整理了Docker网络相关知识，对容器之间及容器与外部之间的通信机制应该有了一定的了解。除了默认的网络实现，Docker还提供了网络的配置及自定义网络，出于篇幅，本文介绍到这，后续再补充。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker的应用运行在容器中，其相互之间或与外部之间是如何通信的，涉及到哪些知识点，本文对相关内容进行整理。因网络这块牵涉的面较多，因此只从日常使用或理解的角度出发，过于专业的就不深入探讨了。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>开发人员需要掌握的日常Linux命令集</title>
    <link href="http://blog.jboost.cn/linux-cmd.html"/>
    <id>http://blog.jboost.cn/linux-cmd.html</id>
    <published>2019-08-27T02:58:43.000Z</published>
    <updated>2019-08-27T10:46:50.460Z</updated>
    
    <content type="html"><![CDATA[<p>不会运维的开发不是好测试。<br><a id="more"></a></p><p>本文整理了开发人员日常用到的linux相关命令，供参考。</p><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p><code>cd</code> # 进入某个目录，不接参数进入当前用户目录（等同于cd ~），如/home/devuser，可接绝对路径或相对路径（../..表示上上级目录），也可以接 “-” 回到上次所在目录</p><p><code>pwd</code> # 显示当前所在目录</p><p><code>ls -la</code> # 列出当前目录所有对象，-a表示包含以.开头的隐藏文件或目录<br><code>ll -h</code> # ll 等同于 ls -l， -h表示按K M G 显示文件大小</p><p><code>df -h</code> # 显示系统各盘符的空间使用情况<br><code>du -h --max-depth=1</code> # 显示当前目录下各文件大小，–max-depth=1只列出当前目录下的文件或目录，不会列出子目录下的文件</p><p><code>mv test.log /home/devuser/</code> # 移动文件（夹） 或重命名</p><p><code>cp [-r] test test.bak</code> # 复制文件，如果是文件夹则加 -r，表示复制文件夹下所有子文件夹内容<br><code>rm -[r]f /home/devuser/</code> # 删除文件，如果删除文件夹则加 -r </p><p><code>find / -name test.log</code> # 在根目录下查找文件名为test.log的文件<br><code>find /var/log/ -size +50M -exec rm -f {} \;</code> # 在/var/log/目录下查找大于50M的文件并删除，建议先将rm改为ls确认<br><code>find /var/log/ -type f -atime +10</code> # 搜索在过去10天内未被使用过的文件<br><code>find /var/log/ -type f -mtime -10</code> # 搜索在10天内被创建或者修改过的文件<br><code>find /var/log/ -type f -atime +10|xargs rm -f</code> # |xargs 作用与 -exec类似<br><code>find ./ -name &quot;*.log&quot; -exec &#39;cat&#39; {} \; &gt; test.log</code> # 将当前目录下所有.log文件内容合并到一个文件test.log</p><p><code>which java</code> # 在系统PATH路径下查找java可执行文件<br><code>whereis java</code> # 查找二进制、源文件、man文件，从文件索引中查找，而不仅仅从PATH路径下查找</p><p><code>zip test.zip test.log test2.log</code> # 创建一个zip格式的压缩包，可以接多个文件或文件夹<br><code>zip -r file.zip file1 file2 dir1</code> # 将几个文件和目录同时压缩成一个zip格式的压缩包<br><code>unzip test.zip</code> # 解压一个zip格式压缩包</p><p><code>tar -zcvf test.tar.gz</code> 要被压缩的文件名或目录 # 以gzip进行压缩 -z 按gzip，-c 压缩，-v 显示内容 -f 指定文件名<br><code>tar -zxvf test.tar.gz -C 解压缩到的目录</code> # 解压到指定目录 -x 解压<br><code>tar -ztvf test.tar.gz</code> # 不解压，只查看内容</p><p><code>tar -jcvf test.tar.bz2 要被压缩的文件名或目录</code> # 以bzip2进行压缩<br><code>tar -jxvf test.tar.bz2 -C 解压缩到的目录</code> # 解压到指定目录</p><h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><p><code>touch test.log</code> # 创建空文件<br><code>echo -e &#39;abc\ncba&#39;&gt; test.log</code> # 覆盖的形式往文件写入内容 -e 解析转移字符，不然当成字符串<br><code>echo &#39;aaa&#39; &gt;&gt; test.log</code> # 追加的形式往文件写入内容</p><p><code>cat [-n] test.log |grep [-v] abc</code> # 过滤文件中包含 abc 的行， 加-v表示不包含， -n表示打印行号<br><code>cat test.log |grep  abc|wc -l</code> # 计算文件中包含 abc 的行数</p><p><code>head -n 2 test.log</code> # 查看一个文件的前两行<br><code>tail -n 2 test.log</code> # 查看一个文件的最后两行<br><code>tail -n +1000 test.log</code> # 从1000行开始显示，显示1000行以后的<br><code>cat test.log | head -n 2000 | tail -n +1000</code> # 显示1000行到2000行的<br><code>cat test.log | tail -n +1000 | head -n 1000</code> # 从第1000行开始，显示1000行</p><p><code>more test.log</code> # 一页一页地查看文件内容，空格键往后一页，B键往前一页，不能通过上下键控制翻滚，会一次加载整个文件<br><code>less test.log</code> # 一页一页地显示文件内容，可以通过上下键控制往前往后翻，可以向上向下搜，不需一次加载整个文件，所以速度比more快，“less is more”， less比more更强大</p><p><code>tail -200f test.log</code> # 查看最后200行，根据文件描述符进行追踪，当文件改名或被删除，追踪停止<br><code>tail -F test.log</code> # 查看最后10行，只要对应文件名存在，就保持监视，即使文件被删除或改名后，如果再次创建相同的文件名，也会继续追踪</p><p><code>grep abc test.log</code> # 在文件中查找关键词”abc”，类似于 <code>cat test.log|grep abc</code><br><code>grep ^abc test.log</code> # 在文件中查找以”abc”开始的词汇<br><code>grep [0-9] test.log</code> # 选择文件中所有包含数字的行<br><code>grep abc -R /var/log</code>/* # 在目录 ‘/var/log’ 及随后的目录中搜索字符串”abc”</p><p><code>sed &#39;s/abc/ccc/g&#39; test.log</code> # 将test.log文件中的 “abc” 替换成 “ccc”并打印，不改变原有文件<br><code>sed &#39;/^$/d&#39; test.log</code> # 从文件中删除所有空白行并打印，不改变原有文件</p><p><code>paste test.log test2.log</code> # 按两列合并两个文件每行的内容并打印，test.log在左边，test2.log在右边<br><code>paste -d &#39;+&#39; file1 file2</code> # 合并两个文件每行的内容并打印，中间用”+”拼接</p><p><code>sort test.log</code> # 对文件内容进行排序，每行首字母排序<br><code>sort test.log test2.log</code> # 排序两个文件的内容<br><code>sort test.log test2.log | uniq</code> # 取出两个文件的并集(重复的行只保留一份)<br><code>sort test.log test2.log | uniq -u</code> # 删除交集，留下其他的行<br><code>sort test.log test2.log | uniq -d</code> # 取出两个文件的交集(同时存在于两个文件中的行)</p><p># comm 类似于集合的差集运算，需要两个文件都是排序的<br><code>comm -1 test.log test2.log</code> # 比较两个文件的内容只删除test.log所包含的内容<br><code>comm -2 test.log test2.log</code> # 比较两个文件的内容只删除test2.log所包含的内容<br><code>comm -3 test.log test2.log</code> # 比较两个文件的内容删除两个文件共有的内容</p><h2 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h2><p><code>chmod +x test.sh</code> # 为一个文件增加可执行权限<br><code>chmod ugo+rwx test.sh</code> # 设置文件的所有者(u)、群组(g)以及其他人(o)读（r，4 ）、写(w，2)和执行(x，1)的权限，+ 改为 - 即删除权限<br><code>chmod 755 test.sh</code> # 对文件所有者，群组，其他人分别设置7（rwx=4+2+1），5（rx=4+1）,5（rx=4+1）的权限</p><p><code>chown [-R] 用户名:群组名 test.log</code> #改变一个文件的所有者和群组，如果是作用于文件夹下所有文件或目录，则加 -R<br><code>chgrp 群组名 test.log</code> # 改变文件的群组</p><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><p><code>top</code> # 实时显示系统中各个进程的资源占用状况<br><code>top -H -p 进程号</code> # 列出进程的所有线程，按1键根据CPU占有率排序<br><code>ps -ef|grep 进程名称</code> # 查看某个进程，一般用户找进程ID<br><code>kill -9 进程ID</code> # 停止某个进程<br><code>jps</code> # 查看所有java进程</p><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><p><code>ifconfig</code> # 查看系统各网卡信息（IP，mac地址，子网掩码等）<br><code>ss -s</code> # 查看当前系统tcp、udp连接数</p><p><code>netstat -ano|grep 端口号</code> # 查看某个端口是否起来<br><code>lsof -i:端口号</code> # 查看某个端口对应的进程信息，lsof可能需要额外安装 （sudo yum install lsof）</p><p><code>ssh devuser@192.168.40.206</code> # 远程连接另一台linux主机</p><p><code>curl http://www.baidu.com</code> # get方式请求某个地址<br><code>curl -i -X POST -H &quot;Content-type:application/json&quot; -d &#39;{&quot;a&quot;:&quot;x&quot;,&quot;b&quot;:[&quot;y&quot;]}&#39;  http://xxx</code> # POST方式请求某个接口</p><p><code>wget http://xxx.zip</code> # 下载文件</p><p><code>scp test.log devuser@192.168.40.206:/home/devuser/</code># 传输文件到另一台主机的目录下，如果是文件夹则加 -r<br># nc 传输，可用于文件传输（scp需要密码，nc不需要密码），需要安装 sudo yum install nc<br><code>nc -l 1234 &gt; test.log</code> # 接收方，监听1234端口，将接收内容存于test.log<br><code>nc 192.168.40.205 1234 &lt; test.log</code> # 发送方，向接收方(ip为192.168.40.205)发送test.log的内容</p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><p><code>top</code> # 查看CPU、内存使用情况，即各进程使用情况<br><code>free -g</code> # 查看内存使用情况<br><code>date</code> # 查看系统当前时间<br><code>uptime</code> # 查看当前CPU使用负载情况，及系统已运行时间，相当于top的第一行<br><code>su</code> # 切换到root用户<br><code>su devuser</code> # 切换到devuser用户<br><br><br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不会运维的开发不是好测试。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="linux" scheme="http://blog.jboost.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>k8s云集群混搭模式，可能帮你节省50%的服务成本</title>
    <link href="http://blog.jboost.cn/mix-eci.html"/>
    <id>http://blog.jboost.cn/mix-eci.html</id>
    <published>2019-08-21T07:32:30.000Z</published>
    <updated>2019-08-22T03:49:19.484Z</updated>
    
    <content type="html"><![CDATA[<p>现在大部分中小企业或团队都是使用云平台来部署自己的服务，如阿里云，亚马逊云等。一般来说，业务的负载都具备一定的规律，比如每天集中在某几个小时，或呈现时间段周期性波峰、波谷交替的现象，如下图<br><img src="/assets/load-trend.png" alt="业务负载周期性"></p><p>如果使用ECS来部署服务，则可能大部分时间ECS的资源没有得到充分利用，造成成本浪费，尤其对于像GPU之类成本较高的资源就更加了。这个时候，我们可以考虑使用云集群的混搭模式来节约成本。</p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>假设有一个这样的业务场景，包括如下特点及要求：</p><ol><li>整个系统包括业务服务与两层视觉服务</li><li>各层服务之间调用需做负载均衡</li><li>每天的业务量主要集中在上午几个小时</li><li>平时业务量较低时仍要保证服务可用</li><li>尽可能降低成本，尤其是GPU服务器成本（GPU贵啊）</li></ol><p><img src="/assets/biz-top.png" alt="业务部署架构"></p><h2 id="k8s云集群混搭模式"><a href="#k8s云集群混搭模式" class="headerlink" title="k8s云集群混搭模式"></a>k8s云集群混搭模式</h2><p>现在各大云平台都已经提供容器云服务，如阿里云有基于ECI（弹性容器实例）的Serverless Kubernetes集群服务，基于ECS节点不需要提供master的Kubernetes托管版集群服务，及自己提供master的Kubernetes专有版集群服务等。为了迎合类似上述业务场景的需求，也提供了Kubernetes + virtual node（虚拟节点）的混合集群服务，如下图所示</p><p><img src="/assets/k8s-vn.png" alt="k8s-vn"></p><p>其中的虚拟节点基于ECI支持多种功能，如GPU容器实例、大规格容器实例等，增强了Kubernetes集群的弹性，使集群不局限于ECS节点的资源，做到弹性无限扩容。</p><h2 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h2><p>结合前面的业务场景，我们可以采用k8s的混合集群服务来部署我们的项目，如下图</p><p><img src="/assets/biz-deploy.png" alt="biz-deploy"></p><p>实现步骤：</p><ol><li>创建Kubernetes托管版集群</li><li>加入已有ECS节点</li><li>添加一个虚拟节点，通过添加应用 ack-virtual-node 来实现</li><li>分别创建无状态的业务Deployment、AI-1 Deployment、AI-2 Deployment（对应三层服务）</li><li>分别在业务Deployment上创建公网SLB，AI-1 Deployment、AI-2 Deployment上创建内网SLB</li><li>分别在各Deployment上根据CPU或内存使用阈值配置弹性水平伸缩HPA</li><li>根据需要可以在某个或某些Deployment上配置定时伸缩，通过添加应用 ack-kubernetes-cronhpa-controller 来实现</li></ol><blockquote><p>因为水平伸缩一般需要一定时间，延迟可能会对业务造成影响，所以在业务负载比较规律的时候，可以通过定时伸缩（就是定时扩展到多少个容器，再定时收缩到多少个容器）来改善；目前定时伸缩配置的查看与更新只能通过kubectl命令行进行。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按照官方文档的计费方式，一个普通的2核8G的ECS一年大概费用是2600左右，如果通过容器服务的方式（按秒计费），假设每天起8小时，则一年大概费用1550左右，如果业务负载再集中到几个小时，费用会更低，对于比较稀缺又昂贵的GPU服务就更加了。但是如果服务全部按容器24小时租赁，其成本就又比ECS贵了（一年约4600），所以在平时业务负载较低的时候，可以将容器调度到ECS上保障服务的提供，业务负载高时，通过HPA或cronHPA的方式动态伸缩到虚拟节点上。对于业务负载具有一定规律的服务来说，采用这种混搭的部署方式将极大地降低你的云服务成本。不过目前k8s云集群服务应该推出时间不久，产品的易用性还比较低，对不具备一定容器与编排基础的人使用门槛相对较高。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在大部分中小企业或团队都是使用云平台来部署自己的服务，如阿里云，亚马逊云等。一般来说，业务的负载都具备一定的规律，比如每天集中在某几个小时，或呈现时间段周期性波峰、波谷交替的现象，如下图&lt;br&gt;&lt;img src=&quot;/assets/load-trend.png&quot; alt=&quot;
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
      <category term="k8s" scheme="http://blog.jboost.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>小技巧：如何自定义logback日志文件的名称</title>
    <link href="http://blog.jboost.cn/trick-logback-prop.html"/>
    <id>http://blog.jboost.cn/trick-logback-prop.html</id>
    <published>2019-08-20T09:42:28.000Z</published>
    <updated>2019-08-20T11:04:34.498Z</updated>
    
    <content type="html"><![CDATA[<p>在logback.xml中获取自定义变量值。<br><a id="more"></a></p><p>我们可以通过在logback.xml中配置appender来指定日志输出格式及输出文件路径，这在一台主机或一个文件系统上部署单个实例没有问题，但是如果部署多个实例（比如通过容器的方式），多个实例同时往同一文件写日志可能就会引起问题。这时可以将每个实例的日志文件加以区分，如IP或UUID，或两者结合的形式。</p><p>可以有4种方式来实现logback.xml中获取自定义变量值：</p><ol><li>通过设置环境变量或传递系统属性（比如在程序启动时通过-D传递）的方式，两者是可以直接在logback.xml中通过 <code>${变量名}</code> 获取的。</li><li>自定义logback.xml的加载时机，在其加载前将需要设置的属性注入到logback的context中，这种方式相对复杂，本文不讨论。</li><li>通过实现PropertyDefiner接口来提供属性值设置</li><li>通过实现LoggerContextListener接口来设置属性值</li></ol><p>第一种方式简单，但不能通过程序生成属性值，第二种方式稍显复杂，本文主要介绍后两种方式。</p><h2 id="PropertyDefiner方式"><a href="#PropertyDefiner方式" class="headerlink" title="PropertyDefiner方式"></a>PropertyDefiner方式</h2><p>首先定义一个类，实现PropertyDefiner接口，可以通过继承PropertyDefinerBase会更方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.core.PropertyDefinerBase;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 将本地IP拼接到日志文件名中，以区分不同实例，避免存储到同一位置时的覆盖冲突问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20 16:17   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPLogDefiner</span> <span class="keyword">extends</span> <span class="title">PropertyDefinerBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(IPLogDefiner.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUniqName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String localIp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            localIp = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">"fail to get ip..."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        String uniqName = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (localIp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqName = localIp + <span class="string">"-"</span> + uniqName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPropertyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getUniqName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现方法 <code>getPropertyValue</code> 中返回你需要生成的值，本例中是返回 <code>本地IP-UUID</code> 的形式。</p><p>然后在logback.xml中，添加 <code>&lt;define&gt;</code> 配置，指定属性名（本例中为localIP）及获取属性值的实现类，这样就可以在配置中通过 <code>${localIP}</code>来引用该属性值了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">define</span> <span class="attr">name</span>=<span class="string">"localIP"</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.IPLogDefiner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLogFile"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>D:\\logs\\elk\\interface-$&#123;localIP&#125;.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"># 省略了其它配置</span><br></pre></td></tr></table></figure></p><h2 id="LoggerContextListener方式"><a href="#LoggerContextListener方式" class="headerlink" title="LoggerContextListener方式"></a>LoggerContextListener方式</h2><p>定义一个实现LoggerContextListener接口的类，在start方法中，将需要设置的属性设置到logback的Context中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Level;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.spi.LoggerContextListener;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.Context;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.spi.ContextAwareBase;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.spi.LifeCycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 第二种实现方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20 18:45   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerStartupListener</span> <span class="keyword">extends</span> <span class="title">ContextAwareBase</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LoggerContextListener</span>, <span class="title">LifeCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (started) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        context.putProperty(<span class="string">"localIP"</span>, getUniqName());</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUniqName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String localIp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            localIp = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">//LOG.error("fail to get ip...", e);</span></span><br><span class="line">        &#125;</span><br><span class="line">        String uniqName = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (localIp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqName = localIp + <span class="string">"-"</span> + uniqName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//省略了其它函数</span></span><br></pre></td></tr></table></figure><p>然后在logback.xml中，配置如上监听器类，这样就可以通过 <code>${localIP}</code> 获取到上面 <code>context.putProperty(&quot;localIP&quot;, getUniqName());</code> 设置的值了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;define name="localIP" class="com.cnbot.common.IPLogDefiner"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextListener</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.LoggerStartupListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">define</span> <span class="attr">name</span>=<span class="string">"localIP"</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.IPLogDefiner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLogFile"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>D:\\logs\\elk\\interface-$&#123;localIP&#125;.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"># 省略了其它配置</span><br></pre></td></tr></table></figure></p><p>这种方式能设置任意个数的属性值，比前一种方式灵活。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在logback.xml中获取自定义属性值，主要是需要在加载前将对应的属性值进行设置，这样加载时才能有效获取。本文虽是自定义日志文件名称，但不局限于此，所有需要动态获取的变量都可以按这种方式实现。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在logback.xml中获取自定义变量值。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.jboost.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（八）：数据管理</title>
    <link href="http://blog.jboost.cn/docker-8.html"/>
    <id>http://blog.jboost.cn/docker-8.html</id>
    <published>2019-08-12T08:50:37.000Z</published>
    <updated>2019-08-12T13:01:44.281Z</updated>
    
    <content type="html"><![CDATA[<p>前面（哪个前面我也忘了）有说过，如果我们需要对数据进行持久化保存，不应使其存储在容器中，因为容器中的数据会随着容器的删除而丢失，而因通过将数据存储于宿主机文件系统的形式来持久化。在Docker容器中管理数据主要有数据卷、宿主机目录挂载两种方式<br><a id="more"></a></p><h2 id="1-数据卷的方式"><a href="#1-数据卷的方式" class="headerlink" title="1. 数据卷的方式"></a>1. 数据卷的方式</h2><p>数据卷是一个特殊的文件目录（或文件），具备如下特性：</p><ol><li>可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>数据卷的更新，不会影响到镜像</li><li>数据卷默认会一直存在，不会随容器的删除而消亡</li></ol><h3 id="1-1-创建数据卷"><a href="#1-1-创建数据卷" class="headerlink" title="1.1 创建数据卷"></a>1.1 创建数据卷</h3><p>可以使用<code>docker volume create 数据卷名称</code>的命令来创建一个数据卷，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume create volume1</span><br><span class="line">volume1</span><br></pre></td></tr></table></figure></p><h3 id="1-2-查看数据卷"><a href="#1-2-查看数据卷" class="headerlink" title="1.2 查看数据卷"></a>1.2 查看数据卷</h3><p>创建完后，这个数据卷具体对应宿主机哪个文件目录在上面是没法得知的，可以通过<code>docker volume inspect 数据卷名称</code>来查看，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume inspect volume1</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "CreatedAt": "2019-08-12T19:43:47+08:00",</span><br><span class="line">        "Driver": "local",</span><br><span class="line">        "Labels": &#123;&#125;,</span><br><span class="line">        "Mountpoint": "/var/lib/docker/volumes/volume1/_data",</span><br><span class="line">        "Name": "volume1",</span><br><span class="line">        "Options": &#123;&#125;,</span><br><span class="line">        "Scope": "local"</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可以看到数据卷volume1对应的文件目录是“/var/lib/docker/volumes/volume1/_data”。</p><p><code>docker inspect xxx</code>这个命令挺有用的，不论是查看镜像相关信息（<code>docker image inspect 镜像名/镜像ID</code>），还是查看容器相关信息（<code>docker container inspect 容器名/容器ID</code>），都可以使用，其中的image,container,volume是可以省略的，只要xxx部分不冲突就行。</p><p>可以通过<code>docker volume ls</code> 命令来查看所有数据卷，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               volume1</span><br></pre></td></tr></table></figure></p><h3 id="1-3-使用数据卷"><a href="#1-3-使用数据卷" class="headerlink" title="1.3 使用数据卷"></a>1.3 使用数据卷</h3><p>可以在启动容器时通过 -v 或 –mount 的方式将一个数据卷挂载到容器的某个目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu1 -v volume1:/vol1 ubuntu:18.04</span><br><span class="line">b060e793d44de2ca871da257b47598334658952943a13d1c478df5c3ae91a01c</span><br></pre></td></tr></table></figure></p><p>按照 <code>-v 数据卷名:容器目录</code> 的格式，也可以使用 –mount 按照 <code>--mount source=数据卷名,target=容器目录</code> 的格式，如我们再启动一个挂载相同数据卷的容器 ubuntu2，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount source=volume1,target=/vol2 ubuntu:18.04</span><br><span class="line">b30971f8a4bbadee10774fce0b4568b5b7b1c9cde36f4bf84ac911a4cdaf6c8d</span><br></pre></td></tr></table></figure></p><p>可以在数据卷所在目录中创建一个文件来看看效果，先创建文件 hello.txt<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# cd /var/lib/docker/volumes/volume1/_data</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ _data]# touch hello.txt</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ _data]# ls</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>然后通过<code>docker exec</code>来查看容器ubuntu1目录/vol1，及容器ubuntu2目录/vol2的内容<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu1 ls /vol1</span><br><span class="line">hello.txt</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu2 ls /vol2</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>可以看到通过挂载目录 /vol1， /vol2 都可以访问到数据卷volume1对应目录下的内容。这就像linux的软链接一样，将容器目录链接到了数据卷目录。并且上述示例也说明，同一个数据卷是可以在被多个容器共享的。</p><p>数据卷的共享也可以通过 <code>volumes-from 容器名称/容器ID</code> 参数来实现，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu3 --volumes-from ubuntu2 ubuntu:18.04</span><br><span class="line">bb5c6d61a1e6eeb18ba8c889e471b2f3215f97efca79b311eeca5968b2700df8</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu3 ls /vol2</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>通过<code>--volumes-from ubuntu2</code>来直接使用ubuntu2挂载的容器配置。</p><h3 id="1-4-删除数据卷"><a href="#1-4-删除数据卷" class="headerlink" title="1.4 删除数据卷"></a>1.4 删除数据卷</h3><p>数据卷不会随着容器的删除而自动删除。<br>如果一个数据卷还被某个容器使用，则不能删除；<br>如果一个数据卷只被一个容器使用，则可在删除容器时通过指定 <code>-v</code> 参数同时删除其挂载的数据卷；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker rm -v ubuntu3</span><br><span class="line">ubuntu3</span><br></pre></td></tr></table></figure></p><p>可以通过 <code>docker volume rm 数据卷名称</code> 来删除某个数据卷；<br>可以通过 <code>docker volume prune</code> 清理掉所有未被任何容器使用的数据卷。</p><h2 id="2-宿主机目录挂载方式"><a href="#2-宿主机目录挂载方式" class="headerlink" title="2. 宿主机目录挂载方式"></a>2. 宿主机目录挂载方式</h2><p>在容器启动时，使用 <code>-v 宿主机目录:容器目录</code> 或 <code>--mount type=bind,source=宿主机目录,target=容器目录</code>的参数格式指定将宿主机目录挂载到容器目录上。宿主机目录必须是绝对路径。两者之间的区别是 <code>-v</code> 如果在宿主机目录不存在时会自动创建目录，而<code>--mount</code>不会。如，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu1 -v /root/v1:/vol1 ubuntu:18.04</span><br><span class="line">25c91911709eebc9290b47b483666f7b7be840df947117f7cad323583905b9f1</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount type=bind,source=/root/v2,target=/vol1 ubuntu:18.04</span><br><span class="line">docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /root/v2.</span><br><span class="line">See 'docker run --help'.</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# mkdir /root/v2</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount type=bind,source=/root/v2,target=/vol1 ubuntu:18.04</span><br><span class="line">5a57285e9261d048dc71cf0476055a290f80538afff2cefd2a24f8b4468b5171</span><br></pre></td></tr></table></figure></p><p>/root/v1,/root/v2都没有事先创建，用 <code>-v</code> 不会报错，会自动创建； <code>--mount</code>则会报错，目录必须先存在。</p><p>docker不仅支持目录的挂载，也支持文件的挂载，如，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run --rm -it -v $HOME/.bash_history:/root/.bash_history ubuntu:18.04 bash </span><br><span class="line">root@3ae4ed4e687d:/# history</span><br><span class="line">    1  ll webapps/</span><br><span class="line">    2  ll confluence/images/</span><br></pre></td></tr></table></figure></p><p>通过将宿主机当前用户的历史操作文件挂载到容器的root用户下的历史操作文件，可在容器中通过<code>history</code>命令查看到宿主机的操作历史。</p><p>可通过 <code>docker inspect</code>来查看容器的挂载情况<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker inspect ubuntu1</span><br><span class="line">--省略了其它信息--</span><br><span class="line">"Mounts": [</span><br><span class="line">            &#123;</span><br><span class="line">                "Type": "bind",</span><br><span class="line">                "Source": "/root/v1",</span><br><span class="line">                "Destination": "/vol1",</span><br><span class="line">                "Mode": "",</span><br><span class="line">                "RW": true,</span><br><span class="line">                "Propagation": "rprivate"</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">--省略了其它信息--</span><br></pre></td></tr></table></figure></p><p>可在“Mounts”部分看到挂载信息。</p><h2 id="3-只读控制"><a href="#3-只读控制" class="headerlink" title="3. 只读控制"></a>3. 只读控制</h2><p>有时候，为了数据安全，我们不允许容器对挂载目录的内容进行修改，即对容器来说，挂载目录是只读的，这可以通过在挂载参数后面加限制实现。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu3 -v /root/v1:/vol1:ro ubuntu:18.04</span><br><span class="line">25eca348ed307afcbef92bc03f0a1304b31b52e6db1fa07772b5dbd1040ff7b6</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu3 bash</span><br><span class="line">root@25eca348ed30:/# touch /vol1/hello.txt</span><br><span class="line">touch: cannot touch '/vol1/hello.txt': Read-only file system</span><br></pre></td></tr></table></figure></p><p><code>-v</code>是在后面加<code>ro</code>（read-only），<code>--mount</code>则是形如<code>--mount type=bind,source=宿主机目录,target=容器目录,read only</code>的格式，可自行试验。<br>加了read only的挂载我们再通过<code>docker inspect</code>命令查看，可看到两者之间的差异 —— Mode与RW的值。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">            &#123;</span><br><span class="line">                "Type": "bind",</span><br><span class="line">                "Source": "/root/v1",</span><br><span class="line">                "Destination": "/vol1",</span><br><span class="line">                "Mode": "ro",</span><br><span class="line">                "RW": false,</span><br><span class="line">                "Propagation": "rprivate"</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>如果要对数据进行持久化管理或在容器之间共享数据，则需要将数据通过数据卷或宿主机目录（或文件）挂载的方式来将数据存储于宿主机上，使得数据的生命周期独立于容器的生命周期。这类似于我们不要把重要文件放在系统盘，而应放在其它数据盘一样，因为系统盘会由于重装系统或系统故障导致文件丢失。本文对Docker的数据管理进行了整理，后续对Docker的网络配置管理部分进行整理，欢迎持续关注。</p><p><br><br>我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面（哪个前面我也忘了）有说过，如果我们需要对数据进行持久化保存，不应使其存储在容器中，因为容器中的数据会随着容器的删除而丢失，而因通过将数据存储于宿主机文件系统的形式来持久化。在Docker容器中管理数据主要有数据卷、宿主机目录挂载两种方式&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>就业，该去小公司还是大公司？</title>
    <link href="http://blog.jboost.cn/company-choice.html"/>
    <id>http://blog.jboost.cn/company-choice.html</id>
    <published>2019-08-09T05:29:58.000Z</published>
    <updated>2019-08-12T04:00:24.375Z</updated>
    
    <content type="html"><![CDATA[<p>前几天跟一朋友交流，他说一个表弟明年就要毕业了，马上面临找工作，是去一线城市找大公司的工作好，还是留在二线城市中小公司发展好。我说，去大公司好。为什么会有这个结论，这篇文章结合自己的经历说说我的一些感受。<br><a id="more"></a></p><p>我的第一份工作是在一家外企，当时抱着“逃离”上海的想法去了二线城市的分公司，但是管理文化氛围跟总部几乎都是一样的，这份工作经历对我后面的工作不论是做事风格、习惯上还是思考问题的方式方法上都有很大的影响。后面陆续进入国企，民企，再进入初创公司，从公司规模上可以说各种类型的都有过体验。下面从环境因素，平台效应因素等几个角度说说自己的感受。</p><h2 id="环境因素"><a href="#环境因素" class="headerlink" title="环境因素"></a>环境因素</h2><p>环境对一个人的影响还是很重要的，不论是大家熟知的“近朱者赤近墨者黑”的说法，还是令我们中国人挤破脑袋的“学区房”现象，都说明环境对一个人的成长起着至关重要的作用。</p><p>小公司与大公司的环境差异首先体现在人员的素养、水平上。大公司的准入门槛相对高一些，所以人员的素质、水平也相对要高一些，如果你周围牛人比较多的话，跟牛人待久了，你也可能慢慢就步入牛人之列了——“近朱者赤”。而小公司，尤其是初创公司，为了尽快招人干活，往往人员的素质、水平会良莠不齐，你可能很难找到一个各方面让你信服，想跟着他学的真正的“牛人”。</p><p>其次在制度、流程规范上。大公司在制度、流程、规范方面相对健全完善，不论是人事管理还是日常合作分工都比较明确，你知道什么时候应该干什么（因为都给你安排好了），处理什么事情应该找谁，都有章可循，有人可找。而在小公司，可能很多人感觉的就一个字——“乱”，人员职责、分工、权限没有明确定义，没有人引导，不知道在什么阶段应该干什么，或者怎么干，明明是个小兵，老板却恨不得你是个全才，啥事都希望你能搞定。有人把在大公司工作比喻是做一颗螺丝钉，而觉得在小公司才能锻炼综合能力，但我觉得在一定的阶段，螺丝钉似的工作才能让你在专业能力上面得到更大的提升，而小公司所谓的综合能力，往往演变的是“打杂”能力，老板为了节约成本，充分发挥（压榨）每个人的能力（价值），往往一人要分饰多角，比如做人事的既要管招聘，又要管行政，甚至还可能被拉去监督项目进度，很难让你在一个专业的领域深度成长。</p><p>再次在产品规模上，大公司产品的日活规模可能少则上百万，多则上亿，不论是在技术实现还是产品运营上，都需要较高的要求与水准，你在其中能学习的技能与套路是小公司日活几千或几万的产品规模无法比拟的。</p><p>最后在文化氛围上，一般大公司都有形成自己的企业文化，包括周围人的工作风格、习惯，都会对你产生潜移默化的影响。比如我现在的不论是写代码，还是写文字，都会反复检查好几遍的习惯就是在第一家公司工作时养成的。因为你的每一行代码你的leader可能都会仔细帮你review，找出有问题的地方让你反复修正直到合格，你的每一封邮件都会被别人（在外企很多时候还包括美国人、印度人）认真查看，所以促使你在发出前会仔细核查是否有遗漏的点，是否存在错别字或语法错误，久而久之，就养成了这种反复检查的比较严谨的做事风格。而在小公司，一般很难在短时间内形成自己的企业文化，很多事情的处理都比较粗放，缺乏对细节的把握，你很难从企业文化氛围上受益。</p><p>如果用游泳来比喻大公司与小公司的差异，我觉得大公司就像是一个掌握各项泳姿、动作标准的游泳运动员，有规范有节奏，从而游得更远；而小公司则更像一个会“狗爬式”的乡下野孩子，虽然路子野，但有效——尽管比较费力，但是能游起来，但能游多远，得看方向对不对，人能不能坚持。</p><h2 id="平台效应因素"><a href="#平台效应因素" class="headerlink" title="平台效应因素"></a>平台效应因素</h2><p>现在有些企业招聘，都明确要求毕业院校必须是985、211，甚至有些岗位直接面向BAT。前不久看到一个案例，上海交大硕博毕业因本科不是211，而被招聘企业直接拒绝。<br><img src="/assets/case-10.jpg" alt="case1">    <img src="/assets/case-11.jpg" alt="case2"></p><p>现实就是这样，看背景，看出身。名企工作与名校毕业一样，对后面的跳槽都会有较大的加分与优势。从小公司跳大公司难，但从大公司跳小公司就容易很多，见过许多阿里系的普通技术人员跳到中小企业做技术管理者的情况。</p><p>名企光环，除了对后面的就业与跳槽方面具备优势，在社会活动上也具备一定的优势，比如现在很多技术书籍，相当一部分出自阿里系，不是说非阿里系的人不具备这个能力，而是因为有着阿里这个名企光环，出的东西更容易被人接受与认可，尽管不一定水平有多好。</p><h2 id="什么人适合去小公司"><a href="#什么人适合去小公司" class="headerlink" title="什么人适合去小公司"></a>什么人适合去小公司</h2><p>毕竟不是每个人都能去大公司，那么什么人适合去小公司呢？我觉得可能主要包括两类，一类是自己在某个领域已经取得了较好的成长，具备了独当一面或者懂得如何带领他人来做事情的能力，这种情况一般是为了追求高薪或对某个领域或公司比较看好，有自己想法的人；另一类是目前还不具备进入大公司的资本与能力的人，人总得工作与生活，所以不得不先进入小公司成长，但这部分人除非自身公司发展特别好，否则还是应该尽力往大公司靠，努力进入大公司体验其管理模式与文化氛围，对你整个职业生涯是有很大帮助的。</p><h2 id="选择什么样的小公司"><a href="#选择什么样的小公司" class="headerlink" title="选择什么样的小公司"></a>选择什么样的小公司</h2><p>选择什么样的小公司比较好，虽然很多时候也没有太多的选择，毕竟好的小公司也是可遇不可求的事情，但如果有的话，我觉得还是尽力选择满足如下四个条件的小公司比较好。</p><ol><li>靠谱的老板。小公司的管理文化与前途基本由老板的品质与能力决定，所以一个有能力、靠谱的老板是第一要素。</li><li>高水平的管理团队，技术、管理、营销各方面。管理团队对于创业公司来说非常重要，只有一个稳定的各方面成熟的团队，成功的几率才会大一点，你在里面能获得的成长空间也更多一些。</li><li>产品项目具备长远发展的潜力。企业经营就是做一个别人愿意花钱购买的产品，并寻找一个将产品源源不断卖不出的方式，所以产品是不是刚需，有没有人买单，能不能长久很重要。</li><li>可靠的资源与渠道。有可靠的资源与渠道，才能将产品源源不断地卖出去，企业才能保持可持续发展。</li></ol><p>以上四点从上往下重要性依次递减，同时满足四个条件的小公司应该是极少的，是可遇不可求的事情，可以按从上往下的重要性进行选择。</p><p>另外进入小公司，可能常见的一个东西是期权，我认为期权是一个美丽的梦，如果以上四点都靠谱，没有期权也能获得很好的锻炼与成长，如果不靠谱，那么就算拿了期权大概率也是一个美丽的梦，看起来很美好，但不会成真的那种，所以面对期权（画饼），也要保持理性。</p><h2 id="职场没有伊甸园"><a href="#职场没有伊甸园" class="headerlink" title="职场没有伊甸园"></a>职场没有伊甸园</h2><p>最后，不论是大公司，还是小公司，都不存在职场的伊甸园，只有自己不断成长，进步，自己强大了，才有更多的选择空间。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天跟一朋友交流，他说一个表弟明年就要毕业了，马上面临找工作，是去一线城市找大公司的工作好，还是留在二线城市中小公司发展好。我说，去大公司好。为什么会有这个结论，这篇文章结合自己的经历说说我的一些感受。&lt;br&gt;
    
    </summary>
    
      <category term="Career" scheme="http://blog.jboost.cn/categories/Career/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker笔记（七）：常用服务安装——Nginx、MySql、Redis</title>
    <link href="http://blog.jboost.cn/docker-7.html"/>
    <id>http://blog.jboost.cn/docker-7.html</id>
    <published>2019-08-07T05:29:45.000Z</published>
    <updated>2019-08-07T10:18:30.564Z</updated>
    
    <content type="html"><![CDATA[<p>开发中经常需要安装一些常用的服务软件，如Nginx、MySql、Redis等，如果按照普通的安装方法，一般都相对比较繁琐 —— 要经过下载软件或源码包，编译安装，配置，启动等步骤，使用 Docker 来安装这些服务软件能极大地简化安装过程，且速度也很快。<br><a id="more"></a></p><p>本文以下操作假定你已经装好了docker，并做好了镜像配置。如果没有，请参考 <a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a></p><h2 id="1-MySql-安装"><a href="#1-MySql-安装" class="headerlink" title="1. MySql 安装"></a>1. MySql 安装</h2><h3 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1 下载镜像"></a>1.1 下载镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull mysql:5.7</span><br></pre></td></tr></table></figure><h3 id="1-2-创建挂载目录"><a href="#1-2-创建挂载目录" class="headerlink" title="1.2 创建挂载目录"></a>1.2 创建挂载目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir -p apps/mysql/conf apps/mysql/data apps/mysql/logs</span><br></pre></td></tr></table></figure><p>如上分别创建了配置文件目录，数据存放目录，以及日志文件目录</p><h3 id="1-3-启动容器实例"><a href="#1-3-启动容器实例" class="headerlink" title="1.3 启动容器实例"></a>1.3 启动容器实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 3306:3306 --name mysql -v /home/devuser/apps/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf -v /home/devuser/apps/mysql/logs:/var/log/mysql -v /home/devuser/apps/mysql/data:/var/lib/mysql --restart=always -e MYSQL_ROOT_PASSWORD=Passw0rd mysql:5.7</span><br></pre></td></tr></table></figure><p>其中<br>-d： 表示在后台运行<br>-p： 宿主机端口与容器端口映射<br>–name： 容器名称<br>-v： 宿主机目录与容器目录映射<br>–restart=always：除非被<code>docker stop</code>命令明确停止，否则一直尝试重启处于停止态的容器；如果Docker重启，也会自动启动容器<br>-e： 设置环境变量，这里设置了mysql root用户的密码为Passw0rd</p><p>如此，MySql服务就跑起来了，很快很简单有木有。</p><h2 id="2-Redis-安装"><a href="#2-Redis-安装" class="headerlink" title="2. Redis 安装"></a>2. Redis 安装</h2><h3 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull redis:5.0.5</span><br></pre></td></tr></table></figure><h3 id="2-2-启动容器"><a href="#2-2-启动容器" class="headerlink" title="2.2 启动容器"></a>2.2 启动容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d --name redis -p 6379:6379 -v /home/devuser/apps/redis/data:/data --restart=always redis:5.0.5 redis-server --appendonly yes --requirepass "Passw1rd"</span><br></pre></td></tr></table></figure><p>-p， -v 与上同，不赘述<br>redis-server –appendonly yes : 在容器启动时执行redis-server命令，并打开redis持久化配置<br>–requirepass： 设置密码</p><h3 id="2-3-连接"><a href="#2-3-连接" class="headerlink" title="2.3 连接"></a>2.3 连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ docker exec -it redis redis-cli -h 172.17.0.4 -p 6379 -a Passw1rd</span><br><span class="line">Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.</span><br><span class="line">172.17.0.4:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">172.17.0.4:6379&gt;</span><br></pre></td></tr></table></figure><p>这种方式把密码暴露了，其它登录用户通过history即可看到密码，不是太安全。可改用如下方式，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~$ docker exec -it redis redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 'Passw1rd'</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><h2 id="3-Nginx-安装"><a href="#3-Nginx-安装" class="headerlink" title="3. Nginx 安装"></a>3. Nginx 安装</h2><h3 id="3-1-拉取镜像"><a href="#3-1-拉取镜像" class="headerlink" title="3.1 拉取镜像"></a>3.1 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull nginx</span><br></pre></td></tr></table></figure><p>会拉取最新的（latest）镜像</p><h3 id="3-2-创建目录"><a href="#3-2-创建目录" class="headerlink" title="3.2 创建目录"></a>3.2 创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir -p apps/nginx/html apps/nginx/logs apps/nginx/conf</span><br></pre></td></tr></table></figure><h3 id="3-3-先不指定映射路径启动一个容器"><a href="#3-3-先不指定映射路径启动一个容器" class="headerlink" title="3.3 先不指定映射路径启动一个容器"></a>3.3 先不指定映射路径启动一个容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 80:80 --name nginx nginx</span><br><span class="line">1fdcd13457a6eaacb511878e10d84ffbe48fe63fd1fb3705f58b2d4195b151d8</span><br></pre></td></tr></table></figure><p>这里如果直接指定映射路径运行会报错，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 80:80 --name nginx -v ~/apps/nginx/html:/usr/share/nginx/html -v ~/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/apps/nginx/logs:/var/log/nginx nginx</span><br><span class="line">dab56c13f9e76aad37fcf73411c78d495a6466f1c0d214949650dbae44adddf4</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused "process_linux.go:424: container init caused \"rootfs_linux.go:58: mounting \\\"/home/devuser/apps/nginx/conf/nginx.conf\\\" to rootfs \\\"/home/docker_image/overlay2/e40ccaf4d845a9af92487b47cbc4d505c5c776800ef8887c5b43833b10661427/merged\\\" at \\\"/home/docker_image/overlay2/e40ccaf4d845a9af92487b47cbc4d505c5c776800ef8887c5b43833b10661427/merged/etc/nginx/nginx.conf\\\" caused \\\"not a directory\\\"\"": unknown: Are you trying to mount a directory onto a file (or vice-versa)? Check if the specified host path exists and is the expected type.</span><br></pre></td></tr></table></figure></p><h3 id="3-4-将运行容器的配置文件复制到宿主机目录下"><a href="#3-4-将运行容器的配置文件复制到宿主机目录下" class="headerlink" title="3.4 将运行容器的配置文件复制到宿主机目录下"></a>3.4 将运行容器的配置文件复制到宿主机目录下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker cp 1fdcd13457a6:/etc/nginx/nginx.conf ~/apps/nginx/conf/</span><br></pre></td></tr></table></figure><h3 id="3-5-删除容器并重新运行"><a href="#3-5-删除容器并重新运行" class="headerlink" title="3.5 删除容器并重新运行"></a>3.5 删除容器并重新运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker stop 1fdcd1345</span><br><span class="line">~$ docker rm 1fdcd1345</span><br><span class="line">~$ docker run -d -p 80:80 --name nginx -v ~/apps/nginx/html:/usr/share/nginx/html -v ~/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/apps/nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure><h3 id="3-6-更新配置后重新加载"><a href="#3-6-更新配置后重新加载" class="headerlink" title="3.6 更新配置后重新加载"></a>3.6 更新配置后重新加载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker kill -s HUP nginx</span><br></pre></td></tr></table></figure><p>类似于 <code>nginx -s reload</code></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文没有总结。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中经常需要安装一些常用的服务软件，如Nginx、MySql、Redis等，如果按照普通的安装方法，一般都相对比较繁琐 —— 要经过下载软件或源码包，编译安装，配置，启动等步骤，使用 Docker 来安装这些服务软件能极大地简化安装过程，且速度也很快。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot（十一）：注解结合JWT实现简单的接口鉴权</title>
    <link href="http://blog.jboost.cn/springboot-simpleauth.html"/>
    <id>http://blog.jboost.cn/springboot-simpleauth.html</id>
    <published>2019-08-01T12:45:59.000Z</published>
    <updated>2019-08-12T04:00:24.375Z</updated>
    
    <content type="html"><![CDATA[<p>一般服务的安全包括认证（Authentication）与授权（Authorization）两部分，认证即证明一个用户是合法的用户，比如通过用户名密码的形式，授权则是控制某个用户可以访问哪些资源。比较成熟的框架有Shiro、Spring Security，如果要实现第三方授权模式，则可采用OAuth2。但如果是一些简单的应用，比如一个只需要鉴别用户是否登录的APP，则可以简单地通过注解+拦截器的方式来实现。本文介绍了具体实现过程，虽基于Spring Boot实现，但稍作修改（主要是拦截器配置）就可以引入其它Spring MVC的项目。<br><a id="more"></a></p><h2 id="1-涉及的知识点"><a href="#1-涉及的知识点" class="headerlink" title="1. 涉及的知识点"></a>1. 涉及的知识点</h2><ol><li>注解：用来标记某个接口是否需要登录</li><li>拦截器：拦截所有请求，判断请求的接口是否需要登录验证（基于是否标记了注解），如果需要，验证相应的信息（token），通过则放行，否则返回错误信息</li><li>JWT： Json Web Token，一种流行的认证解决方案，它可以生成携带信息的token，但token一旦生成，其过期时间就不好更新，如果需要实现用户有操作就自动延长过期时间的场景，就相对比较麻烦。我们这里只用来生成token，过期通过redis实现</li><li>RedisTemplate： 将token存在redis中，通过redis的过期机制来控制token的有效期</li><li>ThreadLocal：可以将一次请求中多个环节需要访问的变量通过ThreadLocal来传递，比如userId</li></ol><h2 id="2-依赖配置"><a href="#2-依赖配置" class="headerlink" title="2. 依赖配置"></a>2. 依赖配置</h2><p>在pom.xml中添加JWT与redis依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jwt.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在application.yml配置文件中添加redis相关配置属性<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123654</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">    jedis:</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        min-idle:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        max-idle:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        max-active:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        max-wait:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure></p><h2 id="3-定义注解"><a href="#3-定义注解" class="headerlink" title="3. 定义注解"></a>3. 定义注解</h2><p>注解的定义你可以根据项目的具体场景，比如需要登录的接口比较多，就可以定义如 @SkipAuth 的注解来标记不需要登录的接口，反之，则可以定义如 @NeedAuth 的注解来标记需要登录的接口，总之就是让标记接口这个操作尽可能少。但也可以基于另一种考虑，万一需要登录的接口忘了加不就存在安全问题吗，所以用 @SkipAuth 相对要保险点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SkipAuth &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-定义token管理器"><a href="#4-定义token管理器" class="headerlink" title="4. 定义token管理器"></a>4. 定义token管理器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTokenManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成TOKEN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createToken</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用uuid作为源token</span></span><br><span class="line">        String token = Jwts.builder().setId(userId).setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">            .signWith(SignatureAlgorithm.HS256, JwtConstant.JWT_SECRET).compact();</span><br><span class="line">        <span class="comment">//存储到redis并设置过期时间</span></span><br><span class="line">        redisTemplate.boundValueOps(JwtConstant.AUTHORIZATION + <span class="string">":"</span> + userId)</span><br><span class="line">            .set(token, JwtConstant.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkToken</span><span class="params">(TokenModel model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = redisTemplate.boundValueOps(JwtConstant.AUTHORIZATION + <span class="string">":"</span> </span><br><span class="line">            + model.getUserId()).get();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> || !token.equals(model.getToken())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果验证成功，说明此用户进行了一次有效操作，延长token的过期时间</span></span><br><span class="line">        redisTemplate.boundValueOps(model.getUserId())</span><br><span class="line">            .expire(JwtConstant.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteToken</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        redisTemplate.delete(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在登录接口通过时，调用 <code>createToken</code> 创建token，并保存到redis中，设置过期时间， 在调用未被 @SkipAuth 注解标记的接口时，调用 <code>checkToken</code> 来验证，并更新token的过期时间， 退出登录时，删除token。</p><h2 id="5-定义拦截器"><a href="#5-定义拦截器" class="headerlink" title="5. 定义拦截器"></a>5. 定义拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTokenManager tokenManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                             HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String requestPath = request.getRequestURI().substring(request.getContextPath().length());</span><br><span class="line">        <span class="comment">// 如果不是映射到方法直接通过</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line">        <span class="comment">// 如果方法注明了 SkipAuth，则不需要登录token验证</span></span><br><span class="line">        <span class="keyword">if</span> (method.getAnnotation(SkipAuth.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从header中得到token</span></span><br><span class="line">        String authorization = request.getHeader(JwtConstant.AUTHORIZATION);</span><br><span class="line">        <span class="comment">// 验证token</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(authorization))&#123;</span><br><span class="line">            WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"未提供有效Token！"</span>), response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = Jwts.parser().setSigningKey(JwtConstant.JWT_SECRET)</span><br><span class="line">                .parseClaimsJws(authorization).getBody();</span><br><span class="line">            String userId = claims.getId();</span><br><span class="line">            TokenModel model = <span class="keyword">new</span> TokenModel(userId, authorization);</span><br><span class="line">            <span class="keyword">if</span> (tokenManager.checkToken(model)) &#123;</span><br><span class="line">                <span class="comment">// 通过ThreadLocal设置下游需要访问的值</span></span><br><span class="line">                AuthUtil.setUserId(model.getUserId());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"连接"</span> + requestPath + <span class="string">"拒绝"</span>);</span><br><span class="line">                WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"未提供有效Token！"</span>), response);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"连接"</span> + requestPath + <span class="string">"发生错误:"</span>, e);</span><br><span class="line">            WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"校验Token发生异常！"</span>), response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结束后清除，否则由于线程池复用，导致ThreadLocal的值被其他用户获取</span></span><br><span class="line">        AuthUtil.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器通过对请求方法是否标记注解 @SkipAuth 来判断是否需要进行token验证，如果验证通过，则从JWT token中解析出userId，通过AuthUtil工具方法保存到ThreadLocal中，供下游访问。在请求处理结束调用 <code>afterCompletion</code> 方法中，要清除掉ThreadLocal中的值，否则由于线程池的复用，导致被其他用户获取。</p><p>然后，注册拦截器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AuthInterceptor authInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthInterceptor</span><span class="params">(AuthInterceptor authInterceptor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authInterceptor = authInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注册鉴权拦截器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(authInterceptor)</span><br><span class="line">            .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">"/error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里将 /error 这个接口排除了，因为如果接口处理过程中出现异常，则spring boot会自动跳转到 /error 接口，又会进入拦截器校验（因为/error接口没有标注 @SkipAuth 注解）。</p><h2 id="6-验证"><a href="#6-验证" class="headerlink" title="6. 验证"></a>6. 验证</h2><p>通过以上几步，一个简单的接口认证功能就实现了，我们可以通过添加一个登录接口，两个测试接口（一个需要认证，一个不需要认证）来验证下。<br>登录接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SkipAuth</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">login</span><span class="params">(@RequestBody Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">    String username = MapUtils.getString(params, <span class="string">"username"</span>);</span><br><span class="line">    String password = MapUtils.getString(params, <span class="string">"password"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"ksxy"</span>.equals(username) &amp;&amp; <span class="string">"jboost"</span>.equals(password))&#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(tokenManager.createToken(username));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.failed(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>登录成功后，通过<code>createToken</code>方法创建了JWT token。<br>测试接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SkipAuth</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/skip-auth"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">skipAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ApiResponse.success(<span class="string">"不需要认证的接口调用"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/need-auth"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">needAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiResponse.success(<span class="string">"username: "</span> + AuthUtil.getUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>本文介绍了一个简单的接口认证方案，适用于不需要基于用户角色进行授权的场景。如果有较复杂的授权需求，则还是基于Shiro， Spring Security， OAuth2等框架来实现。这里也可以不用JWT，但是需要自己去做一些处理，比如将userId以某种形式包含在token中，解析时取出。<br>本文完整实例代码：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-simpleauth" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-simpleauth</a><br><br><br><img src="/assets/card-2.png" alt="微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般服务的安全包括认证（Authentication）与授权（Authorization）两部分，认证即证明一个用户是合法的用户，比如通过用户名密码的形式，授权则是控制某个用户可以访问哪些资源。比较成熟的框架有Shiro、Spring Security，如果要实现第三方授权模式，则可采用OAuth2。但如果是一些简单的应用，比如一个只需要鉴别用户是否登录的APP，则可以简单地通过注解+拦截器的方式来实现。本文介绍了具体实现过程，虽基于Spring Boot实现，但稍作修改（主要是拦截器配置）就可以引入其它Spring MVC的项目。&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>老被跨域问题烦？看看都有哪些处理方法</title>
    <link href="http://blog.jboost.cn/cors.html"/>
    <id>http://blog.jboost.cn/cors.html</id>
    <published>2019-07-30T04:56:24.000Z</published>
    <updated>2019-07-31T05:39:09.209Z</updated>
    
    <content type="html"><![CDATA[<p>前面写的《IT技术人员的自我修养》，没想到几天内收到了不少良好的反馈，在此也感谢大家的关注。往后会不定时分享一些技术、管理领域的工作经验总结与感悟，欢迎大家持续关注、交流。最近被问及一个跨域的问题，包括之前面试时发现很多面试者对跨域及其处理也是一知半解，故本文对该问题进行了梳理总结，以供参考。<br><a id="more"></a></p><h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1. 什么是跨域"></a>1. 什么是跨域</h2><p>理解什么是跨域，就要先了解一个叫“同源策略”的东西，什么是“同源策略”？这是浏览器为了网站访问安全，对来自不同源的请求做一些必要的访问限制的一种策略。那什么叫“同源”呢？我们知道，一个http请求地址一般包含四部分：<code>协议://域名:端口/路径</code>，所谓同源，就是前面三者，即协议、域名、端口都一样。举例说明，假如我们有一个地址 <code>http://blog.jboost.cn/docker-1.html</code>， 来看以下地址是否与它同源</p><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">是否同源</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://blog.jboost.cn/docker-1.html">https://blog.jboost.cn/docker-1.html</a></td><td style="text-align:center">不同源</td><td style="text-align:center">协议不同，一个http，一个https</td></tr><tr><td style="text-align:center"><a href="http://www.jboost.cn/docker-1.html" target="_blank" rel="noopener">http://www.jboost.cn/docker-1.html</a></td><td style="text-align:center">不同源</td><td style="text-align:center">域名不同</td></tr><tr><td style="text-align:center"><a href="http://blog.jboost.cn:8080/docker-1.html">http://blog.jboost.cn:8080/docker-1.html</a></td><td style="text-align:center">不同源</td><td style="text-align:center">端口不同，一个是默认端口80，一个是8080</td></tr><tr><td style="text-align:center"><a href="http://blog.jboost.cn/docker-2.html">http://blog.jboost.cn/docker-2.html</a></td><td style="text-align:center">同源</td><td style="text-align:center">虽然路径不同，但协议、域名、端口（默认80）都相同</td></tr></tbody></table><p>那么浏览器对不同源的请求做了哪些访问限制呢？共有三种限制</p><ol><li>对Cookie、LocalStorage，以及IndexDB（浏览器提供的类NoSQL的一个本地数据库）的访问</li><li>对DOM的访问</li><li>AJAX请求</li></ol><p>而跨域就是要打破这种访问限制，对不同源的资源请求也能顺利进行，最常见的就是AJAX请求，比如前后端分离架构中，两者服务域名不同，前端通过AJAX直接访问服务端接口，就会存在跨域问题。</p><h2 id="2-为什么会存在跨域"><a href="#2-为什么会存在跨域" class="headerlink" title="2. 为什么会存在跨域"></a>2. 为什么会存在跨域</h2><p>前面说“同源策略”时已经提到，浏览器是为了网站的访问安全，才设置了跨域这道屏障。那么前面所说的三种限制，分别都是如何来保障网站安全的。</p><ol><li>对本地存储Cookie、LocalStorage、IndexDB的访问限制<br>我们系统的登录凭证一般是通过在Cookie中设置 SESSIONID（如针对浏览器表单请求）或直接返回 token（如针对REST请求）的形式返回给客户端的，比如Tomcat是通过在Cookie中设置名为 JSESSIONID 的属性来保存的，而一般REST请求的token前端会存储于 LocalStorage 中，如果不存在访问限制，则你访问的其它网站可能就会获取到这些凭证，然后伪造你的身份来发起非法请求，这就太不安全了。</li><li>对DOM的访问限制<br>如果不对DOM进行访问限制，那么其它网站，尤其一些钓鱼网站，就可以通过 <code>&lt;iframe&gt;</code> 的形式拿到你访问网站的DOM，进而获取到你输入的一些敏感信息，比如用户名、密码…</li><li>对AJAX请求的限制<br>同源策略规定，AJAX请求只能发给同源的网址，否则就会报错。至于为什么要限制，一方面是避免1中所提到伪造非法请求，另一方面我理解是AJAX过于灵活，如果不做限制，可能网站的接口资源就会被其它网站随意使用，就像你的私有物品被别人招呼都不打任意拿去用一样。</li></ol><p>总之，同源策略是浏览器提供的最基本的一种安全保障机制或约定。</p><h2 id="3-怎么实现跨域访问"><a href="#3-怎么实现跨域访问" class="headerlink" title="3. 怎么实现跨域访问"></a>3. 怎么实现跨域访问</h2><p>我们平常遇到的跨域问题基本都出现在AJAX请求的场景，一般而言，可以通过代理、CORS、JSONP等方式来解决跨域问题。</p><h3 id="3-1-代理"><a href="#3-1-代理" class="headerlink" title="3.1 代理"></a>3.1 代理</h3><p>既然“同源策略”是浏览器端的机制，那我们就可以绕开浏览器，最常见的做法就是使用代理，如 Nginx，比如我们前端项目的域名是 <a href="http://blog.jboost.cn，服务端接口域名是" target="_blank" rel="noopener">http://blog.jboost.cn，服务端接口域名是</a> <a href="http://api.jboost.cn，我们在" target="_blank" rel="noopener">http://api.jboost.cn，我们在</a> Nginx 中提供如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    # 端口</span><br><span class="line">    listen 80;</span><br><span class="line">    # 域名</span><br><span class="line">    server_name blog.jboost.cn;</span><br><span class="line">    # 所有 http://blog.jboost.cn/api/xxx 请求都会被转发到 http://api.jboost.cn/api/xxx</span><br><span class="line">    location ^~ /api &#123;</span><br><span class="line">        proxy_pass http://api.jboost.cn;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则前端通过AJAX请求服务端接口 <a href="http://api.jboost.cn/api/xxx" target="_blank" rel="noopener">http://api.jboost.cn/api/xxx</a> 都可以改为通过 <a href="http://blog.jboost.cn/api/xxx">http://blog.jboost.cn/api/xxx</a> 来访问，从而避免不同源的跨域问题。</p><h3 id="3-2-CORS"><a href="#3-2-CORS" class="headerlink" title="3.2 CORS"></a>3.2 CORS</h3><p>CORS是Cross-Origin Resource Sharing的简写，即跨域资源共享，CORS需要服务端与浏览器同时支持，目前所有浏览器（除IE10以下）都支持CORS，因此，实现CORS，主要就是服务端的工作了。例如在Spring Boot中，我们可通过如下配置注册一个CorsFilter的过滤器来实现跨域支持。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;Servlet.class, CorsFilter.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CORSAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"corsFilterRegistrationBean"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line"></span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.applyPermitDefaultValues();</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(CorsConfiguration.ALL));</span><br><span class="line">        corsConfiguration.addExposedHeader(HttpHeaders.DATE);</span><br><span class="line"></span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line"></span><br><span class="line">        CorsFilter corsFilter = <span class="keyword">new</span> CorsFilter(corsConfigurationSource);</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(corsFilter);</span><br><span class="line">        filterRegistrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实质就是在响应消息的Header中添加几个属性，主要有</p><ul><li>Access-Control-Allow-Origin  必需，表示允许跨域的请求源，可以是具体的域名，也可以是 * ，表示任意域名</li><li>Access-Control-Allow-Methods 必需，表示允许跨域访问的HTTP方法，如GET、POST、PUT、DELETE等，可以是 * ，表示所有</li><li>Access-Control-Allow-Headers 如果请求包括 Access-Control-Request-Headers 头信息，则必需，表示服务器支持的所有头信息字段</li></ul><h3 id="3-3-JSONP"><a href="#3-3-JSONP" class="headerlink" title="3.3 JSONP"></a>3.3 JSONP</h3><p>JSONP是利用浏览器对JS一些标签（如 <code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>等）的 src 属性不具有同源策略限制的特性实现的，如前端添加<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://api.jboost.cn/hello?name=jboost&amp;callback=jsonpCallback"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>并且定义JS方法 <code>jsonpCallback</code>。服务端接口返回内容需要是JS方法<code>jsonpCallback</code>的调用格式，如<code>jsonpCallback({&quot;name&quot;:&quot;jboost&quot;})</code>，这样在<code>jsonpCallback</code>方法中就可以获取服务端实际返回的结果数据<code>{&quot;name&quot;:&quot;jboost&quot;}</code>了。<br>JSONP方式的局限性也很明显，一是只支持GET请求——你没见过哪些<code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>标签是POST请求吧，二是需要对服务端返回数据格式做处理。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>三种跨域支持的实现，代理方式最简单，对客户端、服务端都不具有侵入性，但如果需要支持的请求源比较多，或者是与第三方对接的话，代理方式就不太适用了。CORS相对来说是一种标准的处理方式，并且通过过滤器的方式对业务代码也没有任何侵入性。而JSONP方式局限性较大，只支持GET，并且需要服务端做返回数据格式的支持。可针对具体情况选择适用的方式。</p><p><br><br><img src="/assets/card-2.png" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面写的《IT技术人员的自我修养》，没想到几天内收到了不少良好的反馈，在此也感谢大家的关注。往后会不定时分享一些技术、管理领域的工作经验总结与感悟，欢迎大家持续关注、交流。最近被问及一个跨域的问题，包括之前面试时发现很多面试者对跨域及其处理也是一知半解，故本文对该问题进行了梳理总结，以供参考。&lt;br&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="web" scheme="http://blog.jboost.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot从入门到实战（十）：异步处理</title>
    <link href="http://blog.jboost.cn/springboot-async.html"/>
    <id>http://blog.jboost.cn/springboot-async.html</id>
    <published>2019-07-22T10:25:49.000Z</published>
    <updated>2019-07-24T01:52:03.885Z</updated>
    
    <content type="html"><![CDATA[<p>在业务开发中，有时候会遇到一些非核心的附加功能，比如短信或微信模板消息通知，或者一些耗时比较久，但主流程不需要立即获得其结果反馈的操作，比如保存图片、同步数据到其它合作方等等。如果将这些操作都置于主流程中同步处理，势必会对核心流程的性能造成影响，甚至由于第三方服务的问题导致自身服务不可用。这时候就应该将这些操作异步化，以提高主流程的性能，并与第三方解耦，提高主流程的可用性。<br><a id="more"></a></p><p>在Spring Boot中，或者说在Spring中，我们实现异步处理一般有以下几种方式：</p><p><strong>1. 通过 @EnableAsync 与 @Asyc 注解结合实现</strong><br><strong>2. 通过异步事件实现</strong><br><strong>3. 通过消息队列实现</strong></p><h2 id="1-基于注解实现"><a href="#1-基于注解实现" class="headerlink" title="1. 基于注解实现"></a>1. 基于注解实现</h2><p>我们以前在Spring中提供异步支持一般是在配置文件 applicationContext.xml 中添加类似如下配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"executor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"executor"</span> <span class="attr">pool-size</span>=<span class="string">"10-200"</span> <span class="attr">queue-capacity</span>=<span class="string">"2000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>Spring的 @EnableAsync 注解的功能与<code>&lt;task:annotation-driven/&gt;</code>类似，将其添加于一个 @Configuration 配置类上，可对Spring应用的上下文开启异步方法支持。 @Async 注解可以标注在方法或类上，表示某个方法或某个类里的所有方法需要通过异步方式来调用。</p><p>我们以一个demo来示例具体用法，demo地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-async" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-async</a></p><ol><li>添加 @EnableAsync 注解</li></ol><p>在一个 @Configuration 配置类上添加 @EnableAysnc 注解，我们一般可以添加到启动类上，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>配置相关的异步执行线程池</li></ol><p>可通过配置类的方式对异步线程池进行配置，并提供异步执行时出现异常的处理方法，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.corePoolSize:10&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.maxPoolSize:200&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.queueCapacity:2000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.keepAlive:5&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAlive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        executor.setKeepAliveSeconds(keepAlive);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"async-"</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.setDaemon(<span class="keyword">false</span>); <span class="comment">//以用户线程模式运行</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAsyncUncaughtExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">AsyncUncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable throwable, Method method, Object... objects)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch exception when invoke "</span> + method.getName());</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们通过实现 AsyncConfigurer 接口提供了一个异步执行线程池对象，各参数的说明可以参考【<a href="/threadpool.html">线程池的基本原理，看完就懂了</a>】，里面有很详细的介绍。且通过实现   AsyncUncaughtExceptionHandler 接口提供了一个异步执行过程中未捕获异常的处理类。</p><ol start="3"><li>定义异步方法</li></ol><p>异步方法的定义只需要在类（类上注解表示该类的所有方法都异步执行）或方法上添加 @Async 注解即可，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethodWithException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"exception in async method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>测试</li></ol><p>我们可以通过如下测试类来对异步方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBasedAsyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        asyncService.asyncMethod();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAysncWithException</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        asyncService.asyncMethodWithException();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为异步方法在一个新的线程中执行，可能在主线程执行完后还没来得及处理，所以通过sleep来等待它执行完成。具体执行结果读者可自行尝试运行，这里就不贴图了。</p><h2 id="2-基于事件实现"><a href="#2-基于事件实现" class="headerlink" title="2. 基于事件实现"></a>2. 基于事件实现</h2><p>第二种方式是通过Spring框架的事件监听机制实现，但Spring的事件监听默认是同步执行的，所以实际上还是需要借助 @EnableAsync 与 @Async 来实现异步。</p><ol><li>添加 @EnableAsync 注解</li></ol><p>与上同，可添加到启动类上。</p><ol start="2"><li><p>自定义事件类<br>通过继承 ApplicationEvent 来自定义一个事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String arg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source, String arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.arg = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义事件处理类<br>支持两种形式，一是通过实现 ApplicationListener 接口，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"2. arg value: "</span> + event.getArg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>二是通过 @EventListener 注解，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(MyEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"3. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"3. arg value: "</span> + event.getArg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意两者都需要添加 @Async 注解，否则默认是同步方式执行。</p><ol start="4"><li><p>定义事件发送类<br>可以通过实现 ApplicationEventPublisherAware 接口来使用 ApplicationEventPublisher 的 publishEvent()方法发送事件，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p>可以通过如下测试类来进行测试，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBasedAsyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyEventPublisher myEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        myEventPublisher.publishEvent(<span class="keyword">new</span> MyEvent(<span class="keyword">this</span>,<span class="string">"testing event based async"</span>));</span><br><span class="line">        Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后发现两个事件处理类都执行了，因为两者都监听了同一个事件 MyEvent 。</p><h2 id="3-基于消息队列实现"><a href="#3-基于消息队列实现" class="headerlink" title="3. 基于消息队列实现"></a>3. 基于消息队列实现</h2><p>以上两种方式都是基于服务器本机运行，如果服务进程出现异常退出，可能导致异步执行中断。如果需要保证任务执行的可靠性，可以借助消息队列的持久化与重试机制。阿里云上的消息队列服务提供了几种类型的消息支持，如顺序消息、定时/延时消息、事务消息等（详情可参考：<a href="https://help.aliyun.com/document_detail/29532.html?spm=5176.234368.1278132.btn4.6f43db25Rn8oey" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/29532.html?spm=5176.234368.1278132.btn4.6f43db25Rn8oey</a> ），如果项目是基于阿里云部署的，可以考虑使用其中一类消息服务来实现业务需求。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文对spring boot下异步处理的几种方法进行了介绍，如果对任务执行的可靠性要求不高，则推荐使用第一种方式，如果可靠性要求较高，则推荐使用自建消息队列或云消息队列服务的方式。<br>本文demo源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-async/src/main/java/cn/jboost/async" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-async/src/main/java/cn/jboost/async</a><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在业务开发中，有时候会遇到一些非核心的附加功能，比如短信或微信模板消息通知，或者一些耗时比较久，但主流程不需要立即获得其结果反馈的操作，比如保存图片、同步数据到其它合作方等等。如果将这些操作都置于主流程中同步处理，势必会对核心流程的性能造成影响，甚至由于第三方服务的问题导致自身服务不可用。这时候就应该将这些操作异步化，以提高主流程的性能，并与第三方解耦，提高主流程的可用性。&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.jboost.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://blog.jboost.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://blog.jboost.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（六）：容器管理</title>
    <link href="http://blog.jboost.cn/docker-6.html"/>
    <id>http://blog.jboost.cn/docker-6.html</id>
    <published>2019-07-21T03:04:16.000Z</published>
    <updated>2019-07-22T10:24:14.304Z</updated>
    
    <content type="html"><![CDATA[<p>容器是Docker中的另一核心概念，在Docker中，应用的运行都是在容器内进行的，容器则基于镜像创建。前面已对Docker镜像做了基本介绍，本文对Docker容器管理的相关内容做一个梳理。<br><a id="more"></a></p><h2 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1. 启动容器"></a>1. 启动容器</h2><p>启动容器的命令格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE-NAME [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure></p><p>其中OPTIONS部分可指定容器运行的一些可选项，常用选项包括：</p><ul><li>-d 将容器以后台进程（daemon）的形式运行</li><li>-p 指定容器内应用暴露端口与主机端口的映射，如 -p 8080:80 表示将容器内80端口映射到主机的8080端口（主机端口在前，容器端口在后）</li><li>-v 指定容器与主机的挂载目录映射，如 -v /var/log:/log 表示将容器的/log目录挂载到主机的/var/log目录（同样主机目录在前，容器目录在后），后续对容器的/log写操作实际作用于主机的/var/log目录</li><li>-e 为容器设置环境变量</li><li>-t 为容器启动一个伪终端（pseudo-tty）</li><li>-i 让容器的标准输入保持打开，一般与 -t 配合使用，让容器启动后就打开一个可交互的命令行界面</li><li>-w 指定容器的工作目录</li></ul><p>COMMAND [ARG..] 部分就是容器需要运行的应用进程启动命令与参数，如果镜像中有通过 CMD， 或 ENTRYPOINT 指定了容器启动程序，则可省略。另外可通过 –name 指定容器的名称，以及 –restart 来指定重启策略，–restart有三种取值，代表容器支持的三种不同的重启策略</p><table><thead><tr><th style="text-align:center">取值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:left">除非被<code>docker stop</code>命令明确停止，否则一直尝试重启处于停止态的容器；如果Docker重启，也会自动启动容器</td></tr><tr><td style="text-align:center">unless-stopped</td><td style="text-align:left">与always的区别是，停止态的容器不在Docker重启的时候被重启</td></tr><tr><td style="text-align:center">on-failed</td><td style="text-align:left">在容器退出时返回值不为0的时候，重启容器；如果Docker重启，容器也会被启动，不管之前是否处于停止状态</td></tr></tbody></table><p>以启动一个mysql数据库服务为例<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name mysql \</span><br><span class="line"> -v /home/devuser/apps/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf \</span><br><span class="line"> -v /home/devuser/apps/mysql/logs:/var/log/mysql \</span><br><span class="line"> -v /home/devuser/apps/mysql/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=Passw0rd --restart=always mysql:5.7</span><br></pre></td></tr></table></figure></p><p>上述命令启动了一个mysql容器服务，-d 表示以后台进程运行，执行命令后只返回一个容器ID，不会输出任何其它信息；-p 将容器暴露的端口3306映射到宿主机的3306端口，外部主机就可以通过宿主机IP与3306端口来访问mysql服务； –name 指定了容器名称为mysql； -v 将mysql的配置文件路径、日志路径、数据存储路径映射到了宿主机对应的路径目录；-e 设置了一个环节变量指定mysql root账号的密码；–restart 指定容器在异常退出时，包括Docker重启时，自动启动容器。</p><p>我们前面有提过，当我们执行CLI命令时，实际上是客户端（Docker Client）通过发送请求到Docker后台进程（Docker Daemon），由Docker后台进程来执行的，那么当我们执行上述<code>docker run</code>命令的时候，Docker后台进程具体都干了些啥呢？一般来说，包括如下几个操作步骤</p><ol><li>检测本地是否存在指定的镜像，如果不存在，就从公共仓库下载</li><li>利用镜像创建一个容器，并启动它</li><li>分配一个文件系统，并在只读的镜像层上面挂载一层可读写层（容器存储层）</li><li>从宿主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行应用程序完毕后容器被终止 </li></ol><h2 id="2-管理已有容器"><a href="#2-管理已有容器" class="headerlink" title="2. 管理已有容器"></a>2. 管理已有容器</h2><p>一般对已有容器的管理包括如下几个操作：</p><ol><li>查看运行中的容器 <code>docker ps</code> 或 <code>docker container ls</code></li><li>查看所有容器 <code>docker ps -a</code> 或 <code>docker container ls -a</code></li><li>停止运行 <code>docker stop xxx</code></li><li>开始停止状态的容器 <code>docker start xxx</code></li><li>重启运行状态的容器 <code>docker restart xxx</code></li><li>删除停止状态的容器 <code>docker rm xxx</code></li><li>强制删除容器（包括运行状态中） <code>docker rm -f xxx</code></li><li>删除所有停止状态的容器 <code>docker container prune</code></li></ol><p>其中xxx既可以是容器ID（短ID即可，只要与其它区分开来），也可以是容器名称。<br><code>docker rm</code>之前必须要先<code>docker stop</code>将容器置为停止状态，而<code>docker rm -f</code>可以强制删除运行状态的容器，其背后是通过Linux/POSIX信号来实现的，<code>docker rm -f</code>命令直接发出<code>SIGKILL</code>信号，不会给容器内运行进程任何缓冲的时间，立即终止，而<code>docker stop</code>命令却是先发送<code>SIGTERM</code>信号，通知容器进程结束，会为进程预留一个清理并优雅停止的机会，如果一段时间后进程还没有终止，那么就会发送<code>SIGKILL</code>信号，来终止进程的运行。</p><p>我们也可以像镜像操作中一样，组合使用命令来更方便地操作，如强制删除所有容器（慎用）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure></p><h2 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3. 进入容器"></a>3. 进入容器</h2><p>容器在运行时指定 -d 选项时， 是以后台进程的形式运行的，如果我们需要进入容器查看或操作，可以通过<code>docker exec</code>命令，<code>docker exec</code>命令的格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] container-id COMMAND</span><br></pre></td></tr></table></figure></p><p>OPTIONS常用的一般是 -t， -i，意义跟在<code>docker run</code>选项中一样 —— 为容器启动一个伪终端（pseudo-tty），并保持标准输入打开，从而可以像Linux命令行一样进行交互， COMMAND一般为 <code>bash</code>。</p><p>另外还有一个命令是<code>docker attach xxx</code>，其中xxx是容器ID，但推荐使用<code>docker exec</code>，因为<code>docker attach</code>中当执行<code>exit</code>退出容器时，容器也会随之终止，但<code>docker exec</code>则不会。</p><p>如果不进入容器，也可以通过<code>docker logs xxx</code>，xxx是容器ID，来查看容器的输出信息。</p><h2 id="4-导入导出容器"><a href="#4-导入导出容器" class="headerlink" title="4. 导入导出容器"></a>4. 导入导出容器</h2><p>可以使用<code>docker export</code>命令将一个容器的快照进行导出，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export xxx &gt; mycontainer.tar</span><br></pre></td></tr></table></figure></p><p>其中xxx是容器ID，可以通过<code>docker ps -a</code>查看，上述命令将容器的当前快照导出到了本地文件。</p><p><code>docker import</code>命令则可以将一个容器快照文件导入为镜像，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat mycontainer.tar | docker import - test/myimage:v1.0</span><br></pre></td></tr></table></figure></p><p>可以通过URL来导入，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import http://test.com/testimage.tgz test/myimage2:v1.0</span><br></pre></td></tr></table></figure></p><p>由此可见，我们获取镜像又多了一个来源——从已有容器快照文件导入。 </p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文对容器的一些基本操作进行了介绍，需要注意的是如之前所说，容器应以无状态的形式运行，所有产生的数据应该通过挂载数据卷的方式写入宿主机文件目录，避免容器销毁时造成数据丢失；尽量使用<code>docker stop</code> + <code>docker rm</code>的方式来替代<code>docker rm -f</code>，使容器内运行程序“优雅”地退出。有时候可能遇到这样的场景，容器创建运行后，我们需要对运行的一些参数进行更新或添加，这时候该怎么操作。后文会对该场景进行介绍，欢迎关注。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器是Docker中的另一核心概念，在Docker中，应用的运行都是在容器内进行的，容器则基于镜像创建。前面已对Docker镜像做了基本介绍，本文对Docker容器管理的相关内容做一个梳理。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（五）：整一个自己的镜像</title>
    <link href="http://blog.jboost.cn/docker-5.html"/>
    <id>http://blog.jboost.cn/docker-5.html</id>
    <published>2019-07-17T08:32:35.000Z</published>
    <updated>2019-07-24T01:51:09.675Z</updated>
    
    <content type="html"><![CDATA[<p>获取镜像的途径有两个，一是从镜像仓库获取，如官方的Docker Hub，二是自定义。上文已经介绍如何从镜像仓库获取镜像，本文基于一个Springboot项目，来介绍自定义一个镜像的基本流程。<br><a id="more"></a></p><h2 id="1-定制镜像的本质"><a href="#1-定制镜像的本质" class="headerlink" title="1. 定制镜像的本质"></a>1. 定制镜像的本质</h2><p>我们知道镜像是分层存储的，镜像的构建也是一层一层进行的，一层构建完后，就变为只读，在其上再构建下一层。因此定制镜像，实际上就是定义每一层要干的事，比如执行某个命令，设置一个环境变量，声明一个暴露端口等等。然后在构建时，按照各层的定义，一层一层地完成构建，最终形成一个包含这些层的镜像。</p><h2 id="2-Dockerfile文件"><a href="#2-Dockerfile文件" class="headerlink" title="2. Dockerfile文件"></a>2. Dockerfile文件</h2><p>Docker中定义各层要干的事的文件叫Dockerfile，它是一个文本文件，包含了一条条的指令，每一条指令对应一层镜像，指令的内容就描述了这一层该如何构建。如下示例了一个非常简单的Dockerfile，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello jboost!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>我们定制镜像，必须要以某一个镜像为基础，在其上构建自己需要的层，如上示例中，我们是以nginx镜像为基础，然后在第二层定制了我们自己的内容——修改index.html的内容为<code>&lt;h1&gt;Hello jboost!&lt;/h1&gt;</code>，这样运行容器打开nginx主页时就不会显示默认的页面内容了。</p><p>上面示例中接触了Dockerfile的两个指令</p><ul><li>FROM：FROM指令指定基础镜像，每一个定制镜像必须要有一个基础镜像，所以必须要有一条FROM指令，并且是Dockerfile的第一条指令</li><li>RUN：RUN指令指定需要执行的命令，后面接的命令就像是shell脚本一样可执行</li></ul><p>Dockerfile还提供了许多其它指令，后续我们再集中介绍，本文只对接触到的指令做简单说明。</p><h2 id="3-自定义一个镜像"><a href="#3-自定义一个镜像" class="headerlink" title="3. 自定义一个镜像"></a>3. 自定义一个镜像</h2><p>这部分以一个Springboot项目为基础，介绍自定义一个镜像涉及的基本环节。项目地址为：<a href="https://github.com/ronwxy/swagger-register" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-register</a> ，该项目是一个Swagger API文档注册服务，其它项目可将Swagger API信息注册到该服务，进行统一查看与管理。</p><h3 id="3-1-定义Dockerfile文件"><a href="#3-1-定义Dockerfile文件" class="headerlink" title="3.1 定义Dockerfile文件"></a>3.1 定义Dockerfile文件</h3><p>首先，我们在项目的根目录下创建一个Dockerfile文件（文件名就叫Dockerfile），其内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">ENV PROFILE=dev</span><br><span class="line">RUN mkdir /app /logs</span><br><span class="line">COPY ./target/swagger-register-1.0.0-SNAPSHOT.jar /app/app.jar</span><br><span class="line">WORKDIR /app</span><br><span class="line">VOLUME /register-data</span><br><span class="line">EXPOSE 11090</span><br><span class="line">CMD [&quot;java&quot;, &quot;-Dspring.profiles.active=$&#123;PROFILE&#125;&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]</span><br></pre></td></tr></table></figure></p><p>从上往下依次介绍如下</p><ul><li>第一行：FORM openjdk:8-jdk-alpine， 表示以<code>openjdk:8-jdk-alpine</code>这个镜像为基础镜像，因为这是一个Springboot项目所以必须要有jdk支持，我们在定制镜像时，可以找一个最适合的镜像作为基础镜像。</li><li>第二行：ENV PROFILE=dev， 定义了一个环境变量，这个环境变量可以在后面被引用</li><li>第三行：RUN mkdir /app /logs，通过mkdir命令创建了两个目录，用来保存jar执行文件及日志</li><li>第四行：COPY ./target/swagger-register-1.0.0-SNAPSHOT.jar /app/app.jar 将target目录下的jar包复制到/app目录下，并且进行重命名</li><li>第五行：WORKDIR /app， 指定工作目录为/app，后面各层的当前目录就是指定的工作目录</li><li>第六行：VOLUME /register-data， 定义一个匿名数据卷，前面说过写操作不要直接在容器内进行，而要改为写挂载的数据卷目录，这个定义可在运行容器时通过 -v 来覆盖。</li><li>第七行：EXPOSE 11090， 声明了运行容器时提供的服务端口，也仅仅是个声明而已，只是告诉使用的人要映射这个端口，通过 -p 可映射端口。</li><li>第八行：CMD [“java”, “-Dspring.profiles.active=${PROFILE}”, “-jar”, “app.jar”]， 指定了容器启动命令，因为是一个Springboot项目，所以就是一个java -jar的执行命令，容器启动的时候就会执行该命令来运行Springboot服务，这里引用了第二行定义的环境变量PROFILE</li></ul><h3 id="3-2-配置maven插件"><a href="#3-2-配置maven插件" class="headerlink" title="3.2 配置maven插件"></a>3.2 配置maven插件</h3><p>定义好Dockerfile后，为了方便构建镜像，我们可以借助maven的dockerfile插件<code>dockerfile-maven-plugin</code>，在pom.xml的build部分加入配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>repository指定了镜像的名称，<code>docker.image.prefix</code>需要properties部分进行定义，我这里是<code>springboot</code>。</p><h3 id="3-3-构建镜像"><a href="#3-3-构建镜像" class="headerlink" title="3.3 构建镜像"></a>3.3 构建镜像</h3><p>下载源码：<a href="https://github.com/ronwxy/swagger-register.git" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-register.git</a> ，然后在项目的根目录下执行如下命令(前提是本地已经装好了docker与maven及jdk)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true dockerfile:build</span><br></pre></td></tr></table></figure></p><p>该命令首先会执行<code>mvn clean package -Dmaven.test.skip=true</code>对项目进行打包，生成./target/swagger-register-1.0.0-SNAPSHOT.jar文件，然后基于当前目录下的Dockerfile文件进行构建，如下图所示<br><img src="/assets/docker-build.png" alt="docker-build"></p><p>由上图可看出，该镜像构建分八步(对应Dockerfile的八行指令)，每一步生成一个镜像层，每一层都有唯一的ID。由图中也可以看出，除了COPY之类的命令外，每一层的构建实际上是先基于上一层启动一个容器，然后执行该层定义的操作，再移除这个容器来实现的，如第八步中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Step 8/8 : CMD ["java", "-Dspring.profiles.active=$&#123;PROFILE&#125;", "-jar", "app.jar"]</span><br><span class="line">[INFO] </span><br><span class="line">[INFO]  ---&gt; Running in f4acd0b53bca</span><br><span class="line">[INFO] Removing intermediate container f4acd0b53bca</span><br><span class="line">[INFO]  ---&gt; a9ee579f2d62</span><br></pre></td></tr></table></figure></p><p>先启动一个ID为f4acd0b53bca的容器，在其中执行CMD所定义的命令，然后再移除容器f4acd0b53bca，最后生成ID为a9ee579f2d62的镜像。</p><p>构建完后，我们就可以在本地镜像中通过<code>docker iamges</code>看到我们定制的镜像了，如图<br><img src="/assets/docker-image.png" alt="docker-image"></p><p>图中springboot/swagger-register镜像即为我们刚刚构建好的定制镜像。</p><h3 id="3-4-启动容器"><a href="#3-4-启动容器" class="headerlink" title="3.4 启动容器"></a>3.4 启动容器</h3><p>我们可以通过以下命令来启动一个刚才定制镜像的容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name swagger-register -p 11090:11090 -v /home/jenkins/swagger-register/register-data:/register-data -v /home/jenkins/swagger-register/logs:/logs --restart=always springboot/swagger-register:latest</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>-d 表示以后台进程方式运行</li><li>–name 指定容器名称</li><li>-p 指定端口映射，左边为宿主机端口，右边为容器服务端口</li><li>-v 指定数据卷挂载，左边为宿主机目录，右边为容器目录</li><li>–restart=always 表示在docker启动时自动启动该容器</li></ul><p>关于容器相关的内容后面详细介绍，这里不展开说明了。启动容器后， 我们就可以浏览器打开地址 http://宿主机ip:11090/doc.html 来访问服务了（打开页面后内容是空的，因为没有任何服务注册Swagger API， 相关内容可参考 <a href="/swagger-register.html">swagger api文档集中化注册管理</a>）</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文介绍了一个基于Springboot项目的Docker镜像定制及使用过程，对镜像的构建过程，及Dockerfile的基本指令以及容器的运行做了基本介绍。后续会对Dockerfile的其它指令及Dockerfile的一些最佳实践进行更为详细的介绍，欢迎关注。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;获取镜像的途径有两个，一是从镜像仓库获取，如官方的Docker Hub，二是自定义。上文已经介绍如何从镜像仓库获取镜像，本文基于一个Springboot项目，来介绍自定义一个镜像的基本流程。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（四）：Docker镜像管理</title>
    <link href="http://blog.jboost.cn/docker-4.html"/>
    <id>http://blog.jboost.cn/docker-4.html</id>
    <published>2019-07-16T13:22:11.000Z</published>
    <updated>2019-07-24T01:51:02.477Z</updated>
    
    <content type="html"><![CDATA[<p>在Docker中，应用是通过容器来运行的，而容器的运行是基于镜像的，类似面向对象设计中类与对象的关系——没有类的定义就谈不上实例的创建与使用，没有镜像的定义就谈不上容器的创建与运行。<br><a id="more"></a></p><h2 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h2><p>镜像从哪里来，一般两个途径，一是公共镜像库，如官方镜像库Docker Hub，上面有大量的高质量的镜像直接可拿来用；二是自定义，我们可基于一个已有镜像，在其基础上增加一些层（还记得镜像的分层存储特性吧），然后构建形成自己的镜像。</p><p>如果我们知道某个镜像的名称，则可直接通过<code>docker pull</code>来下载镜像到本地，如ubuntu、redis、nginx等，<code>docker pull</code>命令的格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry的地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure></p><p>其中选项可设置：</p><ul><li>-a, –all-tags：下载仓库中所有标签（一般指版本）的镜像</li><li>–disable-content-trust：跳过镜像验证，默认为true</li></ul><p>Docker Registry的地址即镜像仓库地址，一般为域名或IP加端口号，如果不指定则默认为Docker Hub；仓库名包含两部分，&lt;用户名&gt;/&lt;软件名&gt;，对于Docker Hub，如果不给出用户名，则默认为library，表示官方提供；标签一般是对应软件的版本号，如果不指定则默认为latest。</p><p>比如我们要下一个nginx镜像，则可执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker pull nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">fc7181108d40: Already exists </span><br><span class="line">d2e987ca2267: Pull complete </span><br><span class="line">0b760b431b11: Pull complete </span><br><span class="line">Digest: sha256:48cbeee0cb0a3b5e885e36222f969e0a2f41819a68e07aeb6631ca7cb356fed1</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br></pre></td></tr></table></figure><p>这里我们没有指定选项，也没有指定镜像仓库地址，那么默认会从Docker Hub获取镜像（但Docker Hub由于在国外，速度比较慢，所以一般要设置国内加速器，参考<a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a>第二部分：配置国内镜像)，也没有给出用户名，所以默认是library（第三行），没有指定标签，所以默认是latest（第二行），由第四至第六行可见，这个镜像包含三个层，并且第一个层已经存在了（之前下载的镜像已经包含了这个层， 直接复用），镜像分层的概念及层的复用，应该已经理解了。</p><p>如果我们不知道镜像的完整名称怎么办，那就搜索一下，有两个途径，一是通过命令，假设我们记不起nginx全称了， 只记得<code>ngi</code>，则可通过如下命令搜索<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker search ngi</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                             Official build of Nginx.                        11693               [OK]                </span><br><span class="line">jwilder/nginx-proxy               Automated Nginx reverse proxy for docker con…   1628                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm           Container running Nginx + PHP-FPM capable of…   726                                     [OK]</span><br><span class="line">bitnami/nginx                     Bitnami nginx Docker Image                      69                                      [OK]</span><br><span class="line">linuxserver/nginx                 An Nginx container, brought to you by LinuxS…   69                                      </span><br><span class="line">tiangolo/nginx-rtmp               Docker image with Nginx using the nginx-rtmp…   48                                      [OK]</span><br><span class="line">nginx/nginx-ingress               NGINX Ingress Controller for Kubernetes         20                                      </span><br><span class="line">nginxdemos/hello                  NGINX webserver that serves a simple page co…   18                                      [OK]</span><br><span class="line">jlesage/nginx-proxy-manager       Docker container for Nginx Proxy Manager        17                                      [OK]</span><br><span class="line">schmunk42/nginx-redirect          A very simple container to redirect HTTP tra…   17                                      [OK]</span><br><span class="line">crunchgeek/nginx-pagespeed        Nginx with PageSpeed + GEO IP + VTS + more_s…   13                                      </span><br><span class="line">blacklabelops/nginx               Dockerized Nginx Reverse Proxy Server.          12                                      [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>该命令会从Docker Hub搜索镜像名包含<code>ngi</code>的镜像，其中STARS表示收藏用户数，OFFICIAL为[OK]表示官方提供的镜像，AUTOMATED [OK]表示由自动构建生成，一般选择STARS最多，官方提供的镜像。<br>这种方式获取到的信息有限，比如具体包含哪些版本不知道。还有一个途径是直接在Docker Hub网站上搜索，打开 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> ， 在搜索框输入<code>ngi</code>，如下图<br><img src="/assets/docker-hub.png" alt="docker-hub"></p><p>则会列出所有满足条件的镜像，点开<code>nginx</code>结果链接，可以看到提供的版本（通过版本链接可以查看定义对应镜像的Dockerfile），及相应的文档说明。这种方式获取的信息更加全面，所以推荐这种方式！</p><p>另外，当我们没有执行<code>docker pull</code>，直接通过<code>docker run xx</code>来运行一个容器时，如果没有对应的镜像，则会先自动下载镜像，再基于镜像启动一个容器，比如我们在<a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a>中检验docker是否安装成功时运行的<code>hello-world</code><br><img src="/assets/hello-docker.png" alt="hello-docker"></p><h2 id="2-管理本地镜像"><a href="#2-管理本地镜像" class="headerlink" title="2. 管理本地镜像"></a>2. 管理本地镜像</h2><p>将镜像下载到本地后，我们可以基于镜像来创建、运行容器，及对镜像进行管理。</p><p><strong>查看本地镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              f68d6e55e065        2 weeks ago         109MB</span><br><span class="line">mysql               latest              c7109f74d339        5 weeks ago         443MB</span><br><span class="line">hello-world         latest              fce289e99eb9        6 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>上面各列依次列出了镜像名称、标签（版本）、镜像ID、创建时间、镜像大小。镜像可以拥有多个标签（版本）。镜像的大小总和一般要大于实际的磁盘占有量，为什么？回忆一下镜像的分层存储概念，层是可以复用的，某个层其中一个镜像有了，另一个镜像就不会再下载了。口说无凭，我们来验证下，<code>docker system df</code>可列出镜像、容器、数据卷所占用的空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              3                   1                   497.1MB             497.1MB (99%)</span><br><span class="line">Containers          1                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><p>通过<code>docker image ls</code>列出的各镜像大小总共约552MB，但这里列出的镜像大小只有约497MB，这下有凭有据了吧。</p><p><strong>根据条件列出镜像</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image ls nginx # 根据名称列出镜像</span><br><span class="line">docker image ls nginx:latest # 根据名称与标签列出镜像</span><br><span class="line">docker image ls -f since=hello-world:latest # -f 是--filter的缩写，过滤器参数，列出在hello-world:latest之后建立的镜像，before=hello-world:latest则查看之前建立的镜像</span><br></pre></td></tr></table></figure></p><p><strong>指定显示格式</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -q # 只显示镜像ID</span><br><span class="line">docker image ls --digests # 列出镜像摘要</span><br><span class="line"></span><br><span class="line">docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"  # 使用Go的模板语法格式化显示，这里显示格式为 镜像ID：镜像名称</span><br><span class="line">docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;" # 自己定义表格格式</span><br></pre></td></tr></table></figure></p><p><strong>虚悬镜像</strong><br>有时候会看到某些镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。这些镜像原本是有镜像名和标签的，随着官方镜像维护，发布了新版本后(新版本会复用之前的镜像名称与标签，一般是bug修复版)，重新<code>docker pull xx</code> 时， 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了<code>&lt;none&gt;</code> 。除了<code>docker pull</code>可能导致这种情况， <code>docker build</code>也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像被称为虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -f dangling=true</span><br></pre></td></tr></table></figure></p><p>一般虚悬镜像没什么意义了，可以通过如下命令删除<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure></p><p><strong>中间层镜像</strong><br>为了加速镜像构建、重复利用资源，Docker会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的<code>docker image ls</code>列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，可以加 -a<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls -a</span></span><br></pre></td></tr></table></figure></p><p>这样会看到很多无标签的镜像，与虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><p><strong>删除镜像</strong><br>删除镜像命令格式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure></p><p>选项可以设置：</p><ul><li>-f, –force  强制删除镜像</li><li>–no-prune   不删除没有标签的父镜像</li></ul><p>&lt;镜像1&gt;、&lt;镜像2&gt; 等可以是镜像的名称，镜像的全ID，也可以是镜像ID的前面几个数字（只要与其它镜像区分开来就行），或者是镜像摘要。 如删除镜像名称为mysql的镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker image rm mysql</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:415ac63da0ae6725d5aefc9669a1c02f39a00c574fdbc478dfd08db1e97c8f1b</span><br><span class="line">Deleted: sha256:c7109f74d339896c8e1a7526224f10a3197e7baf674ff03acbab387aa027882a</span><br><span class="line">Deleted: sha256:35d60530f024aa75c91a123a69099f7f6eaf5ad7001bb983f427f674980d8482</span><br><span class="line">Deleted: sha256:49d8bb533eee600076e3a513a203ee24044673fcef0c1b79e088b2ba43db2c17</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>由上面命令的执行结果可见，删除镜像包括另个行为：Untagged、Deleted。</p><p>当我们使用上面命令来删除镜像的时候，实际上是在要求删除某个/某些标签的镜像。所以首先需要做的是将满足要求的所有镜像标签都取消，这就是Untagged的行为。一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么Delete行为就不会发生，仅仅是取消了这个镜像的符合要求的所有标签。所以并非所有的<code>docker image rm</code>都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能就失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。如果某个其它镜像正依赖于当前镜像的某一层，这种情况，依旧不会触发删除该层的行为。直到没有任何镜像依赖当前层时，才会真实的删除当前层。</p><p>另外还需要注意是容器对镜像的依赖。如果基于镜像启动的容器存在（即使容器没有运行处于停止状态） ，同样不可以删除这个镜像。我们之前说了容器是以镜像为基础，再加一层容器存储层组成的多层存储结构去运行的。所以如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。 </p><p><strong>通过组合命令来删除</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q nginx) # 删除镜像名称为nginx的所有镜像</span><br><span class="line">docker image rm $(docker image ls -q -f since=hello-world:latest) # 删除所有在hello-world:latest之后建立的镜像</span><br></pre></td></tr></table></figure></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本文对镜像的获取及本地镜像的基本管理做了介绍，本文镜像的获取途径都是从镜像仓库直接获取，镜像的另一个获取途径便是自定义，接下来会通过实例来进行介绍，欢迎关注。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Docker中，应用是通过容器来运行的，而容器的运行是基于镜像的，类似面向对象设计中类与对象的关系——没有类的定义就谈不上实例的创建与使用，没有镜像的定义就谈不上容器的创建与运行。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（三）：Docker安装与配置</title>
    <link href="http://blog.jboost.cn/docker-3.html"/>
    <id>http://blog.jboost.cn/docker-3.html</id>
    <published>2019-07-14T11:54:05.000Z</published>
    <updated>2019-07-15T00:47:02.022Z</updated>
    
    <content type="html"><![CDATA[<p>Docker分为Docker CE社区免费版与Docker EE企业收费版。Docker EE主要是在安全性及镜像、容器高级管理方面提供了一些额外的支持。对于中小型企业、团队或个人来说，用Docker CE即可。<br><a id="more"></a></p><h2 id="1-安装Docker-CE"><a href="#1-安装Docker-CE" class="headerlink" title="1. 安装Docker CE"></a>1. 安装Docker CE</h2><p>Docker CE有三个更新渠道：</p><ul><li>Stable：提供最新的GA（General Availability）稳定版，每六个月一版，如 18.09 表示18年9月版，下一版就是19.03——19年3月版</li><li>Test：提供GA之前的Pre-release版</li><li>Nightly：提供最新的build版本，每天一版</li></ul><p>我们一般使用stable版。Docker CE支持在多种操作系统下安装，本文只介绍比较常见的Ubuntu 18.04 LTS、CentOS7、及Windows 10上的安装与配置。</p><h3 id="1-1-Ubuntu-18-04-LTS-上安装"><a href="#1-1-Ubuntu-18-04-LTS-上安装" class="headerlink" title="1.1 Ubuntu 18.04 LTS 上安装"></a>1.1 Ubuntu 18.04 LTS 上安装</h3><p>Docker CE支持的64位Ubuntu系统版本为</p><ul><li>Cosmic 18.10</li><li>Bionic 18.04 (LTS)</li><li>Xenial 16.04 (LTS)</li></ul><p>Docker CE在Ubuntu上支持 overlay2， aufs， 以及 btrfs 几种存储驱动程序，对于Linux内核版本为4或以上系统的安装，Docker CE默认使用 overlay2，如果需要使用 aufs，则需要手动配置（参考： <a href="https://docs.docker.com/storage/storagedriver/aufs-driver/" target="_blank" rel="noopener">Use the AUFS storage driver</a>）</p><ol><li>卸载旧版本</li></ol><p>如果系统安装有旧版本，旧版本命名为 docker， docker.io，或docker.engine，可使用如下命令进行卸载<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove docker docker-engine docker.io containerd runc</span></span><br></pre></td></tr></table></figure></p><p>目录/var/lib/docker下的内容，包括镜像、容器、数据卷、网络等，会被保留。</p><ol start="2"><li>使用APT安装</li></ol><p>apt源使用HTTPS来确保软件下载过程中不被篡改，所以首先添加使用HTTPS传输需要的软件包以及CA证书<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install \</span></span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></p><p>为了确认下载软件包的合法性，添加Docker官方的GPG key：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/</span></span><br><span class="line">gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></p><p>由于国内网络原因，我们一般要使用国内源，否则安装将会灰常灰常慢。向source.list中添加Docker软件源（以下命令添加的是stable版本的APT镜像源，如果需要test或nightly版，将stable改为对应test或nightly即可）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository \</span></span><br><span class="line">"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line"><span class="meta">$</span><span class="bash">(lsb_release -cs) \</span></span><br><span class="line">stable"</span><br></pre></td></tr></table></figure></p><p>然后，便可更新apt软件包缓存，开始安装了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install docker-ce</span></span><br></pre></td></tr></table></figure></p><p>以上命令默认会安装软件源里的最新版本，如果需要安装指定版本，则可通过查看可用版本，然后指定版本安装，查看版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-cache madison docker-ce</span></span><br></pre></td></tr></table></figure></p><p>安装指定版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install docker-ce=&lt;VERSION_STRING&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>使用脚本自动安装</li></ol><p>Docker提供了一个方便的安装脚本来在开发测试环境安装Docker CE的edge或测试版，Ubuntu上可使用这套脚本来安装Docker CE的edge版<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL https://get.docker.com -o get-docker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh get-docker.sh --mirror Aliyun</span></span><br></pre></td></tr></table></figure></p><ol start="4"><li>启动Docker CE</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker <span class="comment">#开启开机自动启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker  <span class="comment">#启动docker</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>用户组配置</li></ol><p>docker命令默认是使用Unix socket与Docker引擎进行通信（回顾下除了Unix socket还有REST API及网络端口），只有root用户或docker用户组里的用户才有权限访问Docker引擎的Unix socket，因此，需要将使用docker的用户加入docker用户组（处于安全考虑，一般尽量不要直接使用root用户来操作）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd docker <span class="comment">#添加docker用户组</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker <span class="variable">$USER</span> <span class="comment">#将当前用户加到docker用户组</span></span></span><br></pre></td></tr></table></figure></p><p>退出账号重新登录即可。</p><ol start="6"><li>测试安装是否成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run hello-world</span></span><br></pre></td></tr></table></figure><p>如果显示如下图，则说明安装已成功<br><img src="/assets/hello-docker.png" alt="hello-docker"></p><ol start="7"><li>卸载</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><p>以上命令可以卸载docker-ce，但是之前的镜像、容器、数据卷等不会自动删除，可通过如下命令彻底删除<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo rm -rf /var/lib/docker</span></span><br></pre></td></tr></table></figure></p><h3 id="1-2-CentOS-7-上安装"><a href="#1-2-CentOS-7-上安装" class="headerlink" title="1.2 CentOS 7 上安装"></a>1.2 CentOS 7 上安装</h3><p>Docker CE支持64位的CentOS7，并且要求内核版本不低于3.10。CentOS 7满足最低内核的要求，但由于版本较低，一些功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。<br>可以通过<code>uname -r</code>命令来查看系统内核版本，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# uname -r</span><br><span class="line">3.10.0-957.1.3.el7.x86_64</span><br></pre></td></tr></table></figure></p><ol><li>卸载旧版本</li></ol><p>如果安装了旧版本，需要先卸载。旧版本的Docker称为docker或者docker-engine，卸载命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker \</span></span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-selinux \</span><br><span class="line">    docker-engine-selinux \</span><br><span class="line">    docker-engine</span><br></pre></td></tr></table></figure></p><ol start="2"><li>使用yum安装</li></ol><p>安装依赖包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils \</span></span><br><span class="line">    device-mapper-persistent-data \</span><br><span class="line">    lvm2</span><br></pre></td></tr></table></figure></p><p>由于国内网络原因，我们一般要使用国内源，否则安装可能会灰常灰常慢。添加yum软件源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce</span><br><span class="line">    .repo</span><br></pre></td></tr></table></figure></p><p>如果要安装nightly或test版，执行如下对应的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-nightly <span class="comment"># 启用nightly， 将--enbale改为disable又可以禁用</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-test <span class="comment"># 启用test</span></span></span><br></pre></td></tr></table></figure></p><p>安装最新版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum makecache fast <span class="comment"># 更新软件源缓存</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce <span class="comment"># 安装最新版本</span></span></span><br></pre></td></tr></table></figure></p><p>安装指定版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum list docker-ce --showduplicates | sort -r <span class="comment"># 列出可用版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce-&lt;VERSION_STRING&gt; <span class="comment"># 安装指定版本</span></span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>使用脚本自动安装</li></ol><p>执行如下命令，则会自动安装Docker CE的edge版，注意只在开发或测试环境这么用（建议最好还是用stable版）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL get.docker.com -o get-docker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh get-docker.sh --mirror Aliyun</span></span><br></pre></td></tr></table></figure><ol start="4"><li>启动Docker CE</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker <span class="comment">#开启开机自动启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker  <span class="comment">#启动docker</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>用户组配置</li></ol><p>docker命令默认是使用Unix socket与Docker引擎进行通信（回顾下除了Unix socket还有REST API及网络端口），只有root用户或docker用户组里的用户才有权限访问Docker引擎的Unix socket，因此，需要将使用docker的用户加入docker用户组（处于安全考虑，一般尽量不要直接使用root用户来操作）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd docker <span class="comment">#添加docker用户组</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker <span class="variable">$USER</span> <span class="comment">#将当前用户加到docker用户组</span></span></span><br></pre></td></tr></table></figure></p><p>退出账号重新登录即可。</p><ol start="6"><li>测试安装是否成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run hello-world</span></span><br></pre></td></tr></table></figure><p>如果显示如下图，则说明安装已成功<br><img src="/assets/hello-docker.png" alt="hello-docker"></p><p>如果在 CentOS 中使用 Docker CE 看到下面的这些警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: bridge-nf-call-iptables is disabled</span><br><span class="line">WARNING: bridge-nf-call-ip6tables is disabled</span><br></pre></td></tr></table></figure></p><p>可以添加内核配置参数以启用这些功能。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tee -a /etc/sysctl.conf &lt;&lt;-EOF</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>然后重新加载 sysctl.conf 即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl -p</span></span><br></pre></td></tr></table></figure></p><ol start="7"><li>卸载</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker-ce <span class="comment"># 卸载docker-ce</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm -rf /var/lib/docker <span class="comment"># 该目录下的镜像、容器、数据卷、网络等不会自动删除</span></span></span><br></pre></td></tr></table></figure><h3 id="1-3-Windows-10-上安装"><a href="#1-3-Windows-10-上安装" class="headerlink" title="1.3 Windows 10 上安装"></a>1.3 Windows 10 上安装</h3><p>windows 10上的安装非常简单，直接下载<a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="noopener">stable版本</a>安装。<br>安装完后，在 Windows 搜索栏输入 Docker 点击 Docker for Windows 开始运行</p><h2 id="2-配置国内镜像"><a href="#2-配置国内镜像" class="headerlink" title="2. 配置国内镜像"></a>2. 配置国内镜像</h2><p>Docker默认是从Docker Hub（官方的镜像仓库）拉取镜像的，国内访问一般会比较慢，因此可以配置一些镜像加速器，很多云服务商提供了自己的加速器服务，如Azure中国，阿里云（需要登录获取），七牛云等。</p><p>Ubuntu、CentOS上，配置国内镜像只需要在/etc/docker/daemon.json中写入如下内容（如果文件不存在则创建一个）<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">        <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后重新启动服务<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure></p><p>对于Windows 10，在系统右下角托盘Docker图标上右键菜单选择<br>Settings ，打开配置窗口后在左侧导航菜单选择 Daemon 。在 Registry<br>mirrors 一栏中填写加速器地址 <a href="https://dockerhub.azk8s.cn" target="_blank" rel="noopener">https://dockerhub.azk8s.cn</a> ，之后点击<br>Apply 保存， Docker 就会自动重启并应用配置的镜像地址了。 </p><p>可以通过<code>docker info</code>命令来检查加速器是否生效，如果执行命令能看到类似如下信息，则说明加速器配置生效了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line">    https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Docker分Docker CE与Docker EE两个版本，对大多数人来说，一般使用Docker CE就行了。我们在安装Docker CE时，最好安装stable版，比较稳定可靠。同时，Linux安装时，记得配置Docker软件源，不然有可能太慢。安装完后，需要配置镜像加速器，加快镜像的下载速度。工具有了，接下来就是探索实践了，加油吧少年！<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker分为Docker CE社区免费版与Docker EE企业收费版。Docker EE主要是在安全性及镜像、容器高级管理方面提供了一些额外的支持。对于中小型企业、团队或个人来说，用Docker CE即可。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（二）：Docker管理的对象</title>
    <link href="http://blog.jboost.cn/docker-2.html"/>
    <id>http://blog.jboost.cn/docker-2.html</id>
    <published>2019-07-14T00:36:56.000Z</published>
    <updated>2019-07-24T01:50:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/docker-1.html">Docker笔记（一）：什么是Docker</a>中，我们提到了Docker管理的对象包含镜像、容器、网络、数据卷等，本文就来介绍下这些对象及用途。<br><a id="more"></a></p><h2 id="1-镜像"><a href="#1-镜像" class="headerlink" title="1. 镜像"></a>1. 镜像</h2><p>所谓镜像，是一个静态的概念。它对我们期望干的事情做了一些定义，比如要运行什么程序，需要哪些依赖，需要什么样的配置，需要开放哪个网络端口等等。<br>Docker的镜像是一个特殊的文件系统，提供了运行时需要的程序、库、资源、配置等文件，还包含一些为运行时准备的配置参数（如环境变量、匿名数据卷、用户等），镜像不包含任何动态数据，其内容在构建之后也不会被改变。<br>镜像的文件系统有一个分层存储的概念，采用的是Union FS技术，因此，镜像并不是简单地由一组文件组成，而是由多层文件系统叠加联合组成。如下图所示<br><img src="/assets/container-layers.jpg" alt="container-layers"></p><p>镜像构建时，会一层一层地构建，前一层是后一层的基础，每层构建完后就变成只读的，不会再发生改变。镜像分层存储的一大好处是复用，镜像的每一层可以在不同镜像间复用，这就好比我们开发项目时将一些公共功能封装成jar包，在各个项目可以直接依赖使用一样。关于镜像的更多内容，在后续使用时再详述。</p><h2 id="2-容器"><a href="#2-容器" class="headerlink" title="2. 容器"></a>2. 容器</h2><p>相对镜像，容器是一个动态的运行时的概念，它与镜像的关系类似于面向对象中类与实例的关系。容器可以被创建、启动、停止、删除等。容器运行实质上就是运行一个进程，但与那些直接在宿主机上运行的进程不同，容器运行在自己的独立的隔离的命名空间中——拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间，因此虽然是以进程的形式运行，但好像是运行在一个独立的系统中一样，这样相比直接运行于宿主机的进程，容器的运行显得更为安全。<br>前面说到镜像的分层存储概念，对于容器来说，实际上也是以镜像作为基础层，在其上创建了一个当前容器的存储层，如下图<br><img src="/assets/sharing-layers.jpg" alt="sharing-layers.jpg"></p><p>以镜像ubuntu:15.04为基础层所创建的容器，都有一个自己的可读写的存储层（镜像的存储层是只读的）。容器存储层的生命周期与容器一样，容器销毁时，容器的存储层也会随之消亡，任何保存在容器存储层的数据也都会随容器的删除而丢失，因此一般我们要保持容器存储层的无状态化，所有文件的写操作，都应该使用数据卷或绑定宿主机目录。</p><h2 id="3-数据卷"><a href="#3-数据卷" class="headerlink" title="3. 数据卷"></a>3. 数据卷</h2><p>数据卷是一个独立于容器，可供一个或多个容器使用的特殊目录，它绕过了Union FS，不会随容器的销毁而消亡。这好比我们在阿里云上建虚机，再加载一个数据盘一样，一般产生的数据都要保存在数据盘，而不是虚机的系统盘。<br>数据卷具备如下特性：</p><ol><li>可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>数据卷的更新，不会影响到镜像</li><li>数据卷默认会一直存在，不会随容器的删除而消亡</li></ol><h2 id="4-网络"><a href="#4-网络" class="headerlink" title="4. 网络"></a>4. 网络</h2><p>Docker容器是如何与外部进行网络通信的？一般来说，我们在运行容器时，只需要指定容器服务端口与宿主机端口的映射，就可以通过宿主机IP与映射的端口访问容器服务了，因为Docker默认使用了Bridge的模式来实现容器与外部的通信。<br>Docker的网络子系统通过使用一些驱动程序，是可插拔式的，默认提供了如下几种驱动：</p><ol><li>bridge：默认的网络驱动。运行在容器中的应用程序一般是通过网桥与外部进行通信。</li><li>host：容器直接使用宿主机的网络通信。host只在基于Docker 17.06或以上版本的Swarm服务中可用</li><li>overlay：overlay可将多个Docker daemon进程连接起来使得Swarm服务之间能相互通信，也可以将overlay用于Swarm服务与容器之间，或运行在不同Docker daemon上的容器之间的通信，不需要操作系统层面的路由配置。</li><li>macvlan：macvlan允许你分配一个mac地址给容器，让它像一台物理设备一样加入你的网络中。Docker daemon通过mac地址将请求路由给容器，适用于那些希望直接连到物理网络的遗留应用。</li><li>none：禁用所有网络。一般与一个自定义的网络驱动一起使用。none不能用于Swarm服务。</li><li>其它第三方网络插件：可从Docker Hub或其它第三方供应商获取安装。</li></ol><p>总之，bridge适用于在同一台宿主机运行多个容器的场景；host适用于不应与宿主机进行网络隔离的场景；overlay适用于运行在不同宿主机上的容器间通信，或多个应用通过Swarm服务来共同协作的场景；macvlan适用于从虚拟机迁移配置或希望容器作为物理机一样使用网络的场景。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文对Docker所管理的几个基本对象——镜像、容器、数据卷、网络做了简单介绍，这是认识或学习Docker的基础，在后续实践操作过程中，将会对各部分进行更详细的使用说明，欢迎持续关注。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/docker-1.html&quot;&gt;Docker笔记（一）：什么是Docker&lt;/a&gt;中，我们提到了Docker管理的对象包含镜像、容器、网络、数据卷等，本文就来介绍下这些对象及用途。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（一）：什么是Docker</title>
    <link href="http://blog.jboost.cn/docker-1.html"/>
    <id>http://blog.jboost.cn/docker-1.html</id>
    <published>2019-07-13T02:13:25.000Z</published>
    <updated>2019-07-13T09:59:13.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>接触Docker也有两年多了，断断续续玩过一些应用场景，如安装一些常用工具服务，部署业务项目，基于gitlab+jenkins pipeline+docker的CI/CD实现等。了解其基本知识与操作，但不能说深度掌握，故借此系列进行梳理与学习，也希望对有意学习Docker的人提供参考。</p><a id="more"></a><h2 id="2-Docker简介"><a href="#2-Docker简介" class="headerlink" title="2. Docker简介"></a>2. Docker简介</h2><p>Docker最初是dotCloud公司（后来也改名为Docker）的一个内部项目，于2013年3月开源。Docker使用Google推出的Go语言实现，基于Linux内核的cgroup、namespace、Union FS等技术（先不用急着了解这些都是啥），对进程进行隔离，是操作系统层面的虚拟化技术。相对于传统的硬件层面的虚拟化技术（虚拟机），Docker显得更为轻量化。下图为传统虚拟机与Docker的结构对比<br><img src="/assets/vm-docker.png" alt="vm-docker"></p><p>由上图可看出传统虚拟机技术是在硬件层面虚拟出一套硬件（CPU、内存、磁盘、网卡等）后，在其上运行一个完整的操作系统，再在操作系统上运行应用进程；而Docker的应用进程是直接运行在宿主机的内核上，也不需要进行硬件虚拟，因此，Docker要比传统虚拟机更为轻便。</p><p>总结Docker相对传统虚拟化技术的优势如下：</p><ol><li><strong>更高的资源利用率：</strong>Docker不需要硬件虚拟与运行完整操作系统的开销，所以资源利用率更高，同样配置的主机，采用Docker往往可以运行更多数量的应用。</li><li><strong>更高效的使用体验：</strong>在操作系统上安装一些常用软件，如mysql，redis等，往往需要折腾好一阵，有些还要手动安装各种依赖，而采用Docker，可能几行命令就可以让一个服务快速运行起来。</li><li><strong>一致的运行环境：</strong>Docker镜像功能可以把程序运行需要的环境进行封装，确保程序在开发、测试、生产环境都能保持一致性，避免因环境不一致导致程序运行异常。</li><li><strong>CI/CD支持：</strong>使用Docker可以定制镜像来实现持续集成、持续部署，如基于gitlab + jenkins pipeline + docker的自动化部署。</li><li><strong>更轻松的维护：</strong>因为Docker保证了运行环境的一致性，因此应用的迁移或缩放将变得很容易；Docker的分层存储与镜像技术，也使得应用重复部分的复用变得更简单，基于基础镜像可以进一步扩展定义自己的镜像，也可以直接使用官方镜像来使用。</li></ol><h2 id="3-Docker的基本架构"><a href="#3-Docker的基本架构" class="headerlink" title="3. Docker的基本架构"></a>3. Docker的基本架构</h2><p>Docker的基本架构图如下<br><img src="/assets/docker-arch.png" alt="docker-arch"></p><p>主要包括几部分：</p><ol><li>Docker daemon（Docker守护进程 <code>dockerd</code>）：Docker的执行引擎，负责监听处理Docker客户端请求与管理Docker相关对象，如镜像、容器、网络、数据卷等。一个Docker守护进程可与其它Docker守护进程进行通信，作为Docker服务进行管理。</li><li>Docker client（Docker客户端 <code>docker</code>）：Docker客户端（<code>docker</code> CLI命令）是大多数用户用来与Docker守护进程交互的方式，比如你在命令行执行<code>docker run</code>，Docker客户端将发送该命令请求到Docker守护进程，由守护进程执行。Docker客户端可通过REST API, UNIX Socket或网络接口来与Docker守护进程进行通信，并且可与多个Docker守护进程进行通信。</li><li>Docker Registry（Docker注册中心）：用来存储Docker镜像的仓库，类似于Maven的Nexus。Docker官方提供了一个公共镜像仓库Docker Hub（ <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> ），<code>docker</code>相关命令默认会从Docker Hub上搜索与下载镜像，我们可以配置一些国内镜像仓库地址来进行加速，甚至搭建自己的私有镜像仓库。</li><li>Docker Objects：Docker管理的对象，主要包括镜像、容器、网络、数据卷等。</li></ol><h2 id="4-Docker的用途"><a href="#4-Docker的用途" class="headerlink" title="4. Docker的用途"></a>4. Docker的用途</h2><p>根据第二部分Docker的优势及笔者的经验来看，目前Docker主要用于</p><ol><li>常用软件服务的搭建运行，如Mysql、Redis、Nginx等</li><li>业务服务的发布部署，尤其是基于SpringBoot的微服务</li><li>CI/CD实现，结合Gitlab的webhook，Jenkins的pipeline，实现自动化集成与部署</li><li>快速的弹性伸缩，在容器集群化管理的场景中，如Swarm、K8s解决方案中，可基于容器对服务进行快速的弹性伸缩来应对业务量的突发情况</li><li>执行环境封装，如一些深度学习框架模型，打成Docker镜像的方式进行发布，可以快速在不同的环境中运行起来</li><li>…</li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>在微服务架构、DevOps这些概念盛行的时代，容器化技术变得越来越重要，几乎成为每一位开发人员需要掌握的技能。本系列文章是笔者基于自身实践及相关文献参考，对Docker相关技术进行整理，欢迎关注，共同学习。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;接触Docker也有两年多了，断断续续玩过一些应用场景，如安装一些常用工具服务，部署业务项目，基于gitlab+jenkins pipeline+docker的CI/CD实现等。了解其基本知识与操作，但不能说深度掌握，故借此系列进行梳理与学习，也希望对有意学习Docker的人提供参考。&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.jboost.cn/categories/DevOps/"/>
    
    
      <category term="docker" scheme="http://blog.jboost.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu18.04上搭建KVM虚拟机环境超完整过程</title>
    <link href="http://blog.jboost.cn/ubuntu-kvm.html"/>
    <id>http://blog.jboost.cn/ubuntu-kvm.html</id>
    <published>2019-07-11T06:13:23.000Z</published>
    <updated>2019-08-26T02:05:42.429Z</updated>
    
    <content type="html"><![CDATA[<p>看标题这是篇纯运维的文章。在中小型企业中，一般很少配置专业的运维人员，都是由开发人员兼着。同时，对有志于技术管理的开发人员来说，多了解一些运维及整个软件生命周期的知识，是很有帮助的，因为带团队不仅仅是个管人的活，更多的是在你的部下遇到难题或者无人能上的时候，你能协助他解决或亲自上阵，这比只会“吆五喝六”的管理者将能获得更高的敬重与威信。闲话不多说了，记录下整个KVM虚拟机的搭建过程吧。<br><a id="more"></a></p><h2 id="1-KVM安装"><a href="#1-KVM安装" class="headerlink" title="1. KVM安装"></a>1. KVM安装</h2><h3 id="1-1-配置确认"><a href="#1-1-配置确认" class="headerlink" title="1.1 配置确认"></a>1.1 配置确认</h3><p>首先需要确认服务器的硬件是否支持虚拟化，执行如下命令确认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ egrep -c '(vmx|svm)' /proc/cpuinfo</span><br><span class="line">48</span><br></pre></td></tr></table></figure><p>如果输出结果大于0，意味着服务器硬件是支持虚拟化的。否则，重启进入BIOS设置中启用VT技术。<br>执行如下命令安装kvm-ok程序，来确定服务器是否能够运行硬件加速的KVM虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ sudo apt install cpu-checker</span><br><span class="line"></span><br><span class="line">devuser@server_01:~$ sudo kvm-ok</span><br><span class="line">INFO: /dev/kvm exists</span><br><span class="line">KVM acceleration can be used</span><br></pre></td></tr></table></figure><h3 id="1-2-安装KVM"><a href="#1-2-安装KVM" class="headerlink" title="1.2 安装KVM"></a>1.2 安装KVM</h3><p>安装KVM及依赖项<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ sudo apt update</span><br><span class="line">devuser@server_01:~$ sudo apt install qemu qemu-kvm libvirt-bin  bridge-utils  virt-manager</span><br></pre></td></tr></table></figure></p><p>启动libvirtd服务，并设置开机自动启动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ sudo systemctl start libvirtd.service</span><br><span class="line">devuser@server_01:~$ sudo systemctl enable libvirtd.service</span><br></pre></td></tr></table></figure></p><p>执行<code>service libvirtd status</code>查看libvirtd服务状态，如图<br><img src="/assets/kvm1.png" alt="libvirtd-status"></p><h3 id="1-3-桥接网络配置"><a href="#1-3-桥接网络配置" class="headerlink" title="1.3 桥接网络配置"></a>1.3 桥接网络配置</h3><p>一般虚拟机网络配置有Bridge、NAT等几种模式。NAT模式下，虚拟机不需要配置自己的IP，通过宿主机来访问外部网络；Bridge模式下， 虚拟机需要配置自己的IP，然后虚拟出一个网卡， 与宿主机的网卡一起挂到一个虚拟网桥上（类似于交换机）来访问外部网络，这种模式下，虚拟机拥有独立的IP，局域网其它主机能直接通过IP与其通信。简单理解，就是NAT模式下，虚机隐藏在宿主机后面了，虚机能通过宿主机访问外网，但局域网其它主机访问不到它，Bridge模式下，虚机跟宿主机一样平等地存在，局域网其它主机可直接通过IP与其通信。一般我们创建虚机是用来部署服务供使用的， 所以都是用Bridge模式。</p><p>ubuntu 18中，网络配置通过netplan来实现了，如下，更改配置文件 /etc/netplan/50-cloud-init.yaml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">devuser@cserver_01:~$ sudo vim /etc/netplan/50-cloud-init.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> This file is generated from information provided by</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the datasource.  Changes to it will not persist across an instance.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">disable</span> cloud-init<span class="string">'s network configuration capabilities, write a file</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> network: &#123;config: disabled&#125;</span></span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        enp6s0:</span><br><span class="line">            dhcp4: true</span><br><span class="line">        enp7s0:</span><br><span class="line">            dhcp4: no</span><br><span class="line">            dhcp6: no</span><br><span class="line">    version: 2</span><br><span class="line"></span><br><span class="line">    bridges:</span><br><span class="line">         br0:</span><br><span class="line">             interfaces: [enp7s0]</span><br><span class="line">             dhcp4: no</span><br><span class="line">             addresses: [192.168.40.241/24]</span><br><span class="line">             gateway4: 192.168.40.1</span><br><span class="line">             nameservers:</span><br><span class="line">                 addresses: [114.114.114.114,8.8.8.8]</span><br></pre></td></tr></table></figure><p>将宿主机原有网卡enp7s0挂到网桥br0上，并指定IP地址为192.168.40.241，nameservers指定DNS服务器。修改完后，通过<code>sudo netplan apply</code>重启网络服务生效，然后通过<code>ifconfig</code>查看，<br><img src="/assets/kvm2.png" alt="kvm2"><br>原来挂在enp7s0网卡下的IP现在挂到了br0上，宿主机及所有其它虚拟机都通过该网桥来与外部通讯。我们也可以通过<code>brctl show</code>来直观地查看，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ brctl show</span><br><span class="line">bridge name    bridge idSTP enabled    interfaces</span><br><span class="line">br0    8000.2a5be3ec2698no        enp7s0</span><br><span class="line">docker08000.02424524dcceno        veth580af8e</span><br><span class="line">        veth74119f3</span><br><span class="line">        vethe7a2b0f</span><br><span class="line">        vethfe89039</span><br></pre></td></tr></table></figure></p><p>目前因为还没虚机，所以只有宿主机的网卡enp7s0挂在网桥br0上。同时也可以看到docker容器也是通过网桥docker0来通讯的。</p><h2 id="2-虚拟机安装"><a href="#2-虚拟机安装" class="headerlink" title="2. 虚拟机安装"></a>2. 虚拟机安装</h2><h3 id="2-1-安装虚拟机"><a href="#2-1-安装虚拟机" class="headerlink" title="2.1 安装虚拟机"></a>2.1 安装虚拟机</h3><p>安装命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-install --name=dev-server1 --memory=16384,maxmemory=16384 \</span><br><span class="line">--vcpus=4,maxvcpus=4 --os-type=linux --os-variant=rhel7 \</span><br><span class="line">--location=/home/devuser/tools/CentOS-7-x86_64-DVD-1810.iso \</span><br><span class="line">--disk path=/var/lib/libvirt/images/devserver1.img,size=300 \</span><br><span class="line">--bridge=br0 --graphics=none --console=pty,target_type=serial \</span><br><span class="line">--extra-args="console=tty0 console=ttyS0"</span><br></pre></td></tr></table></figure></p><p>其中–name指定虚机名称；–memory=16384,maxmemory=16384配置了16G内存；–vcpus=4,maxvcpus=4配置了4个CPU内核；centos7需要指定–os-variant=rhel7；–disk path=xx,size=300指定了磁盘路径与大小，这里是300G。</p><p>如果执行上述命令出现<code>qemu-kvm: could not open &#39;xx/CentOS-7-x86_64-DVD-1810.iso&#39;: Permission denied</code>异常退出时，可通过修改<code>/etc/libvirt/qemu.conf</code>文件将<code>user = &quot;root&quot;</code>，<code>group = &quot;root&quot;</code>前面的注释去掉解决（<a href="https://github.com/jedi4ever/veewee/issues/996）" target="_blank" rel="noopener">https://github.com/jedi4ever/veewee/issues/996）</a></p><p>如无问题，安装程序将出现如下配置界面<br><img src="/assets/kvm3.png" alt="kvm3"></p><p>可通过输入选项对应的数字来选择不同的配置，依次操作如下步骤完成时区设置：<br>输入2，回车，选择时区设置；输入1，回车，选择“Set timezone”；输入2，回车，选择“Asia”；回车，输入64，回车，选择“Shanghai”</p><p>然后进行安装设置，<br><img src="/assets/kvm4.png" alt="kvm4"><br>依次操作如下：<br>输入5，回车，进入安装设置；输入c，回车，选择默认的磁盘进行安装；输入c，回车，使用默认的“2) Use All<br> Space”；输入1，回车，选择“1) Standard Partition”进行标准分区；输入c，回车，完成分区设置</p><p>最后进入root密码设置，<br><img src="/assets/kvm5.png" alt="kvm5"><br>操作如下：<br>输入8，回车，进入root密码设置；输入密码，回车；输入确认密码，回车</p><p>完成上述设置后，输入b开始进行安装<br><img src="/assets/kvm6.png" alt="kvm6"></p><p>等待一段时间后，安装程序停在如下界面<br><img src="/assets/kvm7.png" alt="kvm7"></p><p>按回车继续，最后输入用户名root，及前面设置的密码登录系统<br><img src="/assets/kvm8.png" alt="kvm8"></p><h3 id="2-2-虚拟机网络配置"><a href="#2-2-虚拟机网络配置" class="headerlink" title="2.2 虚拟机网络配置"></a>2.2 虚拟机网络配置</h3><p>虚拟机安装完后，是没有分配IP的，我们通过<code>ip a</code>命令查看，<br><img src="/assets/kvm9.png" alt="kvm9"></p><p>这时候的eth0下面空空如也，什么都没有。在<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>文件中添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static #静态指定IP</span><br><span class="line">DEFROUTE=yes</span><br><span class="line"><span class="meta">#</span><span class="bash">IPV4_FAILURE_FATAL=no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6INIT=yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_AUTOCONF=yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_DEFROUTE=yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_FAILURE_FATAL=no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_ADDR_GEN_MODE=stable-privacy</span></span><br><span class="line">NAME=eth0</span><br><span class="line">UUID=449ed621-97a8-45b9-902f-0d347e27de98</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes  #开机自动启动</span><br><span class="line">IPADDR=192.168.40.96</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.40.1</span><br><span class="line">DNS1=192.168.40.1</span><br></pre></td></tr></table></figure><p>并通过<code>systemctl restart network</code>重启网络生效，这时候再运行<code>ip a</code>查看，eth0下面已经有配置的IP了。不出意外的话，局域网其它主机就可以通过该IP来远程SSH连接了。<br><img src="/assets/kvm10.png" alt="kvm10"></p><p>这时候我们再通过<code>brctl show</code>来查看网桥挂载情况，br0下面已经多了一个vnet0虚拟网卡了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ brctl show</span><br><span class="line">bridge name    bridge idSTP enabled    interfaces</span><br><span class="line">br0    8000.2a5be3ec2698no        enp7s0</span><br><span class="line">        vnet0</span><br><span class="line">docker08000.02424524dcceno        veth580af8e</span><br><span class="line">        veth74119f3</span><br><span class="line">        vethd270ee8</span><br><span class="line">        vethe7a2b0f</span><br><span class="line">        vethfe89039</span><br></pre></td></tr></table></figure></p><p>虚拟机装完后，默认的hostname是localhost，针对centos7，我们可以通过如下命令来修改hostname<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl set-hostname dev-server1</span><br></pre></td></tr></table></figure></p><p>然后在/etc/hosts文件中添加127.0.0.1的host映射 dev-server1<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 dev-server1</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure></p><blockquote><p>Note: 如果出现虚拟机中无法访问外网，外部主机也无法ping通虚拟机的情况，则尝试如下处理</p></blockquote><p>向文件/etc/sysctl.conf添加以下代码，禁用网络过滤器:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 0</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 0</span><br><span class="line">net.bridge.bridge-nf-call-arptables = 0</span><br></pre></td></tr></table></figure></p><p>重新加载kernel参数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01: sudo sysctl -p</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">...</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 0</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 0</span><br><span class="line">net.bridge.bridge-nf-call-arptables = 0</span><br></pre></td></tr></table></figure></p><h2 id="3-虚拟机管理"><a href="#3-虚拟机管理" class="headerlink" title="3. 虚拟机管理"></a>3. 虚拟机管理</h2><ol><li>列出当前运行的虚拟机<code>virsh list</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh list</span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 5     dev-server1                    running</span><br></pre></td></tr></table></figure></li></ol><p>如果列出所有的，则<code>virsh list --all</code></p><ol start="2"><li>从宿主机进入虚拟机<code>virsh console</code>，后面接虚拟机ID或名称<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh console 5</span><br><span class="line">Connected to domain dev-server1</span><br><span class="line">Escape character is ^]</span><br><span class="line"></span><br><span class="line">CentOS Linux 7 (Core)</span><br><span class="line">Kernel 3.10.0-957.el7.x86_64 on an x86_64</span><br><span class="line"></span><br><span class="line">dev-server1 login:</span><br></pre></td></tr></table></figure></li></ol><p>输入用户名，密码即可登录虚拟机，按<code>Ctrl+]</code>可退出。</p><ol start="3"><li><p>启动与关闭虚拟机<code>virsh start|shutdown</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devuser@cserver_01:~$ virsh start dev-server1</span><br><span class="line">Domain dev-server1 started</span><br><span class="line"></span><br><span class="line">devuser@server_01:~$ virsh shutdown 5</span><br><span class="line">Domain 5 is being shutdown</span><br></pre></td></tr></table></figure></li><li><p>libvirtd启动时，自动启动虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh autostart dev-server1</span><br><span class="line">Domain dev-server1 marked as autostarted</span><br></pre></td></tr></table></figure></li><li><p>挂起/恢复虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh suspend dev-server1    # 挂起虚拟机</span><br><span class="line">devuser@server_01:~$ virsh resume dev-server1    # 恢复挂起的虚拟机</span><br></pre></td></tr></table></figure></li><li><p>销毁虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh undefine dev-server1   # 彻底销毁虚拟机，会删除虚拟机配置文件，但不会删除虚拟磁盘</span><br></pre></td></tr></table></figure></li></ol><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看标题这是篇纯运维的文章。在中小型企业中，一般很少配置专业的运维人员，都是由开发人员兼着。同时，对有志于技术管理的开发人员来说，多了解一些运维及整个软件生命周期的知识，是很有帮助的，因为带团队不仅仅是个管人的活，更多的是在你的部下遇到难题或者无人能上的时候，你能协助他解决或亲自上阵，这比只会“吆五喝六”的管理者将能获得更高的敬重与威信。闲话不多说了，记录下整个KVM虚拟机的搭建过程吧。&lt;br&gt;
    
    </summary>
    
      <category term="高效实践" scheme="http://blog.jboost.cn/categories/%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="kvm" scheme="http://blog.jboost.cn/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>软件项目研发流程该怎么规范</title>
    <link href="http://blog.jboost.cn/project-process.html"/>
    <id>http://blog.jboost.cn/project-process.html</id>
    <published>2019-07-08T11:14:47.000Z</published>
    <updated>2019-07-09T11:13:37.300Z</updated>
    
    <content type="html"><![CDATA[<p>在软件项目研发管理过程中，是否经常出现这样的场景：开发人员不知道什么时候转测；项目经理拿个Excel文档群里一发，某任务前天就应该完成的，怎么现在还没开始搞；前端问这部分UI是谁在做，什么时候能做完；测试说线上这个bug又是谁改出来的，这次没转测这模块……等等。整个协作感觉一团乱麻，团队内部充满了甩锅与抱怨的氛围。软件项目的研发流程该怎么规范，让团队成员都能目标明确，步调一致，让产品迭代充满节奏感。本文基于笔者项目研发管理经验整理，希望起到抛砖引玉的作用，探讨高效团队的协作流程模式。<br><a id="more"></a></p><h2 id="1-协作流程图"><a href="#1-协作流程图" class="headerlink" title="1. 协作流程图"></a>1. 协作流程图</h2><p><img src="/assets/project.png" alt="协作流程图"></p><p>基本原则：</p><ol><li>所有问题可跟踪 （需求、Bug、优化）</li><li>所有工作透明化 （工作量、进展、Block因素）</li></ol><h2 id="2-各阶段内容详解"><a href="#2-各阶段内容详解" class="headerlink" title="2. 各阶段内容详解"></a>2. 各阶段内容详解</h2><h3 id="2-1-需求收集确认"><a href="#2-1-需求收集确认" class="headerlink" title="2.1. 需求收集确认"></a>2.1. 需求收集确认</h3><p>本阶段主要是与产品经理相关的活动内容：</p><ol><li>产品经理在每次版本开始之前定期收集各方需求，包括客户反馈、领导意见（对很多中小企业来说，老板就是最大的“用户”）、市场调研及技术团队需求等来源，输出需求列表</li><li>在版本开始之前召开<strong>版本计划会议</strong>，参与者包括项目经理、产品经理，及项目核心成员，按优先级梳理需求列表，输出下次版本的初步任务列表（之所以说初步，是因为该列表后面可能根据评审情况进行调整）</li><li>产品经理基于初步任务列表完成详细需求文档，组织团队成员——包括相关UI、开发、测试，召开 <strong>需求评审会议</strong>，输出评审意见及修正完成时间</li><li>产品经理针对需求评审会议中团队提出的意见建议，在修正完成时间内及时修正需求文档，并及时通知团队相关成员，输出确定的需求文档</li></ol><blockquote><p>注：可在需求评审会议后，进行任务的初步认领分配与时间估算，初步<strong>确定转测、上线时间节点</strong></p></blockquote><h3 id="2-2-设计开发"><a href="#2-2-设计开发" class="headerlink" title="2.2. 设计开发"></a>2.2. 设计开发</h3><ol><li>项目经理根据需求文档完成任务拆解，并在任务管理系统中创建对应任务单，指定经办人</li><li>各经办人认领任务后，根据自身任务的期限，及时与依赖方沟通，确定依赖任务的完成时间，以免影响自身任务进度，存在问题及时向项目经理反馈。</li><li>UI设计完成后，相关开发人员与产品经理需对UI设计进行确认，如果涉及内容较多，可组织<strong>UI评审会议</strong>（由产品经理或项目经理权衡组织）</li><li>涉及流程的开发任务需要有必要的设计，技术相关负责人负责对<strong>设计review</strong>，没有review的设计不能开发；任务开发完成需要进行<strong>代码review</strong></li><li>项目经理定期组织项目例会（紧急版本建议每天一次，较长期版本建议一周一次或两次），持续跟进任务进度与问题，并及时协调处理，以保障进度预期</li><li>在预定转测时间节点前一天，开发人员编写转测文档，描述本次版本调整内容（附上任务列表）及注意事项，并通知项目相关人员（钉钉群或邮件）</li></ol><h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3. 测试"></a>2.3. 测试</h3><ol><li>需求评审会议后，测试人员需对各功能模块编写测试用例文档，并在转测前组织<strong>测试评审会议</strong>，对各功能各环节进行复核与查漏补缺</li><li>一次版本任务可根据情况分批测试，并确定每轮转测的内容与时间节点；分批测试完成后，需在上线前进行集成测试，注意预留一定的时间用于问题修复</li><li>测试完成，需要将测试结论通报项目相关人员（钉钉群或邮件），包括遗留问题与是否达到上线要求结论</li></ol><blockquote><p>注：产品经理可在转测后对开发实现进行验收，以确定开发是否符合需求实际，以便及时进行调整</p></blockquote><h3 id="2-4-上线"><a href="#2-4-上线" class="headerlink" title="2.4. 上线"></a>2.4. 上线</h3><ol><li>上线人员需在上线前编写上线方案文档，记录此次上线内容，并对此次上线操作进行推演，对所涉及的所有操作按步骤进行记录，如数据库操作，代码merge，jenkins构建等；对可能存在的问题进行备注及对应的处理方案，并提交技术相关负责人review</li><li>项目经理结合测试结论及其它各方面情况，决策是否上线，并将意见通知到项目相关人员（钉钉群或邮件）</li><li>上线人员按照上线方案文档记录的步骤，依次完成上线操作（上线操作最好至少由两人完成，一人操作，一人检视，避免出错）</li><li>上线完成后，测试人员与产品经理对此次上线进行线上验证，确保线上功能流程无问题</li><li>验证无误后，由项目经理或其他指定负责人将上线通知发布至利益相关者，包括项目团队所有成员及相关合作方，说明上线时间、上线内容、影响因素、注意事项等（即时通讯群或邮件）</li></ol><h3 id="2-5-复盘"><a href="#2-5-复盘" class="headerlink" title="2.5. 复盘"></a>2.5. 复盘</h3><ol><li>版本结束后，项目经理根据情况对上个周期组织复盘总结会，总结存在的问题与原因，及后续规避的办法，总结积累的经验等</li></ol><blockquote><p>以上各阶段并不是完全串行推进的，相互之间存在一些穿插，比如下一版本需求的收集整理与当前版本的开发是并行推进的，开发与测试也可以以分阶段转测的形式并行推进，等等。</p></blockquote><h2 id="3-一些常用工具"><a href="#3-一些常用工具" class="headerlink" title="3. 一些常用工具"></a>3. 一些常用工具</h2><ol><li>jira 用于项目任务管理，其中Agile插件可方便查看整体任务面板，对任务状态一目了然，需要求团队成员养成及时更新状态的习惯</li><li>confluence 文档管理，用于各类文档的集中化维护，以上所述的如需求文档、开发设计文档、转测文档、上线文档等均可使用confluence以项目空间的形式集中化管理。</li><li>gitlab 代码管理</li><li>jenkins 项目部署构建工具</li><li>nexus 搭建maven私有库</li></ol><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>团队工作讲求步调与节奏，好的流程与规范可以让一个水平一般的人也能充分发挥其作用，从而让团队整体稳步前进，高效产出。而不好的流程，或根本不重视流程的团队，却往往一盘散沙，甩锅与抱怨充斥，战斗力低下。本文以相对较粗粒度对软件项目的基本流程管理做了介绍，更细节的内容可能需要团队根据内部具体情况进行相应处理与对待。链接： <a href="https://pan.baidu.com/s/1WBHsIWoquKTQHJ6IaSql3Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1WBHsIWoquKTQHJ6IaSql3Q</a>  是笔者基于以前团队敏捷项目管理及一些具体问题的思考分享PPT，供参考。提取码：awya </p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在软件项目研发管理过程中，是否经常出现这样的场景：开发人员不知道什么时候转测；项目经理拿个Excel文档群里一发，某任务前天就应该完成的，怎么现在还没开始搞；前端问这部分UI是谁在做，什么时候能做完；测试说线上这个bug又是谁改出来的，这次没转测这模块……等等。整个协作感觉一团乱麻，团队内部充满了甩锅与抱怨的氛围。软件项目的研发流程该怎么规范，让团队成员都能目标明确，步调一致，让产品迭代充满节奏感。本文基于笔者项目研发管理经验整理，希望起到抛砖引玉的作用，探讨高效团队的协作流程模式。&lt;br&gt;
    
    </summary>
    
      <category term="teamwork" scheme="http://blog.jboost.cn/categories/teamwork/"/>
    
    
      <category term="agile" scheme="http://blog.jboost.cn/tags/agile/"/>
    
  </entry>
  
</feed>
