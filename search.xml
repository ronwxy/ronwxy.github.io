<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发人员需要掌握的日常Linux命令集</title>
      <link href="/linux-cmd.html"/>
      <url>/linux-cmd.html</url>
      
        <content type="html"><![CDATA[<p>不会运维的开发不是好测试。<br><a id="more"></a></p><p>本文整理了开发人员日常用到的linux相关命令，供参考。</p><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p><code>cd</code> # 进入某个目录，不接参数进入当前用户目录（等同于cd ~），如/home/devuser，可接绝对路径或相对路径（../..表示上上级目录），也可以接 “-” 回到上次所在目录</p><p><code>pwd</code> # 显示当前所在目录</p><p><code>ls -la</code> # 列出当前目录所有对象，-a表示包含以.开头的隐藏文件或目录<br><code>ll -h</code> # ll 等同于 ls -l， -h表示按K M G 显示文件大小</p><p><code>df -h</code> # 显示系统各盘符的空间使用情况<br><code>du -h --max-depth=1</code> # 显示当前目录下各文件大小，–max-depth=1只列出当前目录下的文件或目录，不会列出子目录下的文件</p><p><code>mv test.log /home/devuser/</code> # 移动文件（夹） 或重命名</p><p><code>cp [-r] test test.bak</code> # 复制文件，如果是文件夹则加 -r，表示复制文件夹下所有子文件夹内容<br><code>rm -[r]f /home/devuser/</code> # 删除文件，如果删除文件夹则加 -r </p><p><code>find / -name test.log</code> # 在根目录下查找文件名为test.log的文件<br><code>find /var/log/ -size +50M -exec rm -f {} \;</code> # 在/var/log/目录下查找大于50M的文件并删除，建议先将rm改为ls确认<br><code>find /var/log/ -type f -atime +10</code> # 搜索在过去10天内未被使用过的文件<br><code>find /var/log/ -type f -mtime -10</code> # 搜索在10天内被创建或者修改过的文件<br><code>find /var/log/ -type f -atime +10|xargs rm -f</code> # |xargs 作用与 -exec类似<br><code>find ./ -name &quot;*.log&quot; -exec &#39;cat&#39; {} \; &gt; test.log</code> # 将当前目录下所有.log文件内容合并到一个文件test.log</p><p><code>which java</code> # 在系统PATH路径下查找java可执行文件<br><code>whereis java</code> # 查找二进制、源文件、man文件，从文件索引中查找，而不仅仅从PATH路径下查找</p><p><code>zip test.zip test.log test2.log</code> # 创建一个zip格式的压缩包，可以接多个文件或文件夹<br><code>zip -r file.zip file1 file2 dir1</code> # 将几个文件和目录同时压缩成一个zip格式的压缩包<br><code>unzip test.zip</code> # 解压一个zip格式压缩包</p><p><code>tar -zcvf test.tar.gz</code> 要被压缩的文件名或目录 # 以gzip进行压缩 -z 按gzip，-c 压缩，-v 显示内容 -f 指定文件名<br><code>tar -zxvf test.tar.gz -C 解压缩到的目录</code> # 解压到指定目录 -x 解压<br><code>tar -ztvf test.tar.gz</code> # 不解压，只查看内容</p><p><code>tar -jcvf test.tar.bz2 要被压缩的文件名或目录</code> # 以bzip2进行压缩<br><code>tar -jxvf test.tar.bz2 -C 解压缩到的目录</code> # 解压到指定目录</p><h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><p><code>touch test.log</code> # 创建空文件<br><code>echo -e &#39;abc\ncba&#39;&gt; test.log</code> # 覆盖的形式往文件写入内容 -e 解析转移字符，不然当成字符串<br><code>echo &#39;aaa&#39; &gt;&gt; test.log</code> # 追加的形式往文件写入内容</p><p><code>cat [-n] test.log |grep [-v] abc</code> # 过滤文件中包含 abc 的行， 加-v表示不包含， -n表示打印行号<br><code>cat test.log |grep  abc|wc -l</code> # 计算文件中包含 abc 的行数</p><p><code>head -n 2 test.log</code> # 查看一个文件的前两行<br><code>tail -n 2 test.log</code> # 查看一个文件的最后两行<br><code>tail -n +1000 test.log</code> # 从1000行开始显示，显示1000行以后的<br><code>cat test.log | head -n 2000 | tail -n +1000</code> # 显示1000行到2000行的<br><code>cat test.log | tail -n +1000 | head -n 1000</code> # 从第1000行开始，显示1000行</p><p><code>more test.log</code> # 一页一页地查看文件内容，空格键往后一页，B键往前一页，不能通过上下键控制翻滚，会一次加载整个文件<br><code>less test.log</code> # 一页一页地显示文件内容，可以通过上下键控制往前往后翻，可以向上向下搜，不需一次加载整个文件，所以速度比more快，“less is more”， less比more更强大</p><p><code>tail -200f test.log</code> # 查看最后200行，根据文件描述符进行追踪，当文件改名或被删除，追踪停止<br><code>tail -F test.log</code> # 查看最后10行，只要对应文件名存在，就保持监视，即使文件被删除或改名后，如果再次创建相同的文件名，也会继续追踪</p><p><code>grep abc test.log</code> # 在文件中查找关键词”abc”，类似于 <code>cat test.log|grep abc</code><br><code>grep ^abc test.log</code> # 在文件中查找以”abc”开始的词汇<br><code>grep [0-9] test.log</code> # 选择文件中所有包含数字的行<br><code>grep abc -R /var/log</code>/* # 在目录 ‘/var/log’ 及随后的目录中搜索字符串”abc”</p><p><code>sed &#39;s/abc/ccc/g&#39; test.log</code> # 将test.log文件中的 “abc” 替换成 “ccc”并打印，不改变原有文件<br><code>sed &#39;/^$/d&#39; test.log</code> # 从文件中删除所有空白行并打印，不改变原有文件</p><p><code>paste test.log test2.log</code> # 按两列合并两个文件每行的内容并打印，test.log在左边，test2.log在右边<br><code>paste -d &#39;+&#39; file1 file2</code> # 合并两个文件每行的内容并打印，中间用”+”拼接</p><p><code>sort test.log</code> # 对文件内容进行排序，每行首字母排序<br><code>sort test.log test2.log</code> # 排序两个文件的内容<br><code>sort test.log test2.log | uniq</code> # 取出两个文件的并集(重复的行只保留一份)<br><code>sort test.log test2.log | uniq -u</code> # 删除交集，留下其他的行<br><code>sort test.log test2.log | uniq -d</code> # 取出两个文件的交集(同时存在于两个文件中的行)</p><p># comm 类似于集合的差集运算，需要两个文件都是排序的<br><code>comm -1 test.log test2.log</code> # 比较两个文件的内容只删除test.log所包含的内容<br><code>comm -2 test.log test2.log</code> # 比较两个文件的内容只删除test2.log所包含的内容<br><code>comm -3 test.log test2.log</code> # 比较两个文件的内容删除两个文件共有的内容</p><h2 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h2><p><code>chmod +x test.sh</code> # 为一个文件增加可执行权限<br><code>chmod ugo+rwx test.sh</code> # 设置文件的所有者(u)、群组(g)以及其他人(o)读（r，4 ）、写(w，2)和执行(x，1)的权限，+ 改为 - 即删除权限<br><code>chmod 755 test.sh</code> # 对文件所有者，群组，其他人分别设置7（rwx=4+2+1），5（rx=4+1）,5（rx=4+1）的权限</p><p><code>chown [-R] 用户名:群组名 test.log</code> #改变一个文件的所有者和群组，如果是作用于文件夹下所有文件或目录，则加 -R<br><code>chgrp 群组名 test.log</code> # 改变文件的群组</p><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><p><code>top</code> # 实时显示系统中各个进程的资源占用状况<br><code>top -H -p 进程号</code> # 列出进程的所有线程，按1键根据CPU占有率排序<br><code>ps -ef|grep 进程名称</code> # 查看某个进程，一般用户找进程ID<br><code>kill -9 进程ID</code> # 停止某个进程<br><code>jps</code> # 查看所有java进程</p><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><p><code>ifconfig</code> # 查看系统各网卡信息（IP，mac地址，子网掩码等）<br><code>ss -s</code> # 查看当前系统tcp、udp连接数</p><p><code>netstat -ano|grep 端口号</code> # 查看某个端口是否起来<br><code>lsof -i:端口号</code> # 查看某个端口对应的进程信息，lsof可能需要额外安装 （sudo yum install lsof）</p><p><code>ssh devuser@192.168.40.206</code> # 远程连接另一台linux主机</p><p><code>curl http://www.baidu.com</code> # get方式请求某个地址<br><code>curl -i -X POST -H &quot;Content-type:application/json&quot; -d &#39;{&quot;a&quot;:&quot;x&quot;,&quot;b&quot;:[&quot;y&quot;]}&#39;  http://xxx</code> # POST方式请求某个接口</p><p><code>wget http://xxx.zip</code> # 下载文件</p><p><code>scp test.log devuser@192.168.40.206:/home/devuser/</code># 传输文件到另一台主机的目录下，如果是文件夹则加 -r<br># nc 传输，可用于文件传输（scp需要密码，nc不需要密码），需要安装 sudo yum install nc<br><code>nc -l 1234 &gt; test.log</code> # 接收方，监听1234端口，将接收内容存于test.log<br><code>nc 192.168.40.205 1234 &lt; test.log</code> # 发送方，向接收方(ip为192.168.40.205)发送test.log的内容</p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><p><code>top</code> # 查看CPU、内存使用情况，即各进程使用情况<br><code>free -g</code> # 查看内存使用情况<br><code>date</code> # 查看系统当前时间<br><code>uptime</code> # 查看当前CPU使用负载情况，及系统已运行时间，相当于top的第一行<br><code>su</code> # 切换到root用户<br><code>su devuser</code> # 切换到devuser用户<br><br><br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s云集群混搭模式，可能帮你节省50%的服务成本</title>
      <link href="/mix-eci.html"/>
      <url>/mix-eci.html</url>
      
        <content type="html"><![CDATA[<p>现在大部分中小企业或团队都是使用云平台来部署自己的服务，如阿里云，亚马逊云等。一般来说，业务的负载都具备一定的规律，比如每天集中在某几个小时，或呈现时间段周期性波峰、波谷交替的现象，如下图<br><img src="/assets/load-trend.png" alt="业务负载周期性"></p><p>如果使用ECS来部署服务，则可能大部分时间ECS的资源没有得到充分利用，造成成本浪费，尤其对于像GPU之类成本较高的资源就更加了。这个时候，我们可以考虑使用云集群的混搭模式来节约成本。</p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>假设有一个这样的业务场景，包括如下特点及要求：</p><ol><li>整个系统包括业务服务与两层视觉服务</li><li>各层服务之间调用需做负载均衡</li><li>每天的业务量主要集中在上午几个小时</li><li>平时业务量较低时仍要保证服务可用</li><li>尽可能降低成本，尤其是GPU服务器成本（GPU贵啊）</li></ol><p><img src="/assets/biz-top.png" alt="业务部署架构"></p><h2 id="k8s云集群混搭模式"><a href="#k8s云集群混搭模式" class="headerlink" title="k8s云集群混搭模式"></a>k8s云集群混搭模式</h2><p>现在各大云平台都已经提供容器云服务，如阿里云有基于ECI（弹性容器实例）的Serverless Kubernetes集群服务，基于ECS节点不需要提供master的Kubernetes托管版集群服务，及自己提供master的Kubernetes专有版集群服务等。为了迎合类似上述业务场景的需求，也提供了Kubernetes + virtual node（虚拟节点）的混合集群服务，如下图所示</p><p><img src="/assets/k8s-vn.png" alt="k8s-vn"></p><p>其中的虚拟节点基于ECI支持多种功能，如GPU容器实例、大规格容器实例等，增强了Kubernetes集群的弹性，使集群不局限于ECS节点的资源，做到弹性无限扩容。</p><h2 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h2><p>结合前面的业务场景，我们可以采用k8s的混合集群服务来部署我们的项目，如下图</p><p><img src="/assets/biz-deploy.png" alt="biz-deploy"></p><p>实现步骤：</p><ol><li>创建Kubernetes托管版集群</li><li>加入已有ECS节点</li><li>添加一个虚拟节点，通过添加应用 ack-virtual-node 来实现</li><li>分别创建无状态的业务Deployment、AI-1 Deployment、AI-2 Deployment（对应三层服务）</li><li>分别在业务Deployment上创建公网SLB，AI-1 Deployment、AI-2 Deployment上创建内网SLB</li><li>分别在各Deployment上根据CPU或内存使用阈值配置弹性水平伸缩HPA</li><li>根据需要可以在某个或某些Deployment上配置定时伸缩，通过添加应用 ack-kubernetes-cronhpa-controller 来实现</li></ol><blockquote><p>因为水平伸缩一般需要一定时间，延迟可能会对业务造成影响，所以在业务负载比较规律的时候，可以通过定时伸缩（就是定时扩展到多少个容器，再定时收缩到多少个容器）来改善；目前定时伸缩配置的查看与更新只能通过kubectl命令行进行。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按照官方文档的计费方式，一个普通的2核8G的ECS一年大概费用是2600左右，如果通过容器服务的方式（按秒计费），假设每天起8小时，则一年大概费用1550左右，如果业务负载再集中到几个小时，费用会更低，对于比较稀缺又昂贵的GPU服务就更加了。但是如果服务全部按容器24小时租赁，其成本就又比ECS贵了（一年约4600），所以在平时业务负载较低的时候，可以将容器调度到ECS上保障服务的提供，业务负载高时，通过HPA或cronHPA的方式动态伸缩到虚拟节点上。对于业务负载具有一定规律的服务来说，采用这种混搭的部署方式将极大地降低你的云服务成本。不过目前k8s云集群服务应该推出时间不久，产品的易用性还比较低，对不具备一定容器与编排基础的人使用门槛相对较高。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技巧：如何自定义logback日志文件的名称</title>
      <link href="/trick-logback-prop.html"/>
      <url>/trick-logback-prop.html</url>
      
        <content type="html"><![CDATA[<p>在logback.xml中获取自定义变量值。<br><a id="more"></a></p><p>我们可以通过在logback.xml中配置appender来指定日志输出格式及输出文件路径，这在一台主机或一个文件系统上部署单个实例没有问题，但是如果部署多个实例（比如通过容器的方式），多个实例同时往同一文件写日志可能就会引起问题。这时可以将每个实例的日志文件加以区分，如IP或UUID，或两者结合的形式。</p><p>可以有4种方式来实现logback.xml中获取自定义变量值：</p><ol><li>通过设置环境变量或传递系统属性（比如在程序启动时通过-D传递）的方式，两者是可以直接在logback.xml中通过 <code>${变量名}</code> 获取的。</li><li>自定义logback.xml的加载时机，在其加载前将需要设置的属性注入到logback的context中，这种方式相对复杂，本文不讨论。</li><li>通过实现PropertyDefiner接口来提供属性值设置</li><li>通过实现LoggerContextListener接口来设置属性值</li></ol><p>第一种方式简单，但不能通过程序生成属性值，第二种方式稍显复杂，本文主要介绍后两种方式。</p><h2 id="PropertyDefiner方式"><a href="#PropertyDefiner方式" class="headerlink" title="PropertyDefiner方式"></a>PropertyDefiner方式</h2><p>首先定义一个类，实现PropertyDefiner接口，可以通过继承PropertyDefinerBase会更方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.core.PropertyDefinerBase;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 将本地IP拼接到日志文件名中，以区分不同实例，避免存储到同一位置时的覆盖冲突问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20 16:17   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPLogDefiner</span> <span class="keyword">extends</span> <span class="title">PropertyDefinerBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(IPLogDefiner.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUniqName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String localIp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            localIp = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">"fail to get ip..."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        String uniqName = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (localIp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqName = localIp + <span class="string">"-"</span> + uniqName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPropertyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getUniqName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现方法 <code>getPropertyValue</code> 中返回你需要生成的值，本例中是返回 <code>本地IP-UUID</code> 的形式。</p><p>然后在logback.xml中，添加 <code>&lt;define&gt;</code> 配置，指定属性名（本例中为localIP）及获取属性值的实现类，这样就可以在配置中通过 <code>${localIP}</code>来引用该属性值了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">define</span> <span class="attr">name</span>=<span class="string">"localIP"</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.IPLogDefiner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLogFile"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>D:\\logs\\elk\\interface-$&#123;localIP&#125;.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"># 省略了其它配置</span><br></pre></td></tr></table></figure></p><h2 id="LoggerContextListener方式"><a href="#LoggerContextListener方式" class="headerlink" title="LoggerContextListener方式"></a>LoggerContextListener方式</h2><p>定义一个实现LoggerContextListener接口的类，在start方法中，将需要设置的属性设置到logback的Context中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Level;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.spi.LoggerContextListener;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.Context;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.spi.ContextAwareBase;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.spi.LifeCycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 第二种实现方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20 18:45   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerStartupListener</span> <span class="keyword">extends</span> <span class="title">ContextAwareBase</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LoggerContextListener</span>, <span class="title">LifeCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (started) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        context.putProperty(<span class="string">"localIP"</span>, getUniqName());</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUniqName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String localIp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            localIp = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">//LOG.error("fail to get ip...", e);</span></span><br><span class="line">        &#125;</span><br><span class="line">        String uniqName = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (localIp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqName = localIp + <span class="string">"-"</span> + uniqName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//省略了其它函数</span></span><br></pre></td></tr></table></figure><p>然后在logback.xml中，配置如上监听器类，这样就可以通过 <code>${localIP}</code> 获取到上面 <code>context.putProperty(&quot;localIP&quot;, getUniqName());</code> 设置的值了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;define name="localIP" class="com.cnbot.common.IPLogDefiner"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextListener</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.LoggerStartupListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">define</span> <span class="attr">name</span>=<span class="string">"localIP"</span> <span class="attr">class</span>=<span class="string">"com.cnbot.common.IPLogDefiner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLogFile"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>D:\\logs\\elk\\interface-$&#123;localIP&#125;.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"># 省略了其它配置</span><br></pre></td></tr></table></figure></p><p>这种方式能设置任意个数的属性值，比前一种方式灵活。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在logback.xml中获取自定义属性值，主要是需要在加载前将对应的属性值进行设置，这样加载时才能有效获取。本文虽是自定义日志文件名称，但不局限于此，所有需要动态获取的变量都可以按这种方式实现。</p><p><br><br>欢迎关注我的微信公众号：jboost-ksxy<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记（八）：数据管理</title>
      <link href="/docker-8.html"/>
      <url>/docker-8.html</url>
      
        <content type="html"><![CDATA[<p>前面（哪个前面我也忘了）有说过，如果我们需要对数据进行持久化保存，不应使其存储在容器中，因为容器中的数据会随着容器的删除而丢失，而因通过将数据存储于宿主机文件系统的形式来持久化。在Docker容器中管理数据主要有数据卷、宿主机目录挂载两种方式<br><a id="more"></a></p><h2 id="1-数据卷的方式"><a href="#1-数据卷的方式" class="headerlink" title="1. 数据卷的方式"></a>1. 数据卷的方式</h2><p>数据卷是一个特殊的文件目录（或文件），具备如下特性：</p><ol><li>可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>数据卷的更新，不会影响到镜像</li><li>数据卷默认会一直存在，不会随容器的删除而消亡</li></ol><h3 id="1-1-创建数据卷"><a href="#1-1-创建数据卷" class="headerlink" title="1.1 创建数据卷"></a>1.1 创建数据卷</h3><p>可以使用<code>docker volume create 数据卷名称</code>的命令来创建一个数据卷，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume create volume1</span><br><span class="line">volume1</span><br></pre></td></tr></table></figure></p><h3 id="1-2-查看数据卷"><a href="#1-2-查看数据卷" class="headerlink" title="1.2 查看数据卷"></a>1.2 查看数据卷</h3><p>创建完后，这个数据卷具体对应宿主机哪个文件目录在上面是没法得知的，可以通过<code>docker volume inspect 数据卷名称</code>来查看，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume inspect volume1</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "CreatedAt": "2019-08-12T19:43:47+08:00",</span><br><span class="line">        "Driver": "local",</span><br><span class="line">        "Labels": &#123;&#125;,</span><br><span class="line">        "Mountpoint": "/var/lib/docker/volumes/volume1/_data",</span><br><span class="line">        "Name": "volume1",</span><br><span class="line">        "Options": &#123;&#125;,</span><br><span class="line">        "Scope": "local"</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可以看到数据卷volume1对应的文件目录是“/var/lib/docker/volumes/volume1/_data”。</p><p><code>docker inspect xxx</code>这个命令挺有用的，不论是查看镜像相关信息（<code>docker image inspect 镜像名/镜像ID</code>），还是查看容器相关信息（<code>docker container inspect 容器名/容器ID</code>），都可以使用，其中的image,container,volume是可以省略的，只要xxx部分不冲突就行。</p><p>可以通过<code>docker volume ls</code> 命令来查看所有数据卷，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               volume1</span><br></pre></td></tr></table></figure></p><h3 id="1-3-使用数据卷"><a href="#1-3-使用数据卷" class="headerlink" title="1.3 使用数据卷"></a>1.3 使用数据卷</h3><p>可以在启动容器时通过 -v 或 –mount 的方式将一个数据卷挂载到容器的某个目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu1 -v volume1:/vol1 ubuntu:18.04</span><br><span class="line">b060e793d44de2ca871da257b47598334658952943a13d1c478df5c3ae91a01c</span><br></pre></td></tr></table></figure></p><p>按照 <code>-v 数据卷名:容器目录</code> 的格式，也可以使用 –mount 按照 <code>--mount source=数据卷名,target=容器目录</code> 的格式，如我们再启动一个挂载相同数据卷的容器 ubuntu2，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount source=volume1,target=/vol2 ubuntu:18.04</span><br><span class="line">b30971f8a4bbadee10774fce0b4568b5b7b1c9cde36f4bf84ac911a4cdaf6c8d</span><br></pre></td></tr></table></figure></p><p>可以在数据卷所在目录中创建一个文件来看看效果，先创建文件 hello.txt<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# cd /var/lib/docker/volumes/volume1/_data</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ _data]# touch hello.txt</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ _data]# ls</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>然后通过<code>docker exec</code>来查看容器ubuntu1目录/vol1，及容器ubuntu2目录/vol2的内容<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu1 ls /vol1</span><br><span class="line">hello.txt</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu2 ls /vol2</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>可以看到通过挂载目录 /vol1， /vol2 都可以访问到数据卷volume1对应目录下的内容。这就像linux的软链接一样，将容器目录链接到了数据卷目录。并且上述示例也说明，同一个数据卷是可以在被多个容器共享的。</p><p>数据卷的共享也可以通过 <code>volumes-from 容器名称/容器ID</code> 参数来实现，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu3 --volumes-from ubuntu2 ubuntu:18.04</span><br><span class="line">bb5c6d61a1e6eeb18ba8c889e471b2f3215f97efca79b311eeca5968b2700df8</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu3 ls /vol2</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure></p><p>通过<code>--volumes-from ubuntu2</code>来直接使用ubuntu2挂载的容器配置。</p><h3 id="1-4-删除数据卷"><a href="#1-4-删除数据卷" class="headerlink" title="1.4 删除数据卷"></a>1.4 删除数据卷</h3><p>数据卷不会随着容器的删除而自动删除。<br>如果一个数据卷还被某个容器使用，则不能删除；<br>如果一个数据卷只被一个容器使用，则可在删除容器时通过指定 <code>-v</code> 参数同时删除其挂载的数据卷；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker rm -v ubuntu3</span><br><span class="line">ubuntu3</span><br></pre></td></tr></table></figure></p><p>可以通过 <code>docker volume rm 数据卷名称</code> 来删除某个数据卷；<br>可以通过 <code>docker volume prune</code> 清理掉所有未被任何容器使用的数据卷。</p><h2 id="2-宿主机目录挂载方式"><a href="#2-宿主机目录挂载方式" class="headerlink" title="2. 宿主机目录挂载方式"></a>2. 宿主机目录挂载方式</h2><p>在容器启动时，使用 <code>-v 宿主机目录:容器目录</code> 或 <code>--mount type=bind,source=宿主机目录,target=容器目录</code>的参数格式指定将宿主机目录挂载到容器目录上。宿主机目录必须是绝对路径。两者之间的区别是 <code>-v</code> 如果在宿主机目录不存在时会自动创建目录，而<code>--mount</code>不会。如，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu1 -v /root/v1:/vol1 ubuntu:18.04</span><br><span class="line">25c91911709eebc9290b47b483666f7b7be840df947117f7cad323583905b9f1</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount type=bind,source=/root/v2,target=/vol1 ubuntu:18.04</span><br><span class="line">docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /root/v2.</span><br><span class="line">See 'docker run --help'.</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# mkdir /root/v2</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu2 --mount type=bind,source=/root/v2,target=/vol1 ubuntu:18.04</span><br><span class="line">5a57285e9261d048dc71cf0476055a290f80538afff2cefd2a24f8b4468b5171</span><br></pre></td></tr></table></figure></p><p>/root/v1,/root/v2都没有事先创建，用 <code>-v</code> 不会报错，会自动创建； <code>--mount</code>则会报错，目录必须先存在。</p><p>docker不仅支持目录的挂载，也支持文件的挂载，如，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run --rm -it -v $HOME/.bash_history:/root/.bash_history ubuntu:18.04 bash </span><br><span class="line">root@3ae4ed4e687d:/# history</span><br><span class="line">    1  ll webapps/</span><br><span class="line">    2  ll confluence/images/</span><br></pre></td></tr></table></figure></p><p>通过将宿主机当前用户的历史操作文件挂载到容器的root用户下的历史操作文件，可在容器中通过<code>history</code>命令查看到宿主机的操作历史。</p><p>可通过 <code>docker inspect</code>来查看容器的挂载情况<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker inspect ubuntu1</span><br><span class="line">--省略了其它信息--</span><br><span class="line">"Mounts": [</span><br><span class="line">            &#123;</span><br><span class="line">                "Type": "bind",</span><br><span class="line">                "Source": "/root/v1",</span><br><span class="line">                "Destination": "/vol1",</span><br><span class="line">                "Mode": "",</span><br><span class="line">                "RW": true,</span><br><span class="line">                "Propagation": "rprivate"</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">--省略了其它信息--</span><br></pre></td></tr></table></figure></p><p>可在“Mounts”部分看到挂载信息。</p><h2 id="3-只读控制"><a href="#3-只读控制" class="headerlink" title="3. 只读控制"></a>3. 只读控制</h2><p>有时候，为了数据安全，我们不允许容器对挂载目录的内容进行修改，即对容器来说，挂载目录是只读的，这可以通过在挂载参数后面加限制实现。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker run -dit --name ubuntu3 -v /root/v1:/vol1:ro ubuntu:18.04</span><br><span class="line">25eca348ed307afcbef92bc03f0a1304b31b52e6db1fa07772b5dbd1040ff7b6</span><br><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker exec -it ubuntu3 bash</span><br><span class="line">root@25eca348ed30:/# touch /vol1/hello.txt</span><br><span class="line">touch: cannot touch '/vol1/hello.txt': Read-only file system</span><br></pre></td></tr></table></figure></p><p><code>-v</code>是在后面加<code>ro</code>（read-only），<code>--mount</code>则是形如<code>--mount type=bind,source=宿主机目录,target=容器目录,read only</code>的格式，可自行试验。<br>加了read only的挂载我们再通过<code>docker inspect</code>命令查看，可看到两者之间的差异 —— Mode与RW的值。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">            &#123;</span><br><span class="line">                "Type": "bind",</span><br><span class="line">                "Source": "/root/v1",</span><br><span class="line">                "Destination": "/vol1",</span><br><span class="line">                "Mode": "ro",</span><br><span class="line">                "RW": false,</span><br><span class="line">                "Propagation": "rprivate"</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>如果要对数据进行持久化管理或在容器之间共享数据，则需要将数据通过数据卷或宿主机目录（或文件）挂载的方式来将数据存储于宿主机上，使得数据的生命周期独立于容器的生命周期。这类似于我们不要把重要文件放在系统盘，而应放在其它数据盘一样，因为系统盘会由于重装系统或系统故障导致文件丢失。本文对Docker的数据管理进行了整理，后续对Docker的网络配置管理部分进行整理，欢迎持续关注。</p><p><br><br>我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>就业，该去小公司还是大公司？</title>
      <link href="/company-choice.html"/>
      <url>/company-choice.html</url>
      
        <content type="html"><![CDATA[<p>前几天跟一朋友交流，他说一个表弟明年就要毕业了，马上面临找工作，是去一线城市找大公司的工作好，还是留在二线城市中小公司发展好。我说，去大公司好。为什么会有这个结论，这篇文章结合自己的经历说说我的一些感受。<br><a id="more"></a></p><p>我的第一份工作是在一家外企，当时抱着“逃离”上海的想法去了二线城市的分公司，但是管理文化氛围跟总部几乎都是一样的，这份工作经历对我后面的工作不论是做事风格、习惯上还是思考问题的方式方法上都有很大的影响。后面陆续进入国企，民企，再进入初创公司，从公司规模上可以说各种类型的都有过体验。下面从环境因素，平台效应因素等几个角度说说自己的感受。</p><h2 id="环境因素"><a href="#环境因素" class="headerlink" title="环境因素"></a>环境因素</h2><p>环境对一个人的影响还是很重要的，不论是大家熟知的“近朱者赤近墨者黑”的说法，还是令我们中国人挤破脑袋的“学区房”现象，都说明环境对一个人的成长起着至关重要的作用。</p><p>小公司与大公司的环境差异首先体现在人员的素养、水平上。大公司的准入门槛相对高一些，所以人员的素质、水平也相对要高一些，如果你周围牛人比较多的话，跟牛人待久了，你也可能慢慢就步入牛人之列了——“近朱者赤”。而小公司，尤其是初创公司，为了尽快招人干活，往往人员的素质、水平会良莠不齐，你可能很难找到一个各方面让你信服，想跟着他学的真正的“牛人”。</p><p>其次在制度、流程规范上。大公司在制度、流程、规范方面相对健全完善，不论是人事管理还是日常合作分工都比较明确，你知道什么时候应该干什么（因为都给你安排好了），处理什么事情应该找谁，都有章可循，有人可找。而在小公司，可能很多人感觉的就一个字——“乱”，人员职责、分工、权限没有明确定义，没有人引导，不知道在什么阶段应该干什么，或者怎么干，明明是个小兵，老板却恨不得你是个全才，啥事都希望你能搞定。有人把在大公司工作比喻是做一颗螺丝钉，而觉得在小公司才能锻炼综合能力，但我觉得在一定的阶段，螺丝钉似的工作才能让你在专业能力上面得到更大的提升，而小公司所谓的综合能力，往往演变的是“打杂”能力，老板为了节约成本，充分发挥（压榨）每个人的能力（价值），往往一人要分饰多角，比如做人事的既要管招聘，又要管行政，甚至还可能被拉去监督项目进度，很难让你在一个专业的领域深度成长。</p><p>再次在产品规模上，大公司产品的日活规模可能少则上百万，多则上亿，不论是在技术实现还是产品运营上，都需要较高的要求与水准，你在其中能学习的技能与套路是小公司日活几千或几万的产品规模无法比拟的。</p><p>最后在文化氛围上，一般大公司都有形成自己的企业文化，包括周围人的工作风格、习惯，都会对你产生潜移默化的影响。比如我现在的不论是写代码，还是写文字，都会反复检查好几遍的习惯就是在第一家公司工作时养成的。因为你的每一行代码你的leader可能都会仔细帮你review，找出有问题的地方让你反复修正直到合格，你的每一封邮件都会被别人（在外企很多时候还包括美国人、印度人）认真查看，所以促使你在发出前会仔细核查是否有遗漏的点，是否存在错别字或语法错误，久而久之，就养成了这种反复检查的比较严谨的做事风格。而在小公司，一般很难在短时间内形成自己的企业文化，很多事情的处理都比较粗放，缺乏对细节的把握，你很难从企业文化氛围上受益。</p><p>如果用游泳来比喻大公司与小公司的差异，我觉得大公司就像是一个掌握各项泳姿、动作标准的游泳运动员，有规范有节奏，从而游得更远；而小公司则更像一个会“狗爬式”的乡下野孩子，虽然路子野，但有效——尽管比较费力，但是能游起来，但能游多远，得看方向对不对，人能不能坚持。</p><h2 id="平台效应因素"><a href="#平台效应因素" class="headerlink" title="平台效应因素"></a>平台效应因素</h2><p>现在有些企业招聘，都明确要求毕业院校必须是985、211，甚至有些岗位直接面向BAT。前不久看到一个案例，上海交大硕博毕业因本科不是211，而被招聘企业直接拒绝。<br><img src="/assets/case-10.jpg" alt="case1">    <img src="/assets/case-11.jpg" alt="case2"></p><p>现实就是这样，看背景，看出身。名企工作与名校毕业一样，对后面的跳槽都会有较大的加分与优势。从小公司跳大公司难，但从大公司跳小公司就容易很多，见过许多阿里系的普通技术人员跳到中小企业做技术管理者的情况。</p><p>名企光环，除了对后面的就业与跳槽方面具备优势，在社会活动上也具备一定的优势，比如现在很多技术书籍，相当一部分出自阿里系，不是说非阿里系的人不具备这个能力，而是因为有着阿里这个名企光环，出的东西更容易被人接受与认可，尽管不一定水平有多好。</p><h2 id="什么人适合去小公司"><a href="#什么人适合去小公司" class="headerlink" title="什么人适合去小公司"></a>什么人适合去小公司</h2><p>毕竟不是每个人都能去大公司，那么什么人适合去小公司呢？我觉得可能主要包括两类，一类是自己在某个领域已经取得了较好的成长，具备了独当一面或者懂得如何带领他人来做事情的能力，这种情况一般是为了追求高薪或对某个领域或公司比较看好，有自己想法的人；另一类是目前还不具备进入大公司的资本与能力的人，人总得工作与生活，所以不得不先进入小公司成长，但这部分人除非自身公司发展特别好，否则还是应该尽力往大公司靠，努力进入大公司体验其管理模式与文化氛围，对你整个职业生涯是有很大帮助的。</p><h2 id="选择什么样的小公司"><a href="#选择什么样的小公司" class="headerlink" title="选择什么样的小公司"></a>选择什么样的小公司</h2><p>选择什么样的小公司比较好，虽然很多时候也没有太多的选择，毕竟好的小公司也是可遇不可求的事情，但如果有的话，我觉得还是尽力选择满足如下四个条件的小公司比较好。</p><ol><li>靠谱的老板。小公司的管理文化与前途基本由老板的品质与能力决定，所以一个有能力、靠谱的老板是第一要素。</li><li>高水平的管理团队，技术、管理、营销各方面。管理团队对于创业公司来说非常重要，只有一个稳定的各方面成熟的团队，成功的几率才会大一点，你在里面能获得的成长空间也更多一些。</li><li>产品项目具备长远发展的潜力。企业经营就是做一个别人愿意花钱购买的产品，并寻找一个将产品源源不断卖不出的方式，所以产品是不是刚需，有没有人买单，能不能长久很重要。</li><li>可靠的资源与渠道。有可靠的资源与渠道，才能将产品源源不断地卖出去，企业才能保持可持续发展。</li></ol><p>以上四点从上往下重要性依次递减，同时满足四个条件的小公司应该是极少的，是可遇不可求的事情，可以按从上往下的重要性进行选择。</p><p>另外进入小公司，可能常见的一个东西是期权，我认为期权是一个美丽的梦，如果以上四点都靠谱，没有期权也能获得很好的锻炼与成长，如果不靠谱，那么就算拿了期权大概率也是一个美丽的梦，看起来很美好，但不会成真的那种，所以面对期权（画饼），也要保持理性。</p><h2 id="职场没有伊甸园"><a href="#职场没有伊甸园" class="headerlink" title="职场没有伊甸园"></a>职场没有伊甸园</h2><p>最后，不论是大公司，还是小公司，都不存在职场的伊甸园，只有自己不断成长，进步，自己强大了，才有更多的选择空间。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
      
      
      <categories>
          
          <category> Career </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记（七）：常用服务安装——Nginx、MySql、Redis</title>
      <link href="/docker-7.html"/>
      <url>/docker-7.html</url>
      
        <content type="html"><![CDATA[<p>开发中经常需要安装一些常用的服务软件，如Nginx、MySql、Redis等，如果按照普通的安装方法，一般都相对比较繁琐 —— 要经过下载软件或源码包，编译安装，配置，启动等步骤，使用 Docker 来安装这些服务软件能极大地简化安装过程，且速度也很快。<br><a id="more"></a></p><p>本文以下操作假定你已经装好了docker，并做好了镜像配置。如果没有，请参考 <a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a></p><h2 id="1-MySql-安装"><a href="#1-MySql-安装" class="headerlink" title="1. MySql 安装"></a>1. MySql 安装</h2><h3 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1 下载镜像"></a>1.1 下载镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull mysql:5.7</span><br></pre></td></tr></table></figure><h3 id="1-2-创建挂载目录"><a href="#1-2-创建挂载目录" class="headerlink" title="1.2 创建挂载目录"></a>1.2 创建挂载目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir -p apps/mysql/conf apps/mysql/data apps/mysql/logs</span><br></pre></td></tr></table></figure><p>如上分别创建了配置文件目录，数据存放目录，以及日志文件目录</p><h3 id="1-3-启动容器实例"><a href="#1-3-启动容器实例" class="headerlink" title="1.3 启动容器实例"></a>1.3 启动容器实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 3306:3306 --name mysql -v /home/devuser/apps/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf -v /home/devuser/apps/mysql/logs:/var/log/mysql -v /home/devuser/apps/mysql/data:/var/lib/mysql --restart=always -e MYSQL_ROOT_PASSWORD=Passw0rd mysql:5.7</span><br></pre></td></tr></table></figure><p>其中<br>-d： 表示在后台运行<br>-p： 宿主机端口与容器端口映射<br>–name： 容器名称<br>-v： 宿主机目录与容器目录映射<br>–restart=always：除非被<code>docker stop</code>命令明确停止，否则一直尝试重启处于停止态的容器；如果Docker重启，也会自动启动容器<br>-e： 设置环境变量，这里设置了mysql root用户的密码为Passw0rd</p><p>如此，MySql服务就跑起来了，很快很简单有木有。</p><h2 id="2-Redis-安装"><a href="#2-Redis-安装" class="headerlink" title="2. Redis 安装"></a>2. Redis 安装</h2><h3 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull redis:5.0.5</span><br></pre></td></tr></table></figure><h3 id="2-2-启动容器"><a href="#2-2-启动容器" class="headerlink" title="2.2 启动容器"></a>2.2 启动容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d --name redis -p 6379:6379 -v /home/devuser/apps/redis/data:/data --restart=always redis:5.0.5 redis-server --appendonly yes --requirepass "Passw1rd"</span><br></pre></td></tr></table></figure><p>-p， -v 与上同，不赘述<br>redis-server –appendonly yes : 在容器启动时执行redis-server命令，并打开redis持久化配置<br>–requirepass： 设置密码</p><h3 id="2-3-连接"><a href="#2-3-连接" class="headerlink" title="2.3 连接"></a>2.3 连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ docker exec -it redis redis-cli -h 172.17.0.4 -p 6379 -a Passw1rd</span><br><span class="line">Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.</span><br><span class="line">172.17.0.4:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">172.17.0.4:6379&gt;</span><br></pre></td></tr></table></figure><p>这种方式把密码暴露了，其它登录用户通过history即可看到密码，不是太安全。可改用如下方式，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~$ docker exec -it redis redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 'Passw1rd'</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><h2 id="3-Nginx-安装"><a href="#3-Nginx-安装" class="headerlink" title="3. Nginx 安装"></a>3. Nginx 安装</h2><h3 id="3-1-拉取镜像"><a href="#3-1-拉取镜像" class="headerlink" title="3.1 拉取镜像"></a>3.1 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker pull nginx</span><br></pre></td></tr></table></figure><p>会拉取最新的（latest）镜像</p><h3 id="3-2-创建目录"><a href="#3-2-创建目录" class="headerlink" title="3.2 创建目录"></a>3.2 创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir -p apps/nginx/html apps/nginx/logs apps/nginx/conf</span><br></pre></td></tr></table></figure><h3 id="3-3-先不指定映射路径启动一个容器"><a href="#3-3-先不指定映射路径启动一个容器" class="headerlink" title="3.3 先不指定映射路径启动一个容器"></a>3.3 先不指定映射路径启动一个容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 80:80 --name nginx nginx</span><br><span class="line">1fdcd13457a6eaacb511878e10d84ffbe48fe63fd1fb3705f58b2d4195b151d8</span><br></pre></td></tr></table></figure><p>这里如果直接指定映射路径运行会报错，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker run -d -p 80:80 --name nginx -v ~/apps/nginx/html:/usr/share/nginx/html -v ~/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/apps/nginx/logs:/var/log/nginx nginx</span><br><span class="line">dab56c13f9e76aad37fcf73411c78d495a6466f1c0d214949650dbae44adddf4</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused "process_linux.go:424: container init caused \"rootfs_linux.go:58: mounting \\\"/home/devuser/apps/nginx/conf/nginx.conf\\\" to rootfs \\\"/home/docker_image/overlay2/e40ccaf4d845a9af92487b47cbc4d505c5c776800ef8887c5b43833b10661427/merged\\\" at \\\"/home/docker_image/overlay2/e40ccaf4d845a9af92487b47cbc4d505c5c776800ef8887c5b43833b10661427/merged/etc/nginx/nginx.conf\\\" caused \\\"not a directory\\\"\"": unknown: Are you trying to mount a directory onto a file (or vice-versa)? Check if the specified host path exists and is the expected type.</span><br></pre></td></tr></table></figure></p><h3 id="3-4-将运行容器的配置文件复制到宿主机目录下"><a href="#3-4-将运行容器的配置文件复制到宿主机目录下" class="headerlink" title="3.4 将运行容器的配置文件复制到宿主机目录下"></a>3.4 将运行容器的配置文件复制到宿主机目录下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker cp 1fdcd13457a6:/etc/nginx/nginx.conf ~/apps/nginx/conf/</span><br></pre></td></tr></table></figure><h3 id="3-5-删除容器并重新运行"><a href="#3-5-删除容器并重新运行" class="headerlink" title="3.5 删除容器并重新运行"></a>3.5 删除容器并重新运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker stop 1fdcd1345</span><br><span class="line">~$ docker rm 1fdcd1345</span><br><span class="line">~$ docker run -d -p 80:80 --name nginx -v ~/apps/nginx/html:/usr/share/nginx/html -v ~/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/apps/nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure><h3 id="3-6-更新配置后重新加载"><a href="#3-6-更新配置后重新加载" class="headerlink" title="3.6 更新配置后重新加载"></a>3.6 更新配置后重新加载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ docker kill -s HUP nginx</span><br></pre></td></tr></table></figure><p>类似于 <code>nginx -s reload</code></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文没有总结。<br><br><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot（十一）：注解结合JWT实现简单的接口鉴权</title>
      <link href="/springboot-simpleauth.html"/>
      <url>/springboot-simpleauth.html</url>
      
        <content type="html"><![CDATA[<p>一般服务的安全包括认证（Authentication）与授权（Authorization）两部分，认证即证明一个用户是合法的用户，比如通过用户名密码的形式，授权则是控制某个用户可以访问哪些资源。比较成熟的框架有Shiro、Spring Security，如果要实现第三方授权模式，则可采用OAuth2。但如果是一些简单的应用，比如一个只需要鉴别用户是否登录的APP，则可以简单地通过注解+拦截器的方式来实现。本文介绍了具体实现过程，虽基于Spring Boot实现，但稍作修改（主要是拦截器配置）就可以引入其它Spring MVC的项目。<br><a id="more"></a></p><h2 id="1-涉及的知识点"><a href="#1-涉及的知识点" class="headerlink" title="1. 涉及的知识点"></a>1. 涉及的知识点</h2><ol><li>注解：用来标记某个接口是否需要登录</li><li>拦截器：拦截所有请求，判断请求的接口是否需要登录验证（基于是否标记了注解），如果需要，验证相应的信息（token），通过则放行，否则返回错误信息</li><li>JWT： Json Web Token，一种流行的认证解决方案，它可以生成携带信息的token，但token一旦生成，其过期时间就不好更新，如果需要实现用户有操作就自动延长过期时间的场景，就相对比较麻烦。我们这里只用来生成token，过期通过redis实现</li><li>RedisTemplate： 将token存在redis中，通过redis的过期机制来控制token的有效期</li><li>ThreadLocal：可以将一次请求中多个环节需要访问的变量通过ThreadLocal来传递，比如userId</li></ol><h2 id="2-依赖配置"><a href="#2-依赖配置" class="headerlink" title="2. 依赖配置"></a>2. 依赖配置</h2><p>在pom.xml中添加JWT与redis依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jwt.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在application.yml配置文件中添加redis相关配置属性<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123654</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">    jedis:</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        min-idle:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        max-idle:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        max-active:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        max-wait:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure></p><h2 id="3-定义注解"><a href="#3-定义注解" class="headerlink" title="3. 定义注解"></a>3. 定义注解</h2><p>注解的定义你可以根据项目的具体场景，比如需要登录的接口比较多，就可以定义如 @SkipAuth 的注解来标记不需要登录的接口，反之，则可以定义如 @NeedAuth 的注解来标记需要登录的接口，总之就是让标记接口这个操作尽可能少。但也可以基于另一种考虑，万一需要登录的接口忘了加不就存在安全问题吗，所以用 @SkipAuth 相对要保险点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SkipAuth &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-定义token管理器"><a href="#4-定义token管理器" class="headerlink" title="4. 定义token管理器"></a>4. 定义token管理器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTokenManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成TOKEN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createToken</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用uuid作为源token</span></span><br><span class="line">        String token = Jwts.builder().setId(userId).setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">            .signWith(SignatureAlgorithm.HS256, JwtConstant.JWT_SECRET).compact();</span><br><span class="line">        <span class="comment">//存储到redis并设置过期时间</span></span><br><span class="line">        redisTemplate.boundValueOps(JwtConstant.AUTHORIZATION + <span class="string">":"</span> + userId)</span><br><span class="line">            .set(token, JwtConstant.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkToken</span><span class="params">(TokenModel model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = redisTemplate.boundValueOps(JwtConstant.AUTHORIZATION + <span class="string">":"</span> </span><br><span class="line">            + model.getUserId()).get();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> || !token.equals(model.getToken())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果验证成功，说明此用户进行了一次有效操作，延长token的过期时间</span></span><br><span class="line">        redisTemplate.boundValueOps(model.getUserId())</span><br><span class="line">            .expire(JwtConstant.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteToken</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        redisTemplate.delete(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在登录接口通过时，调用 <code>createToken</code> 创建token，并保存到redis中，设置过期时间， 在调用未被 @SkipAuth 注解标记的接口时，调用 <code>checkToken</code> 来验证，并更新token的过期时间， 退出登录时，删除token。</p><h2 id="5-定义拦截器"><a href="#5-定义拦截器" class="headerlink" title="5. 定义拦截器"></a>5. 定义拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTokenManager tokenManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                             HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String requestPath = request.getRequestURI().substring(request.getContextPath().length());</span><br><span class="line">        <span class="comment">// 如果不是映射到方法直接通过</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line">        <span class="comment">// 如果方法注明了 SkipAuth，则不需要登录token验证</span></span><br><span class="line">        <span class="keyword">if</span> (method.getAnnotation(SkipAuth.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从header中得到token</span></span><br><span class="line">        String authorization = request.getHeader(JwtConstant.AUTHORIZATION);</span><br><span class="line">        <span class="comment">// 验证token</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(authorization))&#123;</span><br><span class="line">            WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"未提供有效Token！"</span>), response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = Jwts.parser().setSigningKey(JwtConstant.JWT_SECRET)</span><br><span class="line">                .parseClaimsJws(authorization).getBody();</span><br><span class="line">            String userId = claims.getId();</span><br><span class="line">            TokenModel model = <span class="keyword">new</span> TokenModel(userId, authorization);</span><br><span class="line">            <span class="keyword">if</span> (tokenManager.checkToken(model)) &#123;</span><br><span class="line">                <span class="comment">// 通过ThreadLocal设置下游需要访问的值</span></span><br><span class="line">                AuthUtil.setUserId(model.getUserId());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"连接"</span> + requestPath + <span class="string">"拒绝"</span>);</span><br><span class="line">                WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"未提供有效Token！"</span>), response);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"连接"</span> + requestPath + <span class="string">"发生错误:"</span>, e);</span><br><span class="line">            WebUtil.outputJsonString(ApiResponse.failed(<span class="string">"校验Token发生异常！"</span>), response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结束后清除，否则由于线程池复用，导致ThreadLocal的值被其他用户获取</span></span><br><span class="line">        AuthUtil.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器通过对请求方法是否标记注解 @SkipAuth 来判断是否需要进行token验证，如果验证通过，则从JWT token中解析出userId，通过AuthUtil工具方法保存到ThreadLocal中，供下游访问。在请求处理结束调用 <code>afterCompletion</code> 方法中，要清除掉ThreadLocal中的值，否则由于线程池的复用，导致被其他用户获取。</p><p>然后，注册拦截器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AuthInterceptor authInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthInterceptor</span><span class="params">(AuthInterceptor authInterceptor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authInterceptor = authInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注册鉴权拦截器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(authInterceptor)</span><br><span class="line">            .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">"/error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里将 /error 这个接口排除了，因为如果接口处理过程中出现异常，则spring boot会自动跳转到 /error 接口，又会进入拦截器校验（因为/error接口没有标注 @SkipAuth 注解）。</p><h2 id="6-验证"><a href="#6-验证" class="headerlink" title="6. 验证"></a>6. 验证</h2><p>通过以上几步，一个简单的接口认证功能就实现了，我们可以通过添加一个登录接口，两个测试接口（一个需要认证，一个不需要认证）来验证下。<br>登录接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SkipAuth</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">login</span><span class="params">(@RequestBody Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">    String username = MapUtils.getString(params, <span class="string">"username"</span>);</span><br><span class="line">    String password = MapUtils.getString(params, <span class="string">"password"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"ksxy"</span>.equals(username) &amp;&amp; <span class="string">"jboost"</span>.equals(password))&#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(tokenManager.createToken(username));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.failed(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>登录成功后，通过<code>createToken</code>方法创建了JWT token。<br>测试接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SkipAuth</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/skip-auth"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">skipAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ApiResponse.success(<span class="string">"不需要认证的接口调用"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/need-auth"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">needAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiResponse.success(<span class="string">"username: "</span> + AuthUtil.getUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>本文介绍了一个简单的接口认证方案，适用于不需要基于用户角色进行授权的场景。如果有较复杂的授权需求，则还是基于Shiro， Spring Security， OAuth2等框架来实现。这里也可以不用JWT，但是需要自己去做一些处理，比如将userId以某种形式包含在token中，解析时取出。<br>本文完整实例代码：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-simpleauth" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-simpleauth</a><br><br><br><img src="/assets/card-2.png" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老被跨域问题烦？看看都有哪些处理方法</title>
      <link href="/cors.html"/>
      <url>/cors.html</url>
      
        <content type="html"><![CDATA[<p>前面写的《IT技术人员的自我修养》，没想到几天内收到了不少良好的反馈，在此也感谢大家的关注。往后会不定时分享一些技术、管理领域的工作经验总结与感悟，欢迎大家持续关注、交流。最近被问及一个跨域的问题，包括之前面试时发现很多面试者对跨域及其处理也是一知半解，故本文对该问题进行了梳理总结，以供参考。<br><a id="more"></a></p><h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1. 什么是跨域"></a>1. 什么是跨域</h2><p>理解什么是跨域，就要先了解一个叫“同源策略”的东西，什么是“同源策略”？这是浏览器为了网站访问安全，对来自不同源的请求做一些必要的访问限制的一种策略。那什么叫“同源”呢？我们知道，一个http请求地址一般包含四部分：<code>协议://域名:端口/路径</code>，所谓同源，就是前面三者，即协议、域名、端口都一样。举例说明，假如我们有一个地址 <code>http://blog.jboost.cn/docker-1.html</code>， 来看以下地址是否与它同源</p><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">是否同源</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://blog.jboost.cn/docker-1.html">https://blog.jboost.cn/docker-1.html</a></td><td style="text-align:center">不同源</td><td style="text-align:center">协议不同，一个http，一个https</td></tr><tr><td style="text-align:center"><a href="http://www.jboost.cn/docker-1.html" target="_blank" rel="noopener">http://www.jboost.cn/docker-1.html</a></td><td style="text-align:center">不同源</td><td style="text-align:center">域名不同</td></tr><tr><td style="text-align:center"><a href="http://blog.jboost.cn:8080/docker-1.html">http://blog.jboost.cn:8080/docker-1.html</a></td><td style="text-align:center">不同源</td><td style="text-align:center">端口不同，一个是默认端口80，一个是8080</td></tr><tr><td style="text-align:center"><a href="http://blog.jboost.cn/docker-2.html">http://blog.jboost.cn/docker-2.html</a></td><td style="text-align:center">同源</td><td style="text-align:center">虽然路径不同，但协议、域名、端口（默认80）都相同</td></tr></tbody></table><p>那么浏览器对不同源的请求做了哪些访问限制呢？共有三种限制</p><ol><li>对Cookie、LocalStorage，以及IndexDB（浏览器提供的类NoSQL的一个本地数据库）的访问</li><li>对DOM的访问</li><li>AJAX请求</li></ol><p>而跨域就是要打破这种访问限制，对不同源的资源请求也能顺利进行，最常见的就是AJAX请求，比如前后端分离架构中，两者服务域名不同，前端通过AJAX直接访问服务端接口，就会存在跨域问题。</p><h2 id="2-为什么会存在跨域"><a href="#2-为什么会存在跨域" class="headerlink" title="2. 为什么会存在跨域"></a>2. 为什么会存在跨域</h2><p>前面说“同源策略”时已经提到，浏览器是为了网站的访问安全，才设置了跨域这道屏障。那么前面所说的三种限制，分别都是如何来保障网站安全的。</p><ol><li>对本地存储Cookie、LocalStorage、IndexDB的访问限制<br>我们系统的登录凭证一般是通过在Cookie中设置 SESSIONID（如针对浏览器表单请求）或直接返回 token（如针对REST请求）的形式返回给客户端的，比如Tomcat是通过在Cookie中设置名为 JSESSIONID 的属性来保存的，而一般REST请求的token前端会存储于 LocalStorage 中，如果不存在访问限制，则你访问的其它网站可能就会获取到这些凭证，然后伪造你的身份来发起非法请求，这就太不安全了。</li><li>对DOM的访问限制<br>如果不对DOM进行访问限制，那么其它网站，尤其一些钓鱼网站，就可以通过 <code>&lt;iframe&gt;</code> 的形式拿到你访问网站的DOM，进而获取到你输入的一些敏感信息，比如用户名、密码…</li><li>对AJAX请求的限制<br>同源策略规定，AJAX请求只能发给同源的网址，否则就会报错。至于为什么要限制，一方面是避免1中所提到伪造非法请求，另一方面我理解是AJAX过于灵活，如果不做限制，可能网站的接口资源就会被其它网站随意使用，就像你的私有物品被别人招呼都不打任意拿去用一样。</li></ol><p>总之，同源策略是浏览器提供的最基本的一种安全保障机制或约定。</p><h2 id="3-怎么实现跨域访问"><a href="#3-怎么实现跨域访问" class="headerlink" title="3. 怎么实现跨域访问"></a>3. 怎么实现跨域访问</h2><p>我们平常遇到的跨域问题基本都出现在AJAX请求的场景，一般而言，可以通过代理、CORS、JSONP等方式来解决跨域问题。</p><h3 id="3-1-代理"><a href="#3-1-代理" class="headerlink" title="3.1 代理"></a>3.1 代理</h3><p>既然“同源策略”是浏览器端的机制，那我们就可以绕开浏览器，最常见的做法就是使用代理，如 Nginx，比如我们前端项目的域名是 <a href="http://blog.jboost.cn，服务端接口域名是" target="_blank" rel="noopener">http://blog.jboost.cn，服务端接口域名是</a> <a href="http://api.jboost.cn，我们在" target="_blank" rel="noopener">http://api.jboost.cn，我们在</a> Nginx 中提供如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    # 端口</span><br><span class="line">    listen 80;</span><br><span class="line">    # 域名</span><br><span class="line">    server_name blog.jboost.cn;</span><br><span class="line">    # 所有 http://blog.jboost.cn/api/xxx 请求都会被转发到 http://api.jboost.cn/api/xxx</span><br><span class="line">    location ^~ /api &#123;</span><br><span class="line">        proxy_pass http://api.jboost.cn;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则前端通过AJAX请求服务端接口 <a href="http://api.jboost.cn/api/xxx" target="_blank" rel="noopener">http://api.jboost.cn/api/xxx</a> 都可以改为通过 <a href="http://blog.jboost.cn/api/xxx">http://blog.jboost.cn/api/xxx</a> 来访问，从而避免不同源的跨域问题。</p><h3 id="3-2-CORS"><a href="#3-2-CORS" class="headerlink" title="3.2 CORS"></a>3.2 CORS</h3><p>CORS是Cross-Origin Resource Sharing的简写，即跨域资源共享，CORS需要服务端与浏览器同时支持，目前所有浏览器（除IE10以下）都支持CORS，因此，实现CORS，主要就是服务端的工作了。例如在Spring Boot中，我们可通过如下配置注册一个CorsFilter的过滤器来实现跨域支持。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;Servlet.class, CorsFilter.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CORSAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"corsFilterRegistrationBean"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line"></span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.applyPermitDefaultValues();</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(CorsConfiguration.ALL));</span><br><span class="line">        corsConfiguration.addExposedHeader(HttpHeaders.DATE);</span><br><span class="line"></span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line"></span><br><span class="line">        CorsFilter corsFilter = <span class="keyword">new</span> CorsFilter(corsConfigurationSource);</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(corsFilter);</span><br><span class="line">        filterRegistrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实质就是在响应消息的Header中添加几个属性，主要有</p><ul><li>Access-Control-Allow-Origin  必需，表示允许跨域的请求源，可以是具体的域名，也可以是 * ，表示任意域名</li><li>Access-Control-Allow-Methods 必需，表示允许跨域访问的HTTP方法，如GET、POST、PUT、DELETE等，可以是 * ，表示所有</li><li>Access-Control-Allow-Headers 如果请求包括 Access-Control-Request-Headers 头信息，则必需，表示服务器支持的所有头信息字段</li></ul><h3 id="3-3-JSONP"><a href="#3-3-JSONP" class="headerlink" title="3.3 JSONP"></a>3.3 JSONP</h3><p>JSONP是利用浏览器对JS一些标签（如 <code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>等）的 src 属性不具有同源策略限制的特性实现的，如前端添加<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://api.jboost.cn/hello?name=jboost&amp;callback=jsonpCallback"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>并且定义JS方法 <code>jsonpCallback</code>。服务端接口返回内容需要是JS方法<code>jsonpCallback</code>的调用格式，如<code>jsonpCallback({&quot;name&quot;:&quot;jboost&quot;})</code>，这样在<code>jsonpCallback</code>方法中就可以获取服务端实际返回的结果数据<code>{&quot;name&quot;:&quot;jboost&quot;}</code>了。<br>JSONP方式的局限性也很明显，一是只支持GET请求——你没见过哪些<code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>标签是POST请求吧，二是需要对服务端返回数据格式做处理。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>三种跨域支持的实现，代理方式最简单，对客户端、服务端都不具有侵入性，但如果需要支持的请求源比较多，或者是与第三方对接的话，代理方式就不太适用了。CORS相对来说是一种标准的处理方式，并且通过过滤器的方式对业务代码也没有任何侵入性。而JSONP方式局限性较大，只支持GET，并且需要服务端做返回数据格式的支持。可针对具体情况选择适用的方式。</p><p><br><br><img src="/assets/card-2.png" alt="微信公众号">  </p>]]></content>
      
      
      <categories>
          
          <category> 高效实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（十）：异步处理</title>
      <link href="/springboot-async.html"/>
      <url>/springboot-async.html</url>
      
        <content type="html"><![CDATA[<p>在业务开发中，有时候会遇到一些非核心的附加功能，比如短信或微信模板消息通知，或者一些耗时比较久，但主流程不需要立即获得其结果反馈的操作，比如保存图片、同步数据到其它合作方等等。如果将这些操作都置于主流程中同步处理，势必会对核心流程的性能造成影响，甚至由于第三方服务的问题导致自身服务不可用。这时候就应该将这些操作异步化，以提高主流程的性能，并与第三方解耦，提高主流程的可用性。<br><a id="more"></a></p><p>在Spring Boot中，或者说在Spring中，我们实现异步处理一般有以下几种方式：</p><p><strong>1. 通过 @EnableAsync 与 @Asyc 注解结合实现</strong><br><strong>2. 通过异步事件实现</strong><br><strong>3. 通过消息队列实现</strong></p><h2 id="1-基于注解实现"><a href="#1-基于注解实现" class="headerlink" title="1. 基于注解实现"></a>1. 基于注解实现</h2><p>我们以前在Spring中提供异步支持一般是在配置文件 applicationContext.xml 中添加类似如下配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"executor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"executor"</span> <span class="attr">pool-size</span>=<span class="string">"10-200"</span> <span class="attr">queue-capacity</span>=<span class="string">"2000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>Spring的 @EnableAsync 注解的功能与<code>&lt;task:annotation-driven/&gt;</code>类似，将其添加于一个 @Configuration 配置类上，可对Spring应用的上下文开启异步方法支持。 @Async 注解可以标注在方法或类上，表示某个方法或某个类里的所有方法需要通过异步方式来调用。</p><p>我们以一个demo来示例具体用法，demo地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-async" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-async</a></p><ol><li>添加 @EnableAsync 注解</li></ol><p>在一个 @Configuration 配置类上添加 @EnableAysnc 注解，我们一般可以添加到启动类上，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>配置相关的异步执行线程池</li></ol><p>可通过配置类的方式对异步线程池进行配置，并提供异步执行时出现异常的处理方法，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.corePoolSize:10&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.maxPoolSize:200&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.queueCapacity:2000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.keepAlive:5&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAlive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        executor.setKeepAliveSeconds(keepAlive);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"async-"</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.setDaemon(<span class="keyword">false</span>); <span class="comment">//以用户线程模式运行</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAsyncUncaughtExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">AsyncUncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable throwable, Method method, Object... objects)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch exception when invoke "</span> + method.getName());</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们通过实现 AsyncConfigurer 接口提供了一个异步执行线程池对象，各参数的说明可以参考【<a href="/threadpool.html">线程池的基本原理，看完就懂了</a>】，里面有很详细的介绍。且通过实现   AsyncUncaughtExceptionHandler 接口提供了一个异步执行过程中未捕获异常的处理类。</p><ol start="3"><li>定义异步方法</li></ol><p>异步方法的定义只需要在类（类上注解表示该类的所有方法都异步执行）或方法上添加 @Async 注解即可，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethodWithException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"exception in async method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>测试</li></ol><p>我们可以通过如下测试类来对异步方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBasedAsyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        asyncService.asyncMethod();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAysncWithException</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        asyncService.asyncMethodWithException();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为异步方法在一个新的线程中执行，可能在主线程执行完后还没来得及处理，所以通过sleep来等待它执行完成。具体执行结果读者可自行尝试运行，这里就不贴图了。</p><h2 id="2-基于事件实现"><a href="#2-基于事件实现" class="headerlink" title="2. 基于事件实现"></a>2. 基于事件实现</h2><p>第二种方式是通过Spring框架的事件监听机制实现，但Spring的事件监听默认是同步执行的，所以实际上还是需要借助 @EnableAsync 与 @Async 来实现异步。</p><ol><li>添加 @EnableAsync 注解</li></ol><p>与上同，可添加到启动类上。</p><ol start="2"><li><p>自定义事件类<br>通过继承 ApplicationEvent 来自定义一个事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String arg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source, String arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.arg = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义事件处理类<br>支持两种形式，一是通过实现 ApplicationListener 接口，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"2. arg value: "</span> + event.getArg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>二是通过 @EventListener 注解，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(MyEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"3. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"3. arg value: "</span> + event.getArg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意两者都需要添加 @Async 注解，否则默认是同步方式执行。</p><ol start="4"><li><p>定义事件发送类<br>可以通过实现 ApplicationEventPublisherAware 接口来使用 ApplicationEventPublisher 的 publishEvent()方法发送事件，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p>可以通过如下测试类来进行测试，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBasedAsyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyEventPublisher myEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1. running in thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        myEventPublisher.publishEvent(<span class="keyword">new</span> MyEvent(<span class="keyword">this</span>,<span class="string">"testing event based async"</span>));</span><br><span class="line">        Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后发现两个事件处理类都执行了，因为两者都监听了同一个事件 MyEvent 。</p><h2 id="3-基于消息队列实现"><a href="#3-基于消息队列实现" class="headerlink" title="3. 基于消息队列实现"></a>3. 基于消息队列实现</h2><p>以上两种方式都是基于服务器本机运行，如果服务进程出现异常退出，可能导致异步执行中断。如果需要保证任务执行的可靠性，可以借助消息队列的持久化与重试机制。阿里云上的消息队列服务提供了几种类型的消息支持，如顺序消息、定时/延时消息、事务消息等（详情可参考：<a href="https://help.aliyun.com/document_detail/29532.html?spm=5176.234368.1278132.btn4.6f43db25Rn8oey" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/29532.html?spm=5176.234368.1278132.btn4.6f43db25Rn8oey</a> ），如果项目是基于阿里云部署的，可以考虑使用其中一类消息服务来实现业务需求。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文对spring boot下异步处理的几种方法进行了介绍，如果对任务执行的可靠性要求不高，则推荐使用第一种方式，如果可靠性要求较高，则推荐使用自建消息队列或云消息队列服务的方式。<br>本文demo源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-async/src/main/java/cn/jboost/async" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-async/src/main/java/cn/jboost/async</a><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记（六）：容器管理</title>
      <link href="/docker-6.html"/>
      <url>/docker-6.html</url>
      
        <content type="html"><![CDATA[<p>容器是Docker中的另一核心概念，在Docker中，应用的运行都是在容器内进行的，容器则基于镜像创建。前面已对Docker镜像做了基本介绍，本文对Docker容器管理的相关内容做一个梳理。<br><a id="more"></a></p><h2 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1. 启动容器"></a>1. 启动容器</h2><p>启动容器的命令格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE-NAME [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure></p><p>其中OPTIONS部分可指定容器运行的一些可选项，常用选项包括：</p><ul><li>-d 将容器以后台进程（daemon）的形式运行</li><li>-p 指定容器内应用暴露端口与主机端口的映射，如 -p 8080:80 表示将容器内80端口映射到主机的8080端口（主机端口在前，容器端口在后）</li><li>-v 指定容器与主机的挂载目录映射，如 -v /var/log:/log 表示将容器的/log目录挂载到主机的/var/log目录（同样主机目录在前，容器目录在后），后续对容器的/log写操作实际作用于主机的/var/log目录</li><li>-e 为容器设置环境变量</li><li>-t 为容器启动一个伪终端（pseudo-tty）</li><li>-i 让容器的标准输入保持打开，一般与 -t 配合使用，让容器启动后就打开一个可交互的命令行界面</li><li>-w 指定容器的工作目录</li></ul><p>COMMAND [ARG..] 部分就是容器需要运行的应用进程启动命令与参数，如果镜像中有通过 CMD， 或 ENTRYPOINT 指定了容器启动程序，则可省略。另外可通过 –name 指定容器的名称，以及 –restart 来指定重启策略，–restart有三种取值，代表容器支持的三种不同的重启策略</p><table><thead><tr><th style="text-align:center">取值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:left">除非被<code>docker stop</code>命令明确停止，否则一直尝试重启处于停止态的容器；如果Docker重启，也会自动启动容器</td></tr><tr><td style="text-align:center">unless-stopped</td><td style="text-align:left">与always的区别是，停止态的容器不在Docker重启的时候被重启</td></tr><tr><td style="text-align:center">on-failed</td><td style="text-align:left">在容器退出时返回值不为0的时候，重启容器；如果Docker重启，容器也会被启动，不管之前是否处于停止状态</td></tr></tbody></table><p>以启动一个mysql数据库服务为例<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name mysql \</span><br><span class="line"> -v /home/devuser/apps/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf \</span><br><span class="line"> -v /home/devuser/apps/mysql/logs:/var/log/mysql \</span><br><span class="line"> -v /home/devuser/apps/mysql/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=Passw0rd --restart=always mysql:5.7</span><br></pre></td></tr></table></figure></p><p>上述命令启动了一个mysql容器服务，-d 表示以后台进程运行，执行命令后只返回一个容器ID，不会输出任何其它信息；-p 将容器暴露的端口3306映射到宿主机的3306端口，外部主机就可以通过宿主机IP与3306端口来访问mysql服务； –name 指定了容器名称为mysql； -v 将mysql的配置文件路径、日志路径、数据存储路径映射到了宿主机对应的路径目录；-e 设置了一个环节变量指定mysql root账号的密码；–restart 指定容器在异常退出时，包括Docker重启时，自动启动容器。</p><p>我们前面有提过，当我们执行CLI命令时，实际上是客户端（Docker Client）通过发送请求到Docker后台进程（Docker Daemon），由Docker后台进程来执行的，那么当我们执行上述<code>docker run</code>命令的时候，Docker后台进程具体都干了些啥呢？一般来说，包括如下几个操作步骤</p><ol><li>检测本地是否存在指定的镜像，如果不存在，就从公共仓库下载</li><li>利用镜像创建一个容器，并启动它</li><li>分配一个文件系统，并在只读的镜像层上面挂载一层可读写层（容器存储层）</li><li>从宿主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行应用程序完毕后容器被终止 </li></ol><h2 id="2-管理已有容器"><a href="#2-管理已有容器" class="headerlink" title="2. 管理已有容器"></a>2. 管理已有容器</h2><p>一般对已有容器的管理包括如下几个操作：</p><ol><li>查看运行中的容器 <code>docker ps</code> 或 <code>docker container ls</code></li><li>查看所有容器 <code>docker ps -a</code> 或 <code>docker container ls -a</code></li><li>停止运行 <code>docker stop xxx</code></li><li>开始停止状态的容器 <code>docker start xxx</code></li><li>重启运行状态的容器 <code>docker restart xxx</code></li><li>删除停止状态的容器 <code>docker rm xxx</code></li><li>强制删除容器（包括运行状态中） <code>docker rm -f xxx</code></li><li>删除所有停止状态的容器 <code>docker container prune</code></li></ol><p>其中xxx既可以是容器ID（短ID即可，只要与其它区分开来），也可以是容器名称。<br><code>docker rm</code>之前必须要先<code>docker stop</code>将容器置为停止状态，而<code>docker rm -f</code>可以强制删除运行状态的容器，其背后是通过Linux/POSIX信号来实现的，<code>docker rm -f</code>命令直接发出<code>SIGKILL</code>信号，不会给容器内运行进程任何缓冲的时间，立即终止，而<code>docker stop</code>命令却是先发送<code>SIGTERM</code>信号，通知容器进程结束，会为进程预留一个清理并优雅停止的机会，如果一段时间后进程还没有终止，那么就会发送<code>SIGKILL</code>信号，来终止进程的运行。</p><p>我们也可以像镜像操作中一样，组合使用命令来更方便地操作，如强制删除所有容器（慎用）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure></p><h2 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3. 进入容器"></a>3. 进入容器</h2><p>容器在运行时指定 -d 选项时， 是以后台进程的形式运行的，如果我们需要进入容器查看或操作，可以通过<code>docker exec</code>命令，<code>docker exec</code>命令的格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] container-id COMMAND</span><br></pre></td></tr></table></figure></p><p>OPTIONS常用的一般是 -t， -i，意义跟在<code>docker run</code>选项中一样 —— 为容器启动一个伪终端（pseudo-tty），并保持标准输入打开，从而可以像Linux命令行一样进行交互， COMMAND一般为 <code>bash</code>。</p><p>另外还有一个命令是<code>docker attach xxx</code>，其中xxx是容器ID，但推荐使用<code>docker exec</code>，因为<code>docker attach</code>中当执行<code>exit</code>退出容器时，容器也会随之终止，但<code>docker exec</code>则不会。</p><p>如果不进入容器，也可以通过<code>docker logs xxx</code>，xxx是容器ID，来查看容器的输出信息。</p><h2 id="4-导入导出容器"><a href="#4-导入导出容器" class="headerlink" title="4. 导入导出容器"></a>4. 导入导出容器</h2><p>可以使用<code>docker export</code>命令将一个容器的快照进行导出，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export xxx &gt; mycontainer.tar</span><br></pre></td></tr></table></figure></p><p>其中xxx是容器ID，可以通过<code>docker ps -a</code>查看，上述命令将容器的当前快照导出到了本地文件。</p><p><code>docker import</code>命令则可以将一个容器快照文件导入为镜像，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat mycontainer.tar | docker import - test/myimage:v1.0</span><br></pre></td></tr></table></figure></p><p>可以通过URL来导入，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import http://test.com/testimage.tgz test/myimage2:v1.0</span><br></pre></td></tr></table></figure></p><p>由此可见，我们获取镜像又多了一个来源——从已有容器快照文件导入。 </p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文对容器的一些基本操作进行了介绍，需要注意的是如之前所说，容器应以无状态的形式运行，所有产生的数据应该通过挂载数据卷的方式写入宿主机文件目录，避免容器销毁时造成数据丢失；尽量使用<code>docker stop</code> + <code>docker rm</code>的方式来替代<code>docker rm -f</code>，使容器内运行程序“优雅”地退出。有时候可能遇到这样的场景，容器创建运行后，我们需要对运行的一些参数进行更新或添加，这时候该怎么操作。后文会对该场景进行介绍，欢迎关注。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"> </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记（五）：整一个自己的镜像</title>
      <link href="/docker-5.html"/>
      <url>/docker-5.html</url>
      
        <content type="html"><![CDATA[<p>获取镜像的途径有两个，一是从镜像仓库获取，如官方的Docker Hub，二是自定义。上文已经介绍如何从镜像仓库获取镜像，本文基于一个Springboot项目，来介绍自定义一个镜像的基本流程。<br><a id="more"></a></p><h2 id="1-定制镜像的本质"><a href="#1-定制镜像的本质" class="headerlink" title="1. 定制镜像的本质"></a>1. 定制镜像的本质</h2><p>我们知道镜像是分层存储的，镜像的构建也是一层一层进行的，一层构建完后，就变为只读，在其上再构建下一层。因此定制镜像，实际上就是定义每一层要干的事，比如执行某个命令，设置一个环境变量，声明一个暴露端口等等。然后在构建时，按照各层的定义，一层一层地完成构建，最终形成一个包含这些层的镜像。</p><h2 id="2-Dockerfile文件"><a href="#2-Dockerfile文件" class="headerlink" title="2. Dockerfile文件"></a>2. Dockerfile文件</h2><p>Docker中定义各层要干的事的文件叫Dockerfile，它是一个文本文件，包含了一条条的指令，每一条指令对应一层镜像，指令的内容就描述了这一层该如何构建。如下示例了一个非常简单的Dockerfile，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello jboost!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>我们定制镜像，必须要以某一个镜像为基础，在其上构建自己需要的层，如上示例中，我们是以nginx镜像为基础，然后在第二层定制了我们自己的内容——修改index.html的内容为<code>&lt;h1&gt;Hello jboost!&lt;/h1&gt;</code>，这样运行容器打开nginx主页时就不会显示默认的页面内容了。</p><p>上面示例中接触了Dockerfile的两个指令</p><ul><li>FROM：FROM指令指定基础镜像，每一个定制镜像必须要有一个基础镜像，所以必须要有一条FROM指令，并且是Dockerfile的第一条指令</li><li>RUN：RUN指令指定需要执行的命令，后面接的命令就像是shell脚本一样可执行</li></ul><p>Dockerfile还提供了许多其它指令，后续我们再集中介绍，本文只对接触到的指令做简单说明。</p><h2 id="3-自定义一个镜像"><a href="#3-自定义一个镜像" class="headerlink" title="3. 自定义一个镜像"></a>3. 自定义一个镜像</h2><p>这部分以一个Springboot项目为基础，介绍自定义一个镜像涉及的基本环节。项目地址为：<a href="https://github.com/ronwxy/swagger-register" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-register</a> ，该项目是一个Swagger API文档注册服务，其它项目可将Swagger API信息注册到该服务，进行统一查看与管理。</p><h3 id="3-1-定义Dockerfile文件"><a href="#3-1-定义Dockerfile文件" class="headerlink" title="3.1 定义Dockerfile文件"></a>3.1 定义Dockerfile文件</h3><p>首先，我们在项目的根目录下创建一个Dockerfile文件（文件名就叫Dockerfile），其内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">ENV PROFILE=dev</span><br><span class="line">RUN mkdir /app /logs</span><br><span class="line">COPY ./target/swagger-register-1.0.0-SNAPSHOT.jar /app/app.jar</span><br><span class="line">WORKDIR /app</span><br><span class="line">VOLUME /register-data</span><br><span class="line">EXPOSE 11090</span><br><span class="line">CMD [&quot;java&quot;, &quot;-Dspring.profiles.active=$&#123;PROFILE&#125;&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]</span><br></pre></td></tr></table></figure></p><p>从上往下依次介绍如下</p><ul><li>第一行：FORM openjdk:8-jdk-alpine， 表示以<code>openjdk:8-jdk-alpine</code>这个镜像为基础镜像，因为这是一个Springboot项目所以必须要有jdk支持，我们在定制镜像时，可以找一个最适合的镜像作为基础镜像。</li><li>第二行：ENV PROFILE=dev， 定义了一个环境变量，这个环境变量可以在后面被引用</li><li>第三行：RUN mkdir /app /logs，通过mkdir命令创建了两个目录，用来保存jar执行文件及日志</li><li>第四行：COPY ./target/swagger-register-1.0.0-SNAPSHOT.jar /app/app.jar 将target目录下的jar包复制到/app目录下，并且进行重命名</li><li>第五行：WORKDIR /app， 指定工作目录为/app，后面各层的当前目录就是指定的工作目录</li><li>第六行：VOLUME /register-data， 定义一个匿名数据卷，前面说过写操作不要直接在容器内进行，而要改为写挂载的数据卷目录，这个定义可在运行容器时通过 -v 来覆盖。</li><li>第七行：EXPOSE 11090， 声明了运行容器时提供的服务端口，也仅仅是个声明而已，只是告诉使用的人要映射这个端口，通过 -p 可映射端口。</li><li>第八行：CMD [“java”, “-Dspring.profiles.active=${PROFILE}”, “-jar”, “app.jar”]， 指定了容器启动命令，因为是一个Springboot项目，所以就是一个java -jar的执行命令，容器启动的时候就会执行该命令来运行Springboot服务，这里引用了第二行定义的环境变量PROFILE</li></ul><h3 id="3-2-配置maven插件"><a href="#3-2-配置maven插件" class="headerlink" title="3.2 配置maven插件"></a>3.2 配置maven插件</h3><p>定义好Dockerfile后，为了方便构建镜像，我们可以借助maven的dockerfile插件<code>dockerfile-maven-plugin</code>，在pom.xml的build部分加入配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>repository指定了镜像的名称，<code>docker.image.prefix</code>需要properties部分进行定义，我这里是<code>springboot</code>。</p><h3 id="3-3-构建镜像"><a href="#3-3-构建镜像" class="headerlink" title="3.3 构建镜像"></a>3.3 构建镜像</h3><p>下载源码：<a href="https://github.com/ronwxy/swagger-register.git" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-register.git</a> ，然后在项目的根目录下执行如下命令(前提是本地已经装好了docker与maven及jdk)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true dockerfile:build</span><br></pre></td></tr></table></figure></p><p>该命令首先会执行<code>mvn clean package -Dmaven.test.skip=true</code>对项目进行打包，生成./target/swagger-register-1.0.0-SNAPSHOT.jar文件，然后基于当前目录下的Dockerfile文件进行构建，如下图所示<br><img src="/assets/docker-build.png" alt="docker-build"></p><p>由上图可看出，该镜像构建分八步(对应Dockerfile的八行指令)，每一步生成一个镜像层，每一层都有唯一的ID。由图中也可以看出，除了COPY之类的命令外，每一层的构建实际上是先基于上一层启动一个容器，然后执行该层定义的操作，再移除这个容器来实现的，如第八步中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Step 8/8 : CMD ["java", "-Dspring.profiles.active=$&#123;PROFILE&#125;", "-jar", "app.jar"]</span><br><span class="line">[INFO] </span><br><span class="line">[INFO]  ---&gt; Running in f4acd0b53bca</span><br><span class="line">[INFO] Removing intermediate container f4acd0b53bca</span><br><span class="line">[INFO]  ---&gt; a9ee579f2d62</span><br></pre></td></tr></table></figure></p><p>先启动一个ID为f4acd0b53bca的容器，在其中执行CMD所定义的命令，然后再移除容器f4acd0b53bca，最后生成ID为a9ee579f2d62的镜像。</p><p>构建完后，我们就可以在本地镜像中通过<code>docker iamges</code>看到我们定制的镜像了，如图<br><img src="/assets/docker-image.png" alt="docker-image"></p><p>图中springboot/swagger-register镜像即为我们刚刚构建好的定制镜像。</p><h3 id="3-4-启动容器"><a href="#3-4-启动容器" class="headerlink" title="3.4 启动容器"></a>3.4 启动容器</h3><p>我们可以通过以下命令来启动一个刚才定制镜像的容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name swagger-register -p 11090:11090 -v /home/jenkins/swagger-register/register-data:/register-data -v /home/jenkins/swagger-register/logs:/logs --restart=always springboot/swagger-register:latest</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>-d 表示以后台进程方式运行</li><li>–name 指定容器名称</li><li>-p 指定端口映射，左边为宿主机端口，右边为容器服务端口</li><li>-v 指定数据卷挂载，左边为宿主机目录，右边为容器目录</li><li>–restart=always 表示在docker启动时自动启动该容器</li></ul><p>关于容器相关的内容后面详细介绍，这里不展开说明了。启动容器后， 我们就可以浏览器打开地址 http://宿主机ip:11090/doc.html 来访问服务了（打开页面后内容是空的，因为没有任何服务注册Swagger API， 相关内容可参考 <a href="/swagger-register.html">swagger api文档集中化注册管理</a>）</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文介绍了一个基于Springboot项目的Docker镜像定制及使用过程，对镜像的构建过程，及Dockerfile的基本指令以及容器的运行做了基本介绍。后续会对Dockerfile的其它指令及Dockerfile的一些最佳实践进行更为详细的介绍，欢迎关注。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记（四）：Docker镜像管理</title>
      <link href="/docker-4.html"/>
      <url>/docker-4.html</url>
      
        <content type="html"><![CDATA[<p>在Docker中，应用是通过容器来运行的，而容器的运行是基于镜像的，类似面向对象设计中类与对象的关系——没有类的定义就谈不上实例的创建与使用，没有镜像的定义就谈不上容器的创建与运行。<br><a id="more"></a></p><h2 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h2><p>镜像从哪里来，一般两个途径，一是公共镜像库，如官方镜像库Docker Hub，上面有大量的高质量的镜像直接可拿来用；二是自定义，我们可基于一个已有镜像，在其基础上增加一些层（还记得镜像的分层存储特性吧），然后构建形成自己的镜像。</p><p>如果我们知道某个镜像的名称，则可直接通过<code>docker pull</code>来下载镜像到本地，如ubuntu、redis、nginx等，<code>docker pull</code>命令的格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry的地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure></p><p>其中选项可设置：</p><ul><li>-a, –all-tags：下载仓库中所有标签（一般指版本）的镜像</li><li>–disable-content-trust：跳过镜像验证，默认为true</li></ul><p>Docker Registry的地址即镜像仓库地址，一般为域名或IP加端口号，如果不指定则默认为Docker Hub；仓库名包含两部分，&lt;用户名&gt;/&lt;软件名&gt;，对于Docker Hub，如果不给出用户名，则默认为library，表示官方提供；标签一般是对应软件的版本号，如果不指定则默认为latest。</p><p>比如我们要下一个nginx镜像，则可执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker pull nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">fc7181108d40: Already exists </span><br><span class="line">d2e987ca2267: Pull complete </span><br><span class="line">0b760b431b11: Pull complete </span><br><span class="line">Digest: sha256:48cbeee0cb0a3b5e885e36222f969e0a2f41819a68e07aeb6631ca7cb356fed1</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br></pre></td></tr></table></figure><p>这里我们没有指定选项，也没有指定镜像仓库地址，那么默认会从Docker Hub获取镜像（但Docker Hub由于在国外，速度比较慢，所以一般要设置国内加速器，参考<a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a>第二部分：配置国内镜像)，也没有给出用户名，所以默认是library（第三行），没有指定标签，所以默认是latest（第二行），由第四至第六行可见，这个镜像包含三个层，并且第一个层已经存在了（之前下载的镜像已经包含了这个层， 直接复用），镜像分层的概念及层的复用，应该已经理解了。</p><p>如果我们不知道镜像的完整名称怎么办，那就搜索一下，有两个途径，一是通过命令，假设我们记不起nginx全称了， 只记得<code>ngi</code>，则可通过如下命令搜索<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker search ngi</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                             Official build of Nginx.                        11693               [OK]                </span><br><span class="line">jwilder/nginx-proxy               Automated Nginx reverse proxy for docker con…   1628                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm           Container running Nginx + PHP-FPM capable of…   726                                     [OK]</span><br><span class="line">bitnami/nginx                     Bitnami nginx Docker Image                      69                                      [OK]</span><br><span class="line">linuxserver/nginx                 An Nginx container, brought to you by LinuxS…   69                                      </span><br><span class="line">tiangolo/nginx-rtmp               Docker image with Nginx using the nginx-rtmp…   48                                      [OK]</span><br><span class="line">nginx/nginx-ingress               NGINX Ingress Controller for Kubernetes         20                                      </span><br><span class="line">nginxdemos/hello                  NGINX webserver that serves a simple page co…   18                                      [OK]</span><br><span class="line">jlesage/nginx-proxy-manager       Docker container for Nginx Proxy Manager        17                                      [OK]</span><br><span class="line">schmunk42/nginx-redirect          A very simple container to redirect HTTP tra…   17                                      [OK]</span><br><span class="line">crunchgeek/nginx-pagespeed        Nginx with PageSpeed + GEO IP + VTS + more_s…   13                                      </span><br><span class="line">blacklabelops/nginx               Dockerized Nginx Reverse Proxy Server.          12                                      [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>该命令会从Docker Hub搜索镜像名包含<code>ngi</code>的镜像，其中STARS表示收藏用户数，OFFICIAL为[OK]表示官方提供的镜像，AUTOMATED [OK]表示由自动构建生成，一般选择STARS最多，官方提供的镜像。<br>这种方式获取到的信息有限，比如具体包含哪些版本不知道。还有一个途径是直接在Docker Hub网站上搜索，打开 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> ， 在搜索框输入<code>ngi</code>，如下图<br><img src="/assets/docker-hub.png" alt="docker-hub"></p><p>则会列出所有满足条件的镜像，点开<code>nginx</code>结果链接，可以看到提供的版本（通过版本链接可以查看定义对应镜像的Dockerfile），及相应的文档说明。这种方式获取的信息更加全面，所以推荐这种方式！</p><p>另外，当我们没有执行<code>docker pull</code>，直接通过<code>docker run xx</code>来运行一个容器时，如果没有对应的镜像，则会先自动下载镜像，再基于镜像启动一个容器，比如我们在<a href="/docker-3.html">Docker笔记（三）：Docker安装与配置</a>中检验docker是否安装成功时运行的<code>hello-world</code><br><img src="/assets/hello-docker.png" alt="hello-docker"></p><h2 id="2-管理本地镜像"><a href="#2-管理本地镜像" class="headerlink" title="2. 管理本地镜像"></a>2. 管理本地镜像</h2><p>将镜像下载到本地后，我们可以基于镜像来创建、运行容器，及对镜像进行管理。</p><p><strong>查看本地镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              f68d6e55e065        2 weeks ago         109MB</span><br><span class="line">mysql               latest              c7109f74d339        5 weeks ago         443MB</span><br><span class="line">hello-world         latest              fce289e99eb9        6 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>上面各列依次列出了镜像名称、标签（版本）、镜像ID、创建时间、镜像大小。镜像可以拥有多个标签（版本）。镜像的大小总和一般要大于实际的磁盘占有量，为什么？回忆一下镜像的分层存储概念，层是可以复用的，某个层其中一个镜像有了，另一个镜像就不会再下载了。口说无凭，我们来验证下，<code>docker system df</code>可列出镜像、容器、数据卷所占用的空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              3                   1                   497.1MB             497.1MB (99%)</span><br><span class="line">Containers          1                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><p>通过<code>docker image ls</code>列出的各镜像大小总共约552MB，但这里列出的镜像大小只有约497MB，这下有凭有据了吧。</p><p><strong>根据条件列出镜像</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image ls nginx # 根据名称列出镜像</span><br><span class="line">docker image ls nginx:latest # 根据名称与标签列出镜像</span><br><span class="line">docker image ls -f since=hello-world:latest # -f 是--filter的缩写，过滤器参数，列出在hello-world:latest之后建立的镜像，before=hello-world:latest则查看之前建立的镜像</span><br></pre></td></tr></table></figure></p><p><strong>指定显示格式</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -q # 只显示镜像ID</span><br><span class="line">docker image ls --digests # 列出镜像摘要</span><br><span class="line"></span><br><span class="line">docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"  # 使用Go的模板语法格式化显示，这里显示格式为 镜像ID：镜像名称</span><br><span class="line">docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;" # 自己定义表格格式</span><br></pre></td></tr></table></figure></p><p><strong>虚悬镜像</strong><br>有时候会看到某些镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。这些镜像原本是有镜像名和标签的，随着官方镜像维护，发布了新版本后(新版本会复用之前的镜像名称与标签，一般是bug修复版)，重新<code>docker pull xx</code> 时， 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了<code>&lt;none&gt;</code> 。除了<code>docker pull</code>可能导致这种情况， <code>docker build</code>也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像被称为虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -f dangling=true</span><br></pre></td></tr></table></figure></p><p>一般虚悬镜像没什么意义了，可以通过如下命令删除<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure></p><p><strong>中间层镜像</strong><br>为了加速镜像构建、重复利用资源，Docker会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的<code>docker image ls</code>列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，可以加 -a<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls -a</span></span><br></pre></td></tr></table></figure></p><p>这样会看到很多无标签的镜像，与虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><p><strong>删除镜像</strong><br>删除镜像命令格式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure></p><p>选项可以设置：</p><ul><li>-f, –force  强制删除镜像</li><li>–no-prune   不删除没有标签的父镜像</li></ul><p>&lt;镜像1&gt;、&lt;镜像2&gt; 等可以是镜像的名称，镜像的全ID，也可以是镜像ID的前面几个数字（只要与其它镜像区分开来就行），或者是镜像摘要。 如删除镜像名称为mysql的镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker image rm mysql</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:415ac63da0ae6725d5aefc9669a1c02f39a00c574fdbc478dfd08db1e97c8f1b</span><br><span class="line">Deleted: sha256:c7109f74d339896c8e1a7526224f10a3197e7baf674ff03acbab387aa027882a</span><br><span class="line">Deleted: sha256:35d60530f024aa75c91a123a69099f7f6eaf5ad7001bb983f427f674980d8482</span><br><span class="line">Deleted: sha256:49d8bb533eee600076e3a513a203ee24044673fcef0c1b79e088b2ba43db2c17</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>由上面命令的执行结果可见，删除镜像包括另个行为：Untagged、Deleted。</p><p>当我们使用上面命令来删除镜像的时候，实际上是在要求删除某个/某些标签的镜像。所以首先需要做的是将满足要求的所有镜像标签都取消，这就是Untagged的行为。一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么Delete行为就不会发生，仅仅是取消了这个镜像的符合要求的所有标签。所以并非所有的<code>docker image rm</code>都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能就失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。如果某个其它镜像正依赖于当前镜像的某一层，这种情况，依旧不会触发删除该层的行为。直到没有任何镜像依赖当前层时，才会真实的删除当前层。</p><p>另外还需要注意是容器对镜像的依赖。如果基于镜像启动的容器存在（即使容器没有运行处于停止状态） ，同样不可以删除这个镜像。我们之前说了容器是以镜像为基础，再加一层容器存储层组成的多层存储结构去运行的。所以如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。 </p><p><strong>通过组合命令来删除</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q nginx) # 删除镜像名称为nginx的所有镜像</span><br><span class="line">docker image rm $(docker image ls -q -f since=hello-world:latest) # 删除所有在hello-world:latest之后建立的镜像</span><br></pre></td></tr></table></figure></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本文对镜像的获取及本地镜像的基本管理做了介绍，本文镜像的获取途径都是从镜像仓库直接获取，镜像的另一个获取途径便是自定义，接下来会通过实例来进行介绍，欢迎关注。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记（三）：Docker安装与配置</title>
      <link href="/docker-3.html"/>
      <url>/docker-3.html</url>
      
        <content type="html"><![CDATA[<p>Docker分为Docker CE社区免费版与Docker EE企业收费版。Docker EE主要是在安全性及镜像、容器高级管理方面提供了一些额外的支持。对于中小型企业、团队或个人来说，用Docker CE即可。<br><a id="more"></a></p><h2 id="1-安装Docker-CE"><a href="#1-安装Docker-CE" class="headerlink" title="1. 安装Docker CE"></a>1. 安装Docker CE</h2><p>Docker CE有三个更新渠道：</p><ul><li>Stable：提供最新的GA（General Availability）稳定版，每六个月一版，如 18.09 表示18年9月版，下一版就是19.03——19年3月版</li><li>Test：提供GA之前的Pre-release版</li><li>Nightly：提供最新的build版本，每天一版</li></ul><p>我们一般使用stable版。Docker CE支持在多种操作系统下安装，本文只介绍比较常见的Ubuntu 18.04 LTS、CentOS7、及Windows 10上的安装与配置。</p><h3 id="1-1-Ubuntu-18-04-LTS-上安装"><a href="#1-1-Ubuntu-18-04-LTS-上安装" class="headerlink" title="1.1 Ubuntu 18.04 LTS 上安装"></a>1.1 Ubuntu 18.04 LTS 上安装</h3><p>Docker CE支持的64位Ubuntu系统版本为</p><ul><li>Cosmic 18.10</li><li>Bionic 18.04 (LTS)</li><li>Xenial 16.04 (LTS)</li></ul><p>Docker CE在Ubuntu上支持 overlay2， aufs， 以及 btrfs 几种存储驱动程序，对于Linux内核版本为4或以上系统的安装，Docker CE默认使用 overlay2，如果需要使用 aufs，则需要手动配置（参考： <a href="https://docs.docker.com/storage/storagedriver/aufs-driver/" target="_blank" rel="noopener">Use the AUFS storage driver</a>）</p><ol><li>卸载旧版本</li></ol><p>如果系统安装有旧版本，旧版本命名为 docker， docker.io，或docker.engine，可使用如下命令进行卸载<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove docker docker-engine docker.io containerd runc</span></span><br></pre></td></tr></table></figure></p><p>目录/var/lib/docker下的内容，包括镜像、容器、数据卷、网络等，会被保留。</p><ol start="2"><li>使用APT安装</li></ol><p>apt源使用HTTPS来确保软件下载过程中不被篡改，所以首先添加使用HTTPS传输需要的软件包以及CA证书<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install \</span></span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></p><p>为了确认下载软件包的合法性，添加Docker官方的GPG key：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/</span></span><br><span class="line">gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></p><p>由于国内网络原因，我们一般要使用国内源，否则安装将会灰常灰常慢。向source.list中添加Docker软件源（以下命令添加的是stable版本的APT镜像源，如果需要test或nightly版，将stable改为对应test或nightly即可）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository \</span></span><br><span class="line">"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line"><span class="meta">$</span><span class="bash">(lsb_release -cs) \</span></span><br><span class="line">stable"</span><br></pre></td></tr></table></figure></p><p>然后，便可更新apt软件包缓存，开始安装了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install docker-ce</span></span><br></pre></td></tr></table></figure></p><p>以上命令默认会安装软件源里的最新版本，如果需要安装指定版本，则可通过查看可用版本，然后指定版本安装，查看版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-cache madison docker-ce</span></span><br></pre></td></tr></table></figure></p><p>安装指定版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install docker-ce=&lt;VERSION_STRING&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>使用脚本自动安装</li></ol><p>Docker提供了一个方便的安装脚本来在开发测试环境安装Docker CE的edge或测试版，Ubuntu上可使用这套脚本来安装Docker CE的edge版<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL https://get.docker.com -o get-docker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh get-docker.sh --mirror Aliyun</span></span><br></pre></td></tr></table></figure></p><ol start="4"><li>启动Docker CE</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker <span class="comment">#开启开机自动启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker  <span class="comment">#启动docker</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>用户组配置</li></ol><p>docker命令默认是使用Unix socket与Docker引擎进行通信（回顾下除了Unix socket还有REST API及网络端口），只有root用户或docker用户组里的用户才有权限访问Docker引擎的Unix socket，因此，需要将使用docker的用户加入docker用户组（处于安全考虑，一般尽量不要直接使用root用户来操作）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd docker <span class="comment">#添加docker用户组</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker <span class="variable">$USER</span> <span class="comment">#将当前用户加到docker用户组</span></span></span><br></pre></td></tr></table></figure></p><p>退出账号重新登录即可。</p><ol start="6"><li>测试安装是否成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run hello-world</span></span><br></pre></td></tr></table></figure><p>如果显示如下图，则说明安装已成功<br><img src="/assets/hello-docker.png" alt="hello-docker"></p><ol start="7"><li>卸载</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><p>以上命令可以卸载docker-ce，但是之前的镜像、容器、数据卷等不会自动删除，可通过如下命令彻底删除<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo rm -rf /var/lib/docker</span></span><br></pre></td></tr></table></figure></p><h3 id="1-2-CentOS-7-上安装"><a href="#1-2-CentOS-7-上安装" class="headerlink" title="1.2 CentOS 7 上安装"></a>1.2 CentOS 7 上安装</h3><p>Docker CE支持64位的CentOS7，并且要求内核版本不低于3.10。CentOS 7满足最低内核的要求，但由于版本较低，一些功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。<br>可以通过<code>uname -r</code>命令来查看系统内核版本，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# uname -r</span><br><span class="line">3.10.0-957.1.3.el7.x86_64</span><br></pre></td></tr></table></figure></p><ol><li>卸载旧版本</li></ol><p>如果安装了旧版本，需要先卸载。旧版本的Docker称为docker或者docker-engine，卸载命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker \</span></span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-selinux \</span><br><span class="line">    docker-engine-selinux \</span><br><span class="line">    docker-engine</span><br></pre></td></tr></table></figure></p><ol start="2"><li>使用yum安装</li></ol><p>安装依赖包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils \</span></span><br><span class="line">    device-mapper-persistent-data \</span><br><span class="line">    lvm2</span><br></pre></td></tr></table></figure></p><p>由于国内网络原因，我们一般要使用国内源，否则安装可能会灰常灰常慢。添加yum软件源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce</span><br><span class="line">    .repo</span><br></pre></td></tr></table></figure></p><p>如果要安装nightly或test版，执行如下对应的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-nightly <span class="comment"># 启用nightly， 将--enbale改为disable又可以禁用</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-test <span class="comment"># 启用test</span></span></span><br></pre></td></tr></table></figure></p><p>安装最新版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum makecache fast <span class="comment"># 更新软件源缓存</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce <span class="comment"># 安装最新版本</span></span></span><br></pre></td></tr></table></figure></p><p>安装指定版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum list docker-ce --showduplicates | sort -r <span class="comment"># 列出可用版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce-&lt;VERSION_STRING&gt; <span class="comment"># 安装指定版本</span></span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>使用脚本自动安装</li></ol><p>执行如下命令，则会自动安装Docker CE的edge版，注意只在开发或测试环境这么用（建议最好还是用stable版）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL get.docker.com -o get-docker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh get-docker.sh --mirror Aliyun</span></span><br></pre></td></tr></table></figure><ol start="4"><li>启动Docker CE</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker <span class="comment">#开启开机自动启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker  <span class="comment">#启动docker</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>用户组配置</li></ol><p>docker命令默认是使用Unix socket与Docker引擎进行通信（回顾下除了Unix socket还有REST API及网络端口），只有root用户或docker用户组里的用户才有权限访问Docker引擎的Unix socket，因此，需要将使用docker的用户加入docker用户组（处于安全考虑，一般尽量不要直接使用root用户来操作）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd docker <span class="comment">#添加docker用户组</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker <span class="variable">$USER</span> <span class="comment">#将当前用户加到docker用户组</span></span></span><br></pre></td></tr></table></figure></p><p>退出账号重新登录即可。</p><ol start="6"><li>测试安装是否成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run hello-world</span></span><br></pre></td></tr></table></figure><p>如果显示如下图，则说明安装已成功<br><img src="/assets/hello-docker.png" alt="hello-docker"></p><p>如果在 CentOS 中使用 Docker CE 看到下面的这些警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: bridge-nf-call-iptables is disabled</span><br><span class="line">WARNING: bridge-nf-call-ip6tables is disabled</span><br></pre></td></tr></table></figure></p><p>可以添加内核配置参数以启用这些功能。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tee -a /etc/sysctl.conf &lt;&lt;-EOF</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>然后重新加载 sysctl.conf 即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl -p</span></span><br></pre></td></tr></table></figure></p><ol start="7"><li>卸载</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker-ce <span class="comment"># 卸载docker-ce</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm -rf /var/lib/docker <span class="comment"># 该目录下的镜像、容器、数据卷、网络等不会自动删除</span></span></span><br></pre></td></tr></table></figure><h3 id="1-3-Windows-10-上安装"><a href="#1-3-Windows-10-上安装" class="headerlink" title="1.3 Windows 10 上安装"></a>1.3 Windows 10 上安装</h3><p>windows 10上的安装非常简单，直接下载<a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="noopener">stable版本</a>安装。<br>安装完后，在 Windows 搜索栏输入 Docker 点击 Docker for Windows 开始运行</p><h2 id="2-配置国内镜像"><a href="#2-配置国内镜像" class="headerlink" title="2. 配置国内镜像"></a>2. 配置国内镜像</h2><p>Docker默认是从Docker Hub（官方的镜像仓库）拉取镜像的，国内访问一般会比较慢，因此可以配置一些镜像加速器，很多云服务商提供了自己的加速器服务，如Azure中国，阿里云（需要登录获取），七牛云等。</p><p>Ubuntu、CentOS上，配置国内镜像只需要在/etc/docker/daemon.json中写入如下内容（如果文件不存在则创建一个）<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">        <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后重新启动服务<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure></p><p>对于Windows 10，在系统右下角托盘Docker图标上右键菜单选择<br>Settings ，打开配置窗口后在左侧导航菜单选择 Daemon 。在 Registry<br>mirrors 一栏中填写加速器地址 <a href="https://dockerhub.azk8s.cn" target="_blank" rel="noopener">https://dockerhub.azk8s.cn</a> ，之后点击<br>Apply 保存， Docker 就会自动重启并应用配置的镜像地址了。 </p><p>可以通过<code>docker info</code>命令来检查加速器是否生效，如果执行命令能看到类似如下信息，则说明加速器配置生效了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line">    https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Docker分Docker CE与Docker EE两个版本，对大多数人来说，一般使用Docker CE就行了。我们在安装Docker CE时，最好安装stable版，比较稳定可靠。同时，Linux安装时，记得配置Docker软件源，不然有可能太慢。安装完后，需要配置镜像加速器，加快镜像的下载速度。工具有了，接下来就是探索实践了，加油吧少年！<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记（二）：Docker管理的对象</title>
      <link href="/docker-2.html"/>
      <url>/docker-2.html</url>
      
        <content type="html"><![CDATA[<p>在<a href="/docker-1.html">Docker笔记（一）：什么是Docker</a>中，我们提到了Docker管理的对象包含镜像、容器、网络、数据卷等，本文就来介绍下这些对象及用途。<br><a id="more"></a></p><h2 id="1-镜像"><a href="#1-镜像" class="headerlink" title="1. 镜像"></a>1. 镜像</h2><p>所谓镜像，是一个静态的概念。它对我们期望干的事情做了一些定义，比如要运行什么程序，需要哪些依赖，需要什么样的配置，需要开放哪个网络端口等等。<br>Docker的镜像是一个特殊的文件系统，提供了运行时需要的程序、库、资源、配置等文件，还包含一些为运行时准备的配置参数（如环境变量、匿名数据卷、用户等），镜像不包含任何动态数据，其内容在构建之后也不会被改变。<br>镜像的文件系统有一个分层存储的概念，采用的是Union FS技术，因此，镜像并不是简单地由一组文件组成，而是由多层文件系统叠加联合组成。如下图所示<br><img src="/assets/container-layers.jpg" alt="container-layers"></p><p>镜像构建时，会一层一层地构建，前一层是后一层的基础，每层构建完后就变成只读的，不会再发生改变。镜像分层存储的一大好处是复用，镜像的每一层可以在不同镜像间复用，这就好比我们开发项目时将一些公共功能封装成jar包，在各个项目可以直接依赖使用一样。关于镜像的更多内容，在后续使用时再详述。</p><h2 id="2-容器"><a href="#2-容器" class="headerlink" title="2. 容器"></a>2. 容器</h2><p>相对镜像，容器是一个动态的运行时的概念，它与镜像的关系类似于面向对象中类与实例的关系。容器可以被创建、启动、停止、删除等。容器运行实质上就是运行一个进程，但与那些直接在宿主机上运行的进程不同，容器运行在自己的独立的隔离的命名空间中——拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间，因此虽然是以进程的形式运行，但好像是运行在一个独立的系统中一样，这样相比直接运行于宿主机的进程，容器的运行显得更为安全。<br>前面说到镜像的分层存储概念，对于容器来说，实际上也是以镜像作为基础层，在其上创建了一个当前容器的存储层，如下图<br><img src="/assets/sharing-layers.jpg" alt="sharing-layers.jpg"></p><p>以镜像ubuntu:15.04为基础层所创建的容器，都有一个自己的可读写的存储层（镜像的存储层是只读的）。容器存储层的生命周期与容器一样，容器销毁时，容器的存储层也会随之消亡，任何保存在容器存储层的数据也都会随容器的删除而丢失，因此一般我们要保持容器存储层的无状态化，所有文件的写操作，都应该使用数据卷或绑定宿主机目录。</p><h2 id="3-数据卷"><a href="#3-数据卷" class="headerlink" title="3. 数据卷"></a>3. 数据卷</h2><p>数据卷是一个独立于容器，可供一个或多个容器使用的特殊目录，它绕过了Union FS，不会随容器的销毁而消亡。这好比我们在阿里云上建虚机，再加载一个数据盘一样，一般产生的数据都要保存在数据盘，而不是虚机的系统盘。<br>数据卷具备如下特性：</p><ol><li>可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>数据卷的更新，不会影响到镜像</li><li>数据卷默认会一直存在，不会随容器的删除而消亡</li></ol><h2 id="4-网络"><a href="#4-网络" class="headerlink" title="4. 网络"></a>4. 网络</h2><p>Docker容器是如何与外部进行网络通信的？一般来说，我们在运行容器时，只需要指定容器服务端口与宿主机端口的映射，就可以通过宿主机IP与映射的端口访问容器服务了，因为Docker默认使用了Bridge的模式来实现容器与外部的通信。<br>Docker的网络子系统通过使用一些驱动程序，是可插拔式的，默认提供了如下几种驱动：</p><ol><li>bridge：默认的网络驱动。运行在容器中的应用程序一般是通过网桥与外部进行通信。</li><li>host：容器直接使用宿主机的网络通信。host只在基于Docker 17.06或以上版本的Swarm服务中可用</li><li>overlay：overlay可将多个Docker daemon进程连接起来使得Swarm服务之间能相互通信，也可以将overlay用于Swarm服务与容器之间，或运行在不同Docker daemon上的容器之间的通信，不需要操作系统层面的路由配置。</li><li>macvlan：macvlan允许你分配一个mac地址给容器，让它像一台物理设备一样加入你的网络中。Docker daemon通过mac地址将请求路由给容器，适用于那些希望直接连到物理网络的遗留应用。</li><li>none：禁用所有网络。一般与一个自定义的网络驱动一起使用。none不能用于Swarm服务。</li><li>其它第三方网络插件：可从Docker Hub或其它第三方供应商获取安装。</li></ol><p>总之，bridge适用于在同一台宿主机运行多个容器的场景；host适用于不应与宿主机进行网络隔离的场景；overlay适用于运行在不同宿主机上的容器间通信，或多个应用通过Swarm服务来共同协作的场景；macvlan适用于从虚拟机迁移配置或希望容器作为物理机一样使用网络的场景。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文对Docker所管理的几个基本对象——镜像、容器、数据卷、网络做了简单介绍，这是认识或学习Docker的基础，在后续实践操作过程中，将会对各部分进行更详细的使用说明，欢迎持续关注。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记（一）：什么是Docker</title>
      <link href="/docker-1.html"/>
      <url>/docker-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>接触Docker也有两年多了，断断续续玩过一些应用场景，如安装一些常用工具服务，部署业务项目，基于gitlab+jenkins pipeline+docker的CI/CD实现等。了解其基本知识与操作，但不能说深度掌握，故借此系列进行梳理与学习，也希望对有意学习Docker的人提供参考。</p><a id="more"></a><h2 id="2-Docker简介"><a href="#2-Docker简介" class="headerlink" title="2. Docker简介"></a>2. Docker简介</h2><p>Docker最初是dotCloud公司（后来也改名为Docker）的一个内部项目，于2013年3月开源。Docker使用Google推出的Go语言实现，基于Linux内核的cgroup、namespace、Union FS等技术（先不用急着了解这些都是啥），对进程进行隔离，是操作系统层面的虚拟化技术。相对于传统的硬件层面的虚拟化技术（虚拟机），Docker显得更为轻量化。下图为传统虚拟机与Docker的结构对比<br><img src="/assets/vm-docker.png" alt="vm-docker"></p><p>由上图可看出传统虚拟机技术是在硬件层面虚拟出一套硬件（CPU、内存、磁盘、网卡等）后，在其上运行一个完整的操作系统，再在操作系统上运行应用进程；而Docker的应用进程是直接运行在宿主机的内核上，也不需要进行硬件虚拟，因此，Docker要比传统虚拟机更为轻便。</p><p>总结Docker相对传统虚拟化技术的优势如下：</p><ol><li><strong>更高的资源利用率：</strong>Docker不需要硬件虚拟与运行完整操作系统的开销，所以资源利用率更高，同样配置的主机，采用Docker往往可以运行更多数量的应用。</li><li><strong>更高效的使用体验：</strong>在操作系统上安装一些常用软件，如mysql，redis等，往往需要折腾好一阵，有些还要手动安装各种依赖，而采用Docker，可能几行命令就可以让一个服务快速运行起来。</li><li><strong>一致的运行环境：</strong>Docker镜像功能可以把程序运行需要的环境进行封装，确保程序在开发、测试、生产环境都能保持一致性，避免因环境不一致导致程序运行异常。</li><li><strong>CI/CD支持：</strong>使用Docker可以定制镜像来实现持续集成、持续部署，如基于gitlab + jenkins pipeline + docker的自动化部署。</li><li><strong>更轻松的维护：</strong>因为Docker保证了运行环境的一致性，因此应用的迁移或缩放将变得很容易；Docker的分层存储与镜像技术，也使得应用重复部分的复用变得更简单，基于基础镜像可以进一步扩展定义自己的镜像，也可以直接使用官方镜像来使用。</li></ol><h2 id="3-Docker的基本架构"><a href="#3-Docker的基本架构" class="headerlink" title="3. Docker的基本架构"></a>3. Docker的基本架构</h2><p>Docker的基本架构图如下<br><img src="/assets/docker-arch.png" alt="docker-arch"></p><p>主要包括几部分：</p><ol><li>Docker daemon（Docker守护进程 <code>dockerd</code>）：Docker的执行引擎，负责监听处理Docker客户端请求与管理Docker相关对象，如镜像、容器、网络、数据卷等。一个Docker守护进程可与其它Docker守护进程进行通信，作为Docker服务进行管理。</li><li>Docker client（Docker客户端 <code>docker</code>）：Docker客户端（<code>docker</code> CLI命令）是大多数用户用来与Docker守护进程交互的方式，比如你在命令行执行<code>docker run</code>，Docker客户端将发送该命令请求到Docker守护进程，由守护进程执行。Docker客户端可通过REST API, UNIX Socket或网络接口来与Docker守护进程进行通信，并且可与多个Docker守护进程进行通信。</li><li>Docker Registry（Docker注册中心）：用来存储Docker镜像的仓库，类似于Maven的Nexus。Docker官方提供了一个公共镜像仓库Docker Hub（ <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> ），<code>docker</code>相关命令默认会从Docker Hub上搜索与下载镜像，我们可以配置一些国内镜像仓库地址来进行加速，甚至搭建自己的私有镜像仓库。</li><li>Docker Objects：Docker管理的对象，主要包括镜像、容器、网络、数据卷等。</li></ol><h2 id="4-Docker的用途"><a href="#4-Docker的用途" class="headerlink" title="4. Docker的用途"></a>4. Docker的用途</h2><p>根据第二部分Docker的优势及笔者的经验来看，目前Docker主要用于</p><ol><li>常用软件服务的搭建运行，如Mysql、Redis、Nginx等</li><li>业务服务的发布部署，尤其是基于SpringBoot的微服务</li><li>CI/CD实现，结合Gitlab的webhook，Jenkins的pipeline，实现自动化集成与部署</li><li>快速的弹性伸缩，在容器集群化管理的场景中，如Swarm、K8s解决方案中，可基于容器对服务进行快速的弹性伸缩来应对业务量的突发情况</li><li>执行环境封装，如一些深度学习框架模型，打成Docker镜像的方式进行发布，可以快速在不同的环境中运行起来</li><li>…</li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>在微服务架构、DevOps这些概念盛行的时代，容器化技术变得越来越重要，几乎成为每一位开发人员需要掌握的技能。本系列文章是笔者基于自身实践及相关文献参考，对Docker相关技术进行整理，欢迎关注，共同学习。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.04上搭建KVM虚拟机环境超完整过程</title>
      <link href="/ubuntu-kvm.html"/>
      <url>/ubuntu-kvm.html</url>
      
        <content type="html"><![CDATA[<p>看标题这是篇纯运维的文章。在中小型企业中，一般很少配置专业的运维人员，都是由开发人员兼着。同时，对有志于技术管理的开发人员来说，多了解一些运维及整个软件生命周期的知识，是很有帮助的，因为带团队不仅仅是个管人的活，更多的是在你的部下遇到难题或者无人能上的时候，你能协助他解决或亲自上阵，这比只会“吆五喝六”的管理者将能获得更高的敬重与威信。闲话不多说了，记录下整个KVM虚拟机的搭建过程吧。<br><a id="more"></a></p><h2 id="1-KVM安装"><a href="#1-KVM安装" class="headerlink" title="1. KVM安装"></a>1. KVM安装</h2><h3 id="1-1-配置确认"><a href="#1-1-配置确认" class="headerlink" title="1.1 配置确认"></a>1.1 配置确认</h3><p>首先需要确认服务器的硬件是否支持虚拟化，执行如下命令确认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ egrep -c '(vmx|svm)' /proc/cpuinfo</span><br><span class="line">48</span><br></pre></td></tr></table></figure><p>如果输出结果大于0，意味着服务器硬件是支持虚拟化的。否则，重启进入BIOS设置中启用VT技术。<br>执行如下命令安装kvm-ok程序，来确定服务器是否能够运行硬件加速的KVM虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ sudo apt install cpu-checker</span><br><span class="line"></span><br><span class="line">devuser@server_01:~$ sudo kvm-ok</span><br><span class="line">INFO: /dev/kvm exists</span><br><span class="line">KVM acceleration can be used</span><br></pre></td></tr></table></figure><h3 id="1-2-安装KVM"><a href="#1-2-安装KVM" class="headerlink" title="1.2 安装KVM"></a>1.2 安装KVM</h3><p>安装KVM及依赖项<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ sudo apt update</span><br><span class="line">devuser@server_01:~$ sudo apt install qemu qemu-kvm libvirt-bin  bridge-utils  virt-manager</span><br></pre></td></tr></table></figure></p><p>启动libvirtd服务，并设置开机自动启动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ sudo systemctl start libvirtd.service</span><br><span class="line">devuser@server_01:~$ sudo systemctl enable libvirtd.service</span><br></pre></td></tr></table></figure></p><p>执行<code>service libvirtd status</code>查看libvirtd服务状态，如图<br><img src="/assets/kvm1.png" alt="libvirtd-status"></p><h3 id="1-3-桥接网络配置"><a href="#1-3-桥接网络配置" class="headerlink" title="1.3 桥接网络配置"></a>1.3 桥接网络配置</h3><p>一般虚拟机网络配置有Bridge、NAT等几种模式。NAT模式下，虚拟机不需要配置自己的IP，通过宿主机来访问外部网络；Bridge模式下， 虚拟机需要配置自己的IP，然后虚拟出一个网卡， 与宿主机的网卡一起挂到一个虚拟网桥上（类似于交换机）来访问外部网络，这种模式下，虚拟机拥有独立的IP，局域网其它主机能直接通过IP与其通信。简单理解，就是NAT模式下，虚机隐藏在宿主机后面了，虚机能通过宿主机访问外网，但局域网其它主机访问不到它，Bridge模式下，虚机跟宿主机一样平等地存在，局域网其它主机可直接通过IP与其通信。一般我们创建虚机是用来部署服务供使用的， 所以都是用Bridge模式。</p><p>ubuntu 18中，网络配置通过netplan来实现了，如下，更改配置文件 /etc/netplan/50-cloud-init.yaml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">devuser@cserver_01:~$ sudo vim /etc/netplan/50-cloud-init.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> This file is generated from information provided by</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the datasource.  Changes to it will not persist across an instance.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">disable</span> cloud-init<span class="string">'s network configuration capabilities, write a file</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> network: &#123;config: disabled&#125;</span></span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        enp6s0:</span><br><span class="line">            dhcp4: true</span><br><span class="line">        enp7s0:</span><br><span class="line">            dhcp4: no</span><br><span class="line">            dhcp6: no</span><br><span class="line">    version: 2</span><br><span class="line"></span><br><span class="line">    bridges:</span><br><span class="line">         br0:</span><br><span class="line">             interfaces: [enp7s0]</span><br><span class="line">             dhcp4: no</span><br><span class="line">             addresses: [192.168.40.241/24]</span><br><span class="line">             gateway4: 192.168.40.1</span><br><span class="line">             nameservers:</span><br><span class="line">                 addresses: [114.114.114.114,8.8.8.8]</span><br></pre></td></tr></table></figure><p>将宿主机原有网卡enp7s0挂到网桥br0上，并指定IP地址为192.168.40.241，nameservers指定DNS服务器。修改完后，通过<code>sudo netplan apply</code>重启网络服务生效，然后通过<code>ifconfig</code>查看，<br><img src="/assets/kvm2.png" alt="kvm2"><br>原来挂在enp7s0网卡下的IP现在挂到了br0上，宿主机及所有其它虚拟机都通过该网桥来与外部通讯。我们也可以通过<code>brctl show</code>来直观地查看，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ brctl show</span><br><span class="line">bridge name    bridge idSTP enabled    interfaces</span><br><span class="line">br0    8000.2a5be3ec2698no        enp7s0</span><br><span class="line">docker08000.02424524dcceno        veth580af8e</span><br><span class="line">        veth74119f3</span><br><span class="line">        vethe7a2b0f</span><br><span class="line">        vethfe89039</span><br></pre></td></tr></table></figure></p><p>目前因为还没虚机，所以只有宿主机的网卡enp7s0挂在网桥br0上。同时也可以看到docker容器也是通过网桥docker0来通讯的。</p><h2 id="2-虚拟机安装"><a href="#2-虚拟机安装" class="headerlink" title="2. 虚拟机安装"></a>2. 虚拟机安装</h2><h3 id="2-1-安装虚拟机"><a href="#2-1-安装虚拟机" class="headerlink" title="2.1 安装虚拟机"></a>2.1 安装虚拟机</h3><p>安装命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-install --name=dev-server1 --memory=16384,maxmemory=16384 \</span><br><span class="line">--vcpus=4,maxvcpus=4 --os-type=linux --os-variant=rhel7 \</span><br><span class="line">--location=/home/devuser/tools/CentOS-7-x86_64-DVD-1810.iso \</span><br><span class="line">--disk path=/var/lib/libvirt/images/devserver1.img,size=300 \</span><br><span class="line">--bridge=br0 --graphics=none --console=pty,target_type=serial \</span><br><span class="line">--extra-args="console=tty0 console=ttyS0"</span><br></pre></td></tr></table></figure></p><p>其中–name指定虚机名称；–memory=16384,maxmemory=16384配置了16G内存；–vcpus=4,maxvcpus=4配置了4个CPU内核；centos7需要指定–os-variant=rhel7；–disk path=xx,size=300指定了磁盘路径与大小，这里是300G。</p><p>如果执行上述命令出现<code>qemu-kvm: could not open &#39;xx/CentOS-7-x86_64-DVD-1810.iso&#39;: Permission denied</code>异常退出时，可通过修改<code>/etc/libvirt/qemu.conf</code>文件将<code>user = &quot;root&quot;</code>，<code>group = &quot;root&quot;</code>前面的注释去掉解决（<a href="https://github.com/jedi4ever/veewee/issues/996）" target="_blank" rel="noopener">https://github.com/jedi4ever/veewee/issues/996）</a></p><p>如无问题，安装程序将出现如下配置界面<br><img src="/assets/kvm3.png" alt="kvm3"></p><p>可通过输入选项对应的数字来选择不同的配置，依次操作如下步骤完成时区设置：<br>输入2，回车，选择时区设置；输入1，回车，选择“Set timezone”；输入2，回车，选择“Asia”；回车，输入64，回车，选择“Shanghai”</p><p>然后进行安装设置，<br><img src="/assets/kvm4.png" alt="kvm4"><br>依次操作如下：<br>输入5，回车，进入安装设置；输入c，回车，选择默认的磁盘进行安装；输入c，回车，使用默认的“2) Use All<br> Space”；输入1，回车，选择“1) Standard Partition”进行标准分区；输入c，回车，完成分区设置</p><p>最后进入root密码设置，<br><img src="/assets/kvm5.png" alt="kvm5"><br>操作如下：<br>输入8，回车，进入root密码设置；输入密码，回车；输入确认密码，回车</p><p>完成上述设置后，输入b开始进行安装<br><img src="/assets/kvm6.png" alt="kvm6"></p><p>等待一段时间后，安装程序停在如下界面<br><img src="/assets/kvm7.png" alt="kvm7"></p><p>按回车继续，最后输入用户名root，及前面设置的密码登录系统<br><img src="/assets/kvm8.png" alt="kvm8"></p><h3 id="2-2-虚拟机网络配置"><a href="#2-2-虚拟机网络配置" class="headerlink" title="2.2 虚拟机网络配置"></a>2.2 虚拟机网络配置</h3><p>虚拟机安装完后，是没有分配IP的，我们通过<code>ip a</code>命令查看，<br><img src="/assets/kvm9.png" alt="kvm9"></p><p>这时候的eth0下面空空如也，什么都没有。在<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>文件中添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static #静态指定IP</span><br><span class="line">DEFROUTE=yes</span><br><span class="line"><span class="meta">#</span><span class="bash">IPV4_FAILURE_FATAL=no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6INIT=yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_AUTOCONF=yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_DEFROUTE=yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_FAILURE_FATAL=no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IPV6_ADDR_GEN_MODE=stable-privacy</span></span><br><span class="line">NAME=eth0</span><br><span class="line">UUID=449ed621-97a8-45b9-902f-0d347e27de98</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes  #开机自动启动</span><br><span class="line">IPADDR=192.168.40.96</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.40.1</span><br><span class="line">DNS1=192.168.40.1</span><br></pre></td></tr></table></figure><p>并通过<code>systemctl restart network</code>重启网络生效，这时候再运行<code>ip a</code>查看，eth0下面已经有配置的IP了。不出意外的话，局域网其它主机就可以通过该IP来远程SSH连接了。<br><img src="/assets/kvm10.png" alt="kvm10"></p><p>这时候我们再通过<code>brctl show</code>来查看网桥挂载情况，br0下面已经多了一个vnet0虚拟网卡了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ brctl show</span><br><span class="line">bridge name    bridge idSTP enabled    interfaces</span><br><span class="line">br0    8000.2a5be3ec2698no        enp7s0</span><br><span class="line">        vnet0</span><br><span class="line">docker08000.02424524dcceno        veth580af8e</span><br><span class="line">        veth74119f3</span><br><span class="line">        vethd270ee8</span><br><span class="line">        vethe7a2b0f</span><br><span class="line">        vethfe89039</span><br></pre></td></tr></table></figure></p><p>虚拟机装完后，默认的hostname是localhost，针对centos7，我们可以通过如下命令来修改hostname<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl set-hostname dev-server1</span><br></pre></td></tr></table></figure></p><p>然后在/etc/hosts文件中添加127.0.0.1的host映射 dev-server1<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 dev-server1</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure></p><blockquote><p>Note: 如果出现虚拟机中无法访问外网，外部主机也无法ping通虚拟机的情况，则尝试如下处理</p></blockquote><p>向文件/etc/sysctl.conf添加以下代码，禁用网络过滤器:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 0</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 0</span><br><span class="line">net.bridge.bridge-nf-call-arptables = 0</span><br></pre></td></tr></table></figure></p><p>重新加载kernel参数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01: sudo sysctl -p</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">...</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 0</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 0</span><br><span class="line">net.bridge.bridge-nf-call-arptables = 0</span><br></pre></td></tr></table></figure></p><h2 id="3-虚拟机管理"><a href="#3-虚拟机管理" class="headerlink" title="3. 虚拟机管理"></a>3. 虚拟机管理</h2><ol><li>列出当前运行的虚拟机<code>virsh list</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh list</span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 5     dev-server1                    running</span><br></pre></td></tr></table></figure></li></ol><p>如果列出所有的，则<code>virsh list --all</code></p><ol start="2"><li>从宿主机进入虚拟机<code>virsh console</code>，后面接虚拟机ID或名称<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh console 5</span><br><span class="line">Connected to domain dev-server1</span><br><span class="line">Escape character is ^]</span><br><span class="line"></span><br><span class="line">CentOS Linux 7 (Core)</span><br><span class="line">Kernel 3.10.0-957.el7.x86_64 on an x86_64</span><br><span class="line"></span><br><span class="line">dev-server1 login:</span><br></pre></td></tr></table></figure></li></ol><p>输入用户名，密码即可登录虚拟机，按<code>Ctrl+]</code>可退出。</p><ol start="3"><li><p>启动与关闭虚拟机<code>virsh start|shutdown</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devuser@cserver_01:~$ virsh start dev-server1</span><br><span class="line">Domain dev-server1 started</span><br><span class="line"></span><br><span class="line">devuser@server_01:~$ virsh shutdown 5</span><br><span class="line">Domain 5 is being shutdown</span><br></pre></td></tr></table></figure></li><li><p>libvirtd启动时，自动启动虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh autostart dev-server1</span><br><span class="line">Domain dev-server1 marked as autostarted</span><br></pre></td></tr></table></figure></li><li><p>挂起/恢复虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh suspend dev-server1    # 挂起虚拟机</span><br><span class="line">devuser@server_01:~$ virsh resume dev-server1    # 恢复挂起的虚拟机</span><br></pre></td></tr></table></figure></li><li><p>销毁虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devuser@server_01:~$ virsh undefine dev-server1   # 彻底销毁虚拟机，会删除虚拟机配置文件，但不会删除虚拟磁盘</span><br></pre></td></tr></table></figure></li></ol><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">  </p>]]></content>
      
      
      <categories>
          
          <category> 高效实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件项目研发流程该怎么规范</title>
      <link href="/project-process.html"/>
      <url>/project-process.html</url>
      
        <content type="html"><![CDATA[<p>在软件项目研发管理过程中，是否经常出现这样的场景：开发人员不知道什么时候转测；项目经理拿个Excel文档群里一发，某任务前天就应该完成的，怎么现在还没开始搞；前端问这部分UI是谁在做，什么时候能做完；测试说线上这个bug又是谁改出来的，这次没转测这模块……等等。整个协作感觉一团乱麻，团队内部充满了甩锅与抱怨的氛围。软件项目的研发流程该怎么规范，让团队成员都能目标明确，步调一致，让产品迭代充满节奏感。本文基于笔者项目研发管理经验整理，希望起到抛砖引玉的作用，探讨高效团队的协作流程模式。<br><a id="more"></a></p><h2 id="1-协作流程图"><a href="#1-协作流程图" class="headerlink" title="1. 协作流程图"></a>1. 协作流程图</h2><p><img src="/assets/project.png" alt="协作流程图"></p><p>基本原则：</p><ol><li>所有问题可跟踪 （需求、Bug、优化）</li><li>所有工作透明化 （工作量、进展、Block因素）</li></ol><h2 id="2-各阶段内容详解"><a href="#2-各阶段内容详解" class="headerlink" title="2. 各阶段内容详解"></a>2. 各阶段内容详解</h2><h3 id="2-1-需求收集确认"><a href="#2-1-需求收集确认" class="headerlink" title="2.1. 需求收集确认"></a>2.1. 需求收集确认</h3><p>本阶段主要是与产品经理相关的活动内容：</p><ol><li>产品经理在每次版本开始之前定期收集各方需求，包括客户反馈、领导意见（对很多中小企业来说，老板就是最大的“用户”）、市场调研及技术团队需求等来源，输出需求列表</li><li>在版本开始之前召开<strong>版本计划会议</strong>，参与者包括项目经理、产品经理，及项目核心成员，按优先级梳理需求列表，输出下次版本的初步任务列表（之所以说初步，是因为该列表后面可能根据评审情况进行调整）</li><li>产品经理基于初步任务列表完成详细需求文档，组织团队成员——包括相关UI、开发、测试，召开 <strong>需求评审会议</strong>，输出评审意见及修正完成时间</li><li>产品经理针对需求评审会议中团队提出的意见建议，在修正完成时间内及时修正需求文档，并及时通知团队相关成员，输出确定的需求文档</li></ol><blockquote><p>注：可在需求评审会议后，进行任务的初步认领分配与时间估算，初步<strong>确定转测、上线时间节点</strong></p></blockquote><h3 id="2-2-设计开发"><a href="#2-2-设计开发" class="headerlink" title="2.2. 设计开发"></a>2.2. 设计开发</h3><ol><li>项目经理根据需求文档完成任务拆解，并在任务管理系统中创建对应任务单，指定经办人</li><li>各经办人认领任务后，根据自身任务的期限，及时与依赖方沟通，确定依赖任务的完成时间，以免影响自身任务进度，存在问题及时向项目经理反馈。</li><li>UI设计完成后，相关开发人员与产品经理需对UI设计进行确认，如果涉及内容较多，可组织<strong>UI评审会议</strong>（由产品经理或项目经理权衡组织）</li><li>涉及流程的开发任务需要有必要的设计，技术相关负责人负责对<strong>设计review</strong>，没有review的设计不能开发；任务开发完成需要进行<strong>代码review</strong></li><li>项目经理定期组织项目例会（紧急版本建议每天一次，较长期版本建议一周一次或两次），持续跟进任务进度与问题，并及时协调处理，以保障进度预期</li><li>在预定转测时间节点前一天，开发人员编写转测文档，描述本次版本调整内容（附上任务列表）及注意事项，并通知项目相关人员（钉钉群或邮件）</li></ol><h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3. 测试"></a>2.3. 测试</h3><ol><li>需求评审会议后，测试人员需对各功能模块编写测试用例文档，并在转测前组织<strong>测试评审会议</strong>，对各功能各环节进行复核与查漏补缺</li><li>一次版本任务可根据情况分批测试，并确定每轮转测的内容与时间节点；分批测试完成后，需在上线前进行集成测试，注意预留一定的时间用于问题修复</li><li>测试完成，需要将测试结论通报项目相关人员（钉钉群或邮件），包括遗留问题与是否达到上线要求结论</li></ol><blockquote><p>注：产品经理可在转测后对开发实现进行验收，以确定开发是否符合需求实际，以便及时进行调整</p></blockquote><h3 id="2-4-上线"><a href="#2-4-上线" class="headerlink" title="2.4. 上线"></a>2.4. 上线</h3><ol><li>上线人员需在上线前编写上线方案文档，记录此次上线内容，并对此次上线操作进行推演，对所涉及的所有操作按步骤进行记录，如数据库操作，代码merge，jenkins构建等；对可能存在的问题进行备注及对应的处理方案，并提交技术相关负责人review</li><li>项目经理结合测试结论及其它各方面情况，决策是否上线，并将意见通知到项目相关人员（钉钉群或邮件）</li><li>上线人员按照上线方案文档记录的步骤，依次完成上线操作（上线操作最好至少由两人完成，一人操作，一人检视，避免出错）</li><li>上线完成后，测试人员与产品经理对此次上线进行线上验证，确保线上功能流程无问题</li><li>验证无误后，由项目经理或其他指定负责人将上线通知发布至利益相关者，包括项目团队所有成员及相关合作方，说明上线时间、上线内容、影响因素、注意事项等（即时通讯群或邮件）</li></ol><h3 id="2-5-复盘"><a href="#2-5-复盘" class="headerlink" title="2.5. 复盘"></a>2.5. 复盘</h3><ol><li>版本结束后，项目经理根据情况对上个周期组织复盘总结会，总结存在的问题与原因，及后续规避的办法，总结积累的经验等</li></ol><blockquote><p>以上各阶段并不是完全串行推进的，相互之间存在一些穿插，比如下一版本需求的收集整理与当前版本的开发是并行推进的，开发与测试也可以以分阶段转测的形式并行推进，等等。</p></blockquote><h2 id="3-一些常用工具"><a href="#3-一些常用工具" class="headerlink" title="3. 一些常用工具"></a>3. 一些常用工具</h2><ol><li>jira 用于项目任务管理，其中Agile插件可方便查看整体任务面板，对任务状态一目了然，需要求团队成员养成及时更新状态的习惯</li><li>confluence 文档管理，用于各类文档的集中化维护，以上所述的如需求文档、开发设计文档、转测文档、上线文档等均可使用confluence以项目空间的形式集中化管理。</li><li>gitlab 代码管理</li><li>jenkins 项目部署构建工具</li><li>nexus 搭建maven私有库</li></ol><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>团队工作讲求步调与节奏，好的流程与规范可以让一个水平一般的人也能充分发挥其作用，从而让团队整体稳步前进，高效产出。而不好的流程，或根本不重视流程的团队，却往往一盘散沙，甩锅与抱怨充斥，战斗力低下。本文以相对较粗粒度对软件项目的基本流程管理做了介绍，更细节的内容可能需要团队根据内部具体情况进行相应处理与对待。链接： <a href="https://pan.baidu.com/s/1WBHsIWoquKTQHJ6IaSql3Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1WBHsIWoquKTQHJ6IaSql3Q</a>  是笔者基于以前团队敏捷项目管理及一些具体问题的思考分享PPT，供参考。提取码：awya </p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">   </p>]]></content>
      
      
      <categories>
          
          <category> teamwork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> agile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池的基本原理，看完就懂了</title>
      <link href="/threadpool.html"/>
      <url>/threadpool.html</url>
      
        <content type="html"><![CDATA[<p>本文内容是基于研发部门内部的分享整理，记录下来供学习或回顾。</p><a id="more"></a><h2 id="1-为什么要用线程池"><a href="#1-为什么要用线程池" class="headerlink" title="1. 为什么要用线程池"></a>1. 为什么要用线程池</h2><ol><li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建、销毁线程造成的消耗。 </p></li><li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控</p></li></ol><h2 id="2-ThreadPoolExecutor线程池类参数详解"><a href="#2-ThreadPoolExecutor线程池类参数详解" class="headerlink" title="2. ThreadPoolExecutor线程池类参数详解"></a>2. ThreadPoolExecutor线程池类参数详解</h2><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">corePoolSize</td><td style="text-align:center">核心线程数量，线程池维护线程的最少数量</td></tr><tr><td style="text-align:center">maximumPoolSize</td><td style="text-align:center">线程池维护线程的最大数量  </td></tr><tr><td style="text-align:center">keepAliveTime</td><td style="text-align:center">线程池除核心线程外的其他线程的最长空闲时间，超过该时间的空闲线程会被销毁</td></tr><tr><td style="text-align:center">unit</td><td style="text-align:center">keepAliveTime的单位，TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS</td></tr><tr><td style="text-align:center">workQueue</td><td style="text-align:center">线程池所使用的任务缓冲队列</td></tr><tr><td style="text-align:center">threadFactory</td><td style="text-align:center">线程工厂，用于创建线程，一般用默认的即可</td></tr><tr><td style="text-align:center">handler</td><td style="text-align:center">线程池对拒绝任务的处理策略</td></tr></tbody></table><p>当线程池任务处理不过来的时候（什么时候认为处理不过来后面描述），可以通过handler指定的策略进行处理，ThreadPoolExecutor提供了四种策略：</p><ol><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常；也是默认的处理方式。</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ol><p>可以通过实现RejectedExecutionHandler接口自定义处理方式。</p><h2 id="3-线程池任务执行"><a href="#3-线程池任务执行" class="headerlink" title="3. 线程池任务执行"></a>3. 线程池任务执行</h2><h3 id="3-1-添加执行任务"><a href="#3-1-添加执行任务" class="headerlink" title="3.1. 添加执行任务"></a>3.1. 添加执行任务</h3><ul><li>submit() 该方法返回一个Future对象，可执行带返回值的线程；或者执行想随时可以取消的线程。Future对象的get()方法获取返回值。Future对象的cancel(true/false)取消任务，未开始或已完成返回false，参数表示是否中断执行中的线程</li><li>execute() 没有返回值。</li></ul><h3 id="3-2-线程池任务提交过程"><a href="#3-2-线程池任务提交过程" class="headerlink" title="3.2. 线程池任务提交过程"></a>3.2. 线程池任务提交过程</h3><p>一个线程提交到线程池的处理流程如下图<br><img src="/assets/threadpool.png" alt="线程池任务提交"></p><ol><li>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 </li><li>如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。 </li><li>如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。 </li><li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。 </li><li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。</li></ol><p>总结即：处理任务判断的优先级为 核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 </p><p><strong> 注意：</strong></p><ol><li>当workQueue使用的是无界限队列时，maximumPoolSize参数就变的无意义了，比如new LinkedBlockingQueue(),或者new ArrayBlockingQueue(Integer.MAX_VALUE);</li><li>使用SynchronousQueue队列时由于该队列没有容量的特性，所以不会对任务进行排队，如果线程池中没有空闲线程，会立即创建一个新线程来接收这个任务。maximumPoolSize要设置大一点。</li><li>核心线程和最大线程数量相等时keepAliveTime无作用.</li></ol><h3 id="3-3-线程池关闭"><a href="#3-3-线程池关闭" class="headerlink" title="3.3. 线程池关闭"></a>3.3. 线程池关闭</h3><ol><li>shutdown() 不接收新任务,会处理已添加任务</li><li>shutdownNow() 不接受新任务,不处理已添加任务,中断正在处理的任务</li></ol><h2 id="4-常用队列介绍"><a href="#4-常用队列介绍" class="headerlink" title="4. 常用队列介绍"></a>4. 常用队列介绍</h2><ol><li>ArrayBlockingQueue： 这是一个由数组实现的容量固定的有界阻塞队列.</li><li>SynchronousQueue： 没有容量，不能缓存数据；每个put必须等待一个take; offer()的时候如果没有另一个线程在poll()或者take()的话返回false。</li><li>LinkedBlockingQueue： 这是一个由单链表实现的默认无界的阻塞队列。LinkedBlockingQueue提供了一个可选有界的构造函数，而在未指明容量时，容量默认为Integer.MAX_VALUE。</li></ol><p>队列操作:</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">增加一个元索; 如果队列已满，则抛出一个异常</td></tr><tr><td style="text-align:center">remove</td><td style="text-align:center">移除并返回队列头部的元素; 如果队列为空，则抛出一个异常</td></tr><tr><td style="text-align:center">offer</td><td style="text-align:center">添加一个元素并返回true; 如果队列已满，则返回false</td></tr><tr><td style="text-align:center">poll</td><td style="text-align:center">移除并返回队列头部的元素; 如果队列为空，则返回null</td></tr><tr><td style="text-align:center">put</td><td style="text-align:center">添加一个元素; 如果队列满，则阻塞</td></tr><tr><td style="text-align:center">take</td><td style="text-align:center">移除并返回队列头部的元素; 如果队列为空，则阻塞</td></tr><tr><td style="text-align:center">element</td><td style="text-align:center">返回队列头部的元素; 如果队列为空，则抛出一个异常</td></tr><tr><td style="text-align:center">peek</td><td style="text-align:center">返回队列头部的元素; 如果队列为空，则返回null</td></tr></tbody></table><h2 id="5-Executors线程工厂类"><a href="#5-Executors线程工厂类" class="headerlink" title="5. Executors线程工厂类"></a>5. Executors线程工厂类</h2><ol><li><p>Executors.newCachedThreadPool();<br>说明: 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.<br>内部实现：new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue<runnable>());</runnable></p></li><li><p>Executors.newFixedThreadPool(int);<br>说明: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>内部实现：new ThreadPoolExecutor(nThreads, nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<runnable>());</runnable></p></li><li><p>Executors.newSingleThreadExecutor();<br>说明:创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照顺序执行。<br>内部实现：new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<runnable>())</runnable></p></li><li><p>Executors.newScheduledThreadPool(int);<br>说明:创建一个定长线程池，支持定时及周期性任务执行。<br>内部实现：new ScheduledThreadPoolExecutor(corePoolSize)</p></li></ol><p><strong> 【附】阿里巴巴Java开发手册中对线程池的使用规范 </strong></p><ol start="2"><li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"TimerTaskThread"</span>); </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br>说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p></li><li>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样<br>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明： Executors 返回的线程池对象的弊端如下：<br>1） FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br>2） CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。</li></ol><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>ThreadPoolExecutor通过几个核心参数来定义不同类型的线程池，适用于不同的使用场景；其中在任务提交时，会依次判断corePoolSize， workQueque， 及maximumPoolSize，不同的状态不同的处理。技术领域水太深，如果不是日常使用，基本一段时间后某些知识点就忘的差不多了，因此阶段性地回顾与总结，对夯实自己的技术基础很有必要。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号">   </p>]]></content>
      
      
      <categories>
          
          <category> 高效实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（九）：统一异常处理</title>
      <link href="/springboot-error.html"/>
      <url>/springboot-error.html</url>
      
        <content type="html"><![CDATA[<p>都说管理的精髓就是“制度管人，流程管事”。而所谓流程，就是对一些日常工作环节、方式方法、次序等进行标准化、规范化。且不论精不精髓，在技术团队中，对一些通用场景，统一规范是必要的，只有步调一致，才能高效向前。如前后端交互协议，如本文探讨的异常处理。</p><a id="more"></a><h3 id="1-Spring-Mvc中的异常处理"><a href="#1-Spring-Mvc中的异常处理" class="headerlink" title="1. Spring Mvc中的异常处理"></a>1. Spring Mvc中的异常处理</h3><p>在spring mvc中，跟异常处理的相关类大致如下</p><p><img src="/assets/springmvcexresolver.png" alt="springmvn异常处理类"></p><p>上图中，spring mvc中处理异常的类（包括在请求映射时与请求处理过程中抛出的异常），都是 HandlerExceptionResolver 接口的实现，并且都实现了 Ordered 接口。与拦截器链类似，如果容器中存在多个实现了 HandlerExceptionResolver 接口的异常处理类，则它们的 resolveException 方法会被依次调用，顺序由order决定，值越小的先执行，只要其中一个调用返回不是null，则后续的异常处理将不再执行。</p><p>各实现类简单介绍如下：</p><ul><li>DefaultHandlerExceptionResolver： 这个是默认实现，处理Spring定义的各种标准异常，将其转换为对应的Http Status Code，具体处理的异常参考 doResolveException 方法</li><li>ResponseStatusExceptionResolver：用来支持@ResponseStatus注解使用的实现，如果自定义的异常通过@ResponseStatus注解进行了修饰，并且容器中存在ResponseStatusExceptionResolver的bean，则自定义异常抛出时会被该bean进行处理，返回注解定义的Http Status Code及内容给客户端</li><li>ExceptionHandlerExceptionResolver：用来支持@ExceptionHandler注解使用的实现，使用该注解修饰的方法来处理对应的异常。不过该注解的作用范围只在controller类，如果需要全局处理，则需要配合@ControllerAdvice注解使用。</li><li>SimpleMappingExceptionResolver：将异常映射为视图</li><li>HandlerExceptionResolverComposite：就是各类实现的组合，依次执行，只要其中一个处理返回不为null，则不再处理。</li></ul><p>因为本文主要是对spring boot如何对异常统一处理进行探讨，所以以上只对各实现做了基本介绍，更加详细的内容可查阅相关文档或后续再补上。</p><h3 id="2-Spring-Boot中如何统一异常处理"><a href="#2-Spring-Boot中如何统一异常处理" class="headerlink" title="2. Spring Boot中如何统一异常处理"></a>2. Spring Boot中如何统一异常处理</h3><p>通过第一部分介绍，可以使用@ExceptionHandler + @ControllerAdvice 组合的方式来实现异常的全局统一处理。对于REST服务来说，spring mvc提供了一个抽象类 ResponseEntityExceptionHandler， 该类类似于上面介绍的 DefaultHandlerExceptionResolver，对一些标准的异常进行了处理，但不是返回 ModelAndView对象， 而是返回 ResponseEntity对象。故我们可以基于该类来实现REST服务异常的统一处理<br>定义异常处理类 BaseWebApplicationExceptionHandler 如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseWebApplicationExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> includeStackTrace;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseWebApplicationExceptionHandler</span><span class="params">(<span class="keyword">boolean</span> includeStackTrace)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.includeStackTrace = includeStackTrace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BizException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">handleBizException</span><span class="params">(BizException ex)</span> </span>&#123;</span><br><span class="line">        logger.warn(<span class="string">"catch biz exception: "</span> + ex.toString(), ex.getCause());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.asResponseEntity(HttpStatus.valueOf(ex.getHttpStatus()), ex.getErrorCode(), ex.getErrorMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;IllegalArgumentException.class, IllegalStateException.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">handleIllegalArgumentException</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.warn(<span class="string">"catch illegal exception."</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.asResponseEntity(HttpStatus.BAD_REQUEST, HttpStatus.BAD_REQUEST.name().toLowerCase(), ex.getMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">handleException</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"catch exception."</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.asResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR, HttpStatus.INTERNAL_SERVER_ERROR.name().toLowerCase(), ExceptionConstants.INNER_SERVER_ERROR_MSG, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResponseEntity&lt;Object&gt; <span class="title">handleExceptionInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatus status, WebRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) &#123;</span><br><span class="line">            request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.warn(<span class="string">"catch uncustom exception."</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.asResponseEntity(status, status.name().toLowerCase(), ex.getMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResponseEntity&lt;Object&gt; <span class="title">asResponseEntity</span><span class="params">(HttpStatus status, String errorCode, String errorMessage, Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        data.put(BizException.ERROR_CODE, errorCode);</span><br><span class="line">        data.put(BizException.ERROR_MESSAGE, errorMessage);</span><br><span class="line">        <span class="comment">//是否包含异常的stack trace</span></span><br><span class="line">        <span class="keyword">if</span>(includeStackTrace)&#123;</span><br><span class="line">            addStackTrace(data, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(data, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addStackTrace</span><span class="params">(Map&lt;String, Object&gt; errorAttributes, Throwable error)</span> </span>&#123;</span><br><span class="line">        StringWriter stackTrace = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        error.printStackTrace(<span class="keyword">new</span> PrintWriter(stackTrace));</span><br><span class="line">        stackTrace.flush();</span><br><span class="line">        errorAttributes.put(BizException.ERROR_TRACE, stackTrace.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有几点：</p><ol><li>定义了一个includeStackTrace变量，来控制是否输出异常栈信息</li><li>自定义了一个异常类BizException，表示可预知的业务异常，并对它提供了处理方法，见handleBizException方法</li><li>对其它未预知异常，用Exception类型进行最后处理，见handleException方法</li><li>重写了超类的handleExceptionInternal方法，统一响应内容的字段与格式</li><li>针对REST服务，使用的是@RestControllerAdvice注解，而不是@ControllerAdvice</li></ol><p>BaseWebApplicationExceptionHandler是通过增强的方式对controller抛出的异常做了统一处理，那如果请求都没有到达controller怎么办，比如在过滤器那边就抛异常了，Spring Boot其实对错误的处理做了一些自动化配置，参考ErrorMvcAutoConfiguration类，具体这里不详述，只提出方案——自定义ErrorAttributes实现，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseErrorAttributes</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> includeStackTrace;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(WebRequest webRequest, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">        addStatus(errorAttributes, webRequest);</span><br><span class="line">        addErrorDetails(errorAttributes, webRequest, <span class="keyword">this</span>.includeStackTrace);</span><br><span class="line">        <span class="keyword">return</span> errorAttributes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>以上只列出了主要部分，具体实现可参考源码。这里同样定义了includeStackTrace来控制是否包含异常栈信息。</p><p>最后，将以上两个实现通过配置文件注入容器，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(ResponseEntityExceptionHandler.class)</span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(ErrorMvcAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"test"</span>, <span class="string">"formal"</span>, <span class="string">"prod"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntityExceptionHandler <span class="title">defaultGlobalExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试、正式环境，不输出异常的stack trace</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseWebApplicationExceptionHandler(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"default"</span>,<span class="string">"local"</span>,<span class="string">"dev"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntityExceptionHandler <span class="title">devGlobalExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//本地、开发环境，输出异常的stack trace</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseWebApplicationExceptionHandler(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"test"</span>, <span class="string">"formal"</span>, <span class="string">"prod"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorAttributes <span class="title">basicErrorAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试、正式环境，不输出异常的stack trace</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseErrorAttributes(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"default"</span>,<span class="string">"local"</span>,<span class="string">"dev"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorAttributes <span class="title">devBasicErrorAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//本地、开发环境，输出异常的stack trace</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseErrorAttributes(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>上面的@Profile主要是控制针对不同环境，输出不同的响应内容。以上配置的意思是在profile为default、local、dev时，响应内容中包含异常栈信息；profile为test、formal、prod时，响应内容不包含异常栈信息。这么做的好处是，开发阶段，当前端联调时，如果出错，可直接从响应内容中看到异常栈，方便服务端开发人员快速定位问题，而测试、生产环境， 就不要返回异常栈信息了。</p></blockquote><h3 id="3-基于Spring-Boot的异常处理规范"><a href="#3-基于Spring-Boot的异常处理规范" class="headerlink" title="3. 基于Spring Boot的异常处理规范"></a>3. 基于Spring Boot的异常处理规范</h3><ol><li>异常的表示形式<br>异常一般可通过自定义异常类，或定义异常的信息，比如code，message之类，然后通过一个统一的异常类进行封装。如果每一种异常都定义一个异常类，则会造成异常类过多，所以实践开发中我一般倾向于后者。<br>可以定义一个接口，该接口主要是方便后面的异常处理工具类实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseErrors</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>然后定义一个枚举，实现该接口，在该枚举中定义异常信息，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ErrorCodeEnum implements BaseErrors &#123;</span><br><span class="line">    qrcode_existed(<span class="string">"该公众号下已存在同名二维码"</span>),</span><br><span class="line">    authorizer_notexist(<span class="string">"公众号不存在"</span>),</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorCodeEnum</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>封装异常处理<br>分场景定义了ClientSideException，ServerSideException，UnauthorizedException，ForbiddenException异常，分别表示客户端异常（400），服务端异常（500），未授权异常（401），禁止访问异常（403），如ClientSideException定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientSideException</span> <span class="keyword">extends</span> <span class="title">BizException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E extends Enum&lt;E&gt; &amp; BaseErrors&gt; ClientSideException(E exceptionCode, Throwable cause) &#123;</span><br><span class="line">        <span class="keyword">super</span>(HttpStatus.BAD_REQUEST, exceptionCode, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E extends Enum&lt;E&gt; &amp; BaseErrors&gt; ClientSideException(E exceptionCode) &#123;</span><br><span class="line">        <span class="keyword">super</span>(HttpStatus.BAD_REQUEST, exceptionCode, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>并且提供一个异常工具类ExceptionUtil，方便不同场景使用，</p><ul><li>rethrowClientSideException：抛出ClientSideException，将以status code 400返回客户端。由客户端引起的异常调用该方法，如参数校验失败。</li><li>rethrowUnauthorizedException： 抛出UnauthorizedException，将以status code 401返回客户端。访问未授权时调用，如token校验失败等。</li><li>rethrowForbiddenException： 抛出ForbidenException，将以status code 403返回客户端。访问被禁止时调用，如用户被禁用等。</li><li>rethrowServerSideException： 抛出ServerSideException，将以status code 500返回客户端。服务端引起的异常调用该方法，如调用第三方服务异常，数据库访问出错等。</li></ul><p>在实际使用时，分两种情况，</p><ol><li><p>不通过try/catch主动抛出异常，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(appId)) &#123;</span><br><span class="line">    LOG.warn(<span class="string">"the authorizer for site[&#123;&#125;] is not existed."</span>, templateMsgRequestDto.getSiteId());</span><br><span class="line">    ExceptionUtil.rethrowClientSideException(ErrorCodeEnum.authorizer_notexist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过try/catch异常重新抛出（注意：可预知的异常，需要给客户端返回某种提示信息的，必须通过该方式重新抛出。否则将返回统一的code 500,提示“抱歉，服务出错了，请稍后重试”的提示信息）如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String result = wxOpenService.getWxOpenComponentService().getWxMpServiceByAppid(appId).getTemplateMsgService().sendTemplateMsg(templateMessage);</span><br><span class="line">    LOG.info(<span class="string">"result: &#123;&#125;"</span>, result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (WxErrorException wxException) &#123;</span><br><span class="line">    <span class="comment">//这里不需要打日志，会统一在异常处理里记录日志</span></span><br><span class="line">    ExceptionUtil.rethrowServerSideException(ExceptionCodeEnum.templatemsg_fail, wxException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>具体实现参考源码： <a href="https://github.com/ronwxy/base-spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/cn/jboost/springboot/autoconfig/error" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/cn/jboost/springboot/autoconfig/error</a><br>另附demo源码：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-error" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-error</a></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>本文写完感觉信息量有点多，对于不具备一定基础的人来说理解可能有点难度。如果有任何疑问，欢迎交流。后续有需要的话也可以针对某个环节再进行细化补充。本文所提的规范不一定是最好的实践，但规范或流程的管理，都是遵循先僵化，后优化，再固化的步骤，先解决有没有的问题，再解决好不好的问题。<br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用nvm来管理Node多版本</title>
      <link href="/use-nvm.html"/>
      <url>/use-nvm.html</url>
      
        <content type="html"><![CDATA[<p>最近在为前端配置jenkins持续集成环境时，在运行<code>npm install</code>下载依赖包的时候，速度极慢，而本地很快。对比node版本，一个v10.15.3，速度很快，一个v8.10.0，速度极慢。两者都设置了国内镜像。升级node能否解决问题？有没有工具支持node多版本管理，像python的anaconda一样？答案是有，叫nvm —— node version manager。<br><a id="more"></a></p><p>项目地址： <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a></p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>linux下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载并执行安装</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装后执行<span class="built_in">source</span>使其生效</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></p><blockquote><p>为了加速node的下载，可在~/.bashrc中添加 <code>export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</code></p></blockquote><p>windows：参考 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ol><li>列出所有node版本<br><code>nvm ls-remote</code></li></ol><ol start="2"><li><p>只列出长期支持版本，一般生产环境使用long term support版<br><code>nvm ls-remote --lts</code></p></li><li><p>安装指定版本<br><code>nvm install v10.15.3</code></p></li><li><p>安装完后即可查看安装的node及npm的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v  </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li><li><p>查看已安装版本<br><code>nvm ls</code></p></li><li><p>使用指定的版本，重连bash即失效<br><code>nvm use 10.15.3</code></p></li><li><p>设置默认，重连也生效<br><code>nvm alias default 10.15.3</code></p></li></ol><blockquote><p>配置npm国内淘宝镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line"></span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>nvm可在一个系统中非常便捷地管理多个node版本，并能自由切换使用哪个版本，方便需要多版本并存的场景。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy<br>————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> 高效实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redission-tomcat 快速实现从单机部署到多机部署</title>
      <link href="/session-redis.html"/>
      <url>/session-redis.html</url>
      
        <content type="html"><![CDATA[<p>一些项目初期出于简单快速，都是做单机开发与部署，但是随着业务的扩展或对可用性要求的提高，单机环境已不满足需求。单机部署往多机部署切换，其中可能存在的一个重要环节就是session的共享（如果一开始就是基于token的认证则可忽略）。本文介绍一个基于redis的tomcat session管理开源项目：redission-tomcat，可无代码侵入式地快速实现session共享。<br><a id="more"></a></p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>redisson是与jedis类似的一个redis客户端，其功能比jedis要更丰富一些。redission-tomcat是一个基于redis的tomcat session管理器项目，项目地址：<a href="https://github.com/redisson/redisson/tree/master/redisson-tomcat" target="_blank" rel="noopener">https://github.com/redisson/redisson/tree/master/redisson-tomcat</a> 。相比于其它实现，该项目的存储更为高效，写操作也更为优化。每一个session参数是在调用<code>HttpSession.setAttribute</code>时写入redis的，其它方案却一般是每次都将整个session进行序列化后写入。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ol><li><p>将<a href="https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&amp;g=org.redisson&amp;a=redisson-all&amp;v=3.11.0&amp;e=jar" target="_blank" rel="noopener">redisson-all-3.11.0.jar</a>，<a href="https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&amp;g=org.redisson&amp;a=redisson-tomcat-8&amp;v=3.11.0&amp;e=jar" target="_blank" rel="noopener">redisson-tomcat-8-3.11.0.jar</a>（针对tomcat8，其它版本可在上述项目地址页面找到下载链接）两个jar包下载放到tomcat的lib目录下。</p></li><li><p>在tomcat conf目录下的context.xml文件中添加如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"org.redisson.tomcat.RedissonSessionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">configPath</span>=<span class="string">"$&#123;catalina.base&#125;/conf/redisson.conf"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">readMode</span>=<span class="string">"MEMORY"</span> <span class="attr">updateMode</span>=<span class="string">"AFTER_REQUEST"</span> <span class="attr">broadcastSessionEvents</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>其中</p><ul><li>configPath：指向Redisson的json或yaml格式的配置文件，第3步中给出。</li><li>readMode：session属性的读取模式。可取值 1. MEMORY, 该模式会将session属性同时保存到本地tomcat session与redis中，后续的session更新通过redis事件传播到本地tomcat session；2. REDIS，只将session属性保存到redis中。默认为REDIS。</li><li>updateMode：session属性的更新模式。可取值 1. DEFAULT，session属性只通过<code>setAttribute</code>方法保存到redis中；2. AFTER_REQUEST，在每次请求之后，将所有session属性保存至redis。默认为DEFAULT。</li><li>broadcastSessionEvents：如果设置为true，则sessionCreated与sessionDestroyed事件将会被广播到所有tomcat实例，并使所有注册的HttpSessionListeners监听器被触发。默认为false。</li></ul><ol start="3"><li>在tomcat conf目录下新增配置文件redisson.conf，内容如下<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"singleServerConfig"</span>:&#123;</span><br><span class="line">    <span class="attr">"idleConnectionTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"connectTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"retryAttempts"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">"retryInterval"</span>:<span class="number">1500</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"123456"</span>,</span><br><span class="line">    <span class="attr">"subscriptionsPerConnection"</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="attr">"clientName"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"address"</span>: <span class="string">"redis://127.0.0.1:6379"</span>,</span><br><span class="line">    <span class="attr">"subscriptionConnectionMinimumIdleSize"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"subscriptionConnectionPoolSize"</span>:<span class="number">50</span>,</span><br><span class="line">    <span class="attr">"connectionMinimumIdleSize"</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="attr">"connectionPoolSize"</span>:<span class="number">64</span>,</span><br><span class="line">    <span class="attr">"database"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"dnsMonitoringInterval"</span>:<span class="number">5000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"threads"</span>:<span class="number">16</span>,</span><br><span class="line">  <span class="attr">"nettyThreads"</span>:<span class="number">32</span>,</span><br><span class="line">  <span class="attr">"codec"</span>:&#123;</span><br><span class="line">    <span class="attr">"class"</span>:<span class="string">"org.redisson.codec.FstCodec"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"transportMode"</span>:<span class="string">"NIO"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上为单机模式redis环境配置，其中password，address修改为自己的值。如果是集群模式，则配置文件为<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sentinelServersConfig"</span>:&#123;</span><br><span class="line">    <span class="attr">"idleConnectionTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"connectTimeout"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"retryAttempts"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">"retryInterval"</span>:<span class="number">1500</span>,</span><br><span class="line">    <span class="attr">"failedSlaveReconnectionInterval"</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"failedSlaveCheckInterval"</span>:<span class="number">60000</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"subscriptionsPerConnection"</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="attr">"clientName"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"loadBalancer"</span>:&#123;</span><br><span class="line">      <span class="attr">"class"</span>:<span class="string">"org.redisson.connection.balancer.RoundRobinLoadBalancer"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"subscriptionConnectionMinimumIdleSize"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"subscriptionConnectionPoolSize"</span>:<span class="number">50</span>,</span><br><span class="line">    <span class="attr">"slaveConnectionMinimumIdleSize"</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="attr">"slaveConnectionPoolSize"</span>:<span class="number">64</span>,</span><br><span class="line">    <span class="attr">"masterConnectionMinimumIdleSize"</span>:<span class="number">24</span>,</span><br><span class="line">    <span class="attr">"masterConnectionPoolSize"</span>:<span class="number">64</span>,</span><br><span class="line">    <span class="attr">"readMode"</span>:<span class="string">"SLAVE"</span>,</span><br><span class="line">    <span class="attr">"subscriptionMode"</span>:<span class="string">"SLAVE"</span>,</span><br><span class="line">    <span class="attr">"sentinelAddresses"</span>:[</span><br><span class="line">      <span class="string">"redis://127.0.0.1:26379"</span>,</span><br><span class="line">      <span class="string">"redis://127.0.0.1:26389"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"masterName"</span>:<span class="string">"mymaster"</span>,</span><br><span class="line">    <span class="attr">"database"</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"threads"</span>:<span class="number">16</span>,</span><br><span class="line">  <span class="attr">"nettyThreads"</span>:<span class="number">32</span>,</span><br><span class="line">  <span class="attr">"codec"</span>:&#123;</span><br><span class="line">    <span class="attr">"class"</span>:<span class="string">"org.redisson.codec.FstCodec"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"transportMode"</span>:<span class="string">"NIO"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>我们可以使用nginx来实现负载均衡，参考配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream cnserver&#123;</span><br><span class="line">  server 127.0.0.1:8080 weight=2 fail_timeout=10s max_fails=1;</span><br><span class="line">  server 127.0.0.1:8081 weight=2 fail_timeout=10s max_fails=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  index index.html index.htm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  location /rest/ &#123;</span><br><span class="line">    index index.html;</span><br><span class="line">    proxy_pass http://cnserver/rest/;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上即为使用redisson-tomcat来实现单机部署到多机部署的所有配置。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>技术架构都是随着业务的发展而不断演进。在业务发展初期，用户量、业务复杂度都相对较低，为了实现快速上线验证，往往采用简单单一的架构。许多项目可能还没来得及进行架构演进升级就GG了，而有幸继续成长的项目必然会随着业务的扩张不断优化与升级。本文介绍的redisson-tomcat可帮助单机项目快速切换到多机支持，当然只是在session管理环节。如果涉及到其它如文件上传，定时任务等分布式支持，则要另做相应调整了。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （一个不只有实战干货的技术公众号， 欢迎关注）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> 高效实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> session </tag>
            
            <tag> tomcat </tag>
            
            <tag> redission </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger api文档集中化注册管理</title>
      <link href="/swagger-register.html"/>
      <url>/swagger-register.html</url>
      
        <content type="html"><![CDATA[<p>接口文档是前后端开发对接时很重要的一个组件。手动编写接口文档既费时，又存在文档不能随代码及时更新的问题，因此产生了像swagger这样的自动生成接口文档的框架。swagger文档一般是随项目代码生成与更新，访问地址也是基于项目地址，因此对项目数不多的团队还好。如果团队的项目很多，比如采用微服务架构的团队，动则几十甚至上百个服务项目，那就意味着前端开发人员需要记住几十甚至上百个swagger文档地址，那就很不友好了。目前貌似还没有较流行的API文档集中化管理项目（也或者是我没找到），因此花了点时间自己集成了一个，介绍如下。</p><a id="more"></a><h3 id="1-swagger-bootstrap-ui项目"><a href="#1-swagger-bootstrap-ui项目" class="headerlink" title="1. swagger-bootstrap-ui项目"></a>1. swagger-bootstrap-ui项目</h3><p>该项目是github上的一个开源项目（<a href="https://github.com/xiaoymin/swagger-bootstrap-ui" target="_blank" rel="noopener">https://github.com/xiaoymin/swagger-bootstrap-ui</a> ），对swagger ui做了增强，功能整体看起来要丰富一些。来看看效果，</p><p><img src="/assets/swaggerui.png" alt="swagger-bootstrap-ui"></p><p>该项目的调试url地址原本是基于自身服务的，我将它改为了注册服务的url地址，以支持注册服务的接口调试。调整后的源码地址： <a href="https://github.com/ronwxy/swagger-bootstrap-ui" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-bootstrap-ui</a></p><h3 id="2-swagger-api注册服务"><a href="#2-swagger-api注册服务" class="headerlink" title="2. swagger api注册服务"></a>2. swagger api注册服务</h3><p>该项目集成了swagger-bootstrap-ui，并提供了swagger api注册接口，接受所有提供了有效配置的服务项目注册，让注册的服务在一个页面上可统一查看，再也不用记太多文档地址了。</p><p><img src="/assets/swaggerui2.png" alt="swagger-bootstrap-ui2"></p><p>启动注册服务后，访问 <a href="http://localhost:11090/doc.html" target="_blank" rel="noopener">http://localhost:11090/doc.html</a> 打开文档页面。如上图，可通过下拉列表来选择不同项目，加载项目的接口文档查看或调试。<br>项目地址： <a href="https://github.com/ronwxy/swagger-register" target="_blank" rel="noopener">https://github.com/ronwxy/swagger-register</a> （如果觉得有用，不要吝啬你的star，反正又不要钱，O(∩_∩)O）</p><h3 id="3-服务端配置"><a href="#3-服务端配置" class="headerlink" title="3. 服务端配置"></a>3. 服务端配置</h3><p>在业务服务端，需要提供一些配置。<br>首先，需要配置一些Bean，如下提供了一个配置类（这里只列出了主要部分，完整代码参考： <a href="https://github.com/ronwxy/base-spring-boot）" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot）</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2AutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">restApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ParameterBuilder builder = <span class="keyword">new</span> ParameterBuilder();</span><br><span class="line">        builder.name(<span class="string">"x-auth-token"</span>).description(<span class="string">"授权token"</span>)</span><br><span class="line">                .modelRef(<span class="keyword">new</span> ModelRef(<span class="string">"string"</span>))</span><br><span class="line">                .parameterType(<span class="string">"header"</span>)</span><br><span class="line">                .required(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(groupName)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(apisBasePackage))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .globalOperationParameters(Collections.singletonList(builder.build()))</span><br><span class="line">                .apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"dev"</span>&#125;)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">swaggerRegistar</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SwaggerInfoRegistar(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * use to register swagger api info url to swagger api registry;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> liubo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerInfoRegistar</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String url = buildLocalSwaggerDocsUrl();</span><br><span class="line">            registerLocalSwaggerUrl(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * register the v2/api-docs url</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerLocalSwaggerUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">            RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">            restTemplate.getMessageConverters().add(<span class="keyword">new</span> FormHttpMessageConverter());</span><br><span class="line">            MultiValueMap&lt;String, Object&gt; body = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            body.add(<span class="string">"project"</span>, getApiTitle());</span><br><span class="line">            body.add(<span class="string">"url"</span>, url);</span><br><span class="line">            ResponseEntity&lt;Map&gt; re = restTemplate.postForEntity(getSwaggerRegisterUrl(), body, Map.class);</span><br><span class="line">            <span class="keyword">if</span> (HttpStatus.OK.equals(re.getStatusCode())) &#123;</span><br><span class="line">                logger.info(<span class="string">"swagger api registered success to &#123;&#125;"</span>, getSwaggerRegisterUrl());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"swagger api registered failed [&#123;&#125;]"</span>, re.getBody().get(<span class="string">"msg"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该类完成了swagger的基本配置，同时将swagger的/v2/api-docs地址注册到了步骤2中介绍的注册服务。</p><p>然后，因为要从注册服务端调用该业务服务的接口进行调试，存在跨域，因此服务需要做跨域支持，配置文件中添加如下定义，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"corsFilterRegistrationBean"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line"></span><br><span class="line">    CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    corsConfiguration.applyPermitDefaultValues();</span><br><span class="line">    corsConfiguration.setAllowedMethods(Arrays.asList(CorsConfiguration.ALL));</span><br><span class="line">    corsConfiguration.addExposedHeader(HttpHeaders.DATE);</span><br><span class="line"></span><br><span class="line">    corsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line"></span><br><span class="line">    CorsFilter corsFilter = <span class="keyword">new</span> CorsFilter(corsConfigurationSource);</span><br><span class="line">    FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    filterRegistrationBean.setFilter(corsFilter);</span><br><span class="line">    filterRegistrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    filterRegistrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在属性配置文件application.yml中配置一些必要的属性，<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">swagger:</span></span><br><span class="line"><span class="attr">  api-title:</span> <span class="string">Demo标题</span>  <span class="comment">#会展示在下拉列表框中，一般写项目名称</span></span><br><span class="line"><span class="attr">  api-description:</span>  <span class="string">Demo描述，集中注册</span></span><br><span class="line"><span class="attr">  group-name:</span> <span class="string">Demo项目</span></span><br><span class="line"><span class="attr">  apis-base-package:</span> <span class="string">cn.jboost.springboot.swagger</span> <span class="comment"># API类所在包名</span></span><br><span class="line"><span class="attr">  swagger-registry-path:</span> <span class="attr">http://localhost:11090/swagger/register</span>  <span class="comment">#就是2中注册服务的注册接口地址</span></span><br></pre></td></tr></table></figure></p><p>配置完后， 就可以像一般项目一样编写接口类，加swagger注解。项目启动时， 会自动向注册服务完成注册，刷新注册服务的文档页面即可在下拉列表看到。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>本文介绍了一个基于swagger ui增强版项目swagger-bootstrap-ui的接口文档集中化管理实现。采用该实现，将所有swagger在线接口文档集中管理，有效提高前后端对接效率。</p><p>如果觉得本文有用，欢迎转发、推荐。</p><p><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （欢迎关注，及时获取技术干货分享）<br>———————————————————————————————————————————————————————————————<br><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> 高效实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（八）：集成AOPLog来记录接口访问日志</title>
      <link href="/springboot-aoplog.html"/>
      <url>/springboot-aoplog.html</url>
      
        <content type="html"><![CDATA[<p>日志是一个Web项目中必不可少的部分，借助它我们可以做许多事情，比如问题排查、访问统计、监控告警等。一般通过引入slf4j的一些实现框架来做日志功能，如log4j,logback,log4j2，其性能也是依次增强。在springboot中，默认使用的框架是logback。我们经常需要在方法开头或结尾加日志记录传入参数或返回结果，以此来复现当时的请求情况。但是手动添加日志，不仅繁琐重复，也影响代码的美观简洁。本文引入一个基于AOP实现的日志框架，并通过spring-boot-starter的方式完成集成。</p><p>原文地址：<a href="http://blog.jboost.cn/springboot-aoplog.html">http://blog.jboost.cn/springboot-aoplog.html</a><br><a id="more"></a></p><h3 id="1-aop-logging项目"><a href="#1-aop-logging项目" class="headerlink" title="1. aop-logging项目"></a>1. aop-logging项目</h3><p>项目地址： <a href="https://github.com/ronwxy/aop-logging" target="_blank" rel="noopener">https://github.com/ronwxy/aop-logging</a><br>该项目基于 <a href="https://github.com/nickvl/aop-logging.git" target="_blank" rel="noopener">https://github.com/nickvl/aop-logging.git</a> ， 在其基础上添加了ReqId来串联某次客户端请求（参考<code>com.github.nickvl.xspring.core.log.aop.ReqIdFilter</code>）, 添加了方法执行时长（参考<code>com.github.nickvl.xspring.core.log.aop.AOPLogger.logTheMethod</code>方法中elapsedTime）。</p><p>该项目提供了基于注解的AOP日志功能。根据不同的日志级别，提供的注解有LogTrace,LogDebug,LogInfo,LogWarn,LogError,LogFatal,LogException，可修饰于类（等同于该类内所有方法上添加）与方法上，前面六个分别表示在不同日志级别下记录方法被调用的日志，LogException表示在方法抛出异常时，记录相应日志。这些注解都提供了一个LogPoint枚举类型的属性value，取值{IN,OUT,BOTH}，分别表示在方法调用入口、方法调用返回前，以及包含两者的位置打印对应日志，默认为BOTH。</p><h3 id="2-集成"><a href="#2-集成" class="headerlink" title="2. 集成"></a>2. 集成</h3><p>可以通过基于xml或基于java配置的方式来集成AOP日志功能，我这里基于java配置（基于xml的方式参考源码README文件）并且通过spring-boot-starter的形式进行封装（源码地址： <a href="https://github.com/ronwxy/base-spring-boot" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot</a> ），避免每个项目都需要配置。自动配置类如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(AOPLogger.class)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(AOPLogger.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopLoggerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SKIP_NULL_FIELDS = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; EXCLUDE_SECURE_FIELD_NAMES = Collections.emptySet();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AOPLogger <span class="title">aopLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">AOPLogger aopLogger = <span class="keyword">new</span> AOPLogger();</span><br><span class="line">aopLogger.setLogAdapter(<span class="keyword">new</span> UniversalLogAdapter(SKIP_NULL_FIELDS, EXCLUDE_SECURE_FIELD_NAMES));</span><br><span class="line"><span class="keyword">return</span> aopLogger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 注册一个过滤器，用来生成一个reqId，标记一次请求，从而将本次请求所产生的日志串联起来</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">reqIdFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ReqIdFilter reqIdFilter = <span class="keyword">new</span> ReqIdFilter();</span><br><span class="line">FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">registrationBean.setFilter(reqIdFilter);</span><br><span class="line">List&lt;String&gt; urlPatterns = Collections.singletonList(<span class="string">"/*"</span>);</span><br><span class="line">registrationBean.setUrlPatterns(urlPatterns);</span><br><span class="line">registrationBean.setOrder(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将基础框架base-spring-boot通过<code>mvn clean install</code>进行本地安装后，即可在项目中通过依赖进行引入（基础框架中已在spring-boot-parent中引入，直接继承亦可），如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aoplog-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><p>引入依赖之后，我们再定义一个日志配置文件logback-spring.xml，为了后面方便地将日志导入ELK做集中的日志分析管理，该配置文件中将日志以json格式输出，并根据日志级别分别写入debug.log,info.log,warn.log,error.log以及interface.log（专用于接口访问日志），配置示例如下（完整配置参考： <a href="https://github.com/ronwxy/springboot-demos/blob/master/springboot-aoplog/src/main/resources/logback-spring.xml）" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/blob/master/springboot-aoplog/src/main/resources/logback-spring.xml）</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"interfaceLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;logPath&#125;/elk/interface.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                        &#123;</span><br><span class="line">                        "project": "$&#123;projectName&#125;",</span><br><span class="line">                        "timestamp": "%date&#123;\"yyyy-MM-dd'T'HH:mm:ss,SSSZ\"&#125;",</span><br><span class="line">                        "log_level": "%level",</span><br><span class="line">                        "thread": "%thread",</span><br><span class="line">                        "class_name": "%X&#123;callingClass&#125;",</span><br><span class="line">                        "class_method":"%X&#123;callingMethod&#125;",</span><br><span class="line">                        "line_number": null,</span><br><span class="line">                        "message": "%message",</span><br><span class="line">                        "stack_trace": "%exception&#123;5&#125;",</span><br><span class="line">                        "req_id": "%X&#123;reqId&#125;",</span><br><span class="line">                        "elapsed_time": "#asLong&#123;%X&#123;elapsedTime&#125;&#125;"</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;logPath&#125;/bak/interface.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>1GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>为了将该日志配置文件可以不经修改地达到复用，将一些参数配置外置了，故需在配置文件applicaiton.yml中配置如下参数<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logger:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="attr">D:\logs</span> <span class="comment">#默认当前项目路径下的logs目录</span></span><br><span class="line"><span class="attr">  level:</span> <span class="string">info</span> <span class="comment"># 默认info</span></span><br><span class="line"><span class="attr">  apiPackage:</span> <span class="string">cn.jboost.springboot.aoplog.controller</span> <span class="comment">#必须配置, api接口类所在包</span></span><br><span class="line"><span class="attr">  rootPackage:</span> <span class="string">cn.jboost.springboot</span> <span class="comment">#必须配置，项目根包，记录该包内各类通过slf4j输出的日志</span></span><br></pre></td></tr></table></figure></p><p>最后，直接在需要记录访问日志的接口类上加注解@LogInfo就行了，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@LogInfo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AoplogTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestParam String user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi "</span> + user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：在pom.xml中默认添加的spring-boot-maven-plugin下需要添加repackage的goal才能自动生成日志目录与日志文件，如下所示</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动程序，调用@LogInfo标注的接口类下的API时，可以看到控制台有打印接口访问日志，如执行demo程序（源码： <a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-aoplog" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-aoplog</a> ），调用  <a href="http://localhost:8080/test?user=jboost" target="_blank" rel="noopener">http://localhost:8080/test?user=jboost</a> 时，控制台打印日志如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2019-06-27 14:29:59] [INFO ] [http-nio-8080-exec-1] [cn.jboost.springboot.aoplog.controller.AoplogTestController:184] --calling: test(user=jboost)</span><br><span class="line">[2019-06-27 14:29:59] [INFO ] [http-nio-8080-exec-1] [cn.jboost.springboot.aoplog.controller.AoplogTestController:189] --returning: test(1 arguments):Hi jboost</span><br></pre></td></tr></table></figure></p><p>日志文件interface.log中打印日志如下，（其中req_id在本次请求的所有日志都相同，这样就可以将一次请求的所有日志串联起来，便于分析与定位问题；elapsed_time标明了方法执行时长，可用于接口性能监测）<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"project"</span>:<span class="string">"aoplog-test"</span>,<span class="attr">"timestamp"</span>:<span class="string">"2019-06-27T14:29:59,030+0800"</span>,<span class="attr">"log_level"</span>:<span class="string">"INFO"</span>,<span class="attr">"thread"</span>:<span class="string">"http-nio-8080-exec-1"</span>,<span class="attr">"class_name"</span>:<span class="string">"cn.jboost.springboot.aoplog.controller.AoplogTestController"</span>,<span class="attr">"class_method"</span>:<span class="string">"test"</span>,<span class="attr">"line_number"</span>:<span class="literal">null</span>,<span class="attr">"message"</span>:<span class="string">"calling: test(user=jboost)"</span>,<span class="attr">"stack_trace"</span>:<span class="string">""</span>,<span class="attr">"req_id"</span>:<span class="string">"5d146267aa147904bc014e71"</span>,<span class="attr">"elapsed_time"</span>:<span class="literal">null</span>&#125;</span><br><span class="line">&#123;<span class="attr">"project"</span>:<span class="string">"aoplog-test"</span>,<span class="attr">"timestamp"</span>:<span class="string">"2019-06-27T14:29:59,036+0800"</span>,<span class="attr">"log_level"</span>:<span class="string">"INFO"</span>,<span class="attr">"thread"</span>:<span class="string">"http-nio-8080-exec-1"</span>,<span class="attr">"class_name"</span>:<span class="string">"cn.jboost.springboot.aoplog.controller.AoplogTestController"</span>,<span class="attr">"class_method"</span>:<span class="string">"test"</span>,<span class="attr">"line_number"</span>:<span class="literal">null</span>,<span class="attr">"message"</span>:<span class="string">"returning: test(1 arguments):Hi jboost"</span>,<span class="attr">"stack_trace"</span>:<span class="string">""</span>,<span class="attr">"req_id"</span>:<span class="string">"5d146267aa147904bc014e71"</span>,<span class="attr">"elapsed_time"</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>Web项目中经常需要通过查看接口请求及返回参数来定位问题，手动编写代码打印显得繁琐而重复。使用aop-logging通过简单的注解即可实现接口日志自动打印。本文介绍的方案与日志配置模板可直接用于实际项目开发。当然，注解不仅可用于Controller层，也可以用于Service等其它层，但一般Controller层加上即可，避免日志打印过多。</p><p>本文示例项目源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-aoplog" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-aoplog</a><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy （欢迎关注，及时获取技术干货分享）<br>——————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>案例解析：springboot自动配置未生效问题定位（条件断点）</title>
      <link href="/issue-conditiontrack.html"/>
      <url>/issue-conditiontrack.html</url>
      
        <content type="html"><![CDATA[<p>Spring Boot在为开发人员提供更高层次的封装，进而提高开发效率的同时，也为出现问题时如何进行定位带来了一定复杂性与难度。但Spring Boot同时又提供了一些诊断工具来辅助开发与分析，如spring-boot-starter-actuator。本文分享一个基于actuator与IDEA条件断点来定位自动配置未生效的案例。望对类似问题分析与处理提供参考。<br><a id="more"></a></p><h3 id="问题确认"><a href="#问题确认" class="headerlink" title="问题确认"></a>问题确认</h3><p>在前文介绍的 <a href="/springboot-tkmapper.html">Spring Boot从入门到实战：整合通用Mapper简化单表操作</a> 中，我们对druid连接池做了自动配置，并且注入了druid的监控统计功能，如下</p><p><img src="/assets/statviewservlet.png" alt="druidstat"></p><p>但本地运行后通过 <a href="http://localhost:8080/druid/index.html" target="_blank" rel="noopener">http://localhost:8080/druid/index.html</a> 访问时却出现错误，通过浏览器的开发者工具查看该请求返回404，推测上述代码中定义的<code>StatViewServlet</code>未注入成功。我们用actuator来确认下是否如此。在项目中加入spring-boot-starter-actuator，并且application.yml中添加如下配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">    endpoints:</span></span><br><span class="line"><span class="attr">        web:</span></span><br><span class="line"><span class="attr">            exposure:</span></span><br><span class="line"><span class="attr">                include:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">                exclude:</span> <span class="string">beans,trace</span></span><br><span class="line"><span class="attr">    endpoint:</span></span><br><span class="line"><span class="attr">        health:</span></span><br><span class="line"><span class="attr">            show-details:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></p><blockquote><p>在spring-boot 2.x 版本当中，作为安全性考虑，将actuator 控件中的端口，只默认开放/health 和/info 两个端口，其他端口默认关闭， 因此需要添加如上配置。注意include的值 <code>*</code> 必须加引号，否则无法启动。</p></blockquote><p>重启程序后访问 <a href="http://localhost:8080/actuator/conditions" target="_blank" rel="noopener">http://localhost:8080/actuator/conditions</a> 确认上述两个实例化方法未满足<code>@ConditionalOnProperty</code>的条件，从而未执行生效，如图</p><p><img src="/assets/actuatorconditions.png" alt="actuator"></p><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>从上面分析确认是因为条件注解 <code>@ConditionalOnProperty(prefix = &quot;spring.datasource.druid&quot;, name = &quot;druidServletSettings&quot;)</code> 未满足使方法未执行导致。那这个条件为什么没有满足呢，查看application.yml中也做了 spring.datasource.druid.druidServletSettings属性的配置。</p><p>当你无法理清头绪，确定问题原因时，那就Debug吧。查看注解<code>@ConditionalOnProperty</code>源码，找到其实现支持类<code>OnPropertyCondition</code>，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;OnPropertyCondition.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnProperty &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">havingValue</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matchIfMissing</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看<code>OnPropertyCondition</code>源码，了解它是通过<code>getMatchOutcome</code>方法来判断是否满足注解参数所指定的条件的，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">List&lt;AnnotationAttributes&gt; allAnnotationAttributes = annotationAttributesFromMultiValueMap(</span><br><span class="line">metadata.getAllAnnotationAttributes(</span><br><span class="line">ConditionalOnProperty.class.getName()));</span><br><span class="line">List&lt;ConditionMessage&gt; noMatch = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;ConditionMessage&gt; match = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes annotationAttributes : allAnnotationAttributes) &#123;</span><br><span class="line">ConditionOutcome outcome = determineOutcome(annotationAttributes,</span><br><span class="line">context.getEnvironment());</span><br><span class="line">(outcome.isMatch() ? match : noMatch).add(outcome.getConditionMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!noMatch.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.of(noMatch));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ConditionOutcome.match(ConditionMessage.of(match));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在调用<code>determineOutcome</code>处打断点，调试什么原因导致条件未满足，但是这里是一个for循环，如果for元素过多的话，将可能需要断点阻断很多次才能找到你想要查看的那个元素。所幸IDEA提供了不同类型的断点来处理这类问题，前面 <a href="/issue-errortrack.html">案例解析：使用IDEA异常断点来定位java.lang.ArrayStoreException的问题</a> 我们介绍了异常断点的使用。这里介绍用条件断点来处理这类循环块中的debug问题。</p><p>在上述代码for循环中调用<code>determineOutcome</code>行打断点，并在断点上右键，弹出如下窗口</p><p><img src="/assets/conditionbreak.png" alt="条件断点"></p><p>图中Condition框即可输入你要指定的条件，可以直接写java判断表达式代码，并引用该行代码处能访问的变量，如这里我们输入 <code>annotationAttributes.get(&quot;name&quot;).equals(&quot;druidServletSettings&quot;)</code>，然后点击Debug窗口的“Resume Program (F9)”按钮，则在不满足指定条件时，断点处将不会被阻断，直到条件满足，这样就能很容易定位到我们想要查看的元素。（当然这里<code>allAnnotationAttributes</code>变量其实只有一个元素，仅仅是为了演示条件变量的使用，当集合元素很多时，使用条件断点就能体会到它的方便之处）</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>通过Debug的方式深入条件注解的判断逻辑（其中循环处可使用条件断点），最终来到如下代码片段</p><p><img src="/assets/conditonbreak3.png" alt="判断条件"></p><p>在这里是判断来自所有属性源配置的属性中，是否包含条件注解指定的属性，即<code>spring.datasource.druid.druidServletSettings</code>，由上图可见，<code>spring.datasource.druid.druidServletSettings</code>只是某些属性的前缀，并不存在完全匹配的属性，因此返回false，导致条件不满足。回看注解@ConditionOnProperty的javadoc，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* If the property is not contained in the &#123;@link Environment&#125; at all, the</span><br><span class="line"> * &#123;@link #matchIfMissing()&#125; attribute is consulted. By default missing attributes do not</span><br><span class="line"> * match.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * This condition cannot be reliably used for matching collection properties. For example,</span><br><span class="line"> * in the following configuration, the condition matches if &#123;@code spring.example.values&#125;</span><br><span class="line"> * is present in the &#123;@link Environment&#125; but does not match if</span><br><span class="line"> * &#123;@code spring.example.values[0]&#125; is present.</span><br><span class="line"> *</span><br></pre></td></tr></table></figure></p><p>当Environment中不包含该属性时，则看matchIfMissing的值，该值默认为false，如果包含该属性，则再对比属性值与havingValue的值，相等即满足，不等则不满足。并且该条件注解不能用于匹配集合类型属性。上述<code>spring.datasource.druid.druidServletSettings</code>实际上属于一个Map类型，因此不能想当然地认为该注解是只要属性集中某属性名称包含该值即满足。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当难以定位到问题原因时，可以进行Debug，跟踪程序运行的各个步骤，当要在循环中Debug定位到某个元素时，可以用条件断点来实现。@ConditionalOnProperty注解不是存在某属性就行，还需要值相等，并且不适用于集合类型属性。<br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> 案例解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（七）：整合通用Mapper简化单表操作</title>
      <link href="/springboot-tkmapper.html"/>
      <url>/springboot-tkmapper.html</url>
      
        <content type="html"><![CDATA[<p>数据库访问是web应用必不可少的部分。现今最常用的数据库ORM框架有Hibernate与Mybatis，Hibernate貌似在传统IT企业用的较多，而Mybatis则在互联网企业应用较多。通用Mapper（<a href="https://github.com/abel533/Mapper）" target="_blank" rel="noopener">https://github.com/abel533/Mapper）</a> 是一个基于Mybatis，将单表的增删改查通过通用方法实现，来减少SQL编写的开源框架，且也有对应开源的mapper-spring-boot-starter提供。我们在此基础上加了一些定制化的内容，以便达到更大程度的复用。</p><a id="more"></a><p>框架源码地址：<a href="https://github.com/ronwxy/base-spring-boot" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot</a>  （持续更新完善中，欢迎follow，star）<br>Demo源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper</a></p><p><strong>在开源mapper-spring-boot-starter的基础上，增加了如下内容：</strong></p><ol><li>针对MySQL数据库与PostgreSQL数据库添加了一些Java类型与数据库类型的转换处理类，如将List、Map类型与MySQL数据库的json类型进行转换处理</li><li>对Domain、Mapper、Service、Controller各层进行了封装，将基本的增删改查功能在各层通用化</li><li>提供了基于druid连接池的自动配置</li><li>其它一些调整，如默认映射复杂类型属性（主要是List、Map类型，其它自定义类型需要自定义转换处理类），将枚举作为简单类型处理</li><li>提供了一个parent项目，将一些常用的框架进行集成，实际项目可继承parent简化依赖配置（持续更新完善）</li></ol><p>该框架可用于实际基于springboot的项目，只需简单配置数据源，即可引入druid连接池及通用mapper的功能，以及各层基本的增删改查方法。</p><p><strong>如何使用？</strong><br>下文给出使用步骤，可参考示例：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-tkmapper</a></p><h3 id="1-框架Maven部署安装"><a href="#1-框架Maven部署安装" class="headerlink" title="1. 框架Maven部署安装"></a>1. 框架Maven部署安装</h3><p>下载框架源码后，在项目根路径下执行<code>mvn clean install</code>可安装到本地maven库。如果需要共享，且搭了Nexus私服，则在根路径pom.xml文件中添加<code>distributionManagement</code>配置，指定Nexus仓库分发地址，使用<code>mvn clean deploy</code>安装到远程maven仓库，如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">             http://ip:port/repository/maven-releases/</span><br><span class="line">         <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">             http://ip:port/repository/maven-snapshots/</span><br><span class="line">         <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上述指定的repository需要在maven的全部配置文件settings.xml中有对应账号配置(id需要一一对应)，如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-pom-xml配置"><a href="#2-pom-xml配置" class="headerlink" title="2. pom.xml配置"></a>2. pom.xml配置</h3><p>项目中引入该数据库框架有三种方式：</p><ol><li>直接引入 cn.jboost.springboot:tkmapper-spring-boot-starter（没有连接池）</li><li>直接引入 cn.jboost.springboot:druid-spring-boot-starter（druid连接池支持）</li><li>项目继承 cn.jboost.springboot:spring-boot-parent（使用的是druid连接池）</li></ol><p>三种方式的pom.xml配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#第一种方式</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tkmapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#第二种方式</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#第三种方式</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据情况引入mysql或postgresql的驱动依赖（其它数据库暂未做类型转换支持，未作测试）</p><h3 id="3-配置数据源"><a href="#3-配置数据源" class="headerlink" title="3. 配置数据源"></a>3. 配置数据源</h3><p>如果使用druid连接池，则在application.yml配置文件中，加入如下数据源配置（推荐）<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    druid:</span></span><br><span class="line"><span class="attr">      driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      password:</span></span><br><span class="line">      <span class="comment"># 自定义配置</span></span><br><span class="line"><span class="attr">      initialSize:</span> <span class="number">2</span>  <span class="comment"># 初始化大小</span></span><br><span class="line"><span class="attr">      minIdle:</span> <span class="number">1</span>   <span class="comment"># 最小连接</span></span><br><span class="line"><span class="attr">      maxActive:</span> <span class="number">5</span> <span class="comment"># 最大连接</span></span><br><span class="line"><span class="attr">      druidServletSettings:</span></span><br><span class="line"><span class="attr">        allow:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">        deny:</span></span><br><span class="line"><span class="attr">        loginUsername:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">        loginPassword:</span> <span class="string">Passw0rd</span></span><br><span class="line"><span class="attr">        resetEnable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      druidFilterSettings:</span></span><br><span class="line"><span class="attr">        exclusions:</span> <span class="string">'*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*'</span></span><br><span class="line"><span class="attr">      maxWait:</span> <span class="number">60000</span>   <span class="comment"># 配置获取连接等待超时的时间</span></span><br><span class="line"><span class="attr">      timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span> <span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line"><span class="attr">      minEvictableIdleTimeMillis:</span> <span class="number">300000</span> <span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line"><span class="attr">      validationQuery:</span> <span class="string">SELECT</span> <span class="string">'x'</span></span><br><span class="line"><span class="attr">      testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      testOnReturn:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      poolPreparedStatements:</span> <span class="literal">true</span> <span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line"><span class="attr">      maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">      filters:</span> <span class="string">stat</span> <span class="comment">#,wall（添加wall代码里不能直接拼接sql，druid有sql注入校验） # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙</span></span><br><span class="line"><span class="attr">      connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span> <span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line"><span class="attr">      useGlobalDataSourceStat:</span> <span class="literal">true</span> <span class="comment"># 合并多个DruidDataSource的监控数据</span></span><br></pre></td></tr></table></figure></p><p>如果不使用连接池，则配置相对简单，如下<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure></p><h3 id="4-定义相应domain，mapper，service，controller各层对象"><a href="#4-定义相应domain，mapper，service，controller各层对象" class="headerlink" title="4. 定义相应domain，mapper，service，controller各层对象"></a>4. 定义相应domain，mapper，service，controller各层对象</h3><p>以demo为例（demo数据库脚本见resources/schema.sql），domain定义一个User类,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">AutoIncrementKeyBaseDomain</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ColumnType</span>(jdbcType = JdbcType.CHAR)</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; favor;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Gender&#123;</span><br><span class="line">        M,</span><br><span class="line">        F</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要添加<code>@Table</code>注解指定数据库表名，可通过继承<code>AutoIncrementKeyBaseDomain</code>来实现自增主键，或<code>UUIDKeyBaseDomain</code>来实现UUID主键，如果自定义其它类型主键，则继承<code>BaseDomain</code>。</p><blockquote><p>该框架Service层通用方法实现<code>BaseService</code>只支持单列主键，不支持组合主键（也不建议使用组合主键）</p></blockquote><blockquote><p>框架默认对List、Map等复杂类型属性会映射到mysql的json类型或postgresql的jsonb类型，如果某个属性不需要映射，可添加@Transient注解；枚举类型需添加@ColumnType指定jdbcType。</p></blockquote><p>dao层定义<code>UserMapper</code>，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>BaseMapper</code>默认实现了单表的增删改查及批量插入等功能，如需定义复杂查询，可在该接口中定义，然后通过mapper xml文件编写实现。</p><p>service层定义 <code>UserService</code>，继承了<code>BaseService</code>的通用功能（具体可查看源码），同样可在该类中自定义方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">Integer</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createWithTransaction</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        create(user);</span><br><span class="line">        <span class="comment">//用于测试事务</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"抛出异常，让前面的数据库操作回滚"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>controller层定义 <code>UserController</code>，继承了<code>BaseController</code>的通用接口（具体可查看源码）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span>&lt;<span class="title">Integer</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，只需要定义各层对应的接口或类，继承基础接口或类，便完成了用户基本的增删改查功能，不需要写一行具体的实现代码。</p><h3 id="5-测试、运行"><a href="#5-测试、运行" class="headerlink" title="5. 测试、运行"></a>5. 测试、运行</h3><ol><li><p>示例中提供了两个新建用户的单元测试，参考<code>SpringbootTkmapperApplicationTests</code>类</p></li><li><p>运行，在主类上直接运行，然后浏览器里打开 <a href="http://localhost:8080/user" target="_blank" rel="noopener">http://localhost:8080/user</a> 则可列出单元测试中创建的用户（其它接口参考<code>BaseController</code>实现）</p></li></ol><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>本文介绍框架基于<code>tk.mybatis:mapper-spring-boot-starter</code>做了一些自定义扩展，以更大程度地实现复用。可用于实际项目开发，使用过程中如果遇到问题，可关注公众号留言反馈。<br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>案例解析：使用IDEA异常断点来定位java.lang.ArrayStoreException的问题</title>
      <link href="/issue-errortrack.html"/>
      <url>/issue-errortrack.html</url>
      
        <content type="html"><![CDATA[<p>最近对 base-spring-boot （<a href="https://github.com/ronwxy/base-spring-boot）" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot）</a> 项目进行了升级。在将其用于应用开发中时遇到<code>java.lang.ArrayStoreException</code>的异常导致程序无法启动。平常开发过程中面对这种描述不够清楚，无法定位具体原因的问题该如何处理？本文分享通过使用IDEA异常断点来定位此类问题的方法。</p><a id="more"></a><p>启动程序时抛出如下异常，导致启动失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;devGlobalExceptionHandler&apos; defined in class path resource [cn/jboost/springboot/autoconfig/error/exception/ExceptionHandlerAutoConfiguration.class]: Post-processing of merged bean definition failed; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:570) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:843) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">at com.cnbot.kindergarten.CnbotKindergartenApplication.main(CnbotKindergartenApplication.java:10) [classes/:na]</span><br><span class="line">Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120) ~[na:1.8.0_201]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72) ~[na:1.8.0_201]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>单纯看异常栈，无法定位问题原因，只能看到是在调用<code>devGlobalExceptionHandler</code>创建bean时出错，错误信息<code>java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</code>。这属于框架内部抛出的异常，通常的设置断点Debug的方法很难定位到具体原因，可通过IDEA的异常断点来进行定位，它会在程序运行过程中出现指定异常时进行阻断。</p><h3 id="1-添加异常断点"><a href="#1-添加异常断点" class="headerlink" title="1. 添加异常断点"></a>1. 添加异常断点</h3><p>在IDEA的Debug面板中，点击“View Breakpoints”（两个重叠的红色圈按钮），如下</p><p><img src="/assets/exceptionbreak0.png" alt="Debug面板"></p><p>打开“Breakpoints”窗口，在该窗口中点击“+”按钮，选择“Java Exception Breakpoints”， 如下图</p><p><img src="/assets/exceptionbreak1.png" alt="Breakpoints"></p><p>然后在弹出的“Enter Exception Class”窗口中输入<code>ArrayStoreException</code>选中对应异常，依次点击OK，Done按钮即完成异常断点添加。</p><h3 id="2-程序debug"><a href="#2-程序debug" class="headerlink" title="2. 程序debug"></a>2. 程序debug</h3><p>开始以Debug模式启动程序。 程序运行后，在前面配置的异常出现时，将会进行阻断，如图</p><p><img src="/assets/exceptionbreak3.png" alt="程序异常阻断"></p><p>可以看到程序阻断在上图高亮的那行代码处，异常便是从这里抛出的。查看<code>parseClassValue</code>方法，可看到这里有catch<code>TypeNotPresentException</code>异常，并且包装成我们在异常栈看到的<code>TypeNotPresentExceptionProxy</code>返回。离真相很近了。</p><p>我们可以在上述catch块中添加一个断点，查看异常包装前的状态，如图</p><p><img src="/assets/exceptionbreak4.png" alt="断点定位"></p><p>重新Debug运行，将定位到上图代码处，查看异常，看到如下图所示信息</p><p><img src="/assets/exceptionbreak5.png" alt="异常信息"></p><p>该信息表示<code>org.springframework.security.access.AccessDeniedException</code>这个类不存在，导致<code>BaseWebApplicationExceptionHandler</code>类型的bean实例化时出错。这时候问题基本已经定位到了。</p><p>查看源码，在BaseWebApplicationExceptionHandler中有对AccessDeniedException的统一处理，但是spring-boot-autoconfigure所有的依赖都是optional的（不会传递依赖），而在新开发的项目中，并没有引入spring-security，因此导致<code>AccessDeniedException</code>这个类找不到而报错。目前通过去掉该部分处理解决。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>IDEA的Debug支持好几种断点类型，如前文介绍的异常断点，以及比较常用的条件断点等。当无法从异常栈信息找到问题所在时，借用这些类型的断点进行Debug，往往事情就变得简单了。</p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> 案例解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（六）：整合Web项目常用功能</title>
      <link href="/springboot-base.html"/>
      <url>/springboot-base.html</url>
      
        <content type="html"><![CDATA[<p>在Web应用开发过程中，一般都涵盖一些常用功能的实现，如数据库访问、异常处理、消息队列、缓存服务、OSS服务，以及接口日志配置，接口文档生成等。如果每个项目都来一套，则既费力又难以维护。可以通过Spring Boot的Starter来将这些常用功能进行整合与集中维护，以达到开箱即用的目的。</p><a id="more"></a><p>项目基于Spring Boot 2.1.5.RELEASE 版。<br>项目地址： <a href="https://github.com/ronwxy/base-spring-boot" target="_blank" rel="noopener">https://github.com/ronwxy/base-spring-boot</a></p><p>整个项目分为如下几部分：</p><ul><li>spring-boot-autoconfigure：  具体的各功能实现，每个功能通过package的形式组织</li><li>spring-boot-commons： 一些公共的工具类或共享类</li><li>spring-boot-dependencies： 依赖的集中维护管理，集中管理各个依赖的版本号</li><li>spring-boot-parent： 提供一个基本的父项目，web服务项目可通过继承该项目创建</li><li>spring-boot-starters： 各功能的starter项目，引入相应starter即引入相应功能</li></ul><h2 id="spring-boot-dependencies-项目"><a href="#spring-boot-dependencies-项目" class="headerlink" title="spring-boot-dependencies 项目"></a>spring-boot-dependencies 项目</h2><p>该项目主要是对所有依赖进行集中定义。通过 dependencyManagement 对依赖进行声明， </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;base-spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，所有依赖的版本可以集中统一管理，在其它地方引用的时候可以省去版本的声明，如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spring-boot-autoconfigure-项目"><a href="#spring-boot-autoconfigure-项目" class="headerlink" title="spring-boot-autoconfigure 项目"></a>spring-boot-autoconfigure 项目</h2><p>该项目是各功能自动配置的具体实现，以package的形式进行组织，如 tkmapper 包下实现了通用Mapper的自动配置，error 包下实现了错误处理的自动配置， 等等。</p><p>该项目继承了spring-boot-dependencies， 在项目的 pom.xml 中，依赖部分声明类似于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring denpendencies --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不需要再指定版本号，通过将optional设置为true，表示该依赖不会进行传递，即另外一个项目引用该项目时，optional的依赖不会被传递依赖过去。</p><p>在 resources/META-INF/spring.factories 文件中，声明了所有自动配置类， 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">cn.jboost.springboot.autoconfig.tkmapper.MapperAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.aoplog.AopLoggerAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.alimq.config.AliMQAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.qiniu.QiniuAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.swagger.Swagger2AutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.druid.DruidAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.error.exception.ExceptionHandlerAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.alimns.MnsAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.redis.RedisClientAutoConfiguration,\</span><br><span class="line">cn.jboost.springboot.autoconfig.web.CORSAutoConfiguration</span><br></pre></td></tr></table></figure><h2 id="spring-boot-starters-项目"><a href="#spring-boot-starters-项目" class="headerlink" title="spring-boot-starters 项目"></a>spring-boot-starters 项目</h2><p>该项目包含按功能划分的多个子项目，主要用来引入依赖以达到自动配置的依赖条件，使引入对应starter时，能让自动配置生效。如通用Mapper集成的 tkmapper-spring-boot-starter 依赖如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时在 resources/META-INF/spring.provides 里声明了该starter的用途，这里可随意编写。</p><h2 id="spring-boot-commons-项目"><a href="#spring-boot-commons-项目" class="headerlink" title="spring-boot-commons 项目"></a>spring-boot-commons 项目</h2><p>可将一些常用的工具类， 或共享类放到这个项目中。比如一些常量定义，加解密工具类等。</p><h2 id="spring-boot-parent-项目"><a href="#spring-boot-parent-项目" class="headerlink" title="spring-boot-parent 项目"></a>spring-boot-parent 项目</h2><p>该项目将Web应用需要的一些常见功能整合进来，应用项目可继承该项目进行构建，从而直接引入相应的功能。</p><p>在接下来的spring boot系列博文中，将一一详细介绍各功能的整合集成与应用。同时会不断更新与完善，以达到能直接用于生产项目的水平。</p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研发团队如何借助Gitlab来做代码review</title>
      <link href="/code-review.html"/>
      <url>/code-review.html</url>
      
        <content type="html"><![CDATA[<p>代码review是代码质量保障的手段之一，同时开发成员之间代码review也是一种技术交流的方式，虽然会占用一些时间，但对团队而言，总体是个利大于弊的事情。如何借助现有工具在团队内部形成代码review的流程与规范，是team leader或技术管理者需要考虑的问题。本文分享一种基于Gitlab代码merge流程的code review方法，以供参考与探讨。如有更好的方法，欢迎交流。</p><a id="more"></a><h2 id="1-设置成员角色"><a href="#1-设置成员角色" class="headerlink" title="1. 设置成员角色"></a>1. 设置成员角色</h2><p>首先需要对你团队的成员分配角色，在Gitlab groups里选择一个group，然后左边菜单栏点击 Members，可在 Members 页面添加或编辑成员角色，如下图所示。</p><p><img src="/assets/gitmember.png" alt="group成员"></p><p>其中角色包含如下几类：</p><ul><li>Guest：权限最小，基本查看功能</li><li>Reporter：只能查看，不能push</li><li>Developer：能push，也能merge不受限制的分支</li><li>Master：除了项目的迁移、删除等管理权限没有，其它权限基本都有</li><li>Owner：权限最大，包括项目的迁移、删除等管理权限</li></ul><p>详细权限参考： <a href="https://docs.gitlab.com/ee/user/permissions.html" target="_blank" rel="noopener">https://docs.gitlab.com/ee/user/permissions.html</a></p><p>确定团队中技术水平、经验较好的成员为Master，负责代码的review与分支的合并；其他成员为Developer，提交合并请求，接受review意见；Master之间可以互相review。</p><h2 id="2-配置分支保护"><a href="#2-配置分支保护" class="headerlink" title="2. 配置分支保护"></a>2. 配置分支保护</h2><p>在项目页面左侧菜单栏 Settings -&gt; Repository， 进入“Protected Branches”部分配置分支保护，如下图所示。</p><p><img src="/assets/protectedbranch.png" alt="分支保护"></p><p>在这里可以针对每个分支，设置允许什么角色可以merge，允许什么角色可以push，选项包括三个：“Masters”， “Developers + Masters”， “No one”。<br>这里设置成只允许master可以直接push与merge这几个常设分支的代码。（如果更严格一点，可以将“Allowed to push”设置成“No one”）</p><h2 id="3-代码review流程"><a href="#3-代码review流程" class="headerlink" title="3. 代码review流程"></a>3. 代码review流程</h2><h3 id="3-1-开发（开发者负责）"><a href="#3-1-开发（开发者负责）" class="headerlink" title="3.1. 开发（开发者负责）"></a>3.1. 开发（开发者负责）</h3><ol><li>本地切到develop分支， 拉取最新代码（相关命令如下，GUI工具操作自行查相关文档） </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch #查看当前位于哪个分支，前面打星号即为当前分支</span><br><span class="line">git checkout develop   #切换到develop分支</span><br><span class="line">git pull  #拉取最新代码</span><br></pre></td></tr></table></figure><ol start="2"><li>从develop分支切出子分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature-1101  #从当前分支切出子分支，命名为"feature-1101"</span><br></pre></td></tr></table></figure><ol start="3"><li>编码、本地自测完之后，提交子分支到远程仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *  #加入暂存区</span><br><span class="line">git commit -m "commit msg" #提交到本地仓库</span><br><span class="line">git push origin feature-1101 #提交到远程仓库</span><br></pre></td></tr></table></figure><h3 id="3-2-发起Merge请求（开发者负责）"><a href="#3-2-发起Merge请求（开发者负责）" class="headerlink" title="3.2 发起Merge请求（开发者负责）"></a>3.2 发起Merge请求（开发者负责）</h3><ol><li>在项目主页面，依次点击左侧“Merge Requests”（下图1），“New merge request”（下图2），打开新建Merge请求页面</li></ol><p><img src="/assets/mergerequest1.png" alt="Merge请求"></p><ol start="2"><li>在新建Merge请求页面，选择merge的源分支，及目标分支，如下图源分支为“feature-1101”，目标分支为“develop”，点击“Compare branches and continue”按钮进入对比与提交页面</li></ol><p><img src="/assets/mergerequest2.png" alt="新建Merge请求"></p><ol start="3"><li>在对比与提交页面，可以点击“Changes” tab查看本次修改（这里我为了演示，只是加了两个换行），确认无误，点击“Submit merge request”按钮，提交merge请求</li></ol><p><img src="/assets/mergesubmit.png" alt="对比修改"></p><ol start="4"><li>提交之后，将结果页面的浏览器地址发到团队即时通讯群（如钉钉），并@相应的同事申请review</li></ol><h3 id="3-3-代码Review（code-reviewer负责）"><a href="#3-3-代码Review（code-reviewer负责）" class="headerlink" title="3.3 代码Review（code reviewer负责）"></a>3.3 代码Review（code reviewer负责）</h3><ol><li>负责代码Review的同事收到申请后，点击merge请求地址，打开页面，查看“Changes”</li></ol><p><img src="/assets/merge.png" alt="对比修改"></p><p>这里可通过“Inline”单边查看，也可以通过“Side-by-side”两个版本对比查看</p><ol start="2"><li>review完成后，若无问题，则可点击”Merge”按钮完成merge，同时可删除对应的子分支“feature-1101”，<br>若有问题，则可点击“Close merge request”按钮关闭该merge请求（也可以不关闭复用该merge请求），同时通知开发者进行相应调整，重新提交代码发起merge请求（如果之前没关闭merge请求，则刷新即可看到调整）。</li></ol><h3 id="3-4-冲突解决（开发者负责）"><a href="#3-4-冲突解决（开发者负责）" class="headerlink" title="3.4 冲突解决（开发者负责）"></a>3.4 冲突解决（开发者负责）</h3><ol><li>merge的时候，可能存在代码冲突，这时，开发者可从develop分支重新拉取最新代码进行本地merge， 解决冲突后重新提交代码进行review</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git pull origin develop #在当前子分支拉取develop分支的最新代码进行本地merge</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决冲突代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交</span></span><br><span class="line">git add *</span><br><span class="line">git commit -m "fix merge conflict"</span><br><span class="line">git push origin feature-1101</span><br></pre></td></tr></table></figure><ol start="2"><li>自行解决不了时，寻求协助</li></ol><h2 id="4-借助阿里钉钉机器人来改善体验"><a href="#4-借助阿里钉钉机器人来改善体验" class="headerlink" title="4. 借助阿里钉钉机器人来改善体验"></a>4. 借助阿里钉钉机器人来改善体验</h2><p>前面流程中提醒code reviewer是需要开发者自己来发消息通知的，可不可以把这个流程自动化。我们可以借助Gitlab的webhook与钉钉机器人来实现。</p><ol><li>在钉钉群右上角点击“…”，打开群设置，群机器人中点击添加机器人，会显示可以添加的机器人类型，如下图所示</li></ol><p><img src="/assets/dingdingmachine.png" alt="钉钉机器人"></p><ol start="2"><li>选择Gitlab，点击添加，输入机器人名称，如“Gitlab”，点击完成即创建了一个Gitlab的钉钉机器人。回到“群机器人”窗口，将能看到刚刚创建的Gitlab机器人，如图</li></ol><p><img src="/assets/dingdingmachinelist.png" alt="钉钉机器人列表"></p><p>点击齿轮按钮，进入设置页，可看到webhook地址，点击复制，复制该机器人的webhook地址。如图</p><p><img src="/assets/dingdingwebhook.png" alt="钉钉机器人webhook"></p><ol start="3"><li>在Gitlab项目主页进入 Settings -&gt; Integrations， 将前面复制的webhook地址填入URL中，Trigger 部分选择“Merge request events”（不要勾太多，不然提醒太多就有点骚扰了），然后点击“Add webhook”就完成了。如图</li></ol><p><img src="/assets/gitlabwebhook.png" alt="GitlabWebhook"></p><ol start="4"><li>当有开发人员提交merge请求时，钉钉机器人将在钉钉群里发出通知，code reviewer点击消息里的链接即可进入页面进行code review， review完成，将分支merge之后，钉钉机器人也会发出消息（所有merge相关的事件都会发出消息）。如图</li></ol><p><img src="/assets/dingdingmachinechat.png" alt="钉钉机器人通知"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>团队协作，流程、规范很重要，不同的团队可能有不同的适用流程与规范。此文分享了基于Gitlab与阿里钉钉群机器人的代码review流程，希望对团队研发协作有一定参考价值，也欢迎一起探讨、交流。</p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> teamwork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团队项目的Git分支如何管理</title>
      <link href="/git-branch.html"/>
      <url>/git-branch.html</url>
      
        <content type="html"><![CDATA[<p>许多公司的开发团队都采用Git来做代码版本控制。如何有效地协同开发人员之间，以及开发、测试、上线各环节的工作，可能都有各自的流程与规范。本文分享的是作者一直沿用的团队项目Git分支管理规范，希望给有缘阅读的人以参考，如果有更好的实践，也欢迎指教、讨论。<br><a id="more"></a></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>创建项目时（一般是服务型项目，工具型或辅助型项目可以简单一些），会针对不同环境创建三个常设分支：</p><ol><li>develop：开发环境的稳定分支，公共开发环境基于该分支构建。</li><li>pre-release：测试环境的稳定分支，测试环境基于该分支构建。</li><li>master：生产环境的稳定分支，生产环境基于该分支构建。仅用来发布新版本，除了从pre-release或生产环境Bug修复分支进行merge，不接受任何其它修改</li></ol><p>平时开发工作中，会根据需要由开发人员创建两类临时分支：</p><ol><li>功能（feature）分支：为了开发某个特定功能，从develop分支上面分出来的。开发完成后，要merge到develop分支。功能分支的命名，可以采用feature-*的形式命名(*为任务单号)</li><li>Bug修复（fixbug）分支：为了修复某个bug，从常设分支上面分出来的。修复完成后，再merge到对应的分支。Bug修复分支的命名，可以采用fixbug-*的形式命名（*为bug单号）</li></ol><h2 id="流程规范"><a href="#流程规范" class="headerlink" title="流程规范"></a>流程规范</h2><h3 id="正常开发流程"><a href="#正常开发流程" class="headerlink" title="正常开发流程"></a>正常开发流程</h3><ol><li>从develop分支切出一个新分支，根据是功能还是bug，命名为feature-* 或 fixbug-*。</li><li>开发者完成开发，提交分支到远程仓库。</li><li>开发者发起merge请求（可在gitlab页面“New merge request”），将新分支请求merge到develop分支，并提醒code reviewer进行review</li><li>code reviewer对代码review之后，若无问题，则接受merge请求，新分支merge到develop分支，同时可删除新建分支；若有问题，则不能进行merge，可close该请求，同时通知开发者在新分支上进行相应调整。调整完后提交代码重复review流程。</li><li>转测时，直接从当前develop分支merge到pre-release分支，重新构建测试环境完成转测。</li><li>测试完成后，从pre-release分支merge到master分支，基于master分支构建生产环境完成上线。并对master分支打tag，tag名可为v1.0.0_2019032115（即版本号_上线时间）</li></ol><p>流程示意图如下所示</p><p><img src="/assets/gitbranch1.png" alt="正常开发流程"></p><h3 id="并行开发测试环境Bug修复流程"><a href="#并行开发测试环境Bug修复流程" class="headerlink" title="并行开发测试环境Bug修复流程"></a>并行开发测试环境Bug修复流程</h3><p>并行开发（即前一个版本已经转测但未上线，后一个版本又已在开发中并部分合并到了develop分支）过程中，转测后测试环境发现的bug需要修复，但是develop分支此时又有新内容且该部分内容目前不计划转测，可以pre-release切出一个bug修复分支。完成之后需要同时merge到pre-release分支与develop分支。merge时参考“正常开发流程”。流程示意图如下</p><p><img src="/assets/gitbranch2.png" alt="并行开发测试环境Bug修复流程"></p><h3 id="生产环境Bug修复流程"><a href="#生产环境Bug修复流程" class="headerlink" title="生产环境Bug修复流程"></a>生产环境Bug修复流程</h3><p>生产环境的Bug分两种情况：</p><ol><li>紧急Bug：严重影响用户使用的为紧急Bug，需立即进行修复。如关键业务流程存在问题，影响用户正常的业务行为。</li><li>非紧急Bug或优化：非关键业务流程问题，仅影响用户使用体验，或出现频率较小等，为非紧急Bug，可规划到后续版本进行修复。</li></ol><p>非紧急Bug修复参考“正常开发流程”。</p><p>紧急Bug修复，需要从master分支切出一个bug修复分支，完成之后需要同时merge到master分支与develop分支（如果需要测试介入验证，则可先merge到pre-release分支，验证通过后再merge到master分支上线）。merge时参考“正常开发流程”。流程示意图如下</p><p><img src="/assets/gitbranch3.png" alt="生产环境Bug修复流程"></p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> teamwork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行高效操作Git，看这篇就够了</title>
      <link href="/use-git.html"/>
      <url>/use-git.html</url>
      
        <content type="html"><![CDATA[<p>对于软件开发人员来说，git几乎是每天都需要接触的工具。但对于相处如此亲密的工作伙伴，你对它的了解又有多少，是不是还在傻瓜式地打开一个GUI工具，点击提交按钮，然后“卧槽，又冲突了”，一脸懵逼到不知所措，责怪谁又在你前面提交了，谁又改了你的代码。</p><a id="more"></a><p>博主从一开始接触git，就没用过任何GUI工具，都是通过命令行进行操作，发现这种方式不仅对git的理解更深，效率也更高，遇到问题时一般都知道如何来处理，故做此分享。本文所有知识与操作只涉及日常使用场景，更多详细内容可自行查阅其它资料。本文Git版本为 windows-2.20.1版。</p><h3 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h3><p>git的理论知识，对使用者来说只需要知道它是分布式版本控制系统，了解如下三个概念即可，</p><ul><li>工作区：就是你直接操作的文件目录与内容</li><li>暂存区：暂时为你保存还没将内容提交到版本库的一个区域，对应.git目录下的stage或index文件</li><li>版本库：分本地版本库与远程版本库，本地版本库就理解为对应.git目录即可，远程版本库就是远程仓库，如gitlab或github的repository。</li></ul><p>如下图，我们平时提交代码的过程基本都是从工作区<code>add</code>到暂存区，然后再<code>commit</code>到本地仓库，最后<code>push</code>到远程仓库。</p><p><img src="/assets/git1.png" alt="git"></p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>对于日常工作，掌握如下几个基本命令一般就够了</p><ul><li><code>git status</code> 查看修改状态</li><li><code>git pull origin master</code> 拉取远程仓库master分支合并到本地，master根据场景换成其它分支名</li><li><code>git add file</code> 添加文件到暂存区，可用 * 添加所有</li><li><code>git commit -m &quot;commit message&quot;</code> 提交到本地版本库，并添加注释，注释表明此次修改内容，要清晰准确</li><li><code>git push origin master</code> 将本地版本提交到远程仓库的master分支，master根据场景换成其它分支名</li></ul><p>对大部分日常工作来说， 上面几个命令基本就够用了。</p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p><strong>1. 从本地到远程</strong></p><p>项目开发的时候，有时候是先在本地建一个项目，再提交到远程仓库的。</p><ol><li>创建项目目录（或通过IDE创建），命令行cd到项目目录</li><li>执行<code>git init</code> ， 将在项目目录创建.git目录</li><li>执行<code>git add *</code> ，将所有文件添加到暂存区，这里要先创建一个.gitignore文件，将不需要版本维护的文件添加进去忽略，不然各种IDE编译文件夹，环境相关文件都加到版本库去了。删除文件用<code>git rm file_name</code></li><li>执行<code>git commit -m &quot;upload project&quot;</code> ，提交到本地仓库</li><li>在gitlab或github上创建一个仓库，并将仓库地址复制下来</li><li>执行<code>git remote add origin git@server-name:path/repo-name.git</code> ，关联远程仓库，仓库地址如果是http开头则要用户名密码，如果是git开头，则是走的ssh协议，需要将你本机的ssh公钥添加到远程仓库服务上。</li><li>执行<code>git push -u origin master</code> ，推送本地仓库内容到远程仓库</li></ol><p>这样在远程仓库目录，就能看到你提交上去的文件内容了。</p><p><strong>2. 从远程到本地</strong><br>更多的时候，是远程仓库已有项目了，需要下载到本地开发。</p><ol><li><code>git clone git@server-name:path/repo-name.git</code> ， 将远程仓库的内容下载到本地，这里仓库地址的处理同上</li><li>修改内容</li><li><code>git add *</code> ，将修改的内容添加到暂存区</li><li><code>git commit -m &quot;fix xxx issue&quot;</code> ，提交到本地仓库</li><li><code>git push -u origin master</code> ， 推送本地仓库内容至远程仓库</li></ol><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>有时候改了文件，想反悔怎么办，git给你“后悔药”。</p><p>单个文件的还原：</p><ul><li><code>git checkout file_name</code> ，丢弃工作区的修改，还原到上次提交（commit）的版本，</li><li><code>git reset HEAD file_name</code> ，把暂存区的修改撤销掉（unstage），重新放回工作区。即还原到上次添加到暂存区（add）的版本</li></ul><p>这里涉及几个场景</p><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout file_name</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时（执行了add，但没执行commit），想丢弃修改，分两步，第一步用命令<code>git reset HEAD file_name</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次的全部提交，参考下面的整个版本的还原，不过前提是没有推送到远程库。</li></ul><p>整个版本的还原：</p><ul><li><code>git reset --hard HEAD^^</code>， 回退到上上个版本</li><li><code>git reset --hard 3628164</code>， 回退到具体某个版本 3628164 是具体某个commit_id缩写</li></ul><blockquote><p>找不到commit_id？ <code>git reflog</code> 可查看每一个命令的历史记录，获取对应操作的commit_id。<code>git log [--pretty=oneline]</code>， 可查看commit记录</p></blockquote><blockquote><p>上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100。3628164 是具体某个commit_id，不需要写全，只需要唯一确定就行，可往前进也可往后退。（git windows2.20.1版貌似不支持对HEAD^的操作）</p></blockquote><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ol><li>首先，可以试图用 <code>git push origin branch_name</code> 推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用 <code>git pull</code> 试图合并；</li><li>如果合并有冲突，则手动解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用 <code>git push origin branch-name</code> 推送就能成功！</li></ol><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name</p><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>平时开发时需要创建子分支来实现你的功能模块，然后再合并到主分支中。</p><ul><li><code>git checkout -b your_branch_name</code> ， 创建并切换分支</li><li><code>git branch</code>  ， 查看分支，标有*号表示当前所在分支</li><li><code>git merge dev</code> ， 合并指定dev分支到当前分支</li><li><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code> ， 合并分支并生成commit记录</li><li><code>git branch -d dev</code> ， 删除分支</li></ul><blockquote><p><code>git checkout -b dev =  git branch dev + git checkout dev</code></p></blockquote><blockquote><p>Fast-forward合并，“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。存在冲突的不能fast forward。<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>  Fast forward模式下，删除分支后，会丢掉分支信息。如果强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p></blockquote><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>当发布版本时，一般需要对当前版本进行标签记录，以便后续进行版本查看或回退。</p><ul><li><code>git tag tag_name</code>  ， 对当前分支打标签</li><li><code>git tag</code> ， 查看所有标签</li><li><code>git tag v0.9 6224937</code>  ，针对某个具体commit id打标签</li><li><code>git show tag_name</code> ， 查看标签信息</li><li><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164</code>  ， 带有说明的标签</li><li><code>git tag -d v0.1</code> ， 删除标签</li><li><code>git push origin tag_name</code> ， 推送标签到远程    </li><li><code>git push origin --tags</code> ， 一次性推送所有标签</li></ul><p>删除已经推送到远程的标签：</p><ul><li><code>git tag -d v0.9</code> ， 先本地删除</li><li><code>git push origin :refs/tags/v0.9</code> ， 然后从远程删除</li></ul><h3 id="提高效率的Tips"><a href="#提高效率的Tips" class="headerlink" title="提高效率的Tips"></a>提高效率的Tips</h3><ol><li><p>配置命令别名   </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status # 后面可以用git st 来代替git status了</span><br><span class="line">git config --global alias.ck checkout  # 后面可以用 git ck 来代替 git checkout了</span><br><span class="line">git config --global alias.cm 'commit -m' # 后面可以用git cm 来代替 git commit -m 了</span><br></pre></td></tr></table></figure></li><li><p><code>git pull origin master</code> 或 <code>git push origin master</code>， 可直接 <code>git pull</code> 或 <code>git push</code>， 如果出现“no tracking information”的提示，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream-to=origin/master master</code> 建立关联即可。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上命令虽然看起来多，但平常用的最频繁的应该是“基本命令”与“分支管理”部分，只要多用几次，自然便能记住，应付日常工作完全没有问题，彻底脱离GUI操作，让工作更有效率。</p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> 高效实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>案例解析：线程池使用不当导致系统崩溃</title>
      <link href="/issue-threadpool.html"/>
      <url>/issue-threadpool.html</url>
      
        <content type="html"><![CDATA[<p>前几天，发现一台阿里云服务器上的Web服务不可用。远程SSH登录不上，尝试几次登录上去之后，执行命令都显示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: fork: Cannot allocate memory</span><br></pre></td></tr></table></figure></p><p>一看以为是内存泄漏导致溢出。因为执行不了任何命令， 只能通过控制台重启服务器恢复服务。<br><a id="more"></a></p><h3 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h3><p>服务恢复后，查看系统日志，linux系统日志路径<code>/var/log/messages</code>，可通过<code>journalctl</code>命令查看，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since="2019-06-12 06:00:00" --until="2019-06-12 10:00:00"</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>可查看since之后，until之前时间段的日志。除了发现<code>crond[14954]: (CRON) CAN&#39;T FORK (do_command): Cannot allocate memory</code> 这个错误日志，未见其它异常（下面的<code>sshd[10764]: error: fork: Cannot allocate memory</code>应是ssh登录执行命名失败的日志）</p><p><img src="/assets/linux-log.png" alt="linux-log"></p><p>通过阿里云-云监控-主机监控查看内存使用率指标，这段时间内，内存使用率一直在40%以下，基本可排除内存溢出的可能。</p><p>通过搜索查阅到进程数超过操作系统限制可能导致<code>bash: fork: Cannot allocate memory</code>的报错(参考： <a href="https://blog.csdn.net/wangshuminjava/article/details/80603847" target="_blank" rel="noopener">https://blog.csdn.net/wangshuminjava/article/details/80603847</a> ）。通过<code>ps -eLf|wc -l</code>查看当前进程线程数(<code>ps -ef</code>只打印进程，<code>ps -eLf</code>会打印所有的线程), 只有1000多个，故障时刻系统到底运行了多少线程已无从得知，只能持续跟进监测。</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>几天后，再次通过<code>ps -eLf|wc -l</code>查看，发现线程数已达16000多个。直接执行<code>ps -eLf</code>可看到大量tomcat进程所产生的线程，猜测是不是线程死锁导致大量线程未完成一直hung在那里。</p><p>执行 <code>jstack 进程号 &gt; ~/jstack.txt</code> 命令将进程所运行线程情况打印出来分析，发现大量的<code>WAITING</code>状态的线程，如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"pool-19-thread-1" #254 prio=5 os_prio=0 tid=0x00007f0b700a6000 nid=0x29a9 waiting on condition [0x00007f0b274df000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  <span class="tag">&lt;<span class="name">0x00000006ce3d8790</span>&gt;</span> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></p><p>根据上述内容可看出线程在等一个条件，并且是在执行<code>LinkedBlockingQueue.take</code>方法的时候，查看该方法的java doc，当队列为空时，该方法将会一直等待直到有元素可用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * until an element becomes available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure></p><p>询问同事在哪里用到了LinkedBlockingQueue，同事回忆起不久前用线程池实现往阿里云OSS服务通过追加的方式上传文件功能，查看代码后发现问题——线程池没有关闭。为了使文件片段保存不存在错乱，每次保存文件时，都new了一个线程池对象，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor saveImgThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br></pre></td></tr></table></figure></p><p>但处理完后， 没有关闭这个线程池对象，这样线程池仍会通过take方法去取等待队列中是否还有未完成的线程任务，等待队列为空时将会一直等待，这样就导致大量的线程hung在这里了（基本是只要方法被调一次，就会产生一个hung住的线程）。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><ol><li><p>线程状态为“waiting for monitor entry”：<br>意味着它 在等待进入一个临界区 ，所以它在”Entry Set“队列中等待。此时线程状态一般都是 Blocked：<br>java.lang.Thread.State: BLOCKED (on object monitor)</p></li><li><p>线程状态为“waiting on condition”：<br>说明它在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了 sleep(N)。此时线程状态大致为以下几种：<br>java.lang.Thread.State: WAITING (parking)：一直等那个条件发生（本文案例即为此种场景）；java.lang.Thread.State: TIMED_WAITING (parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。</p></li><li><p>如果大量线程在“waiting for monitor entry”：可能是一个全局锁阻塞住了大量线程。如果短时间内打印的thread dump 文件反映，随着时间流逝，waiting for monitor entry 的线程越来越多，没有减少的趋势，可能意味着某些线程在临界区里呆的时间太长了，以至于越来越多新线程迟迟无法进入临界区。</p></li><li><p>如果大量线程在“waiting on condition”：可能是它们又跑去获取第三方资源，尤其是第三方网络资源，迟迟获取不到Response，导致大量线程进入等待状态。所以如果你发现有大量的线程都处在 Wait on condition，从线程堆栈看，正等待网络读写，这可能是一个网络瓶颈的征兆，因为网络阻塞导致线程无法执行。也可能是如本文所提到的，由于程序编写不当所致。</p></li></ol><p>参考： <a href="https://www.cnblogs.com/rainy-shurun/p/5732341.html" target="_blank" rel="noopener">https://www.cnblogs.com/rainy-shurun/p/5732341.html</a></p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>——————————————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> 案例解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（五）：写一个自己的starter</title>
      <link href="/springboot-starter.html"/>
      <url>/springboot-starter.html</url>
      
        <content type="html"><![CDATA[<p>曾遇到几位面试者，简历上写着精通Spring Boot，当聊到自动配置及对starter的理解时，却说不出个所以然来。找工作时，简历一定要注重实际，精通这种字眼还是少用，不然面试官对你期望越高，失望也就越大。其实结合前一篇介绍的<a href="/springboot-config.html">Spring Boot自动配置</a>，对Spring Boot的Starter实现将很容易理解，不论是使用其官方提供的Starter，还是自定义自己的Starter，都变得很容易。<br><a id="more"></a></p><p>根据前面介绍，Spring Boot自动配置的实现，主要由如下几部分完成：</p><ol><li>@EnableAutoConfiguration注解</li><li>SpringApplication类</li><li>spring-boot-autoconfigure jar包</li><li>spring.factories文件</li></ol><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>官方提供的starter，大多包含两个jar包： 一个starter——没有任何实现，只用来管理依赖（即实现这个starter的功能需要依赖哪些jar），一个autoconfigure——包含所有具体实现，包括自动配置类，及META-INF/spring.factories文件。本文示例的自定义starter，为了方便，将两者合并写到了一个。</p><blockquote><p>但是在实际项目中，还是建议像官方一样，定义一个spring-boot-dependencies声明所有依赖及其版本，做统一依赖版本管理，一个spring-boot-autoconfigure，实现所有自动配置类及相应的Bean，一个spring-boot-starters，针对每个模块引入必须的jar依赖，方便项目中引入。</p></blockquote><p>官方提供的starter，命名遵循spring-boot-starter-xxx， 自定义starter，命名遵循xxx-spring-boot-starter。</p><p>示例的项目结构如下图<br><img src="/assets/starter-struct.png" alt="starter项目结构"></p><h2 id="springboot-starter"><a href="#springboot-starter" class="headerlink" title="springboot-starter"></a>springboot-starter</h2><p>这里为了简单，将starter与autoconfigure整到一个项目，命名也为了与前面demo项目保持一致，没按规范来。</p><p><strong>配置类 MyAutoConfig</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MyProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyProperties myProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"my"</span>, name = <span class="string">"disable"</span>, havingValue = <span class="string">"false"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyService(<span class="string">"Hi "</span> + myProperties.getName() + <span class="string">", welcome to visit "</span> + myProperties.getWebsite());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该类中通过<code>@EnableConfigurationProperties</code>及<code>@Autowired</code> 引入了配置属性Bean MyProperties 以访问用户配置的属性，<code>@Bean</code>注解即向容器中注入方法返回值类型的Bean，这样在容器其它bean中通过<code>@Autowired</code>即可引用访问， @ConditionalOnProperty是条件注解，这里表明当配置属性my.disable=false时才实例化这个MyService bean。</p><p><strong>配置属性类 MyProperties</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"my"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line"></span><br><span class="line">    getter/setter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置属性类封装了用户在配置文件中定义的属性，该示例中将前缀为my的属性封装起来，访问name，website对应配置属性key就是my.name，my.website。</p><p><strong>服务Bean MyService</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String hiStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(String hiStr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hiStr = hiStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hiStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提供服务功能的bean，也即需要实例化注入到Spring上下文的bean。</p><p><strong>spring.factories</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  cn.jboost.springboot.starter.MyAutoConfig</span><br></pre></td></tr></table></figure></p><p>指定了自动配置类（带包名的全路径类名）</p><h2 id="springboot-usingstarter"><a href="#springboot-usingstarter" class="headerlink" title="springboot-usingstarter"></a>springboot-usingstarter</h2><p>该项目引用springboot-starter，调用MyService服务的项目，主类没什么特别的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootUsingstarterApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootUsingstarterApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置文件application.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my.disable=false</span><br><span class="line">my.name=jboost</span><br><span class="line">my.website=blog.jboost.cn</span><br></pre></td></tr></table></figure></p><p>在测试类SpringbootUsingstarterApplicationTests中编写测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStarter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.printf(myService.sayHi());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>pom.xml中引入springboot-starter依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.jboost.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>运行，控制台会打印出 <code>Hi jboost,  welcome to visit blog.jboost.cn</code><br>将配置属性my.disable的值改为true或其它非false的值再运行测试代码试试，会报MyService bean找不到的错误，说明@ConditionalOnProperty注解生效了</p><p>本示例仅作实现自定义starter演示用，项目结构、命名都不够规范，仅供参考，项目实战starter在后面继续分享。</p><p>本文示例项目源码地址：<br><a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-starter" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-starter</a><br><a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-usingstarter" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-usingstarter</a><br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>——————————————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（四）：Spring Boot配置</title>
      <link href="/springboot-config.html"/>
      <url>/springboot-config.html</url>
      
        <content type="html"><![CDATA[<p>Spring Boot之所以受开发者欢迎， 其中最重要的一个因素就是其配置简单。传统的Spring应用需要手动配置各种.xml文件，为数据库访问，事务支持，缓存功能等提供各项繁杂且重复的配置。Spring Boot将这种繁杂且重复的工作通过预定义的启动器（starter）来实现，只要引入即可拥有相应的功能支持，从而将开发者从复杂的配置工作中解放出来，能够更专注于业务逻辑的开发。</p><a id="more"></a><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>在Spring Boot中，虽然仍然可以通过之前的.xml文件方式来进行配置，但最好还是通过基于java的配置来进行配置管理。在Spring Boot中，基于java的配置是通过注解@Configuration来实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码将一个MyService的Bean注入了容器，这样在其它地方就可以直接通过@Autowired来引用访问。与.xml文件中通过<code>&lt;bean&gt;&lt;/bean&gt;</code>实例化的效果是一样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  myService.sayHello(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际项目开发中，有可能存在一些基于xml配置的旧服务，比如以jar包的形式发布，如果要复用该怎么引入呢？很简单，在@Configuration注解标注的类上，加入@ImportResource注解引用相应的xml文件即可，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"spring.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样类路径下spring.xml配置文件中声明的内容都将生效。在一个应用中，可以定义多个@Configuration配置类，这些配置类可以被@ComponentScan自动扫描并注入容器。</p><blockquote><p>如果应用中没有通过@ComponentScan进行自动扫描，则可在主配置类（一般为入口类）上通过@Import({MyConfig.class})的方式类引入其它配置类</p></blockquote><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>个人认为，自动配置是Spring Boot非常基础但又核心的部分。曾经遇到几个面试者，简历写着精通Spring Boot，当问及自动配置时却支支吾吾不知所云。其实理解Spring Boot的自动配置也不难，基本了解如下几部分差不多就够了：</p><ol><li>@EnableAutoConfiguration注解</li><li>SpringApplication类</li><li>spring-boot-autoconfigure jar包</li><li>spring.factories文件</li></ol><p><strong>@EnableAutoConfiguration注解</strong><br>这个注解的作用是告诉Spring Boot基于添加的jar依赖来自动配置Spring，比如添加了spring-boot-starter-web依赖，则Spring Boot认为你在开发一个web应用，就会自动做好web相应配置。这个注解一般放在主类上。在前面的示例项目中， 我们在主类上都是使用@SpringBootApplication， 查看源码可以知道： </p><ul><li>@SpringBootApplication 这个注解实际上等效于 @SpringBootConfiguration（等效于@Configuration）， </li><li>@EnableAutoConfiguration，启用自动配置 </li><li>@ComponentScan 自动扫描@Component, @Service, @Controller等注解标注的各类组件   </li></ul><p>三者的组合。如果去掉@EnableAutoConfiguration注解，则Spring Boot将不会自动配置Spring（如实例化必要的Bean），将可能导致应用启动失败。</p><p><strong>SpringApplication类</strong><br>在应用主类中，我们是通过SpringApplication的run方法来启动应用的，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看源码，SpringApplication的静态run方法，实际也是通过创建SpringApplication实例，调用实例方法执行，在SpringApplication构造器方法中，调用了getSpringFactoriesInstances 方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span></span></span><br><span class="line"><span class="function"><span class="params">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>)</span></span>;</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">ApplicationContextInitializer.class));</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>追溯下去，最终会调用到SpringFactoriesLoader的loadSpringFactories方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryClassName, factoryName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在该方法中，会从所有的META-INF目录下加载spring.factories文件里配置的各类型的类名称（包括初始化器，监听器，自动配置类等）。然后上层方法中通过反射机制实例化这些初始化器、监听器，自动配置等，从而完成相应Bean的自动化配置与注入。</p><p><strong>spring-boot-autoconfigure</strong></p><p>官方提供的starter，如spring-boot-starter-web， 都依赖了spring-boot-starter， 而spring-boot-starter又依赖了spring-boot-autoconfigure。 在spring-boot-autoconfigure中提供了大量官方提供的自动配置类，并且包含META-INF/spring.factories文件，如下图</p><p><img src="/assets/config1.png" alt="spring-boot-autoconfigure"></p><p><strong>spring.factories</strong></p><p>由上图可看出，spring.factories包含了   </p><ul><li>org.springframework.context.ApplicationContextInitializer  应用初始化器</li><li>org.springframework.context.ApplicationListener 应用监听器</li><li>org.springframework.boot.autoconfigure.AutoConfigurationImportListener 自动配置引入监听器</li><li>org.springframework.boot.autoconfigure.AutoConfigurationImportFilter 自动配置引入过滤器</li><li>org.springframework.boot.autoconfigure.EnableAutoConfiguration 自动配置类</li><li>org.springframework.boot.diagnostics.FailureAnalyzer 失败分析器</li><li>org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider 模板提供者   </li></ul><p>其中org.springframework.boot.autoconfigure.EnableAutoConfiguration即实现自动配置的@Configuration配置类列表。</p><p>Spring Boot就是通过这种自动配置机制，以starter依赖包的方式，使开发者非常方便地使用项目开发中的许多常用功能，如数据库访问、缓存、队列等。同时，用户也可以根据自身需求，自定义自己的starter（后面介绍）。   </p><h3 id="通过注解控制自动配置"><a href="#通过注解控制自动配置" class="headerlink" title="通过注解控制自动配置"></a>通过注解控制自动配置</h3><p>Spring Boot自动配置包含了许多条件类注解及顺序类注解，这些注解可方便地让自动配置按照某种条件或者顺序进行配置。</p><p>其中条件类注解包括：</p><ul><li>类级别条件注解 @ConditionalOnClass： 类路径中存在指定的类才进行该配置；@ConditionalOnMissingClass： 类路径中不存在指定的类才进行该配置 </li><li>实例级别条件注解 @ConditionalOnBean：只有在当前上下文中存在指定Bean时，才进行该配置<br>@ConditionalOnMissingBean： 只有在当前上下文不存在指定Bean时，才进行该配置</li><li>属性级别条件注解 @ConditionalOnProperty：当存在某个指定属性，且值为指定值时，才进行该配置</li><li>资源级别条件注解 @ConditionalOnResource：在类路径下存在指定的Resource时，才进行配置</li><li>Web应用条件注解 @ConditionalOnWebApplication：该应用为Web应用时进行该配置<br>@ConditionalOnNotWebApplication： 该应用不为Web应用时进行该配置</li><li>SpEL（ Spring Expression Language）表达式注解 @ConditionalOnExpression： 计算SpEL表达式值，值为true时才进行该配置</li></ul><p>顺序类注解包括：</p><ul><li>@AutoConfigureAfter： 在指定的配置类初始化后再加载</li><li>@AutoConfigureBefore： 在指定的配置类初始化前加载</li><li>@AutoConfigureOrder： 数值越小越先初始化   </li></ul><blockquote><p>注意：自动配置类不应该位于组件扫描路径（@ComponentScan注解指定的扫描路径）下，否则上述条件注解与顺序注解可能不会生效。建议只在自动配置的类上注解@ConditionalOnBean， @ConditionalOnMissingBean，因为这可以保证在用户定义bean已经添加到ApplicationContext之后才会加载。这两个注解放在class上，则相当于class里面每一个@Bean标注的方法都加上了。</p></blockquote><p>自动配置是非侵入式的，你可以在任何地方自定义配置来覆盖自动配置中的某些内容，比如你在应用中通过@Configuration类注入一个自定义的DataSource，默认的基于内存的DataSource将被覆盖</p><h3 id="禁用某个自动配置类"><a href="#禁用某个自动配置类" class="headerlink" title="禁用某个自动配置类"></a>禁用某个自动配置类</h3><p>有时候引入的自动配置可能包含我们不想让其生效的配置类，这时候可以通过@EnableAutoConfiguration注解的属性进行排除，使其不生效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span>(exclude = &#123;XXAutoConfiguration.class&#125;)</span><br></pre></td></tr></table></figure></p><p>其中XXAutoConfiguration为某个自动配置类，如果该类不在应用的类路径中，则可以通过属性excludeName指定完整类路径来排除。@SpringBootApplicationz注解同样支持<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = &#123;XXAutoConfiguration.class&#125;)</span><br></pre></td></tr></table></figure></p><p>本文示例项目源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-config" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-config</a><br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>——————————————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（三）：Spring Boot自定义属性</title>
      <link href="/springboot-properties.html"/>
      <url>/springboot-properties.html</url>
      
        <content type="html"><![CDATA[<p>Web项目开发中，经常需要自定义一些属性，如数据库连接，第三方服务接口地址，第三方服务的appKey、appSecret等，以及针对不同环境，这些属性的值还需要有相应的调整，如开发环境、测试环境、生产环境所用数据库不同，则针对不同环境的同一属性需要配置不同的值。<br><a id="more"></a></p><h3 id="传统自定义属性配置及访问（参考Github示例测试类）"><a href="#传统自定义属性配置及访问（参考Github示例测试类）" class="headerlink" title="传统自定义属性配置及访问（参考Github示例测试类）"></a>传统自定义属性配置及访问（参考<a href="https://github.com/ronwxy/springboot-demos/blob/master/springboot-properties/src/test/java/cn/jboost/springboot/properties/TraditionalPropertiesHandleTest.java" target="_blank" rel="noopener">Github示例测试类</a>）</h3><p>在传统的Spring Web应用中，自定义属性一般是通过在类路径中（如resources目录）添加一个类似my.properties配置文件（文件名自定义），然后在xml配置中通过</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"myProps"</span> <span class="attr">location</span>=<span class="string">"classpath:my.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>引入属性文件。再定义一个Bean来读取这些属性，Bean配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"staticMethod"</span> <span class="attr">value</span>=<span class="string">"cn.jboost.springboot.properties.MyPropertiesUtil.init"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arguments"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myProps"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bean定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPropertiesUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line">        properties = props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getValue</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在其它需要访问的地方通过 <code>MyPropertiesUtil.getValue()</code> 方法来访问具体某个属性的值。</p><h3 id="Spring-Boot自定义属性配置及优先级"><a href="#Spring-Boot自定义属性配置及优先级" class="headerlink" title="Spring Boot自定义属性配置及优先级"></a>Spring Boot自定义属性配置及优先级</h3><p>在Spring Boot中，可以在多个地方配置属性，包括.properties文件，.yaml文件，环境变量， 系统属性，命令行参数等， 这些属性都会被Spring Boot加载到Environment中，可通过@Value注解，Environment实例，或 @ConfigurationProperties注解的类来访问。</p><p>属性加载优先级顺序：</p><ol><li>如果有使用devtools，devtools 全局设置的属性（用户目录 ~/.spring-bootdevtools.properties）</li><li>测试类的注解@TestPropertySource</li><li>测试类注解 @SpringBootTest#properties 配置的属性</li><li><strong>命令行参数</strong></li><li>SPRING_APPLICATION_JSON里的属性（环境变量或系统属性）</li><li>ServletConfig初始化参数</li><li>ServletContext初始化参数</li><li>JNDI参数   java:comp/env</li><li><strong>Java系统属性  System.getProperties()</strong></li><li><strong>操作系统环境变量</strong></li><li>RandomValuePropertySource 配置的属性 random.*</li><li>jar包外部的applictaion-{profile}.properties，applictaion-{profile}.yml配置文件</li><li><strong>jar包内部的applictaion-{profile}.properties，applictaion-{profile}.yml配置文件</strong></li><li>jar包外部的applictaion.properties，applictaion.yml配置文件</li><li><strong>jar包内部的applictaion.properties，applictaion.yml配置文件</strong></li><li>@Configuration类上的 @PropertySource注解指定的配置文件</li><li>默认属性： SpringApplication.setDefaultProperties</li></ol><blockquote><p>上述属性配置，除了粗体标注的外，其它一般应用较少。序号低的配置优先级高于序号高的配置，即如果存在相同属性配置 ，则序号低的配置会覆盖序号高的配置。applictaion-{profile}.properties 一般用于具体某个环境特有的属性配置，如application-dev.properties用于开发环境，可通过 spring.profiles.active=dev指定加载dev环境配置</p></blockquote><p>常用属性配置方式</p><ol><li>命令行参数<br>启动Spring Boot应用时，可以指定命令行参数，如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot-properties.jar --my.name=jboost@command_line</span><br></pre></td></tr></table></figure></li></ol><p>该参数值将会覆盖应用在其它地方配置的同名属性值。命令行参数放在xx.jar 的后面。</p><blockquote><p>可以通过SpringApplication.setAddCommandLineProperties(false)  禁用命令行参数配置</p></blockquote><ol start="2"><li>Java系统属性<br>同样在启动Spring Boot应用时，可以指定Java系统属性，一般见于自定义jvm参数，如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dmy.name=jboost@system_properties -jar springboot-properties.jar</span><br></pre></td></tr></table></figure></li></ol><p>Java系统属性放在java命令之后。</p><ol start="3"><li><p>操作系统环境变量（实际应用其实较少）<br>配置过JAVA_HOME的应该理解何为环境变量。某些操作系统可能不支持.分隔的属性名，可以改为以下划线连接。Spring Boot将myName, my.name, MY_NAME视为等效。</p></li><li><p>应用属性配置文件（.properties文件或 .yml文件）<br>.properties文件属性配置格式：  </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my.name=jboost</span><br><span class="line">my.list[0]=aaa  //配置列表</span><br><span class="line">my.list[1]=bbb</span><br></pre></td></tr></table></figure><p>.yml文件属性配置格式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">devlink</span></span><br><span class="line"><span class="attr">  list:</span>   <span class="string">//配置列表</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">aaa</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">bbb</span></span><br></pre></td></tr></table></figure><p>yml中，属性名与值之间冒号后面必须有空格。</p><p>应用属性配置文件位置：</p><ol><li>jar包所在当前目录下的子目录/config（外置属性文件） </li><li>jar包所在当前目录（外置属性文件） </li><li>classpath根目录下的子目录/config（内置属性文件）</li><li>classpath根目录（内置属性文件）</li></ol><blockquote><p>序号低的优先级高于序号高的优先级，即jar包外的配置优先级高于jar包内的配置。同一目录下，.properties文件的优先级高于.yml文件。application-{profile}.properties的优先级高于application.properties。</p></blockquote><h3 id="Spring-Boot自定义属性访问方式（参考Github示例测试类）"><a href="#Spring-Boot自定义属性访问方式（参考Github示例测试类）" class="headerlink" title="Spring Boot自定义属性访问方式（参考Github示例测试类）"></a>Spring Boot自定义属性访问方式（参考<a href="https://github.com/ronwxy/springboot-demos/blob/master/springboot-properties/src/test/java/cn/jboost/springboot/properties/SpringbootPropertiesHandleTest.java" target="_blank" rel="noopener">Github示例测试类</a>）</h3><ol><li>类中属性上添加 @Value(“${xx}”) 注解方式。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;my.name&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ol><p>可以指定默认值，如 @Value(“${my.name:jboost}”)， 当my.name未配置时，默认使用值”jboost”</p><ol start="2"><li>通过@ConfigurationProperties注解的类来访问。如定义：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"my"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了getter、setter函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>然后在需要访问的Bean中，通过@Autowired 注入MyConfigProperties实例，通过getName()方法即可访问my.name属性值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyConfigProperties myConfigProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConfigurationProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test @ConfigurationProperties =========="</span>);</span><br><span class="line">    System.out.println(myConfigProperties.getName());</span><br><span class="line">    System.out.println(myConfigProperties.getWebsite());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>通过Environment 实例访问。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEnvironment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test Environment =========="</span>);</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">"my.name"</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">"my.website"</span>, <span class="string">"default value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>另外也可以通过 spring-boot-starter-actuator 的接口来查看项目加载的属性配置，在pom.xml中加入 spring-boot-starter-actuator 依赖，因为 spring-boot-starter-actuator 在2.x版本中，出于安全性考虑，将actuator 控件中的端口，只默认开放/health 和/info 两个端口，其他端口默认关闭，因此需要添加配置management.endpoints.web.exposure.include= *，<br>management.endpoints.web.exposure.exclude=beans,trace，<br>management.endpoint.health.show-details=ALWAYS，启动项目后，访问 <a href="http://localhost:8080/actuator/env" target="_blank" rel="noopener">http://localhost:8080/actuator/env</a> ，返回的 propertySources 即为加载的所有属性源，优先级从上往下依次降低，与上文所述优先级相符</p></blockquote><p>本文示例项目源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-properties" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-properties</a></p><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（二）：第一个Spring Boot应用</title>
      <link href="/springboot-firstapp.html"/>
      <url>/springboot-firstapp.html</url>
      
        <content type="html"><![CDATA[<p>Spring Boot应用可以通过如下三种方法创建：</p><ol><li>通过 <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 网站创建</li><li>通过 <code>Spring Initializr</code> 创建</li><li>自主创建<a id="more"></a></li></ol><h3 id="推荐开发工具"><a href="#推荐开发工具" class="headerlink" title="推荐开发工具"></a>推荐开发工具</h3><ul><li>JDK 1.8+</li><li>IntelliJ IDEA</li><li>maven 3.3+</li></ul><p>在开始之前，先确认是否安装上述工具，在命令行输入 <code>java -version</code> 查看JDK是否正确安装， 输入 <code>mvn -version</code> 查看maven是否正确安装，如果未正确安装，请先查阅相关文档完成安装。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS D:\&gt; java -version</span><br><span class="line">java version "1.8.0_201"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br><span class="line">PS D:\&gt;</span><br><span class="line">PS D:\&gt;</span><br><span class="line">PS D:\&gt; mvn -version</span><br><span class="line">Apache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)</span><br><span class="line">Maven home: D:\tool\apache-maven-3.6.0\bin\..</span><br><span class="line">Java version: 1.8.0_201, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk1.8.0_201\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: "windows 10", version: "10.0", arch: "amd64", family: "windows"</span><br><span class="line">PS D:\&gt;</span><br></pre></td></tr></table></figure></p><h3 id="1-通过-https-start-spring-io-网站创建"><a href="#1-通过-https-start-spring-io-网站创建" class="headerlink" title="1. 通过 https://start.spring.io/ 网站创建"></a>1. 通过 <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 网站创建</h3><p>进入 <a href="https://start.spring.io/，填写对应的信息，如下图所示" target="_blank" rel="noopener">https://start.spring.io/，填写对应的信息，如下图所示</a><br><img src="/assets/firstapp1.png" alt="项目配置"><br>其中project选 <code>Maven Project</code>， Spring Boot版本选 <code>2.1.5</code> 版， Project Metadata部分， Group一般用你域名的倒序字符串，Artifact即项目名称，选择Packaging类型为Jar，Java版本为8，在Dependencies部分输入Web，选中第一个Spring Web Starter，然后点击“Generate the project”按钮，下载生成的项目。解压项目，在IntelliJ IDEA中 <code>File -&gt; Open</code> 选中项目解压目录打开，即可看到生成的项目结构如下图<br><img src="/assets/firstapp2.png" alt="项目结构"><br>具体各文件含义后面详述。</p><h3 id="2-通过Spring-Initializr创建（推荐）"><a href="#2-通过Spring-Initializr创建（推荐）" class="headerlink" title="2. 通过Spring Initializr创建（推荐）"></a>2. 通过Spring Initializr创建（推荐）</h3><p>IntelliJ IDEA中<code>File -&gt; New -&gt; Project...</code>打开新建项目窗口（这里也可以选择New Module, IDEA的Project类似于Eclipse的Workspace，Module则类似于Eclipse的Project，有时候为了将一些项目统一管理，可以建一个Project，然后在Project内部建立Module），如下图所示<br><img src="/assets/firstapp3.png" alt="新建项目"></p><p>选择<code>Spring Initializr</code>，点击<code>Next</code>，填写相应信息， 如下图所示<br><img src="/assets/firstapp4.png" alt="项目配置"></p><p>点击<code>Next</code>，选择Spring Boot版本以及相应依赖，如下图（这里选择2.1.5版本及Spring Web Starter依赖）<br><img src="/assets/firstapp5.png" alt="项目配置"></p><p>然后依次点击Next, Finish完成项目创建。可以看到创建的项目结构与第一种方法一致。</p><blockquote><p>有的旧IDEA版本下项目可能不能编译，IDE未将其识别为maven项目，只需在pom.xml文件上右键，点击<code>Add as Maven project</code>即可。</p></blockquote><h3 id="3-自主创建"><a href="#3-自主创建" class="headerlink" title="3. 自主创建"></a>3. 自主创建</h3><p>自主创建即像普通Java Maven项目一样，先创建maven项目，然后参考1、2方法中创建的项目结构与目录，手动进行添加。</p><blockquote><p>上述三种创建方法，第1种需要网站生成再下载解压导入，第2种直接基于IDE创建，第3种完全自主手动创建。实际开发中推荐采用第2种创建初始项目原型，再根据具体需求删除或添加相应目录与文件。</p></blockquote><h3 id="4-项目结构"><a href="#4-项目结构" class="headerlink" title="4. 项目结构"></a>4. 项目结构</h3><p>通过上述方法创建的项目，结构如下图所示</p><p><img src="/assets/firstapp6.png" alt="项目结构"></p><p>其中</p><ul><li>SpringbootFirstappApplication 为项目入口类，通过SpringApplication.run()方法来启动项目</li><li>入口类上的注解 @SpringBootApplication 表明，这是一个Spring Boot项目，它会为你自动做一些Spring Boot项目的处理</li><li>resources 下的static目录为静态资源目录，可以放置js，css，img之类的资源，templates目录可放置模板文件，一般做前后端分离开发，这两个目录可删除</li><li>application.properties 文件为项目的配置文件，可在该文件中配置项目所需要的各项配置属性</li><li>SpringbootFirstappApplicationTests 生成的测试类，可基于此进行单元测试编写</li><li>pom.xml即为maven配置文档，可看到项目已继承<code>spring-boot-starter-parent</code>，并且引入了<code>spring-boot-starter-web</code>，<code>spring-boot-starter-test</code>两项依赖，以及<code>spring-boot-maven-plugin</code></li></ul><h3 id="5-运行"><a href="#5-运行" class="headerlink" title="5. 运行　"></a>5. 运行　</h3><p>上述创建的项目可直接运行，大致有如下几种运行方式：</p><ol><li>直接在项目入口类SpringbootFirstappApplication中右键，点击<code>Run &#39;SpringbootFirstappAp...&#39;</code>运行</li><li>在项目根目录下打开终端，或IDEA的Terminal中执行<code>mvn spring-boot:run</code>（前提是项目pom.xml文件中引入了spring-boot-maven-plugin）</li><li>使用<code>mvn package</code>打包，然后通过<code>java -jar target\springboot-firstapp-1.0.0-SNAPSHOT.jar</code> 启动（一般用于远程环境的部署启动）</li><li>如果打包成war，将war包部署到tomcat等Servlet容器运行</li></ol><p>项目启动后，从启动日志可看出默认端口为8080，但打开 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 会显示一个404报错页面，这是因为我们还没有编写任何服务。<br>下面我们添加一个非常简单的Rest服务接口，在项目的根包下（我这里是cn.jboost.springboot.firstapp，实际项目中一般会创建一个controller的子包）添加HelloController类，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>)</span>String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"您好，"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>@RestController</code>注解会将返回结果以字符串的方式解析，<code>@GetMapping</code>等效于<code>@RequestMapping(method = {RequestMethod.GET})</code><br>重启应用，然后浏览器地址栏中输入 <a href="http://localhost:8080/hello?name=jboost，" target="_blank" rel="noopener">http://localhost:8080/hello?name=jboost，</a> 页面输出如下图：</p><p><div align="center"><img src="/assets/firstapp7.png" alt="接口调用"><br></div><br>至此，一个可运行的Web项目即已搭建完成，是不是非常简单。   </p><p>本文示例项目源码地址：<a href="https://github.com/ronwxy/springboot-demos/tree/master/springboot-firstapp" target="_blank" rel="noopener">https://github.com/ronwxy/springboot-demos/tree/master/springboot-firstapp</a><br><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot从入门到实战（一）：Spring Boot简介</title>
      <link href="/springboot-overview.html"/>
      <url>/springboot-overview.html</url>
      
        <content type="html"><![CDATA[<p>Spring Boot这几年非常流行，差不多是基于Spring框架应用开发的首选，同时在微服务架构领域，如Spring Cloud 框架中，Spring Boot也是基础，因此掌握Spring Boot，应成为Java开发人员必不可少的技能。<br><a id="more"></a></p><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>传统的基于Spring的Java Web应用，需要配置 <code>web.xml</code>, <code>applicationContext.xml</code> 等大量xml配置信息，然后将应用打成war包放入web应用服务器(如Tomcat, Jetty等)中运行。有过实践经验的开发者应能体会到这个过程繁杂且重复。Spring Boot将这种繁杂且重复的工作通过<strong>自动化配置</strong>等手段实现，从而将开发者从复杂的配置工作中解放出来，能够更专注于业务逻辑的开发。因此，Spring Boot并不是Spring的替代解决方案，它本身并不提供Spring框架的核心特性以及扩展功能，而是和Spring框架紧密结合用于提升Spring开发者体验，提高开发效率的的工具框架。截至本文，Spring Boot最新GA版本为2.1.5。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Spring Boot框架大致包括如下特性：</p><ul><li>自动化配置。Spring Boot 通过autoconfiguration的方式（后面会详细讨论何为autoconfiguration）来简化配置管理。比如如果需要访问数据库，则只需要引入相应的starter依赖包，Spring Boot便会自动为你配置访问数据库所需要的Bean，如 DataSource， JdbcTemplate等。使用Spring Boot，项目中几乎不需要任何 xml 配置文件。</li><li>内嵌的Web服务容器。Spring Boot内嵌了Tomcat、Jetty、Undertow。因此，Spring Boot应用可以像普通java应用一样打成jar包直接通过 <code>java -jar</code> 执行，而不需传统web应用一样需要打成war包部署到独立的web服务容器中。</li><li>简化依赖管理。Spring Boot官方提供了大量的starter依赖包，帮你管理了使用某个功能所需要的依赖，开发者只需要引入starter依赖，即可使用对应的功能。如spring-boot-starter-web，spring-boot-starter-jdbc等。同时自己也可以自定义starter，为某些通用功能提供模块化共享支持。</li><li>提供生产环境级的应用配置、度量指标、操作控制接口。Spring Boot的spring-boot-starter-actuator提供了查看应用配置信息，获取应用运行指标，以及控制应用（如关闭应用）三种类型的接口。通过这些接口，可以排查问题，监控服务运行情况等。   </li></ul><p>Spring Boot的这些特性，使得应用Spring Boot开发Web应用非常便捷、高效，因此在快速应用开发（Rapid Application Development）领域以及微服务架构方面，Spring Boot都是比较好的选择。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>该序列涉及的开发工具包括但不限于：</p><ul><li>JDK 1.8+ , 一般用的是1.8</li><li>Maven 3.3+ , 我们用的是Maven3.6.0</li><li>IntelliJ IDEA Ultimate Edition， 需要激活，<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">参考这里</a></li><li>MySQL，可选，数据库访问示例需要 </li><li>Redis， 可选，缓存示例需要</li></ul><p><br><br><br><br>我的个人博客地址：<a href="http://blog.jboost.cn">http://blog.jboost.cn</a><br>我的头条空间： <a href="https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112" target="_blank" rel="noopener">https://www.toutiao.com/c/user/5833678517/#mid=1636101215791112</a><br>我的github地址：<a href="https://github.com/ronwxy" target="_blank" rel="noopener">https://github.com/ronwxy</a><br>我的微信公众号：jboost-ksxy</p><p>———————————————————————————————————————————————————————————————</p><p><img src="/assets/qrcode-05.jpg" alt="微信公众号"><br>欢迎关注我的微信公众号，及时获取最新分享</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在前面</title>
      <link href="/ahead.html"/>
      <url>/ahead.html</url>
      
        <content type="html"><![CDATA[<h3 id="一点感悟"><a href="#一点感悟" class="headerlink" title="一点感悟"></a>一点感悟</h3><p>在软件与互联网技术领域从业多年，从一个一知半解的职场菜鸟成长为行业“老司机”，也从一个邯郸学步的技术新手晋升成为能带领团队披荆斩棘，在技术范畴能掌握话语权的技术管理者。其间也与大多数同行一样，踩过不少坑，加过不少班，背过不少锅……，但同时，也为自己不断成长、进步——包括技术、能力层面，也包括薪酬、职位层面，而感到欣慰。但技术领域日新月异，接触的越多，越发现自己的无知，因此 <code>Stay hungry，Stay foolish</code>，保持持续学习的热情，永远不要满足于现状，才能保持自身竞争力，不至于在年龄增长时，出现所谓的“中年危机”。</p><h3 id="一点初衷"><a href="#一点初衷" class="headerlink" title="一点初衷"></a>一点初衷</h3><p>大学期间也曾玩过新浪博客，写过一些心路历程与人生感悟（^_^），随着年龄的增长，逐渐失去了用文字来抒发情感的激情。工作后，开始接触技术博客，也断断续续写过一些分享，但终因阶段性忙或懒惰，没能坚持下来。与之前抒发情感与感悟不同，技术博客更多的是一种经验的自我梳理总结与分享。一方面为那些踏入职场不久实践经验较缺乏的同行提供参考，另一方面也是对自我日常技术工作的整理，以达到“好记性不如烂笔头”的效果。<br>因此，虽然现今从事一线编码工作相对较少，心中一直还是有一个将以往及现在所接触的实践经验记录与分享出来的想法。于是，花了点时间整了这个博客，希望能坚持下去。</p><h3 id="一点期望"><a href="#一点期望" class="headerlink" title="一点期望"></a>一点期望</h3><p>凡事做了，总希望有所回报。整理文章其实需要花费不少时间与精力，因此也希望发出来的分享能为大家带来切实的收获，获得大家的肯定与良性反馈。有更好建议，也欢迎大家通过留言或其它方式与我交流。希望这是一个好的开始，加油！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
