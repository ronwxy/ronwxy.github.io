<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="erIKW497yS"><meta name="google-site-verification" content="UgdHTfiMSYvSc5WkTMWIBaRheQv9f_np2Dm0RUlPFco"><title> Ansible简明教程 · 空山新雨的技术空间</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Ansible简明教程 - 空山新雨"><meta name="keywords" content="Spring,DevOps,技术管理"><meta name="author" content="空山新雨"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.jboost.cn/atom.xml" title="空山新雨的技术空间"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Ansible简明教程</h1><div class="post-info">2020-04-17<p class="visit"><i data-identity="ansible.html" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><p>Ansible是当下比较流行的自动化运维工具，可通过SSH协议对远程服务器进行集中化的配置管理、应用部署等，常结合Jenkins来实现自动化部署。</p>
<a id="more"></a>
<p>除了Ansible，还有像SaltStack、Fabric（曾经管理100多台服务器上的应用时也曾受益于它）、Puppet等自动化工具。相比之下，Ansible最大的优势就是无需在被管理主机端部署任何客户端代理程序，通过SSH通道就可以进行远程命令的执行或配置的下发，足够轻量级，但同时功能非常强大，且各项功能通过模块来实现，具备良好的扩展性。不足之处是Ansible只支持在Linux系统上安装，不支持Windows。</p>
<p>如果你需要在多于一台服务器上做相同的操作，那么建议你使用Ansible之类的自动化工具，这将极大提高你的操作效率。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>1.找一台主机用于做管理服务器，在其上安装Ansible</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ansible</span><br></pre></td></tr></table></figure>
<p>Ansible基于Python实现，一般Linux系统都自带Python，所以可以直接使用yum安装或pip安装。</p>
<p>安装完后，在/etc/ansible/目录下生成三个主要的文件或目录，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# ll /etc/ansible/</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r--. 1 root root 19179 Jan 30  2018 ansible.cfg</span><br><span class="line">-rw-r--r--. 1 root root  1136 Apr 17 15:17 hosts</span><br><span class="line">drwxr-xr-x. 2 root root     6 Jan 30  2018 roles</span><br></pre></td></tr></table></figure>
<ul>
<li>ansible.cfg： Ansible的配置文件</li>
<li>hosts：登记被管理的主机</li>
<li>roles：角色项目定义目录，主要用于代码复用</li>
</ul>
<p>2.在/etc/ansible/hosts文件中添加需要被管理的服务器节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# vim /etc/ansible/hosts</span><br><span class="line">[k8s]</span><br><span class="line">192.168.40.201</span><br><span class="line">192.168.40.202</span><br><span class="line">192.168.40.205</span><br><span class="line">192.168.40.206</span><br></pre></td></tr></table></figure>
<p><code>[k8s]</code>表示将下面的服务器节点分到k8s的组中，后面执行命令时可指定针对某个组执行。</p>
<p>3.生成SSH KEY，并copy到被管理节点上，实现免密SSH访问</p>
<p>在管理节点执行 <code>ssh-keygen</code> 生成SSH KEY，然后copy到各被管理节点上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.40.201</span><br></pre></td></tr></table></figure>
<p>上面命令将<code>~/.ssh/id_rsa.pub</code>文件内容添加到被管理节点的/root/.ssh/authorized_keys文件中，实现管理节点到被管理节点的免密SSH访问。</p>
<p>4.调试Ansible</p>
<p>针对k8s服务器组执行ping，验证Ansible到各被管理节点的连通性</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# ansible k8s -m ping</span><br><span class="line">192.168.40.201 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.40.205 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.40.202 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.40.206 | SUCCESS =&gt; &#123;</span><br><span class="line">    "changed": false,</span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ansible只需要在管理主机上安装，然后打通管理主机到各被管理主机的SSH免密访问即可进行集中化的管理控制，不需在被管理主机安装任何代理程序。</p>
<h2 id="Ansible命令"><a href="#Ansible命令" class="headerlink" title="Ansible命令"></a>Ansible命令</h2><p>Ansible的命令格式为， <code>ansible 主机群组名 -m 命令模块名 -a &quot;批量执行的操作&quot;</code></p>
<p>其中-m不是必须的，默认为command模块，-a也不是必须的，表示命令模块的参数，比如前面的ping模块就没有参数。</p>
<p>可以使用 <code>ansible-doc -l</code> 列出所有可用的命令模块， <code>ansible-doc -s 模块名</code> 查看指定模块的参数信息</p>
<p>常用命令模块</p>
<p>1.command<br>command是Ansible的默认模块，不指定-m参数时默认使用command。command可以运行远程主机权限范围内的所有shell命令，但不支持管道操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看k8s分组主机内存使用情况</span></span><br><span class="line">ansible k8s -m command -a "free -g"</span><br></pre></td></tr></table></figure>
<p>2.shell<br>shell基本与command相同，但shell支持管道操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">shell支持管道操作 |grep Mem</span></span><br><span class="line">ansible k8s -m shell -a "free -g|grep Mem"</span><br></pre></td></tr></table></figure>
<p>3.script<br>script就是在远程主机上执行管理端存储的shell脚本文件，相当于scp+shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /root/echo.sh为管理端本地shell脚本</span></span><br><span class="line">ansible k8s -m script -a "/root/echo.sh"</span><br></pre></td></tr></table></figure>
<p>4.copy<br>copy实现管理端到远程主机的文件拷贝，相当于scp</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拷贝本地echo.sh文件到k8s组中远程主机的/tmp目录下，所属用户、组为 root ，权限为 0755</span></span><br><span class="line">ansible k8s -m copy -a "src=/root/echo.sh dest=/tmp/ owner=root group=root mode=0755"</span><br></pre></td></tr></table></figure>
<p>5.yum<br>软件包安装或删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m yum -a "name=wget state=latest"</span><br></pre></td></tr></table></figure>
<p>其中state有如下取值：</p>
<ul>
<li>针对安装，可取值“present，installed，latest”，present，installed即普通安装，两者无区别，latest是使用yum mirror上最新的版本进行安装</li>
<li>针对删除，可取值“absent，removed”，两者无差别</li>
</ul>
<p>6.service<br>对远程主机的服务进行管理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m service -a "name=nginx state=stoped"</span><br></pre></td></tr></table></figure>
<p>state可取值“started/stopped/restarted/reloaded”。</p>
<p>7.get_url<br>在远程主机上下载指定URL到本地</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m get_url -a "url=http://www.baidu.com dest=/tmp/index.html mode=0440 force=yes"</span><br></pre></td></tr></table></figure>
<p>8.setup<br>获取远程主机的信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m setup</span><br></pre></td></tr></table></figure>
<p>9.file<br>管理远程主机的文件或目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m file -a "dest=/opt/test state=touch"</span><br></pre></td></tr></table></figure>
<p>state可取值</p>
<ul>
<li>directory：创建目录</li>
<li>file：如果文件不存在，则创建</li>
<li>link：创建symbolic link</li>
<li>absent：删除文件或目录</li>
<li>touch： 创建一个不存在的空文件</li>
</ul>
<p>10.cron<br>管理远程主机的crontab定时任务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible k8s -m cron -a "name='backup servcie' minute=*/5 job='/usr/sbin/ntpdate  time.nist.gov &gt;/dev/null 2&gt;&amp;1'"</span><br></pre></td></tr></table></figure>
<p>支持的参数</p>
<ul>
<li>state： 取值present表示创建定时任务，absent表示删除定时任务</li>
<li>disabled： yes表示注释掉定时任务，no表示接触注释</li>
</ul>
<h2 id="Ansible-playbook"><a href="#Ansible-playbook" class="headerlink" title="Ansible playbook"></a>Ansible playbook</h2><p>Ansible的playbook由一个或多个play组成，play的功能就是为归为一组的主机编排要执行的一系列task，其中每一个task就是调用Ansible的一个命令模块。</p>
<p>playbook的核心元素包括：</p>
<ul>
<li>hosts：执行任务的远程主机组或列表</li>
<li>tasks：要执行的任务列表</li>
<li>variables：内置变量或自定义的变量</li>
<li>templates：使用模板语法的文件，通常为配置文件</li>
<li>handlers：和notify结合使用，由特定条件触发，一般用于配置文件变更触发服务重启</li>
<li>tags：标签，可在运行时通过标签指定运行playbook中的部分任务</li>
<li>roles：</li>
</ul>
<p>playbook文件遵循yaml的语法格式，运行命令的格式为 <code>ansible-playbook &lt;filename.yml&gt; ... [options]</code>， 常用options包括</p>
<ul>
<li>–syntax        检查playbook文件语法是否正确</li>
<li>–check 或 -C   只检测可能会发生的改变，但不真正执行操作</li>
<li>–list-hosts    列出运行任务的主机</li>
<li>–list-tags     列出playbook文件中定义所有的tags</li>
<li>–list-tasks    列出playbook文件中定义的所有任务集</li>
<li>–limit         只针对主机列表中的某个主机或者某个组执行</li>
<li>-f              指定并发数，默认为5个</li>
<li>-t              指定某个或多个tags运行（前提playbook中有定义tags）</li>
<li>-v              显示过程 -vv -vvv更详细</li>
</ul>
<p>下面以批量安装Nginx为例，尽可能介绍playbook各核心元素的用法。</p>
<p>定义palybook yaml文件nginx_playbook.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="number">192.168</span><span class="number">.40</span><span class="number">.201</span><span class="string">,192.168.40.205</span> <span class="comment"># 主机列表，也可以是/etc/ansible/hosts中定义的主机分组名</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span> <span class="comment"># 远程用户</span></span><br><span class="line"><span class="attr">  vars:</span>             <span class="comment"># 自定义变量</span></span><br><span class="line"><span class="attr">     version:</span> <span class="number">1.16</span><span class="number">.1</span></span><br><span class="line"><span class="attr">  vars_files:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">./templates/nginx_locations_vars.yml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">install</span> <span class="string">dependencies</span>          <span class="comment"># 定义任务的名称</span></span><br><span class="line"><span class="attr">       yum:</span> <span class="string">name=&#123;&#123;item&#125;&#125;</span> <span class="string">state=installed</span>  <span class="comment"># 调用模块，具体要做的事情，这里使用with_items迭代多个yum任务安装必要的依赖</span></span><br><span class="line"><span class="attr">       with_items:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">gcc</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">gcc-c++</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">pcre</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">pcre-devel</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">zlib</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">zlib-devel</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">openssl</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">openssl-devel</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">download</span> <span class="string">nginx</span>                <span class="comment"># 通过get_url模块下载nginx</span></span><br><span class="line"><span class="attr">       get_url:</span> <span class="string">url=http://nginx.org/download/nginx-&#123;&#123;version&#125;&#125;.tar.gz</span> <span class="string">dest=/tmp/</span> <span class="string">mode=0755</span> <span class="string">force=no</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">unarchive</span>                     <span class="comment"># 通过unarchive模块解压nginx</span></span><br><span class="line"><span class="attr">       unarchive:</span> <span class="string">src=/tmp/nginx-&#123;&#123;version&#125;&#125;.tar.gz</span> <span class="string">dest=/tmp/</span> <span class="string">mode=0755</span> <span class="string">copy=no</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">configure,make</span> <span class="string">and</span> <span class="string">install</span>    <span class="comment"># 通过shell模块执行shell命令编译安装</span></span><br><span class="line"><span class="attr">       shell:</span> <span class="string">cd</span> <span class="string">/tmp/nginx-&#123;&#123;version&#125;&#125;</span> <span class="string">&amp;&amp;</span> <span class="string">./configure</span> <span class="bullet">--prefix=/usr/local/nginx</span> <span class="string">&amp;&amp;</span> <span class="string">make</span> <span class="string">&amp;&amp;</span> <span class="string">make</span> <span class="string">install</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">start</span> <span class="string">nginx</span>                   <span class="comment"># 通过shell模块执行shell命令启动nginx</span></span><br><span class="line"><span class="attr">       shell:</span> <span class="string">/usr/local/nginx/sbin/nginx</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">update</span> <span class="string">config</span>                 <span class="comment"># 通过template模块动态生成配置文件下发到远程主机目录</span></span><br><span class="line"><span class="attr">       template:</span> <span class="string">src=nginx.conf.j2</span> <span class="string">dest=/usr/local/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="attr">       notify:</span> <span class="string">reload</span> <span class="string">nginx</span>                <span class="comment"># 在结束时触发一个操作，具体操作通过handlers来定义</span></span><br><span class="line"><span class="attr">       tags:</span> <span class="string">reload</span>                        <span class="comment"># 对任务定义一个标签，运行时通过-t执行带指定标签的任务</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">reload</span> <span class="string">nginx</span>                  <span class="comment"># 与notify定义的内容对应</span></span><br><span class="line"><span class="attr">       shell:</span> <span class="string">/usr/local/nginx/sbin/nginx</span> <span class="bullet">-s</span> <span class="string">reload</span></span><br></pre></td></tr></table></figure>
<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><p>在上面的示例中使用vars定义了变量version，在tasks中通过进行引用。Ansible支持如下几种定义变量的方式</p>
<p>1.在playbook文件中定义<br>前面示例已经说明</p>
<p>2.命令行指定<br>在执行playbook时通过-e指定，如<code>ansible-playbook -e &quot;version=1.17.9&quot; nginx_playbook.yml</code>， 这里指定的变量将覆盖playbook中定义的同名变量的值</p>
<p>3.hosts文件中定义变量<br>在/etc/ansible/hosts文件中也可以定义针对单个主机或主机组的变量，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">192.168.40.201 version=1.17.9 # 定义单个主机的变量</span><br><span class="line">192.168.40.205 </span><br><span class="line">[nginx:vars]  # 定义整个组的统一变量</span><br><span class="line">version=1.16.1</span><br></pre></td></tr></table></figure>
<p>4.在独立的yaml文件中定义变量<br>专门定义一个yaml变量文件，然后在playbook文件中通过var_files引用，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义存放变量的文件</span></span><br><span class="line">[root@ansible ]# cat var.yml</span><br><span class="line">version: 1.16.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写playbook</span></span><br><span class="line">[root@ansible ]# cat nginx_playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: nginx</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars_files:     # 引用变量文件</span><br><span class="line">    - ./var.yml   # 指定变量文件的path（这里可以是绝对路径，也可以是相对路径）</span><br></pre></td></tr></table></figure>
<p>5.使用setup模块获取到的变量<br>前面介绍setup模块可获取远程主机的信息，可在playbook中直接引用setup模块获取到的属性，比如系统版本： ansible_distribution_major_version</p>
<h3 id="2-模板"><a href="#2-模板" class="headerlink" title="2. 模板"></a>2. 模板</h3><p>playbook模板为我们提供了动态的配置服务，使用jinja2语言，支持多种条件判断、循环、逻辑运算、比较操作等。应用场景就是定义一个模板配置文件，然后在执行的时候动态生成最终的配置文件下发到远程主机。一般将模板文件放在playbook文件同级的templates目录下，这样在playbook文件中可以直接引用，否则需要通过绝对路径指定，模板文件后缀名一般为 .j2。</p>
<p>本例中，我们将nginx.conf配置文件作为模板文件，添加需要动态配置的内容，并定义一个变量文件，通过vars_files引入：<code>vars_files: ./templates/nginx_locations_vars.yml</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 模板文件</span></span><br><span class="line">[root@tool-server nginx-deploy]# vim templates/nginx.conf.j2</span><br><span class="line"> ...</span><br><span class="line"> server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        # 这里的内容动态生成</span><br><span class="line">        &#123;% for location in nginx_locations %&#125;</span><br><span class="line">        location &#123;&#123;location.path&#125;&#125; &#123;</span><br><span class="line">           proxy_pass &#123;&#123;location.proxy&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"> ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 独立的自定义变量文件，用于填充模板文件中的变量</span></span><br><span class="line">[root@tool-server nginx-deploy]# vim templates/nginx_locations_vars.yml</span><br><span class="line"></span><br><span class="line">nginx_locations:</span><br><span class="line">  - &#123;"path": "/cns", "proxy": "http://192.168.40.202/cns"&#125;</span><br><span class="line">  - &#123;"path": "/admin", "proxy": "http://192.168.40.202/admin"&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-handlers"><a href="#3-handlers" class="headerlink" title="3. handlers"></a>3. handlers</h3><p>handlers和notify结合使用，由特定条件触发，一般用于配置文件变更触发服务重启。在本例中我们在配置文件变更时，通过notify定义了一个“reload nginx”的操作，然后在handlers部分定义“reload nginx”操作——通过shell模块调用nginx的reload来重新加载配置。</p>
<h3 id="4-标签"><a href="#4-标签" class="headerlink" title="4. 标签"></a>4. 标签</h3><p>playbook文件中，如果只想执行某一个或几个任务，则可以给任务打标签，在运行的时候通过 -t 选择带指定标签的任务执行，也可以通过 –skip-tags 选择不带指定标签的任务执行。比如在本例中，我们在“update config”的task上加了“reload”的标签，如果后面再修改配置，我们只需要执行“update config”的task并触发reload nginx就行了，可以这么执行playbook</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server nginx-deploy]# ansible-playbook -t reload nginx_playbook.yml</span><br></pre></td></tr></table></figure>
<h3 id="5-when"><a href="#5-when" class="headerlink" title="5. when"></a>5. when</h3><p>可以在task上添加when表示当某个条件达到了该任务才执行，如</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">   - name:</span> <span class="string">install</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">     yum:</span> <span class="string">name=nginx</span> <span class="string">state=installed</span></span><br><span class="line"><span class="attr">   - name:</span> <span class="string">update</span> <span class="string">config</span> <span class="string">for</span> <span class="string">system6</span></span><br><span class="line"><span class="attr">     template:</span> <span class="string">src=nginx.conf.j2</span> <span class="string">dest=/usr/local/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="attr">     when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">"6"</span>   <span class="comment"># 判断系统版本，为6才执行上面的template配置的文件</span></span><br></pre></td></tr></table></figure>
<h3 id="6-roles"><a href="#6-roles" class="headerlink" title="6. roles"></a>6. roles</h3><p>roles就是将变量、文件、任务、模板及处理器放置在单独的目录中，并可以在playbook中include的一种机制，一般用于主机构建服务的场景中，但也可以是用于构建守护进程等场景。</p>
<p>roles的目录结构，默认的roles目录为/etc/ansible/roles</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">roles:</span>          <span class="comment"># 所有的角色项目必须放在roles目录下</span></span><br><span class="line"><span class="attr">  project:</span>      <span class="comment"># 具体的角色项目名称，比如nginx、tomcat</span></span><br><span class="line">    <span class="string">files：</span>     <span class="comment"># 用来存放由copy或script模块调用的文件</span></span><br><span class="line">    <span class="string">templates：</span> <span class="comment"># 用来存放jinjia2模板，template模块会自动在此目录中寻找jinjia2模板文件</span></span><br><span class="line">    <span class="string">tasks：</span>     <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色的任务列表，此文件可以使用include包含其它的位于此目录的task文件。</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">handlers：</span>  <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色中触发条件时执行的动作</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">vars：</span>      <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色用到的变量</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">defaults：</span>  <span class="comment"># 此目录应当包含一个main.yml文件，用于为当前角色设定默认变量</span></span><br><span class="line">      <span class="string">main.yml</span></span><br><span class="line">    <span class="string">meta：</span>      <span class="comment"># 此目录应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系</span></span><br><span class="line">      <span class="string">main.yml</span></span><br></pre></td></tr></table></figure>
<p>我们将上面的例子通过roles改造一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@tool-server ~]# cd /etc/ansible/roles/</span><br><span class="line">[root@tool-server roles]# mkdir -p nginx/&#123;tasks,vars,templates,handlers&#125;</span><br><span class="line">...#创建各目录的mian.yml文件，并将对应的内容加入文件中</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">最终目录结构</span></span><br><span class="line">[root@tool-server roles]# tree  .</span><br><span class="line">.</span><br><span class="line">└── nginx</span><br><span class="line">    ├── handlers</span><br><span class="line">    │   └── main.yml # 上例handlers部分的内容，直接 -name开头，不需要再加 `handlers：`</span><br><span class="line">    ├── tasks</span><br><span class="line">    │   └── main.yml # tasks部分内容，直接-name开头，不需要加tasks，可以将各个task拆分为多个文件，然后在main.yml中通过 `- include: install.yml` 形式的列表引入</span><br><span class="line">    ├── templates</span><br><span class="line">    │   └── main.yml # templates/nginx.conf.j2的内容</span><br><span class="line">    └── vars</span><br><span class="line">        └── main.yml # templates/nginx_locations_vars.yml的内容</span><br><span class="line"></span><br><span class="line">5 directories, 4 files</span><br></pre></td></tr></table></figure>
<p>最后，在playbook中通过roles引入，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible roles]# vim nginx_playbook.yml</span><br><span class="line">---</span><br><span class="line">- hosts: nginx</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - role: nginx # 指定角色名称</span><br></pre></td></tr></table></figure>
<p>roles将playbook的各个部分进行拆分组织，主要用于代码复用度较高的场景。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ansible是功能强大但又很轻量级的自动化运维工具，基于SSH协议批量对远程主机进行管理，不仅可用于日常的服务维护，也可与Jenkins等CI/CD工具结合实现自动化部署。如果你需要在多于一台服务器上做重复又稍显复杂的操作，那么建议你使用Ansible，这将极大提高你的操作效率，并且所有操作文档化，更易维护与迁移。</p>
<hr>
<p>如果你对Java、Spring Boot、Spring Cloud、Docker，技术管理心得等感兴趣<br>欢迎关注作者微信公众号：空山新雨的技术空间，一起学习成长  </p>
<p><img src="/assets/qrcode-05.jpg" alt="微信公众号"></p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/k8s1-installation.html" title="Kubernetes笔记（一）：十分钟部署一套K8s环境" class="prev">PREV</a><a href="/docker-13.html" title="Docker笔记（十三）：容器日志采集实践" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz",
    appKey: "PhFNiYoBJ1Fge6n8stpsfggG",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2019 - 2020 <a target="_blank">空山新雨</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;"> </span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("g1Ew6IgbqodabnGjq0nDI39n-gzGzoHsz", "PhFNiYoBJ1Fge6n8stpsfggG");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>